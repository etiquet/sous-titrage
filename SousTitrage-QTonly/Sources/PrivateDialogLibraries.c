/*ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее*//* *  The following are various utility routines for general dialog management. *  Typically, you'll want to keep them in a library that is available to all *  your dialog modules; however, they are included here (and declared static) *  as a private library so that you can quickly compile this file for testing. */#include  "PrivateDialogLibraries.h"// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;static unsigned long LastTime;/* Convert in place a Pascal string to C string, and deliver its address */char *pdl_PascalToC(char *str)	{		register char *p,*q,*end;		end = str + *(unsigned char *)str;		q = (p=str) + 1;		while (p < end) *p++ = *q++;		*p = '\0';		return(str);	}/* *	Convert in place a C string to Pascal string, and deliver its address. *	The C string should not be greater than 255 chars in length, or the *	resulting Pascal string will be truncated to 255 chars. */char *pdl_CToPascal(char *str)	{		register char *p,*q;		register long len;		len = strlen(str);		if (len > 255) len = 255;		p = str + len;		q = p-1;		while (p != str) *p-- = *q--;		*str = len;		return(str);	}/* Dialog Item Stuffers *//* *	Install a given Pascal string, str, into the given static or edit text item *	in the dialog, dlog.  If the item is an edit text item, leave the installed *	text selected or not according to the value of sel (TRUE or FALSE). */void pdl_PutDlgString(DialogPtr dlog, int item, char *str, int sel)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		SetDialogItemText(hndl,str);		if (type == editText)			SelectDialogItemText(dlog,item,sel?0:32767,32767);		InvalRect(&box);	}/* *	Install a given decimal long value into the static or edit text item of the *	given dialog, dlog.  If the item is an edit text item, leave the installed *	text for the number selected or not according to sel (TRUE or FALSE). */void pdl_PutDlgLong(DialogPtr dlog, int item, long val, int sel)	{		char str[32];		NumToString(val,str);		pdl_PutDlgString(dlog,item,str,sel);	}/* *	Same as above, only for an int (word) decimal number. */void pdl_PutDlgWord(DialogPtr dlog, int item, int val, int sel)	{		pdl_PutDlgLong(dlog,item,(long)val,sel);	}/* *	Set the given check box or radio button item of the given dialog, dlog, to *	on or off, according to val. */void pdl_PutDlgChkRadio(DialogPtr dlog, int item, int val)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		SetControlValue((ControlHandle)hndl,val!=0);	}/* *	Deliver the value of the checkbox or radio button item of the given dialog. */int pdl_GetDlgChkRadio(DialogPtr dlog, int item)	{		short type; Handle hndl; Rect box;				GetDialogItem(dlog,item,&type,&hndl,&box);		return(GetControlValue((ControlHandle)hndl) != 0);	}/* Dialog Item Unstuffers *//* *	Retrieve the value of an edit text item in a given dialog, placing the *	resulting Pascal string in the buffer, str, which is assumed large enough *	to hold the text (256 bytes max).  If item is the number of a static text *	item, the empty string is delivered.  Delivers TRUE or FALSE according to *	whether or not the text so delivered was empty.   */int pdl_GetDlgString(DialogPtr dlog, int item, char *str)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		if (type == editText) GetDialogItemText(hndl,str);		 else                 *str = 0;		return(*str != 0);	}/* *	Retrieve the value of an edit text item in a given dialog, converting the *	Pascal string to a long and setting *val to it.  Delivers TRUE or FALSE *	according to whether or not the text so delivered was empty.  If FALSE, *	*val is set to 0; if TRUE, *val is set to whatever StringToNum() says the *	value is, even if the text contains non-numerical characters. */int pdl_GetDlgLong(DialogPtr dlog, int item, long *val)	{		int ans; char str[256];		*val = 0;		if (ans = pdl_GetDlgString(dlog,item,str))			StringToNum(str,val);		return(ans);		}/* Same as above, only delivers the value of a word */int pdl_GetDlgWord(DialogPtr dlog, int item, short *val)	{		int ans; long num;		*val = 0;		if (ans = pdl_GetDlgLong(dlog,item,&num))			*val = num;		return(ans);	}/* *	Deliver the number of the current editText item in given dialog if any text *	is selected in it, or 0 if none selected. */int pdl_TextSelected(DialogPtr dlog)	{		register TEHandle textH; int item = 0;				textH = ((DialogPeek)dlog)->textH;		if (*textH)			if ( (*textH)->selStart != (*textH)->selEnd )				item = ((DialogPeek)dlog)->editField+1;		return(item);	}/* *  If any of the variable argument scrap types are available for pasting from *  the scrap, deliver the first one.  Otherwise, deliver 0.  For example, *	 *      if (whichType = CanPaste(3,'TEXT','PICT','STUF')) ... * *  There can be any number of types in the list, as long as the preceding count, n, *  is correct. */OSType pdl_CanPaste(int n, ...)	{		register OSType nextType,ans = 0L;		long err,offset;		va_list nextArg;				va_start(nextArg,n);		nextType = va_arg(nextArg, OSType);				while (n-- > 0) {			err = GetScrap(nil, nextType, &offset);			if (err >= -1) {				ans = nextType;				break;				}			nextType = va_arg(nextArg, OSType);			}				va_end(nextArg);		return(ans);	}/* *	Get rectangle, *panel, for a given item (usually a user or picture item) *	and then hide the item so that it doesn't interfere with mouse clicking. *	This lets you stop worrying about the item order any user or pict items that *	obscure other items in the item list, which can affect how the DialogMgr *	returns itemHits. */void pdl_GetDlgPanel(DialogPtr dlog, int item, Rect *panel)	{		short type; Handle hndl;				GetDialogItem(dlog,item,&type,&hndl,panel);		HideDialogItem(dlog,item);	}/*	Draw a given popup user item in the system font. 	ModifiО E.T. 6/95 pour utilisation couleurs du menu*/void pdl_DrawPopUp(UserPopUp *p){short 		font,face,mode,size,sysFontSize,a;RGBColor	color,bcolor,noir,savef,saveb;MCEntryPtr	mcPtr;RgnHandle	rgn;GrafPtr		thePort;PenState	pnState;		GetPort(&thePort);		// sauvegarde couleurs du port		GetForeColor(&savef);		GetBackColor(&saveb);				// on initialise les couleurs		color.red=0;		color.green=0;		color.blue=0;		bcolor.red=-1;		bcolor.green=-1;		bcolor.blue=-1;				noir=color;		GetPenState(&pnState);		if (!p->active) PenPat(&QD.gray);		// on rОcupПre la couleur du fond du menu et du texte pour le menu en entier		mcPtr= GetMCEntry(p->menuID,0);		if (mcPtr) {			if (mcPtr->mctID==0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB2;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem!=0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB2;					RGBForeColor(&color);			}					} // if (mcPtr)		// LA Couleur de l'ОlОment		mcPtr= GetMCEntry(p->menuID,p->currentChoice);		if (mcPtr) {			if (mcPtr->mctID==0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB2;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem!=0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB2;					RGBForeColor(&color);			}					} // if (mcPtr)		EraseRect(&p->bounds);		/* And draw the current setting str in */		MoveTo(p->bounds.left+lMargin,p->bounds.bottom-bMargin);		/* Save/restore current window font characteristics while drawing. */				font = thePort->txFont;		size = thePort->txSize;		face = thePort->txFace;		mode = thePort->txMode;				/* Get the system font size and set system font */		sysFontSize = GetDefFontSize();		if (sysFontSize < 1) sysFontSize = 12;		TextFont(systemFont); TextSize(sysFontSize); TextFace(0); TextMode(0);				RGBForeColor(&color);		DrawString(p->str);		/* Kiss and make up after last argument(s) */		TextFont(font); TextSize(size); TextFace(face); TextMode(mode);						//on rend la couleur noire pour le dessin du reste du popUp		color.red=0;		color.green=0;		color.blue=0;		RGBForeColor(&color);// on dessine le contour du menu				RGBForeColor(&noir);		FrameRect(&p->bounds);		MoveTo(p->bounds.right,p->shadow.top+2);		LineTo(p->bounds.right,p->bounds.bottom);		LineTo(p->shadow.left+2,p->bounds.bottom);		// on dessine le triangle en fin de texte		rgn=NewRgn();		OpenRgn();		a=p->bounds.bottom-p->bounds.top-8;		MoveTo(p->bounds.right-4,(p->bounds.bottom-p->bounds.top-a/2)/2+p->bounds.top);		Line(-a,0);		Line(a/2,a/2);		Line(a/2,-a/2);		CloseRgn(rgn);		PaintRgn(rgn);		DisposeRgn(rgn);// on dessine le rectangle autour du texte				PenSize(1,1);				RGBForeColor(&savef); RGBBackColor(&saveb);		SetPenState(&pnState);}/* *	TruncPopUp() fits the string for the current setting into *	the popup item's bounding box by truncating it and adding ╔ */void pdl_TruncPopUp(UserPopUp *p)	{		int width,space; register int len,n; unsigned char *ptr;		if (p->currentChoice) GetMenuItemText(p->menu,p->currentChoice,p->str);		 else                 *p->str = 0;		/* Trim off any trailing blanks used to increase width of menu as a whole */				for (len = *(unsigned char *)p->str; len>0; len--) {			ptr = p->str + len;			if (*ptr!=' ' && *ptr!='╩') break;		/* Option-space as well */			}		*p->str = len;				space = p->bounds.right - p->bounds.left - (lMargin+rMargin)-(p->bounds.bottom-p->bounds.top-8);;		len = *(unsigned char *)p->str;		while (len > 0)			if (p->str[len]!=' ') break; else len--;		*p->str = len;		width = StringWidth(p->str);		/* Assumes the system font is current */		if (width > space) {			len = *p->str;			width += CharWidth('╔');			while (len>0 && width>space)				width -= CharWidth(p->str[len--]);			p->str[++len] = '╔';			*p->str = len;		}	}/* *	Initialize a UserPopUp data structure, p, for a given dialog, dlog, and the *	user item, item, in it that represents the popup menu. *	pItem is the item number of the staticText prompt item, or 0 if none. *	menuID is the resource ID of the menu to be popped up; choice is the *	initial choice from the menu to show in the popup field, or 0 if none. *	Returns FALSE if error, TRUE otherwise.  A successful call to this *	should be matched by a call to DisposePopUp, in order to get rid of *	the detached MENU resource. */int pdl_InitPopUp(DialogPtr dlog, UserPopUp *p, int item, int pItem, int menuID, int firstChoice){		short type; Handle hndl;		if (pItem) GetDialogItem(dlog,pItem,&type,&hndl,&p->prompt);		 else	   SetRect(&p->prompt,0,0,0,0);				GetDialogItem(dlog,item,&type,&hndl,&p->box);		p->bounds = p->box; InsetRect(&p->bounds,-1,-1);		p->shadow = p->bounds;		p->shadow.right++; p->shadow.bottom++;		p->currentChoice = firstChoice;						if (menuID != 0) {					p->menu = GetMenu(p->menuID = menuID);						if (p->menu = GetMenu(p->menuID = menuID)) {				InsertMenu(p->menu,-1);					pdl_TruncPopUp(p);			if (firstChoice)					SetItemMark(p->menu,firstChoice,(char)checkMark);				}						/* au cas ou			if (p->menu) {				// Make sure each popup has its own local copy of menu				DetachResource((Handle)p->menu);				pdl_TruncPopUp(p);				if (firstChoice)					SetItemMark(p->menu,firstChoice,(char)checkMark);				}				*/								} else {		//menu font BB			p->menu = NewMenu(12000,"\pfontM");			if(p->menu){				AppendResMenu(p->menu,'FONT');		 		InsertMenu(p->menu,-1);		 		pdl_TruncPopUp(p);		 		if (firstChoice)					SetItemMark(p->menu,firstChoice,(char)checkMark);				}			}		return(p->menu != nil);}/* *	This is called to get rid of the MENU handle, which was detached *	by InitPopUp. */void pdl_DisposePopUp(UserPopUp *p)	{		DeleteMenu(p->menuID);		if (p->menu) ReleaseResource((Handle)p->menu);		p->menu = nil;	}/* *	Invoke a popup menu; return TRUE if new choice made, which will be *	in p->currentChoice. */int pdl_DoUserPopUp(UserPopUp *p)	{		long choice; int ans = FALSE; Point pt;		InvertRect(&p->prompt);		/* May be empty if no prompt static text item */				//CalcMenuSize(p->menu);		pt = *(Point *)(&p->box);		LocalToGlobal(&pt);				CheckItem(p->menu,p->currentChoice,true);		choice = PopUpMenuSelect(p->menu,pt.v,pt.h,p->currentChoice);		CheckItem(p->menu,p->currentChoice,false);		InvertRect(&p->prompt);				if (choice) {			choice = LoWord(choice);			if (choice != p->currentChoice) {				 pdl_SetPopUpChoice(p,(short)choice);				ans = TRUE;				}			}		return(ans);	}/* *	Set popup menu to show given choice, or nothing if choice is 0. */void pdl_SetPopUpChoice(UserPopUp *p, int choice)	{		p->currentChoice = choice;		*p->str=0;		 pdl_TruncPopUp(p);		EraseRect(&p->box);		 pdl_DrawPopUp(p);	}/* *	GetLengthList() should compute a given list's length and prepare *	its data to be inserted into screen cells. */int pdl_GetLengthList(UserList *l)	{		if (G.ListeError)			return(l->nCells = (**G.ListeError).TotalErrorElement);    /* Or whatever (8 is size of stubstr[] below) */		else return(l->nCells =0);	}/* *	GetCellData(l,i,len) should deliver start of pure data of i'th cell's *	contents in the given list, and sets the data's length in *len.  It can *	be assumed to be called sequentially from i=0 to l->nCells-1.  The prototype code *	here should be replaced with your content-specific instructions. */void pdl_GetCellData(UserList *l, short i,char* string)	{		*string=0;		/* Reality check */		   if (i < 0) i = 0;			else if (i >= l->nCells) i = l->nCells-1;					if (G.ListeError){			C_ConvertiNumST_String(					C_ConversionNumeroSTPointeur((**G.ListeError).Errors[i].AbsNum)->st_NumeroST,								string);						} 	}void pdl_pdl_FrameDefault(DialogPtr dlog, int item, int frame)	{		short type; Handle hndl; Rect box;		GrafPtr oldPort; PenState oldPen;				GetPort(&oldPort); SetPort(dlog);		GetPenState(&oldPen);				GetDialogItem(dlog,item,&type,&hndl,&box);		InsetRect(&box,-4,-4);				PenSize(3,3);		if (frame) PenPat(&qd.black);		/* Paint frame */		 else      PenPat(&qd.white);		/* Erase frame */		FrameRoundRect(&box,16,16);				SetPenState(&oldPen);		SetPort(oldPort);	}