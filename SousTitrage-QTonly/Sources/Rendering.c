//#include "BB.Globals_C.h"#include "DrawSousTitre.h"// les globals// 	extern MyQDGlobals QD;//	extern AppGlobals G;//pascal void Terminate(void);//#pragma segment Renderingpascal 		void GetMinCharRect(Rect *rect,GWorldPtr OffscreenRendering);pascal 		CTabHandle MakeNBCTAB(void);void 			DoBlur (GWorldPtr OffscreenRendering,short blur,Rect *rect);CharHeaderPtr 	C_GiveDisplayFont_CharInfo(FontRenderRecordPtr theFont,short thechar,short theStyle);pascal void 	C_makeDisplayFontName (FontRenderRecordPtr  FontRender );					//unsigned long MultiplyPixel(unsigned long bgd,unsigned long fgd,short shwfact);pascal Handle 	RPInitReglette(Str255 WindowName,Str255 PromptString,long MinValue,long MaxValue,Boolean BoutonStop);pascal Boolean	RPIdleWText(Handle theRpd,long value,Str255 string,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder );CharHeaderPtr 	C_GiveDisplayFont_FastCharInfo(FontRenderRecordPtr theFont,short thechar,short theStyle);static short  	AskDisplayFontName(FSSpec*   fss ,FontRenderRecordPtr fontRecord );static short 	SaveDisplayFont(FSSpec* fss,FontRenderRecordPtr fontRecord,Ptr bitmap,long bitmapsize);pascal void 	Create_FastFont(FontRenderRecordPtr FontRender,short DestinationSize ,Ptr RenderEffect   );pascal short	C_Render_A_font_Eng(FontRenderRecordPtr FontRender,GDHandle  GraphicDeviceH,long RowBytes,Ptr BaseAdresse);pascal void 	RPDispose(Handle theRpd);void			RenderAntiAliasChar(RenderInfoPtr render);pascal OSErr	PrepareRendering(RenderInfoPtr render);void 			FiniRendering(RenderInfoPtr render);static void C_paintRect(Rect *rect,long color,Ptr BaseAdresse,long RowBytes);typedef struct Pixarray{long	pix;}Pixarray,*PixarrayPtr,**PixarrayHandle;void RenderAntiAliasChar(RenderInfoPtr render){	CGrafPtr		oldport,P=(CGrafPtr)FrontWindow();Boolean			preserv=GetPreserveGlyph();GDHandle		gdh;short			a,savearea;Rect			rect1;FontInfo		finfo;	GetGWorld(&oldport,&gdh);	SetGWorld(render->OffscreenRendering,nil);	RGBForeColor(&render->noir);	RGBBackColor(&render->blanc);	EraseRect(&render->OffscreenRendering->portRect);		TextFont(render->font);	TextSize(render->size*render->Quality);	TextFace(render->style&0xFF); 	GetFontInfo(&finfo);/* 	On positionne l'écriture du caractère	on le décale du bord gauche et du bord haut,	cela pour éviter que le caractère ne soit tronqué lors d'opération	comme blur ou épaississement */			savearea=128;			MoveTo(savearea+render->dx,finfo.ascent+savearea+render->dy);	SetPreserveGlyph (true);	DrawChar(render->thechar);/* on fait le calcul de la bordure */	BitMapToRegion(render->region,&(((GrafPtr)render->OffscreenRendering)->portBits)); 	a=(long)((render->border*render->Quality)*2)/4;	InsetRgn(render->region,-a,-a);	EraseRect(&render->OffscreenRendering->portRect);	PaintRgn(render->region);	/* on prépare le bitmap de destination */		SetGWorld(render->OffscreenRendering2,nil);	RGBForeColor(&render->noir);	RGBBackColor(&render->blanc);	EraseRect(&render->OffscreenRendering2->portRect);		SetRect(&rect1,20,20,					((finfo.widMax+render->border*render->Quality)*2)/2+savearea+render->dx,					((finfo.ascent+finfo.descent+render->border*render->Quality)*2)/2 +savearea+render->dy);	/* on calcule les ≠ bords du caractères *//* on check le rectangles */	if (rect1.left<0) rect1.left=0;	if (rect1.top<0) rect1.top=0;	if (rect1.bottom>3200) rect1.left=3200;	if (rect1.right>3200) rect1.right=3200;	render->rect.left=0;	render->rect.top=0;	a=(rect1.bottom-rect1.top)/render->Quality;	render->rect.bottom=render->rect.top+a;		a=(rect1.right-rect1.left)/render->Quality;	render->rect.right=(render->rect.left+a);	// si on a du blur demandé, on agrandi la font//	if (render->blur){//		InsetRect(&render->rect,-render->blur*2,-render->blur*2);	if (render->ratio==0x1609){		a=(rect1.right-rect1.left)/render->Quality;		render->rect.right=((render->rect.left+a)*3)/4;	}	if (render->ratio==0x0503){		a=((rect1.right-rect1.left)*60)/(64*render->Quality);		render->rect.right=(render->rect.left+a);	}	// on aligne sur un short ...	render->rect.right=(((render->rect.right)*2)/2);	render->rect.bottom=(((render->rect.bottom)*2)/2);	//on calcule la baseline = ((Ypos dessin)*ratio ajusté)		render->baseline=((finfo.ascent+savearea+render->dy)*(render->rect.bottom))/(rect1.bottom-rect1.top);	render->baseline=((finfo.ascent+savearea+render->dy)*(render->rect.bottom-render->rect.top))/(rect1.bottom-rect1.top);	render->baseline=((finfo.ascent+savearea+render->dy)/render->Quality);// ON DÉCALE LE PLAN D'AFFICHAGE POUR ETRE SUR DE NE PAS ROGNER SUR LES BORDS	/* on effectue l'anti-aliasing	*/		render->rect.top+=100;	render->rect.left+=100;	render->rect.bottom+=100;	render->rect.right+=100;	render->baseline+=100;	CopyBits(&((GrafPtr)render->OffscreenRendering)->portBits,				&((GrafPtr)render->OffscreenRendering2)->portBits,				&rect1,&render->rect,srcCopy+ditherCopy,nil);/* on détermine le rectangle correspondant au caractère */	render->rect.left=0;	render->rect.top=0;	render->rect.bottom=400;	render->rect.right=400;		GetMinCharRect(&render->rect,render->OffscreenRendering2);	render->rect.left-=1;	render->rect.top-=1;	render->rect.right+=1;	render->rect.bottom+=1;/* on effectue le blue si nécessaire */	if (render->blur){		DoBlur(render->OffscreenRendering2,render->blur,&render->rect);	} 	//comme on à cropper l'image de tout les cotés, en particulier en haut, 	//il nous faut compenser la baseline, avec le top	render->baseline-=render->rect.top; 	//on à fini, on rend le port	SetGWorld(oldport,gdh);	SetPreserveGlyph (preserv);}pascal void GetMinCharRect(Rect *rect,GWorldPtr OffscreenRendering){Ptr	P;Ptr	P1,P2;PixMapHandle	pmh;long rowbyte,l;short	a,b,i,j;unsigned char c;Boolean	exit;Rect	rect1;	pmh=GetGWorldPixMap(OffscreenRendering);	P=GetPixBaseAddr(pmh);	rowbyte=(long)0x1fff&(**pmh).rowBytes;			//on détermine le bord gauche	exit=false;	a=(*rect).bottom-(*rect).top;	b=(*rect).right;	l=rowbyte*((long)(*rect).top);	P2=P+l;	i=-1;	do {		i++;		j=0;		P1=P2+3; // on regarde le canal vert		do {			c=*P1;			if (c!=255) exit=true;			j++;			P1=P1+rowbyte; // ligne suivante		} while (exit==false && j<b);				P2=P2+4; //pixel suivant			} while (exit==false && i<a);	rect1.left=i;			//on détermine le bord haut	exit=false;	a=(*rect).bottom;	b=(*rect).right-(*rect).left;	i=(*rect).top,	P2=P+i*rowbyte+((*rect).left*4);	i--;	do {		i++;		j=0;		P1=P2+3; // on regarde le canal vert		do {			c=*P1;			if (c!=255) exit=true;			j++;			P1=P1+4; // pixel suivant		} while (exit==false && j<b);		P2=P2+rowbyte; //ligne suivante	} while (exit==false && i<a);	rect1.top=i;		//on détermine le bord bas 	exit=false;	i=(*rect).bottom+1;	P2=P+(*rect).bottom*rowbyte;	l=(long)((*rect).right)*4;	do {		i--;		j=(*rect).right-(*rect).left;		P1=P2+l+2;		do {			c=*P1;			if (c!=255) exit=true;			P1=P1-4;			j--;		} while (exit==false && j>0);		P2=P2-rowbyte;	} while (exit==false && i>0);	rect1.bottom=i+1;	//on détermine le bord droit	exit=false;	a=(*rect).bottom-(*rect).top;	b=(*rect).left;	l=(*rect).right*4;	P2=P+(*rect).top*rowbyte;	i=(*rect).right+1;	do {		j=0;		i--;		P1=P2+l+3; // on regarde le canal vert		do {			c=*P1;			if (c!=255) exit=true;			j++;			P1=P1+rowbyte; // ligne suivante		} while (exit==false && j<a);				P2=P2-4; //pixel precedent	} while (exit==false && i>b);	rect1.right=i+1;	*rect=rect1;	}pascal CTabHandle MakeNBCTAB(void){CTabHandle	tab;short		i;	tab=(CTabHandle)NewHandleClear(sizeof(ColorTable)+256*sizeof(CSpecArray));	HLock((Handle)tab);	(**tab).ctSeed=GetCTSeed();	(**tab).ctFlags=0;	(**tab).ctSize=255;	for(i=0;i<256;i++){		(**tab).ctTable[i].value=i;		(**tab).ctTable[i].rgb.red=i;		(**tab).ctTable[i].rgb.green=i;		(**tab).ctTable[i].rgb.blue=i;	}		HUnlock((Handle)tab);	return tab;}		/* cette routine prepare le rendering */	pascal OSErr PrepareRendering(RenderInfoPtr render){	Rect rect;OSErr	err=0;	render->region=NewRgn();	render->rgn=NewRgn();	SetRect(&rect,0,0,3200,3200);	err=NewGWorld(&render->OffscreenRendering,1,&rect,nil,nil,0);	if (err) return err;		SetRect(&rect,0,0,420,420);	err=NewGWorld(&render->OffscreenRendering2,32,&rect,nil,nil,0);	if (err) {		DisposeGWorld(render->OffscreenRendering);		return err;		}	if (render->OffscreenRendering)		LockPixels(GetGWorldPixMap(render->OffscreenRendering));	if (render->OffscreenRendering2)		LockPixels(GetGWorldPixMap(render->OffscreenRendering2));		/* on beep si problème */		if (! render->OffscreenRendering || !render->OffscreenRendering2){		SysBeep(10);		SysBeep(10);		}	render->blanc.red=-1;	render->blanc.green=-1;	render->blanc.blue=-1;	render->noir.red=0;	render->noir.green=0;	render->noir.blue=0;		return noErr;}/* cette routine dispose le rendering */	void FiniRendering(RenderInfoPtr render){		if (render->OffscreenRendering) {		UnlockPixels(GetGWorldPixMap(render->OffscreenRendering));		DisposeGWorld(render->OffscreenRendering);		}	if (render->OffscreenRendering2){		UnlockPixels(GetGWorldPixMap(render->OffscreenRendering2));		DisposeGWorld(render->OffscreenRendering2);		}	if (render->region) DisposeRgn(render->region);	if (render->rgn) DisposeRgn(render->rgn);}void DoBlur(GWorldPtr Offscreen,short	blur,Rect *rect){long		rowbyte,LL,startlong;short	x,y,dx,dy;long		a,pixel,surface;long*	src; // sourcelong*	Lsrc; // sourcelong*	Lsrc2; // sourcelong*	dst; // destinationlong*	Pdst;// destinationlong*	Psrc;// sourcePixMapHandle	pmh;Handle	h;char*	P3;char*	P2;		pmh=GetGWorldPixMap(Offscreen);	if (! LockPixels(pmh)) return; // on ne peut rien faire erreur		// on calcule et récupère les info de la sources		P3=(Ptr)GetPixBaseAddr(pmh);	rowbyte=(long)(**pmh).rowBytes&0x1fff;	a=(long)( (**pmh).bounds.bottom-(**pmh).bounds.top)*rowbyte; //quantité de mémoire nécessaire pour stocker le plan	surface=((1+2*blur)*(1+2*blur)); // la surface traitée			h=NewHandle(a); // on demande un pointeur	if (!h) return ; // pas de pointeur erreur			// on modifie le rectangle global	rect->top-=2*blur;	rect->left-=2*blur;	rect->right+=2*blur;	rect->bottom+=2*blur;				// ptr ok ?	// on copie le buffer	HLock(h);	P2=*h;	BlockMove(P3,P2,a);			// on fait le blur	startlong=rect->top*rowbyte+rect->left*4; // point de départ (offset) (attention on est en 32 bits )	LL=(long)P2;	LL+=startlong;	Psrc=(long*)LL;		LL=(long)P3;	LL+=startlong;		Pdst=(long*)LL;		rowbyte=rowbyte/4; // et oui ...		for (y=rect->top;y<=rect->bottom;y++){			dst=Pdst;			src=Psrc;			for (x=rect->left;x<=rect->right;x++){				// on détermine la moyenne de la surface				pixel=0;				LL=(long)src;				LL-=rowbyte*4*blur; //y ligne au dessus				LL-=blur*4; // x pixel à gauche				Lsrc=(long*)LL;				for (dy=-blur;dy<=blur;dy++){				    Lsrc2=Lsrc;				   for (dx=-blur;dx<=blur;dx++){						a=(*Lsrc2)&0xff; // on ne prend qu'un octet 						pixel=pixel+a;						Lsrc2++;					}// for dx					Lsrc+=rowbyte;				}// for dy				a=(pixel/surface)&0xff;				pixel=(a<<16)+(a<<8)+a;				// on inscrit la surface				*dst=pixel;				dst++; //pix suivant				src++; //pix suivant							} //for x			Psrc+= rowbyte;			Pdst+= rowbyte;		}//for y	HUnlock(h);	DisposeHandle(h);	UnlockPixels(pmh);}/* Cette routine calcule un police de caractères anti-aliasée *///note: macro de compilation pour la déclaration de la routine//en code PPC, pour la code resource#ifdef 	powerc   // pour la compilation en  code resource PPCProcInfoType __procinfo =  kPascalStackBased     		 | RESULT_SIZE(SIZE_CODE(sizeof(short))) 		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(FontRenderRecordPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(GDHandle)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(char*))) ;#endif //#ifdef 	powerc// cette routine permet de dessiner un caractère anti-aliasépascal short   C_Render_A_font_Eng(FontRenderRecordPtr FontRender,GDHandle  GraphicDeviceH,long RowBytes,Ptr BaseAdresse){RenderInfo	 	render;Str255			st0,st1;short			Y,X;Ptr				Pointeur; 	//déréférence du handleHandle			handle,NewFontHandle;// handle pour le dessinRGBColor		color;short			itemType,ItemHit,Itemchoisi,TheBlur,TheThickness;Handle			itemHandle;		//stockage du handle du itemDialogPtr		dialog;Rect			itemRect,box;Handle			hndl;unsigned long		L;Point			Thepoint;short			TotalChar,type;	// nb total de caractère à rendreshort			CharCounter;	//total de caractère rendushort			largeur;		//cf Render sub routineshort			hauteur;		//cf Render sub routineshort			baseLine;		//cf Render sub routineshort			StyleType;		//style en cour	type style MAC   (cf Quick Draw)short			TheStyle,i,j;		//style en cour compteur 0....nshort			TheChar; 		//caractère en courshort			ThePlane; 		//plan en cour (face/bordure/ombre)Rect			CharRect; 		//carré du plan dessinélong			StartDate,Date;		//long datelong			StartChar;		//time au départ du rendu du caractèrePtr				FontBitmapPtr; //pointeur du début du bitmap de la policelong			FontBitmapSize; // taille du "font bitmaps"  Ptr				FontBitmapHimem	; //pointeur de la fin du bitmap de la police n.u.Ptr				FontCurrentPtr; //pointeur relatif positiion dans  le handlePtr				FontStylePtr; //pointeur relatif du stylePtr				FontPlanePtr;  //pointeur relatif du plan dans le caractèreGrafPtr			SavePort;long			taille,total,contig,rowbyte,b,estTime;OSErr			err;PixMapHandle	pmh;Ptr				P,P1,P2,P3,P4,P5,P6;Rect			offscreenBuffrect,rect,Drect;EventRecord 	theEvent;CharHeaderPtr	CH_Ptr,FontCharPtr,PreviousFontCharPtr;DateTimeRec	datrec;Handle		RPD;unsigned long 	a;FSSpec		fss;         C_makeDisplayFontName (FontRender);					// on fabrique le nom de la police	type=1;	do{		type=AskDisplayFontName(&fss ,FontRender);		if (type==-2) return  -1; // cancel	}while (type); // pas erreur ?/* on efface le  fast font en cours */	if (FontRender->RenderColor_handle)			DisposeHandle((Handle)FontRender->RenderColor_handle);	FontRender->RenderColor_handle=nil;/* on efface le  font en cours */	if (FontRender->Render_handle)			DisposeHandle((Handle)FontRender->Render_handle);	FontRender->Render_handle=nil;// on prepare le record pour la routine de rendu	err=PrepareRendering(&render);	if (err) {	// on regarde pour erreur		return -2;		}/* on recupère les infos du offscreen du rendu */	pmh=GetGWorldPixMap(render.OffscreenRendering2);	if (LockPixels(pmh)){		P3=(Ptr)GetPixBaseAddr(pmh);		rowbyte=(long)(**pmh).rowBytes&0x1fff;		offscreenBuffrect=(**pmh).bounds;		}/*  On ouvre un dialog pour indiquer ce que nous faisons*/	dialog=GetNewDialog(176,nil,(WindowPtr)-1);	DrawDialog(dialog);/* on calcule approximativement la taille necessaire du handle pour stocker la nouvelle font */	taille=(FontRender->FontSize)&0xffff;	taille=taille*taille;	taille=taille*(255-33);	L=(long)FontRender->Plane_Number*(long)FontRender->Face_Number;	FontBitmapSize=taille*L;	FontBitmapSize=FontBitmapSize+32+102400+L*sizeof(CharHeader);	NewFontHandle=NewHandle(FontBitmapSize);	// on regarde si cela a fonctionner	if (!NewFontHandle) {		// non on indique la mémoire dispo et on demande son choix à l'utilisateur		PurgeSpace(&total,&contig); 		NumToString((contig/1024)-32,(unsigned char*)&st1);		NumToString(FontBitmapSize/1024,(unsigned char*)&st0);		ParamText((const unsigned char*) &st0,(const unsigned char*) &st1,nil,nil);		Itemchoisi=Alert(194,nil);		if (Itemchoisi==1){	// on ne fait rien			FiniRendering(&render);			DisposeDialog(dialog);			return -3;		}// on rafraichi le dialog		DrawDialog(dialog);		// on demande le handle		NewFontHandle=NewHandle(contig-32768);		if (!NewFontHandle){ // problème 			Alert(159,nil);			FiniRendering(&render);			DisposeDialog(dialog);			return -4;			}	 		} // problème aloue de la mémoire	/* bon, on a a peu près tout ce qu'il faut pour travailler*/		HLock(NewFontHandle);		DisposeDialog(dialog);	// on ferme le dialog// on initialise le font record et le travail		FontRender->Render_handle=NewFontHandle;		FontBitmapPtr=*NewFontHandle;		FontRender->First_Char=33;		FontRender->last_Char=255;		// initialisation du Displayfont header en tête 		L=FontRender->Face_Number*(long)styleHeaderSize;		FontCurrentPtr=(Ptr)L;	// on calcule le nombre de caractère à rendre	 pour l'indicateur d'état.		TotalChar=(255-33)*FontRender->Face_Number;		CharCounter=0; 	//reset du compteur				GetIndString((unsigned char*)&st0,129,53); // "CALCUL D'UNE POLICE D'AFFICHAGE"		RPD=RPInitReglette((unsigned char*)&st0,(unsigned char*)&FontRender->FontName,1,TotalChar,true);	// LE NOM DE LA POLICE"// initialisation boucle style		TheStyle=0;	//initialisation			GetDateTime((unsigned long*)&StartDate); //on raz le compteur total du temps// --------------- yeeeeaaaa ..../* boucle 1 style par style */	for(TheStyle=0;TheStyle<FontRender->Face_Number;TheStyle++){		// initialisation pointeurs "Display font" boucle style	L=(long)FontCurrentPtr; // on aligne sur long	L=((L+3)/4)*4; 			// on aligne sur long	FontCurrentPtr=(Ptr)L; 			// on aligne sur long	FontStylePtr=FontCurrentPtr;	((MasterPlanePtr)FontBitmapPtr)->styleoffset[TheStyle].offset=(Ptr)FontStylePtr;	((MasterPlanePtr)FontBitmapPtr)->styleoffset[TheStyle].SparePtr=nil;		PreviousFontCharPtr=0;	// raz	//on indique le style en cours dans la fenêtre de progression	switch(TheStyle) {		case 0: //Normal_style			StyleType=0;		break;		case 1: //Italique_style			StyleType=2;		break;		case 2: //Bold_style			StyleType=1;		break;		}			// on regarde s'il faut utilise le style bold à la place du normal		if (FontRender->UseBold) StyleType=StyleType|1;/* boucle 2 char par char */		Drect.left=0; Drect.top=0; Drect.bottom=0; Drect.right=0; 	for (TheChar=33;TheChar<=255;TheChar++){// initialisation des pointeurs "Display font" boucle caractères	FontCharPtr=(CharHeaderPtr)FontCurrentPtr; 		//pointeur courant => fontchar// on calcule le nouveau pointeur	L=0;	L=FontRender->Plane_Number;	L=L*sizeof(PlaneInfo);	L+=sizeof(CharHeader)+(unsigned long)FontCurrentPtr;	FontCurrentPtr=(Ptr)L;			FontPlanePtr=FontCurrentPtr; //adresse du plan	// on update les pointeurs de cet en tête	a=(unsigned long)FontBitmapPtr+(unsigned long) FontCharPtr;  // on calcule le pointeur absolu du ptr	CH_Ptr=(CharHeaderPtr)a;	CH_Ptr->CH_PreviousChar=(Ptr)PreviousFontCharPtr;	CH_Ptr->CH_NextChar=nil;	CH_Ptr->CH_CharNumber=TheChar; //n° de caractère rendu 		//le spare je met $cbcb pour mieux identifier cette position	(CH_Ptr)->CH_Spare=0xcaca;// on raz le rectangle 	CH_Ptr->CH_Rect.left=32760;	CH_Ptr->CH_Rect.top=32760;	CH_Ptr->CH_Rect.right=0;	CH_Ptr->CH_Rect.bottom=0;// on update le nextPtr du char précédent (s'il existe)														if( PreviousFontCharPtr){		a=(unsigned long)FontBitmapPtr+(unsigned long) PreviousFontCharPtr; // on calcule le pointeur absolu du ptr		CH_Ptr=(CharHeaderPtr)a;		CH_Ptr->CH_NextChar=(Ptr)FontCharPtr;	}		PreviousFontCharPtr=FontCharPtr; 	//	l'actuel char devient le précédent 												// au prochain passage												StartChar=TickCount();		//on raz le compteur ticks/caractère//on regarde s'i y a une vx si oui on efface la vx /* boucle 3 plan par plan */	if (GraphicDeviceH) C_paintRect(&Drect,0x0,BaseAdresse,RowBytes); 			for (ThePlane=0;ThePlane<FontRender->Plane_Number;ThePlane++){// on indique ce que nous faisons				switch(ThePlane){					case 0: // face n°0					// on inscrit les valeur types pour la face							render.border=FontRender->FaceThickness;							render.blur=FontRender->FaceBlur;							render.dx=0;render.dy=0;					break;					case 1: // border							render.border=FontRender->BorderThickness;							render.blur=FontRender->BorderBlur;							render.dx=FontRender->BorderDx;render.dy=FontRender->BorderDx;					break;					case 2: // shadow					break;				}				// on appelle le moteur de rendu				render.thechar=TheChar;				render.style=StyleType;				render.font=FontRender->FontNumber;				render.size=FontRender->FontSize;				render.Quality=FontRender->FontQuality;				render.ratio=FontRender->FontRatio;								RenderAntiAliasChar(&render);				/* -------------- on calcule l'offset du plane bitmap dans le font bitmaps; offsetplanen=fontcharoffset+12*ntotalplan+tailleplan(0)+tailleplan(1)+...tailleplan(n-1); nb: les pointeurs (ou offset) sont relatifs à la base de la police; donc l'adresse absolue d'un élément= offset(ou ptr)+base adresse de "l'élément police"				*/			/* ---------------on calcule l'adresse effective des infos du plan en cour dans le header du caractère	;; rappel : infos  	0 	pi_Rect				(Rect);					8 	pi_PlaneBase		(long);					12	pi_Baseline			(word);					14	pi_spare			(word)*/	 				L=sizeof(CharHeader)+(long)FontCharPtr+ThePlane*sizeof(PlaneInfo);				((PlaneInfoPtr)(FontBitmapPtr+L))->pi_PlaneBase=FontPlanePtr; 	//pointeur du plane (dans plane info)				((PlaneInfoPtr)(FontBitmapPtr+L))->pi_spare=0xdbdb;				/* 	--------------    on calcule la taille du caractère					note : on pourrais détecter les caractère existant par le char info du mac*/				((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Rect=render.rect;				err=false;								a=(unsigned long)FontBitmapPtr+(unsigned long) FontCharPtr;  // on calcule le pointeur absolu du ptr				CH_Ptr=(CharHeaderPtr)a;// on regarde si la largeur est négatif				if((render.rect.right-render.rect.left)<=0){								((PlaneInfoPtr)(FontBitmapPtr+L))->pi_PlaneBase=0;								((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Rect.left=0;								((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Rect.right=0;								err=true;				} else {	// update rectangle global caractère 						if( (CH_Ptr->CH_Rect.left) > (render.rect.left) ) CH_Ptr->CH_Rect.left=render.rect.left;					if( (CH_Ptr->CH_Rect.right)< (render.rect.right) ) CH_Ptr->CH_Rect.right=render.rect.right;				}	// on regarde si la hauteur est négatif				if((render.rect.bottom-render.rect.top)<0){								((PlaneInfoPtr)(FontBitmapPtr+L))->pi_PlaneBase=0;								((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Rect.top=0;								((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Rect.bottom=0;								err=true;				} else {	// update rectangle global caractère 							if( CH_Ptr->CH_Rect.top>render.rect.top) CH_Ptr->CH_Rect.top=render.rect.top;					if( CH_Ptr->CH_Rect.bottom<render.rect.bottom ) CH_Ptr->CH_Rect.bottom=render.rect.bottom;						}				// on calcule la base line				((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Baseline=-render.baseline;				if(err){/* il y a un problème il n'y a pas de rendu pour ce caractère; donc on ne copie pas ce caractère*/					((PlaneInfoPtr)(FontBitmapPtr+L))->pi_Rect.top=0;				} else {/* on recopie maintenant le caractère dans le fontbitmaps; cette copie permet de réduire l'espace mémoire utilisé				--------------- recopie du rendu du plan dans le "Font bitmaps" -------------------------*/				// on calcule les pointeurs				Y=render.rect.bottom-render.rect.top;				X=render.rect.right-render.rect.left;								a=(unsigned long)FontBitmapPtr+(unsigned long) FontPlanePtr;  //adresse basse du plan (destination) 				P=(Ptr)a;								P1=P3+( ( (long)render.rect.top )*rowbyte + ( (long)render.rect.left )*4L	); // source offscreen				Drect.bottom=Drect.top+Y;				Drect.right=Drect.left+X;				// on dessine également dans la ve// on centre le caractère dansla VE				P5=0;				if (GraphicDeviceH) {					pmh=(**GraphicDeviceH).gdPMap;					Drect.left=a=((**pmh).bounds.right-(**pmh).bounds.left)-X;					a=a*2;					P5=BaseAdresse+a;					Drect.top=a=((**pmh).bounds.bottom-(**pmh).bounds.top)-Y;					a=a/2;					a=a*RowBytes;					P5=P5+a;					P=P;			  // on centre sur la ve				  // on recopie									for (j=0;j<=Y;j++){						P2=P1;						P4=P;						P6=P5;						for (i=0;i<=X;i++){							a=(255-*((char*)P2+3))&0xff; // on recopie la voie verte							b=a+(a<<8)+(a<<16)+(a<<24);							*((long*)P6)=b;							*(P4)=b;							P4=P4+1;							P2=P2+4;							P6=P6+4;						}						P=P+X+1;						P1=P1+rowbyte;						P5=P5+RowBytes;					} 								} else {			// routine si pas de VE					for (j=0;j<Y;j++){						P2=P1;						P4=P;						for (i=0;i<X;i++){							a=*((long*)P2); // on recopie la voie verte							*(P4)=a;							P4=P4+1;							P2=P2+4;						}						P1=P+X;						P2=P2+rowbyte;					} 				}// on update le pointeur courant				X=X+2;				Y=Y+2;				L=Y*X+4;				L=((L+3)/4)*4; // on aligne sur long word// ----- update du ptr de la zone mémoire				FontCurrentPtr=FontCurrentPtr+L;				FontPlanePtr=FontCurrentPtr; //; "reservation de l'espace"			} // recopie du caractère						} // boucle plans// -------- fin loop des plans incr loop caractères// on effectue un changement de coordonnés pour les ≠ rectangles						a=(unsigned long)FontBitmapPtr+(unsigned long) FontCharPtr;  // on calcule le pointeur absolu du ptr				P=(Ptr)a;								X=((CharHeaderPtr)P)->CH_Rect.left;				Y=((CharHeaderPtr)P)->CH_Rect.top;				((CharHeaderPtr)P)->CH_Rect.left-=X;				((CharHeaderPtr)P)->CH_Rect.top-=Y;				((CharHeaderPtr)P)->CH_Rect.right-=X;				((CharHeaderPtr)P)->CH_Rect.bottom-=Y;				P=P+sizeof(CharHeader); // pour pointer sur les infos du 1 er plan												for (i=0;i<FontRender->Plane_Number;i++){					((PlaneInfoPtr)P)->pi_Rect.left-=X;					((PlaneInfoPtr)P)->pi_Rect.top-=Y;					((PlaneInfoPtr)P)->pi_Rect.right-=X;					((PlaneInfoPtr)P)->pi_Rect.bottom-=Y;					P=P+sizeof(PlaneInfo); 			// plan suivant								}						CharCounter++;						// on rafraichie la réglette			// on essaye d'estimer de temps restant			GetDateTime((unsigned long*)&Date);			Date-=StartDate; 	//le temps ecoulé EN SECONDE						if (Date>2){	// on ne le fait pas pendant la  première secondes				estTime=((TotalChar-CharCounter)*Date)/CharCounter;				SecondsToDate((unsigned long )estTime, &datrec); // on transforme les secondes en minute,secondes								st0[0]=0;				// les minutes				NumToString(datrec.minute,(unsigned char*)&st1); 				if (st1[0]==1) {st0[0]++;  st0[st0[0]]='0';} // on ajoute un leading zero				BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);				st0[0]+=st1[0];				// les secondes				NumToString(datrec.second,(unsigned char*)&st1); 				st0[0]++;  st0[st0[0]]=':';				if (st1[0]==1) {st0[0]++;  st0[st0[0]]='0';} // on ajoute un leading zero				BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);				st0[0]+=st1[0];							} else st0[0]=nil;						if ( RPIdleWText(RPD,CharCounter,st0,nil/*&DoUpdate*/,true) ) // on rafraichi la reglette de progression				if (CautionAlert (295,nil)==1){  // l'utilisateur demande l'arrêt, on demande confirmation						HUnlock(FontRender->Render_handle);// il souhaite arrêter						DisposeHandle((Handle)FontRender->Render_handle); // on dispose le handle						FontRender->Render_handle=nil;						RPDispose(RPD);						return -1;					} //vraiment arrêter ???	}// boucle char }// boucle style// on dispose l'indicateur de progression	RPDispose(RPD);// on taille le handle à la taille voulue	HUnlock(FontRender->Render_handle); // il est préférable de unlocked le handle	SetHandleSize(FontRender->Render_handle,(long)FontCurrentPtr);		HLock(FontRender->Render_handle);// on sauvegarde la police ...	a=SaveDisplayFont(&fss,FontRender,FontBitmapPtr,(long)FontCurrentPtr);	if (!a )	// problème, on redemande à l'utilisateur un endroit pour sauvegarder le fichier		do{			type=AskDisplayFontName(&fss ,FontRender); // boucle de chance de sauvegarder ...			//if (type==-2) type=-2 ; // cancel			if (!type) SaveDisplayFont(&fss,FontRender,FontBitmapPtr,(long)FontCurrentPtr) ;		}while(type!=0 && type !=-2);	HUnlock(FontRender->Render_handle);// ---------------- fin grand boucle// on dispose 	le record pour la routine de rendu	FiniRendering(&render);	FlushEvents(everyEvent,0);	// on ne sait jamais//le rendu est terminé// on l'indique à l'utilisateur	Alert(160,nil);// note si l'on veut une utilisation immédiate// il faut calculer une fast font`//On calcule une fast font pour utilisation immédiate //	if (GraphicDeviceH) Create_FastFont(FontRender,32,0);	if (!GraphicDeviceH){//  on efface la police en mémoire????		DisposeHandle(NewFontHandle);		FontRender->Render_handle=nil;	}	return  0;} //C_Render_A_font/*; ---;; rappel  :     	ptr style 1		<-  début du font bitmaps	);				  / / / / 									) header font bitmap;				ptr style n									) ;;				headerCharN°1	<- début 1 er style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn;				    / / / /;				headerCharN°1	<- début n ème style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn; (il faut réserver un  long ptr pour chaque style) ; il faudra changer le nom face number par style number (nombre de style dans le bitmap); initialisation du Displayfont header en tête *//*	Cette routine créé un nom pour un police d'affichage */pascal void C_makeDisplayFontName (FontRenderRecordPtr  FontRender ){Str255	st0,st1;// on recupere le nom de la police		GetFontName (FontRender->FontNumber,(unsigned char*)&st0);// on regarde si on utilise le bold pour le style normal,si oui on ajoute .bold à la fin  		if (FontRender->UseBold){  			st0[0]++;  st0[st0[0]]='.';  			st0[0]++;  st0[st0[0]]='b';  			st0[0]++;  st0[st0[0]]='o';  			st0[0]++;  st0[st0[0]]='l';  			st0[0]++;  st0[st0[0]]='d';  		}  			st0[0]++;  st0[st0[0]]=' ';// on place la taille de la font//	note: il ya un ration de 25/18 au moment du calcul, ici on n'est tient pas compte on place la valeur originale//		avant on faisait le calcul inverse mais on ne fait plus cela car il y avait des erreur d'arrondi.		NumToString(FontRender->OriginalSize,(unsigned char*)&st1);		// on concatène les chaines		BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);		st0[0]+=st1[0];//on regarde quel style est demandé  		st0[0]++;  st0[st0[0]]='N';		if ((FontRender->FontStyle&italic)==italic) {				st0[0]++;  st0[st0[0]]='I';				}		if ((FontRender->FontStyle&bold)==bold) {				st0[0]++;  st0[st0[0]]='B';				}// on ajoute le ration de la police		switch (FontRender->FontRatio){					case 0x0403:				st0[0]++;  st0[st0[0]]='4';				st0[0]++;  st0[st0[0]]='.';				st0[0]++;  st0[st0[0]]='3';			break;					case 0x1609:				st0[0]++;  st0[st0[0]]='1';				st0[0]++;  st0[st0[0]]='6';				st0[0]++;  st0[st0[0]]='.';				st0[0]++;  st0[st0[0]]='9';			break;			case 0x0504:				st0[0]++;  st0[st0[0]]='5';				st0[0]++;  st0[st0[0]]='.';				st0[0]++;  st0[st0[0]]='4';			break;								}		//	on recopie le nom dans le font render		BlockMove(&st0,&FontRender->FontName,256);} //void makeDisplayFontNamestatic short  	AskDisplayFontName(FSSpec*   fss ,FontRenderRecordPtr fontRecord ){Str255		prompt,defaultName="\pSave Display font as ..";StandardFileReply  reply;OSErr		err;short		MainFRefNum,BackFRefNum,theVolume;ParamBlockRec	pb;long			count;		 //GetIndString(&prompt,129,34);		StandardPutFile((const unsigned char*)&defaultName,fontRecord->FontName,&reply);		if(!reply.sfGood ) return -2;// cancel		if(!reply.sfReplacing ){	// création nouveau fichier			if (reply.sfFile.name[0]>31){	// longueur du nom					reply.sfFile.name[0]=31;					}				err=FSpCreate(&reply.sfFile,'Bbou','Bbdf',reply.sfScript);				if (err) { 					return -1;					}			}			err=FSpOpenDF(&reply.sfFile,fsRdWrPerm,&MainFRefNum);				err=err|FSClose(MainFRefNum);			if (err) { 					return -1;					}			// on copie le header fss							BlockMove((char*)&reply.sfFile,(char*)fss,sizeof(FSSpec));			return 0;}static short 	SaveDisplayFont(FSSpec* fss,FontRenderRecordPtr fontRecord,Ptr bitmap,long bitmapsize){OSErr		err;short		MainFRefNum,theVolume;ParamBlockRec	pb;long			count;// on ouvre le fichier		err=FSpOpenDF(fss,fsRdWrPerm,&MainFRefNum);			if (err) { 					return -1;					}		GetVRefNum(MainFRefNum,&theVolume);//  on commence par sauvegarder le font record		count=sizeof(FontRenderRecord);		err=FSWrite(MainFRefNum,&count,fontRecord);		//  on sauvegarde le display font 				count=bitmapsize;		err=FSWrite(MainFRefNum,&count,bitmap);// on flush le fichier		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioResult=0;		pb.ioParam.ioRefNum=MainFRefNum;		PBFlushFile((ParmBlkPtr)&pb,false);		// on ferme le fichier		FSClose(MainFRefNum);// on flush le volume		pb.ioParam.ioVRefNum=theVolume;		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioNamePtr=(StringPtr)nil;		pb.ioParam.ioResult=0;		PBFlushVol((ParmBlkPtr)&pb,false);		return 0;}static void C_paintRect(Rect *rect,long color,Ptr BaseAdresse,long RowBytes){long		L;long*	P;long		x,y,i,j;	x=rect->right-rect->left;	y=rect->bottom-rect->top;	L=rect->top*RowBytes+rect->left*4;	L+=(long)BaseAdresse;	for(i=0;i<y;i++){		P=(long*)L;		for(j=0;j<x;j++){			*P=color;			P++;		}		L+=RowBytes;	}}