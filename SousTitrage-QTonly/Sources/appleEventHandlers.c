#include "BB.Globals_C.h"// If the interfaces aren't included yet, do the standard includes. Otherwise, precompiled headers// have been loaded already, thank you very much#ifndef __TYPES__	#include <Types.h>	#include <AppleEvents.h>	#include <Desk.h>	#include <Dialogs.h>	#include <Editions.h>	#include <Events.h>	#include <Menus.h>	#include <SegLoad.h>	#include <TextUtils.h>	#include <ToolUtils.h>	#include <Windows.h>#endif#include "appleEventHandlers.h"/*	Private routines */	/* Globals */extern MyQDGlobals QD;extern AppGlobals G;	extern Boolean	gDone;							/* Set to true if user selects Quit */pascal OSErr	OAPPHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon);pascal OSErr	ODOCHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon);pascal OSErr	PDOCHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon);pascal OSErr	QUITHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon);pascal void	HandleGenericHighLevelEvent(EventRecord *event);pascal void	DoHighLevelEvent(EventRecord *event);/*	Handle the ‘oapp’ AppleEvent.	*/pascal OSErr	OAPPHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon){#pragma unused (reply, handlerRefCon)	OSErr		oappErr;	AEKeyword	missedKeyWord;	DescType	actualType;	Size		actualSize;		oappErr = AEGetAttributePtr(&theAppleEvent, keyMissedKeywordAttr, typeWildCard, &actualType, (Ptr) &missedKeyWord, sizeof(missedKeyWord), &actualSize);	if (!oappErr)					/* If no error, then a missing parameter was found */		return errAEParamMissed;		/*	Do whatever needs to be done when starting up and return noErr */		return	noErr;}/*	Handle the ‘odoc’ AppleEvent.	*/pascal OSErr	ODOCHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon){#pragma unused (reply, handlerRefCon)	OSErr			odocErr;	AEKeyword		missedKeyWord;	DescType		actualType;	Size			actualSize;	AEDescList		documentList;	long			itemsInList;	long			i;	AEKeyword		keyWord;	DescType		typeCode;	FSSpec			documentFileSpec;	TargetID		senderType;	OSType			senderCreator;	ProcessSerialNumber	thePSN;		odocErr = AEGetParamDesc(&theAppleEvent, keyDirectObject, typeAEList, &documentList);	/* Get list of documents to open */	if (odocErr)		return odocErr;			odocErr = AEGetAttributePtr(&theAppleEvent, keyMissedKeywordAttr, typeWildCard, &actualType, (Ptr) &missedKeyWord, sizeof(missedKeyWord), &actualSize);	if (!odocErr)					/* If no error, then a missing parameter was found */		return errAEParamMissed;		/* 		If we’re in the background, see if the event was sent from the Finder.  If so,		switch to the front.	*/		if (G.InBackground) {		odocErr = AEGetAttributePtr(&theAppleEvent, keyAddressAttr, typeTargetID, &actualType, (Ptr) &senderType, sizeof(senderType), &actualSize);		BlockMove((Ptr) (&(senderType.name.u.portTypeStr)+1), (Ptr) &(senderCreator), 4);		if (senderCreator == 'MACS') {			thePSN.highLongOfPSN = 0;			thePSN.lowLongOfPSN = kCurrentProcess;			SetFrontProcess(&thePSN);		}	}	/* Open all the documents in documentList */		odocErr = AECountItems(&documentList, &itemsInList);		/* Get number of documents */		for (i = 1; i <= itemsInList; i++) {		odocErr = AEGetNthPtr(&documentList, i, typeFSS, &keyWord, &typeCode, (Ptr) &documentFileSpec, sizeof(documentFileSpec), &actualSize);		/*DoOpenFile(&documentFileSpec);*/			}			odocErr = AEDisposeDesc(&documentList);			/* Dispose of AE structure created by AEGetParamDesc */	return	noErr;}/*	Handle the ‘pdoc’ AppleEvent.	*/pascal OSErr	PDOCHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon){#pragma unused (reply, handlerRefCon)	OSErr		pdocErr;	AEKeyword	missedKeyWord;	DescType	actualType;	Size		actualSize;	AEDescList	documentList;	long		itemsInList;	long		i;	AEKeyword	keyWord;	DescType	typeCode;	FSSpec		documentFileSpec;		pdocErr = AEGetParamDesc(&theAppleEvent, keyDirectObject, typeAEList, &documentList);	/* Get list of documents to open */		pdocErr = AEGetAttributePtr(&theAppleEvent, keyMissedKeywordAttr, typeWildCard, &actualType, (Ptr) &missedKeyWord, sizeof(missedKeyWord), &actualSize);	if (!pdocErr)					/* If no error, then a missing parameter was found */		return errAEParamMissed;		/* Print all the documents in documentList */		pdocErr = AECountItems(&documentList, &itemsInList);		/* Get number of documents */		for (i = 1; i <= itemsInList; i++) {		pdocErr = AEGetNthPtr(&documentList, i, typeFSS, &keyWord, &typeCode, (Ptr) &documentFileSpec, sizeof(documentFileSpec), &actualSize);		/*DoPrintFile(&documentFileSpec);*/	}			pdocErr = AEDisposeDesc(&documentList);					/* Dispose of AE structure created by AEGetParamDesc */	return	noErr;}/*	Handle the ‘quit’ AppleEvent.	*/pascal OSErr	QUITHandler(AppleEvent theAppleEvent, AppleEvent reply, long handlerRefCon){#pragma unused (reply, handlerRefCon)	OSErr		quitErr;	AEKeyword	missedKeyWord;	DescType	actualType;	Size		actualSize;		quitErr = AEGetAttributePtr(&theAppleEvent, keyMissedKeywordAttr, typeWildCard, &actualType, (Ptr) &missedKeyWord, sizeof(missedKeyWord), &actualSize);	if (!quitErr)					/* If no error, then a missing parameter was found */		return errAEParamMissed;		/*	Do whatever needs to be done when quitting and return noErr */		gDone = true;		return	noErr;}/*	Handle high level events */pascal void	DoHighLevelEvent(EventRecord *event){	OSErr	AEProcessResult;		switch	(event->message) {		case kCoreEventClass:	AEProcessResult = AEProcessAppleEvent(event);	/*	Handle core AppleEvents */								break;		//case rSectionType:	break;											/*	Handle Edition Manager AppleEvents */				//default:				HandleGenericHighLevelEvent(event);				/*	Other high level events */		//						break;		}}pascal void	HandleGenericHighLevelEvent(EventRecord *event){	TargetID	eventSenderInfo;	unsigned	long eventIdentifier;	Ptr			dataBuffer;	unsigned	long dataSize;	OSErr	HLEventError;		dataSize = 0;	dataBuffer = nil;	HLEventError = AcceptHighLevelEvent(&eventSenderInfo, &eventIdentifier, dataBuffer, &dataSize);		/*		Since we don’t know how much data is coming in, call AcceptHighLevelEvent once to		find out how much data was sent, then use create a new buffer large enough to hold		all the data, then call AcceptHighLevelEvent again to get the data.	*/		if (HLEventError == bufferIsSmall) {		dataBuffer = NewPtr(dataSize);		HLEventError = AcceptHighLevelEvent(&eventSenderInfo, &eventIdentifier, dataBuffer, &dataSize);	}			/*	Dispatch the high level event to the proper routine depending on the message class */		switch	(event->message) {	}		if (dataBuffer)		DisposPtr(dataBuffer);}