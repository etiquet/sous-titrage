	PRINT	PUSH,OFF				INCLUDE	'NewVista.a'	; pour la nu vista+	INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'FSEqu.a'	INCLUDE	'PackMacs.a';	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.;	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'TimeEqu.a'		; pour utiliser le time manager	include	'PickerEqu.a'	INCLUDE	'Aliases.a'	INCLUDE	'VXEqu.a'	INCLUDE	'VXHWEqu.a'	INCLUDE	'SlotEqu.a'		; pour le slot manager	PRINT	POP		IMPORT	G:AppGlobals		IMPORT	QD:MyQDGlobals	machine	MC68030;		SEG	'Rendering'			; case sensitive; pour l'instant on définie ici les paramètres suivant; ####; note 1: il pourra ètre nécéssaire d'insérer,; un coefficient de réentrée par la droite pour coller les caractères entres eux comme le T par ex; et aussi la hauteur max pour que cela puisse ètre actif.; on pourra utilisé le spare pour cela;; note 2: il faudra placer dans le style spare  adr: n° de style*8 +4;			le max ascent de la police.b , max descent.b , style type.b;;; note 3: il faut inclure dans le font record les parramètres suivants:;			normal spacing, underline position, min spacing ?, ... styleHeaderSize	equ	$0000008		CharHeaderSize	equ	00000020		CH_NextChar		equ	0CH_PreviousChar	equ	4CH_CharNumber	equ	8CH_Spare		equ	10		;(distance de réentrée, hauteur max de réentré ?)CH_Rect			equ	12PlaneInfoSize	equ	16pi_Rect			equ	0		; rectangle du planpi_PlaneBase	equ	8		; ptr du plan charpi_Baseline		equ	12		; base line du planpi_spare		equ	14		; spare 		; cette routine permet de tester la validitée des import de reférence entre routine MPW_asm et Metrowerk_CTestAdresseGlobales_rend 	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointstructure		ds.l	1					; p2				ds.l	1					; ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR								WITH	StackFrame,Rect		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				move.l	structure(a6),a0				lea		QD.dkGray,a1				move.l	a1,(a0)				lea		G.spareForFutur,a1				move.l	a1,4(a0)				move.l	p2(A6),a2				lea		G.performanceTask,a1				move.l	A1,(a2)				lea		G.AskTcTask,a1				move.l	A1,4(a2)				lea		G.Rechercher_STR,a1				move.l	A1,8(a2)				lea		G.EveHandle,a1				move.l	A1,12(a2)				lea		G.versionLogiciel,a1				move.l	A1,16(a2)				lea		G.Justification,a1				move.l	A1,20(a2)				lea		G.SoftProtect,a1				move.l	A1,24(a2)				lea		G.CurrentFileName,a1				move.l	A1,28(a2)							UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)				DbgInfo.new	TestAdresseGlobales_rend			; this name will appear in the debugger		align 4			ENDP			* ********************************************************* ConfigureRenderRecord* ********************************************************;	Cette Macro transforme les valeurs du dialog RenderFontPref;	en un record "RenderFontRecord";;				MACRO 		CONFIGURE_RENDER_RECORD 		PRINT		Push,NoMDir 				pea		DialogStorage(a6)		move.w	#11,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7		lea		FontRenderParram(a6),a0			move.w	d0,FontSize(a0); on récupère la police		move.l	G.PopUp_Font,-(sp)		move.w	PopUpItem(a6),-(sp)		pea		textBuff(a6)		_GetItem				pea		TextBuff(a6)		lea		FontRenderParram(a6),a0			pea		FontNumber(a0)		_GetFNum		; on recupère les styles	; on récupère l'état du gadget use bold		pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue			move.w	(sp)+,d7		lea		FontRenderParram(a6),a0			move.w	d7,UseBold(a0)	; 		moveq	#0,d7; on calcule le nombre de style à dessiner				moveq	#1,d6				pea		DialogStorage(a6)		move.w	#32,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue			move.w	(sp)+,d0		beq.s	@1		or.w	#2,d7				addq.W	#1,d6@1		pea		DialogStorage(a6)		move.w	#33,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem; on regarde si le "use bold est actif"		lea		FontRenderParram(a6),a0			tst.w	UseBold(a0)			bne.s	@2		clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue			move.w	(sp)+,d0		beq.s	@2		addq.W	#1,d6		or.w	#1,d7		@2		pea		DialogStorage(a6)		move.w	#34,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue				move.w	(sp)+,d0		beq.s	@3;		addq.W	#0,d6				; pour le souligné  on ne dessine pas car ce n'est qu'un trait;		or.w	#4,d7		@3				lea		FontRenderParram(a6),a0			move.w	d7,FontStyle(a0)				; type de style à rendre		move.w	d6,Face_Number(a0)				; nombre de style à rendre 1 à 2 (nb sous-ligné = un trait en dessous) 		move.w	#2,Plane_Number(a0)				; nombre de couche pour le caractère (face,border,shadow..., key face,  etc ...)												; fixée à 2 pour l'instant				; on place les thickness 		pea		DialogStorage(a6)		move.w	#14,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7		lea		FontRenderParram(a6),a0			move.w	d0,FaceThickness(a0)					pea		DialogStorage(a6)		move.w	#20,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7		lea		FontRenderParram(a6),a0			move.w	d0,BorderThickness(a0)				; blur		pea		DialogStorage(a6)		move.w	#17,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7		lea		FontRenderParram(a6),a0			move.w	d0,FaceBlur(a0);				pea		DialogStorage(a6)		move.w	#23,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7		lea		FontRenderParram(a6),a0			move.w	d0,BorderBlur(a0)				; border position		pea		DialogStorage(a6)		move.w	#26,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7		lea		FontRenderParram(a6),a0			move.w	d0,BorderXoffset(a0)			pea		DialogStorage(a6)		move.w	#29,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7				neg.w	d0		; oui il faut inverser car Y positif vers le bas		lea		FontRenderParram(a6),a0			move.w	d0,BorderYoffset(a0)		; on recupère le ratio		pea		DialogStorage(a6)		move.w	#36,-(sp)				; item 16:9		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue				move.w	(sp)+,d0		beq		@QuatreTier_Actif		move.w	#$1609,d0		bra.s	@Set_Ratio@QuatreTier_Actif				move.w	#$403,d0@Set_Ratio		lea		FontRenderParram(a6),a0			move.w	d0,FontRatio(a0); pour l'instant on raz les coordonneés de l'ombre		clr.w		ShadowThickness(a0)		clr.w		ShadowXoffset(a0)		clr.w		ShadowYoffset(a0)		clr.w		ShadowSkew(a0)		clr.w		ShadowInclinaison(a0)		clr.w		ShadowHeight(a0)		clr.w		ShadowWidth(a0)		clr.w		ShadowBlur(a0)		clr.w		ShadowPlain(a0)		clr.l		ShadowEffect(a0)		clr.l		ShadowTextur(a0)		clr.l		ShadowRGBAlpha(a0)		clr.l		ShadowRGBAlpha2(a0)		clr.w		ShadowSpread(a0)		clr.l		ShadowSpare(a0)								PRINT	Pop  		ENDM								 * ================================================* PROCEDURE Preference_Affichage(); * ================================================**	Préference d'affichage*Preference_Affichage 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		RectItemHit		ds.w	1itemType2	ds.w	1		; stockage du type de ItemitemHandle2	ds.L	1		; stockage	du handle du itemitemRect2	ds		RectWhere		ds.l	1oldWhere	ds.l	1rectangle	ds		RectRGB_Color			ds.w	3			; rgb valueHSL			ds.w	3			; hsl	valueWindowPort	ds.l	1Luminance	ds.l	1test 		ds.w	1thechar		ds.w	1CharLargeur	ds.w	1LargeurReduction	ds.w	1Row			ds.w	1DialogStorage2 		ds 	dWindLenThe_DialogPtr		ds.l	1PopUp_Police		ds.l	1PopUpItem			ds.w	1	FontRenderParram	ds	FontRenderRecordtrucks				ds.l	1FontHandle			ds.l	1memAvail			ds.l	1Grow				ds.l	1Parrametre			ds.l	1	; face color, border color, outline boxType_Parrametre		ds.l	1	; hue, luminance, saturation, transparenceoffset_curseur		ds.w	1Values				ds.w	16saveFaceColor				ds.l	1saveborderColor				ds.l	1saveshadowColor				ds.l	1saveOutlineBoxColor			ds.l	1FastFontMustBeCreated		ds.w	1TheEvent			ds		evtBlkSizeSaveRgb				ds.w	3				; backRgb				ds.w	3				;SaveX_Offset			ds.w	1SaveY_Offset			ds.w	1saveNormalKerning		ds.w	1savespaceWidth			ds.w	1SaveDrawState			ds.w	1saveResourceRef			ds.w	1FoundHandle				ds.l	1PopUpPoint			ds.l	1	;PrefFileId			ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor,PREF_AFF_REC		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,DropShadowRect,\					draw_Button_Display,draw_Frame_Curseur	IMPORT	qd:MYQDGLOBALS		movem.l d1-d7/a1-a4,-(sp)				clr.w	FastFontMustBeCreated(a6)		; on regarde s'il faut afficher la VRAM		move.w	G.DrawState,SaveDrawState(a6)	; on sauvegarde l'état de la carte d'affichage 		tst.l	G.Base_Adresse			; il y a t-il une carte d'affichage 		beq.s	Pas_deCarteAffichage	; non		; on active la carte		move.w	#$8001,G.DrawState	; travail effectué par la VBL task@azert	move.w	G.DrawState,d0	; travail effectué par la VBL task		and.w	#$ff00,d0		bne.s	@azertPas_deCarteAffichage; on récupère le maximum de mémoire 		suba.l	a1,a1		_maxMem		move.l	d0,memAvail(a6)		clr.l	-(sp)		move.w	#163,-(sp)	; id number		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),The_DialogPtr(a6)  		_DrawDialog   ;	; -------------------------------; 		on lit le pop up menu		clr.l	-(sp)		move.w	#2011,-(sp)		_GetRMenu		move.l	(sp),PopUp_Police(a6)		move.w	#-1,-(sp)	; hierarchical menu		_insertMenu		 		move.l	#'Bbdf',-(sp)		move.l	PopUp_Police(a6),-(sp)		pea		FoundHandle(a6)		import 	C_MakeTheBbdfMenu		jsr 	C_MakeTheBbdfMenu					bsr		InternalDraw		move.w	#1,PopUpItem(a6)		move.l	PopUp_Police(a6),a4		moveq	#1,d1		move.w	#5,d0		; item 5		bsr		DrawPopUpMenu		bsr		ShowHide_Boutton		; ---------------------------------------------------		WaitEvent		move.l		The_DialogPtr(a6),-(sp)			_SetPort		  		import	PrefAffFilter  		pea		PrefAffFilter		pea	ItemHit(a6)		_ModalDialog		move.w	ItemHit(a6),d7				move.l		The_DialogPtr(a6),-(sp)			_SetPort		; grisaille sur boutons kern space etc ... ?				  		cmp.w	#-1,d7 		bne.s	PAsUpdate		move.l	The_DialogPtr(a6),-(sp)			_BeginUpdate				move.l	The_DialogPtr(a6),-(sp)			_DrawDialog		bsr		InternalDraw		move.w	#1,PopUpItem(a6)		move.l	PopUp_Police(a6),a4		moveq	#1,d1		move.w	#5,d0		; item 5		bsr		DrawPopUpMenu		bsr		ShowHide_Boutton		move.l	The_DialogPtr(a6),-(sp)			_EndUpdatePAsUpdate						move.l	The_DialogPtr(a6),-(sp)			move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		case#.w	(d7,if),\		(37,Display_kern_Automatique),\		(1,ok),\		(2,cancel),\		(3,Default),\		(4,testString),\		(5,Pop_Up_Police),\		(88,Overriding),\		(89,clear_Position),\		(57,LoadFont),\		(44,kern_up),\		(45,kern_down),\		(47,space_up),\		(48,space_down),\		(49,interligne_up),\		(50,interligne_down),\		(51,BoxSize_up),\		(52,BoxSize_down),\		(34,justif_Center),\		(35,justif_Left),\		(36,justif_Right),\		(39,BoxSizeV_up),\		(40,BoxSizeV_down),\		(30,Masquing_off),\		(31,Masquing_boxing),\		(32,Masquing_lineBox),\		(33,Masquing_alltheline)		; est ce un click dans une zone reglette		cmp.w	#6,d7		blo.s	WaitEvent	; non		cmp.w	#17,d7		bhi.s	WaitEvent	; non				cmp.w	#13,d7						; faut-il récréer toute la police ?		bhi.s	Pas_FastFontMustBeCreated	; non 		move.w	#$0101,FastFontMustBeCreated(a6)Pas_FastFontMustBeCreated; on détermine à quelle reglette appartient le click		move.w	d7,d0		sub.w	#6,d0		and.L	#$ffff,d0		divu	#4,d0		move.w	d0,Parrametre(a6)		; face color, border color, outline box		swap	d0		move.w	d0,Type_Parrametre(a6)	; hue, luminance, saturation, transparence													move.l	The_DialogPtr(a6),-(sp)			move.w	#false,-(sp)		move.w	d7,d0		move.w	d0,-(sp)		jsr	draw_Frame_Curseur		lea		Values(a6),a0		move.w	d7,d0		sub.w	#6,d0		lsl.w	#1,d0		move.w	(a0,d0.w),d0		; on effectue le ratio largeur rectangle // 65535				move.w	right+itemRect(a6),d1		sub.w	left+itemREct(a6),d1		sub.w	#11-2,d1		mulu	d1,d0		swap	d0		; ÷ $ffff 		move.l		The_DialogPtr(a6),-(sp)	 		move.w	d0,-(sp)			; the value		  		move.w	#true,-(sp) 		move.w	d7,d0 		move.w	d0,-(sp) 		jsr	draw_Button_Display; on calcule un offset // à la position du click de la souris		pea		Where(a6)		_GetMouse						move.w	left+Where(a6),d2		sub.w	left+itemRect(a6),d2		move.w	d7,d1		sub.w	#6,d1				lea		Values(a6),a0		move.w	d7,d0		sub.W	#6,d0		lsl.w	#1,d0		move.w	(a0,d0.w),d0		; on effectue le ratio largeur rectangle // 65535				move.w	right+itemRect(a6),d1		sub.w	left+itemREct(a6),d1		sub.w	#11-2,d1		mulu	d1,d0		divu	#$ffff,d0		; ÷ $ffff				sub.w	d0,d2				move.w	d2,offset_curseur(a6)		; si le click à eu lieu en dehors du curseur, il n'y a pas d'offset		cmp.w	#10,d2		bgt.s	AuDelaBouton		cmp.w	#0,d2		bgt.s	Enfonce		AuDelaBouton				move.w	#6,offset_curseur(a6); on calcule la position du click dans le boutonEnfonce		clr.w	-(sp)		_button		move.w	(sp)+,d0		beq 	Fin_Enfonce		pea		Where(a6)		_GetMouse				move.w	left+Where(a6),d0		sub.w	offset_curseur(a6),d0		move.w	d0,left+Where(a6)				move.w	oldWhere(a6),d0		cmp.w	left+Where(a6),d0			beq.s	Enfonce			move.w	left+Where(a6),oldWhere(a6)			move.l		The_DialogPtr(a6),-(sp)			move.w	#true,-(sp)		move.w	d7,d0		move.w	d0,-(sp)		jsr	draw_Frame_Curseur				move.w	left+Where(a6),d0		sub.w	left+itemRect(a6),d0		 	move.l		The_DialogPtr(a6),-(sp)	 		move.w	d0,-(sp)				  		move.w	#true,-(sp) 		move.w	d7,d0 		move.w	d0,-(sp) 		jsr	draw_Button_Display		move.w	d7,d0		add.w	#12,d0		move.l		The_DialogPtr(a6),-(sp)			move.w	d0,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				pea		itemRect2(a6)		_EraseREct				; on calcule la valeur pour l'afficher sur l'ecran		move.w	left+Where(a6),d0		sub.w	left+itemRect(a6),d0		add.w	#11-2,d0		mulu	#$ffff,d0; on effectue le ratio largeur rectangle // 65535				move.w	right+itemRect(a6),d1		sub.w	left+itemREct(a6),d1		divu	d1,d0						lea		Values(a6),a0		move.w	d7,d1		sub.W	#6,d1		lsl.w	#1,d1		move.w	d0,(a0,d1.w)		; on regarde quel type d'item il s'agit						tst.W	Type_Parrametre(a6)		bne.s	Not_Hue						; pas hue; donc c'est le hue		valeur sur 360°		mulu	#361,d0		divu	#$ffff,d0		cmp.w	#359,d0		blo.s	Display_number		move.w	#359,d0		bra.S	Display_number		; ce n'est pas le hue donc valeur sur 100 %Not_Hue				mulu	#101,d0		divu	#$ffff,d0		cmp.w	#100,d0		blo.s	Display_number		move.w	#100,d0		Display_number				and.l	#$ffff,d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7				move.w	left+itemRect2(a6),d0		add.w	#1,d0		move.w	d0,-(sp)				move.w	bottom+itemRect2(a6),d0		sub.w	#1,d0		move.w	d0,-(sp)		_MoveTo				pea		TextBuff(a6)		_DrawString				import	WaitTicks		move.l	#1,-(sp)		jsr		WaitTicks			bra		Enfonce		; -----------------------------------------------------		Fin_Enfonce						move.l		The_DialogPtr(a6),-(sp)			move.w	#true,-(sp)		move.w	d7,d0		move.w	d0,-(sp)		jsr	draw_Frame_Curseur		move.w	left+Where(a6),d0		sub.w	left+itemRect(a6),d0 		move.l		The_DialogPtr(a6),-(sp)	 		move.w	d0,-(sp)				  		move.w	#false,-(sp) 		move.w	d7,d0 		move.w	d0,-(sp) 		jsr	draw_Button_Display			bra		WaitEvent	; -----------------------------------------------------justif_Centerjustif_Leftjustif_Right		sub.w	#34,d7		move	d7,d0		jsr		set_button_Justif		bra		WaitEvent			; -------- gestion des boutons maskingMasquing_offMasquing_boxingMasquing_lineBoxMasquing_alltheline		sub.w	#30,d7		move	d7,d0		jsr		Do_masking_button						bra		WaitEvent	; -----------------------------------------------------		Default			move.l	#$ffffffff,G.RGB_FaceColor			move.l	#$ff000000,G.RGB_BorderColor			move.l	#$60000000,G.RGB_ShadowColor			move.l	#$60000000,G.RGB_OutlineBoxColor				move.w	#0,G.X_Offset									move.w	#518,G.Y_Offset		; 518= 576*90% 				move.w	#false,G.Overriding_All_Attribute	; on affiche le tout						bsr		initValue							bsr		DessinCurseur			bra		WaitEvent; ------------------------------------------------------kern_up; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#43,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#1,d4		move.l	#-5,d2		move.l	#60,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------kern_down; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#43,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#-1,d4		move.l	#-5,d2		move.l	#60,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------space_up; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#46,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#1,d4		move.l	#1,d2		move.l	#60,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------space_down; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#46,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#-1,d4		move.l	#1,d2		move.l	#60,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------interligne_up	; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#60,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#1,d4		move.l	#-10,d2		move.l	#50,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------interligne_down; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#60,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#-1,d4		move.l	#-10,d2		move.l	#50,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------BoxSize_up; si pas de display font on ne change rien;BoxSizeV_up		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l	The_DialogPtr(a6),-(sp)			move.w	#63,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#1,d4		move.l	#-10,d2		move.l	#50,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------BoxSize_down	; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l		The_DialogPtr(a6),-(sp)			move.w	#63,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#-1,d4		move.l	#-10,d2		move.l	#50,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------BoxSizeV_up; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l	The_DialogPtr(a6),-(sp)			move.w	#38,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#1,d4		move.l	#-10,d2		move.l	#50,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------BoxSizeV_down	; si pas de display font on ne change rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	WaitEvent				move.l	The_DialogPtr(a6),-(sp)			move.w	#38,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.l	#-1,d4		move.l	#-10,d2		move.l	#50,d3		bsr		IncDec_Value		bra		WaitEvent;	-------------------------------------------------------testString; on sauvegarde les données originales 									move.l	G.RGB_FaceColor,saveFaceColor(a6)			move.l	G.RGB_borderColor,saveborderColor(a6)			move.l	G.RGB_shadowColor,saveshadowColor(a6)			move.l	G.RGB_OutlineBoxColor,saveOutlineBoxColor(a6)			move.w	G.X_Offset,SaveX_Offset(a6)			move.w	G.Y_Offset,SaveY_Offset(a6)			lea		G.Display_Font,a0			move.w	NormalKerning(a0),saveNormalKerning(a6)			move.w	spaceWidth(a0),savespaceWidth(a6)			; on place les coordonnées, spacing , kerning; --------------------------------------				move.l		The_DialogPtr(a6),-(sp)			move.w	#43,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b1		move.w	d0,NormalKerning(a0); ---------------------------------------------------		@b1		move.l		The_DialogPtr(a6),-(sp)			move.w	#46,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b2		move.w	d0,spaceWidth(a0); ---------------------------------------------------		@b2				move.l		The_DialogPtr(a6),-(sp)			move.w	#41,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				move.w	d0,G.X_Offset; ------------------------------------				move.l		The_DialogPtr(a6),-(sp)			move.w	#42,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				move.w	d0,G.Y_Offset						move.w	#2,d7		loop_RecopieLesValeurs_EnMemoirebis; on convertie les valeur en RGB		lea		Values(a6),a1		move.w	d7,d1		lsl.w	#3,d1							move.w	0(a1,d1.w),hue+HSL(a6)	;hue		move.w	2(a1,d1.w),Saturation+HSL(a6)		move.w	4(a1,d1.w),Lightness+HSL(a6)				pea		HSL(a6)		pea		RGB_Color(a6)		_HSL2RGB		; on convertie toutes ces valeurs sur un mot de 32 bits		;l'alpha , transparence				lea		Values(a6),a1		move.w	d7,d1		lsl.w	#3,d1				move.b	6(a1,d1.w),d0			; transparence 		and.l	#$ff,d0				lsl.l	#8,d0		or.b	red+RGB_Color(a6),d0	; le rouge		lsl.l	#8,d0		or.b	Green+RGB_Color(a6),d0	; le vert		lsl.l	#8,d0		or.b	blue+RGB_Color(a6),d0	; le bleu						lea		G.RGB_FaceColor,a0		move.w	d7,d1		lsl.l	#2,d1				move.l	d0,(a0,d1.w)		dbra	d7,loop_RecopieLesValeurs_EnMemoirebis			import	clr_VX			jsr		clr_VX			import	Test_draw_string			jsr		Test_draw_string; on rend les données originales			move.w	SaveX_Offset(a6),G.X_Offset			move.w	SaveY_Offset(a6),G.Y_Offset			lea		G.Display_Font,a0			move.w	saveNormalKerning(a6),NormalKerning(a0)			move.w	savespaceWidth(a6),spaceWidth(a0)			move.l	saveFaceColor(a6),G.RGB_FaceColor			move.l	saveborderColor(a6),G.RGB_borderColor			move.l	saveshadowColor(a6),G.RGB_shadowColor			move.l	saveOutlineBoxColor(a6),G.RGB_OutlineBoxColor			bra		WaitEvent; -----------------------------LoadFont			import	Load_A_Font			jsr		Load_A_Font						; on redessine le dialog						bsr		InternalDraw						move.w	#1,PopUpItem(a6)			move.l	PopUp_Police(a6),a4			moveq	#1,d1			move.w	#5,d0		; item 5			bsr		DrawPopUpMenu			; on créer une font rapide;FontRender			ds.l	1		; record pour le passage des parramètres de rendus;DestinationSize		ds.w	1		; 16 ou 32 bits mode ?;RenderEffect		ds.l	1		; effet de rendu 						pea		G.Display_Font			move.w	#32,-(sp)			clr.l	-(sp)			import	Create_FastFont			jsr		Create_FastFont						move.w	#0,FastFontMustBeCreated(a6)		; on vient de la faire; on redessine le dialog									bsr		InternalDraw						move.w	#1,PopUpItem(a6)			move.l	PopUp_Police(a6),a4			moveq	#1,d1			move.w	#5,d0		; item 5			bsr		DrawPopUpMenu						bra		WaitEvent; ----------------------------Pop_Up_Police		move.l		The_DialogPtr(a6),-(sp)			_SetPort		move.l		The_DialogPtr(a6),-(sp)			move.w	#5,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	left+itemRect(a6),left+PopUpPoint(a6)		move.w	top+itemRect(a6),top+PopUpPoint(a6)		add.w	#1,left+PopUpPoint(a6)		add.w	#1,top+PopUpPoint(a6)		pea		PopUpPoint(a6)		_LocalToGlobal				move.l	The_DialogPtr(a6),-(sp)			move.w	#74,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect	; on check l'item		move.l	PopUp_Police(a6),-(sp)		move.w	PopUpItem(a6),-(sp)		move.w	#True,-(sp)		_CheckItem		; on affiche le menu						clr.l	-(sp)		move.l	PopUp_Police(A6),-(sp)		move.w	top+PopUpPoint(a6),-(sp)		move.w	left+PopUpPoint(a6),-(sp); on calcule la valeur de l'item		move.w	PopUpItem(a6),-(sp)		_PopUpMenuSelect		move.l	(sp)+,d6		; on récupère l'item dans d6				move.l	PopUp_Police(a6),-(sp)		move.w	PopUpItem(a6),-(sp)		move.w	#false,-(sp)		_CheckItem				move.l	The_DialogPtr(a6),-(sp)			move.w	#74,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect		tst.w	d6		beq		WaitEvent;; on redessine le texte du rectangle					move.l	PopUp_Police(a6),a4			move.w	D6,d1			move.w	#5,d0		; item 5			bsr		DrawPopUpMenu						move.w	d6,PopUpItem(a6)								; on ouvre le fichier		move.l	a4,-(sp)		move.w	d6,-(sp)		pea		textBuff(a6)		_GetItem						 		clr.w	-(sp) 		pea		textBuff(a6) 		import	GiveUser_Choice 		jsr		GiveUser_Choice 		move.w	(sP)+,d0	 		cmp.w	#1,d0 		bne		WaitEvent				move.l	FoundHandle(A6),A0		MOVE.L	(A0),A0		move.w	PopUpItem(a6),d0		sub.w	#1,D0		mulu	#70,d0		adda.l	d0,A0				move.l	a0,-(sp)		import	C_DoFileOpen		jsr		C_DoFileOpen								bra		WaitEvent			; ----------------------------OutlineBox			bsr	ToggleControl			bra	WaitEvent			; ----------------------------Overriding			bsr	ToggleControl			bra	WaitEvent; ----------------------------Display_kern_Automatique					bsr	ToggleControl		bra		WaitEvent; ----------------------------			Set_Positionclear_Position					bra		WaitEvent	; ----------------------------		ok	; on transfère les valeurs en mémoires; on effectue la conversion valeur dc.l	(RBG => small fract (HSL)										move.w	#2,d7		loop_RecopieLesValeurs_EnMemoire; on convertie les valeur en RGB		lea		Values(a6),a1		move.w	d7,d1		lsl.w	#3,d1							move.w	0(a1,d1.w),hue+HSL(a6)	;hue		move.w	2(a1,d1.w),Saturation+HSL(a6)		move.w	4(a1,d1.w),Lightness+HSL(a6)				pea		HSL(a6)		pea		RGB_Color(a6)		_HSL2RGB		; on convertie toutes ces valeurs sur un mot de 32 bits		;l'alpha , transparence				lea		Values(a6),a1		move.w	d7,d1		lsl.w	#3,d1				move.b	6(a1,d1.w),d0			; transparence 		and.l	#$ff,d0				lsl.l	#8,d0		or.b	red+RGB_Color(a6),d0	; le rouge		lsl.l	#8,d0		or.b	Green+RGB_Color(a6),d0	; le vert		lsl.l	#8,d0		or.b	blue+RGB_Color(a6),d0	; le bleu						lea		G.RGB_FaceColor,a0		move.w	d7,d1		lsl.l	#2,d1				move.l	d0,(a0,d1.w)		dbra	d7,loop_RecopieLesValeurs_EnMemoire; ----------------------------------		; on affecte les états des boutons		move.l		The_DialogPtr(a6),-(sp)			move.w	#30,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,G.Outline_Box; -----		move.l		The_DialogPtr(a6),-(sp)			move.w	#88,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,G.Overriding_All_Attribute		; on affecte le valeur d'affichage x pos, y pos		move.l		The_DialogPtr(a6),-(sp)			move.w	#41,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				move.w	d0,G.X_Offset; ------------------------------------				move.l		The_DialogPtr(a6),-(sp)			move.w	#42,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				move.w	d0,G.Y_Offset; --------------------------------------				move.l		The_DialogPtr(a6),-(sp)			move.w	#43,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@a1		move.w	d0,NormalKerning(a0); ---------------------------------------------------		@a1		move.l		The_DialogPtr(a6),-(sp)			move.w	#46,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@a2		move.w	d0,spaceWidth(a0); ---------------------------------------------------		@a2		move.l		The_DialogPtr(a6),-(sp)			move.w	#60,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@a3		move.w	d0,G.Display_interligne; ---------------------------------------------------		@a3		move.l		The_DialogPtr(a6),-(sp)			move.w	#63,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	@a4		move.w	d0,G.Boxing_Size@a4				move.l	The_DialogPtr(a6),-(sp)			move.w	#38,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_GetIText						lea		TextBuff(a6),a0		move.w	#1,-(sp)		_Pack7				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq 	@a5		move.w	d0,G.Boxing_SizeV@a5			move.w	#0,G.Offset_JustifRL		; ------------type de masquage -------------				move.w	#0,d7				move.l		The_DialogPtr(a6),-(sp)			move.w	#31,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,D0		beq.s	@none		add.w	#1,d7@none				move.l		The_DialogPtr(a6),-(sp)			move.w	#32,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,D0		beq.s	@none_1		add.w	#2,d7@none_1				move.l		The_DialogPtr(a6),-(sp)			move.w	#33,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,D0		beq.s	@none_2		add.w	#3,d7@none_2				move.w	d7,G.Outline_Box; ------------type de justif -------------				move.w	#0,d7				move.l		The_DialogPtr(a6),-(sp)			move.w	#35,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,D0		beq.s	@none_3		add.w	#1,d7@none_3			move.l		The_DialogPtr(a6),-(sp)			move.w	#36,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,D0		beq.s	@none_4		add.w	#2,d7@none_4				move.w	d7,G.Justification				; ------------ kerning automatique ----------		move.l		The_DialogPtr(a6),-(sp)			move.w	#37,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,G.Preference_KernCheck				; on invalide le sous-titre en cour d'affichage; pour que le processeur d'affichage redessine avec les nouveaux parramètres; choisi par l'utilisateur		clr.l	G.Sous_titreInOffscreen		; on invalide celui dans le buffer offscreen		clr.l	G.Sous_titre_dessined		; on invalide celui dans le buffer		; ---------------------------------------------------				; on regarde s'il faut créer une fast font 		move.w	FastFontMustBeCreated(a6),d0		beq		PasCreateFastFont; on créer une font rapide;FontRender			ds.l	1		; record pour le passage des parramètres de rendus;DestinationSize		ds.w	1		; 16 ou 32 bits mode ?;RenderEffect		ds.l	1		; effet de rendu 		pea		G.Display_Font		move.w	#32,-(sp)		clr.l	-(sp)		import	Create_FastFont		jsr		Create_FastFontPasCreateFastFont		move.w	#2011,-(sp)			_DeleteMenu					move.l	PopUp_Police(a6),-(sp)		_ReleaseResource				move.l		The_DialogPtr(a6),-(sp)				_DisposeDialog; on stocke le mode dans le fichier préférence		import	PutPrefAffInGeneralPref		jsr		PutPrefAffInGeneralPref; on stockelefonrender		clr.w	-(sp)	; oserr		clr.l	-(sp)	; pas de fss record		Pea		G.Display_Font		import	MakePrefFileLastDisplayFontUsed 		jsr		MakePrefFileLastDisplayFontUsed		move.w	(sp)+,d0		bra.s	Exit; --------------------------------------------------------------------------Cancel					move.w	#2011,-(sp)			_DeleteMenu					move.l	PopUp_Police(a6),-(sp)		_ReleaseResource				move.l		The_DialogPtr(a6),-(sp)				_DisposDialog		Exit			move.l	FoundHandle(a6),a0	; on dispose le handle  du menu les polices d'affichages		_DisposeHandle				movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		*****             Routines             *********		; ---------------------------------		DrawPopUpMenu						movem.l	d6-d7/a4,-(sp)		move.l	d1,d6		; item menu  		move.l	d0,d7		; n° item DItl				move.w	#2011,d5	; id du menu				move.l		The_DialogPtr(a6),-(sp)			move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem; on récupère la couleur de la chaîne en mémoire		_PenNormal		clr.l	-(sp)		move.w	d5,-(sp)		move.w	d6,-(sp)		_GetMCEntry		move.l	(sp)+,a0		cmp.l	#000000,a0		beq.s	NoColorMenu; on recopie la couleur du texte dans le rgb dans la pile			move.w	mctRGB2(a0),RGB_Color(a6)		move.w	2+mctRGB2(a0),2+RGB_Color(a6)		move.w	4+mctRGB2(a0),4+RGB_Color(a6)	; et on affecte cette couleur au port actuel		pea		RGB_Color(a6)		_RGBForecolor		NoColorMenu; on recupère la chaine de caractèred équivalente à la valeur stockée		move.l	a4,-(sp)		move.w	d6,-(sp)		pea		textBuff(a6)		_GetItem		; on dessine le texte		add.w	#14,left+itemRect(a6)				pea		itemRect(a6)		_eraseRect				move.w	#SrcOr,-(sp)		_TextMode; actif ou non		move.w	ItemType(a6),d0		btst	#7,d0		beq		Do_Normal 				pea		qd.Gray		_penPat		bra.s	Do_Normal_1Do_Normal		_penNormalDo_Normal_1				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),d0		add.w	#12,d0		; font ascent		move.w	d0,-(sp)		_moveTo				; on regarde s'il y a un nom de police dans le font reder record						lea		G.Display_Font,a0		tst.b	FontName(a0)		beq.s	NameNotExist		pea 	FontName(a0)		_drawString		bra.S	StringDone; -NameNotExist		pea		textBuff(a6)		_DrawString; -StringDone				; on rend la couleur noire pour le dessin du reste du popUp		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)	; et on affecte cette couleur au port actuel		pea		RGB_Color(a6)		_RGBForecolor				sub.w	#14,left+itemRect(a6); on dessine le triangle en fin de texte		move.l	itemRect(a6),rectangle(a6)		move.l	4+itemRect(a6),4+rectangle(a6)		move.w	bottom+rectangle(a6),d6		sub.w	top+rectangle(a6),d6	; d6 = hauteur pop up		subq.w	#8,d6					; hauteur triangle		move.w	right+rectangle(a6),d0		sub.w	#6,d0		move.w	d0,-(sp)				move.w	top+rectangle(a6),d0		add.w	#3,d0		move.w	d0,-(sp)		_MoveTo				move.w	#2,-(sp)		move.w	#2,-(sp)		_penSize				neg.w	d6		move.w	d6,-(sp)		neg.w	d6		move.w	d6,-(sp)		_Line				neg.w	d6		move.w	d6,-(sp)		move.w	d6,-(sp)		_Line				neg.w	d6		asl.w	#1,d6			;*2		move.w	d6,-(sp)		clr.w	-(sp)		_Line		; on dessine le rectangle autour du texte						move.w	#1,-(sp)		move.w	#1,-(sp)		_penSize				pea		itemRect(a6)		_FrameRect				move.w	left+itemRect(a6),d0		add.w	#1,d0		move.w	d0,-(sp)				move.w	bottom+itemRect(a6),d0		move.w	d0,-(sp)		_MoveTo				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#1,d0		move.w	d0,-(sp)		clr.w	-(sp)		_line				move.w	top+itemRect(a6),d0		sub.w	bottom+itemRect(a6),d0		clr.w	-(sp)		add.w	#1,d0 		move.w	d0,-(sp)		_line				_PenNormal			Exit_DrawPopUp		movem.l	(sp)+,d6-d7/a4		rts						; ----------------ToggleControl		clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		beq		@1		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue		rts@1		move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue		rts		; ------------------; --------------------------------------------; ----------initValue		; on effectue la conversion valeur dc.l	(RBG => small fract (HSL)						move.w	#2,d7		loop_RecopieLesValeurs		lea.l	G.RGB_FaceColor,a0		move.w	d7,d0		lsl.w	#2,d0			; mot long		move.l	(a0,d0.w),d0				clr.w	blue+RGB_Color(a6)		move.b	d0,blue+RGB_Color(a6)		beq.S	@1		move.b	#$ff,1+blue+RGB_Color(a6)@1				lsr.l	#8,d0		clr.w	Green+RGB_Color(a6)		move.b	d0,Green+RGB_Color(a6)		beq.S	@2		move.b	#$ff,1+Green+RGB_Color(a6)@2				lsr.l	#8,d0		clr.w	Red+RGB_Color(a6)		move.b	d0,Red+RGB_Color(a6)		beq.S	@3		move.b	#$ff,1+Red+RGB_Color(a6)@3				; on effectue la conversion rgb => hsl		pea		RGB_Color(a6)		pea		HSL(a6)		_RGB2HSL; on recopie la valeur de la transparence		lea.l	G.RGB_FaceColor,a0		move.w	d7,d0		lsl.w	#2,d0		move.l	(a0,d0.w),d0				rol.l	#8,d0						lea		Values(a6),a1				move.w	d7,d1		lsl.w	#3,d1							clr.w	6(a1,d1.w)		move.b	d0,6(a1,d1.w)			; transparence expansion 8 => 16 bits		move.b	#$ff,7(a1,d1.w); on recopie les autres valeurs		move.w	hue+HSL(a6),0(a1,d1.w)	;hue		move.w	Saturation+HSL(a6),2(a1,d1.w)		move.w	Lightness+HSL(a6),4(a1,d1.w)		dbra	d7,loop_RecopieLesValeurs		; on affecte les états des boutons; masking mode		move.w	G.Outline_Box,d0		jsr		Do_masking_button		; -----		move.l		The_DialogPtr(a6),-(sp)			move.w	#88,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	G.Overriding_All_Attribute,-(sp)		_SetCtlValue;---------- on affecte les positions d'affichages; x offset		move.l		The_DialogPtr(a6),-(sp)			move.w	#41,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				moveq	#0,d0		move.w	G.X_Offset,d0		ext.l	d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetIText		; baseline						move.l		The_DialogPtr(a6),-(sp)			move.w	#42,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				moveq	#0,d0		move.w	G.Y_Offset,d0		ext.l	d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7				move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetIText		; kern				move.l	The_DialogPtr(a6),-(sp)			move.w	#43,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						moveq	#0,d0		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b1		move.w	NormalKerning(a0),d0		ext.l	d0@b1		lea		TextBuff(a6),a0		clr.w	-(sp)		_pack7		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetItext							pea		itemRect(a6)		move.w	#-2,-(sp)		move.w	#-2,-(sp)		_InsetRect				; space				move.l	The_DialogPtr(a6),-(sp)			move.w	#46,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				moveq	#0,d0		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b2		move.w	spaceWidth(a0),d0		ext.l	d0@b2											lea		TextBuff(a6),a0		clr.w	-(sp)		_pack7		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetItext						pea		itemRect(a6)		move.w	#-2,-(sp)		move.w	#-2,-(sp)		_InsetRect		; ----------- interligne supplémentaire		move.l		The_DialogPtr(a6),-(sp)			move.w	#60,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				moveq	#0,d0		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b3		move.w	G.Display_interligne,d0		ext.l	d0@b3		lea		TextBuff(a6),a0		clr.w	-(sp)		_pack7		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetItext				pea		itemRect(a6)		move.w	#-2,-(sp)		move.w	#-2,-(sp)		_InsetRect		; taille des rectangles	mask		move.l	The_DialogPtr(a6),-(sp)			move.w	#63,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				moveq	#0,d0		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b4		move.w	G.Boxing_Size,d0		ext.l	d0@b4		lea		TextBuff(a6),a0		clr.w	-(sp)		_pack7		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetItext								pea		itemRect(a6)		move.w	#-2,-(sp)		move.w	#-2,-(sp)		_InsetRect; taille des rectangles	mask		move.l	The_DialogPtr(a6),-(sp)			move.w	#38,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				moveq	#0,d0		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq.s	@b5		move.w	G.Boxing_SizeV,d0		ext.l	d0@b5		lea		TextBuff(a6),a0		clr.w	-(sp)		_pack7		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)		_SetItext						pea		itemRect(a6)		move.w	#-2,-(sp)		move.w	#-2,-(sp)		_InsetRect; ------------ kerning automatique ----------		move.l		The_DialogPtr(a6),-(sp)			move.w	#37,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	G.Preference_KernCheck,-(sp)				_SetCtlValue				rts		; ------------------------------------		; routine pour configurer les boutons type de maskingDo_masking_button		move.w	D0,d7		move.l		The_DialogPtr(a6),-(sp)			move.w	#30,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l		The_DialogPtr(a6),-(sp)			move.w	#31,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l		The_DialogPtr(a6),-(sp)			move.w	#32,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l		The_DialogPtr(a6),-(sp)			move.w	#33,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.w	#30,D0		add.w	D7,D0		move.l		The_DialogPtr(a6),-(sp)			move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#True,-(sp)		_SetCtlValue				rts; ------------------------------------		; routine pour configurer les boutons type de justificationset_button_Justif		move.w	D0,d7		move.l		The_DialogPtr(a6),-(sp)			move.w	#34,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue						move.l		The_DialogPtr(a6),-(sp)			move.w	#35,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l		The_DialogPtr(a6),-(sp)			move.w	#36,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.w	#34,D0		add.w	D7,D0		move.l		The_DialogPtr(a6),-(sp)			move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		move.w	#True,-(sp)		_SetCtlValue				; on regarde s'il faut hides quelques items						tst.w	d7		beq.S	Centered_justif; modes non centrénon_Centered_justif				move.l		The_DialogPtr(a6),-(sp)			move.w	#37,-(sp)		_HideDItem		move.l		The_DialogPtr(a6),-(sp)			move.w	#92,-(sp)		_ShowDItem		move.l		The_DialogPtr(a6),-(sp)			rts; -----------		Centered_justif				; on dessine un carré autour de l'offset				move.l		The_DialogPtr(a6),-(sp)			move.w	#92,-(sp)		_HideDItem		move.l		The_DialogPtr(a6),-(sp)			move.w	#37,-(sp)		_ShowDItem		rts; ----------------------------------findIconResourceDitl		move.l	The_DialogPtr(a6),a0		move.l	items(a0),a0		move.l	(a0),a0		; handle		;	on a le ditl 				add.l	#2,a0		moveq	#1,d6		move.w	d0,d7SearchLoop		move.l	(a0),a4				move.b	13(a0),d0	; longueur des data		add.l	#14,a0		cmp.w	d7,d6		beq		Zexit	; ça y est ;non on continue		and.l	#$ff,d0		move.l	d0,d1		divu	#2,d1		swap	d1		add.w	d1,d0		and.l	#$ffff,d0	; alignement sur dc.w		add.l	d0,a0		; item suivant		addq.w	#1,d6		bra.s	SearchLoop		Zexit	move.w	(a0),d0		rts		; hilite icon buttonhilite_icon_button		move.l		The_DialogPtr(a6),-(sp)			move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	d7,d0		jsr		findIconResourceDitl		addq.w	#1,d0		pea		itemRect(a6)		jsr		Custom_PlotCIcon		rts		Unhilite_icon_button				move.l		The_DialogPtr(a6),-(sp)			move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	d7,d0		jsr		findIconResourceDitl				pea		itemRect(a6)		jsr		Custom_PlotCIcon		rts			; -----------------------------------				IncDec_Value			movem.l	d2-d4,-(sp)			Bsr	hilite_icon_button		clr.l	-(sp)		_TickCount		move.l	(sp)+,trucks(a6)		movem.l	(sp)+,d2-d4 	loop_IncDec				movem.l	d2-d4,-(sp)			move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_GetItext				lea		TextBuff(a6),a0		move.w	#1,-(sp)		_pack7				movem.l	(sp)+,d2-d4 				add.l	d4,d0		cmp.l	d2,d0		bgt.s	@2		move.l	d2,d0		bra.s	@3				@2		cmp.l	d3,d0		blt.s	@4		move.l	d3,d0		@3		movem.l	d2-d4,-(sp)			lea		TextBuff(a6),a0		move.w	#0,-(sp)		_pack7		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_SetItext		bra		@5		@4		movem.l	d2-d4,-(sp)			lea		TextBuff(a6),a0		move.w	#0,-(sp)		_pack7		move.l	ItemHandle2(a6),-(sp)		pea		TextBuff(a6)		_SetItext			@5		movem.l	(sp)+,d2-d4 @6		move.l	ticks,d0; on teste si valeur > minimum attente		sub.l	Trucks(a6),d0		cmp.w	KeyThresh,d0		bhi.s	PasAttente				clr.w	-(sp)		_Button			; LE BOUTON SOURIS est-il encore enfoncé ?		move.w	(sp)+,d0			beq		end_IncDec		bra.s	@6PasAttente		import	WaitTicks		moveq	#0,d0		move.w  KeyRepThresh,d0		move.l	d0,-(sp)		jsr		WaitTicks				clr.w	-(sp)		_Button			; LE BOUTON SOURIS est-il encore enfoncé ?		move.w	(sp)+,d0		bne		loop_IncDec		end_incDec				bsr	Unhilite_icon_button			rts; ---------		DessinCurseur		; on entoure les carrés de valeurs; on dessine les rectangles de valeurs; on dessine les boutons en position		move.w	#18,d7		loop_dessinCarre				move.l		The_DialogPtr(a6),-(sp)			move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	d7,d0		sub.w	#12,d0				move.l		The_DialogPtr(a6),-(sp)			move.w	d0,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				pea		itemRect(a6)		move.w	#-1,-(sp)		move.w	#-1,-(sp)		_InsetRect		pea		itemRect(a6)		_FrameRect						pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_InsetRect				pea		itemRect(a6)		_EraseREct				lea		Values(a6),a0		move.w	d7,d0		sub.w	#18,d0		lsl.w	#1,d0		move.w	(a0,d0.w),d0		; on effectue le ratio largeur rectangle // 65535		; on calcule la valeur pour l'afficher sur l'ecran; on effectue le ratio largeur rectangle // 65535				move.w	right+itemRect2(a6),d1		sub.w	left+itemREct2(a6),d1		sub.w	#11+2,d1		mulu	d1,d0		divu	#$ffff,d0		move.w	d0,d5					; postion du curseur				lea		Values(a6),a0		move.w	d7,d0		sub.w	#18,d0		lsl.w	#1,d0		move.w	(a0,d0.w),d0		; on regarde quel type d'item il s'agit						move.w	d7,d6		sub.W	#18,d6		and.w	#$3,d6		bne.s	@5						; pas hue; donc c'est le hue		valeur sur 360°		mulu	#360,d0		divu	#$ffff,d0		bra.S	@6		; ce n'est pas le hue donc valeur sur 100 %@5				mulu	#100,d0		divu	#$ffff,d0		bra.S	@6		@6				and.l	#$ffff,d0		move.W	d0,d6		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7		; on affiche la valeur		move.w	left+itemRect(a6),d0		add.w	#1,d0		move.w	d0,-(sp)				move.w	bottom+itemRect(a6),d0		sub.w	#1,d0		move.w	d0,-(sp)		_MoveTo				pea		TextBuff(a6)		_DrawString						move.l		The_DialogPtr(a6),-(sp)			move.w	#true,-(sp)		move.w	d7,d0		sub.w	#12,d0		move.w	d0,-(sp)		jsr	draw_Frame_Curseur 		move.l		The_DialogPtr(a6),-(sp)	 		move.w	d5,-(sp)				; pour voir 		move.w	#false,-(sp) 		move.w	d7,d0 		sub.w	#12,d0 		move.w	d0,-(sp) 		jsr	draw_Button_Display		addq.w	#1,d7		cmp.w	#30,d7		blo.s	loop_dessinCarre				rts; -------------------------------------internalDraw		move.l		The_DialogPtr(a6),-(sp)					_SetPort				move.l		The_DialogPtr(a6),-(sp)			_drawDialog; on trace le contour du bouton ok				move.l		The_DialogPtr(a6),-(sp)			move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l		The_DialogPtr(a6),-(sp)			_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect; rectangle		move.w	#1,-(sp)		move.w	#1,-(sp)		_PenSize		; ---------------------------------------		; on dessine les rectangles		move.l		The_DialogPtr(a6),-(sp)			move.w	#64,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_FrameRect				move.l		The_DialogPtr(a6),-(sp)			move.w	#65,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect		move.l		The_DialogPtr(a6),-(sp)			move.w	#61,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect				move.l		The_DialogPtr(a6),-(sp)			move.w	#62,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect				move.l		The_DialogPtr(a6),-(sp)			move.w	#53,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect				move.l		The_DialogPtr(a6),-(sp)			move.w	#54,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect				move.l		The_DialogPtr(a6),-(sp)			move.w	#55,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect				move.l		The_DialogPtr(a6),-(sp)			move.w	#56,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameRect; prépositionnement des valeurs				bsr		initValue				bsr		DessinCurseur		rts		; ----------------------------------; Cette routine teste si une display font est présente et hilite les boutons up & down ; en fonction de ce paramètresShowHide_Boutton				lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq		DoGrisaillebouton		rtsDoGrisaillebouton					move.l	The_DialogPtr(a6),-(sp)			move.w	#61,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		SaveRgb(a6)		_GetForeColor							pea		backRgb(a6)		_GetbackColor					pea		backRgb(a6)		_RGBForeColor			pea		qd.Gray		_PenPat				move.w	#srcBic,-(sp)		_PenMode				pea		itemRect(a6)		_PaintRect		_PenNormal				pea		SaveRgb(a6)		_RGBForeColor					rts				DbgInfo.new	Preference_Affichage	; this name will appear in the debugger		align 4			ENDP				* ======================================================================*	Fonction	PrefAffFilter();* ======================================================================**PrefAffFilter		PROC	EXPORT*	*		MyFilter (theDialog:  DialogPtr; VAR theEvent:  EventRecord;*                   VAR itemHit:  INTEGER) :  BOOLEAN;StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordresult			ds.w	1ParamBegin		EQU	*						; start parameters after this pointthe_Dialog		ds.l	1The_Event		ds.l	1The_item		ds.l	1ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkitemType			ds.w	1		; stockage du type de ItemitemHandle			ds.L	1		; stockage	du handle du itemitemRect			ds		Rect	; rectangleRectangle		ds	RectThe_Where		ds.l	1pictHandle		ds.l	1WindowPtr		ds.l	1LocalSize		EQU 	*					; size of all the local variables				ENDR						IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,AdjustCursor,GetGlobalMouse		WITH	StackFrame,SOUSTITRERECORD,AppGlobals			; cover our local stack frame		IMPORT	qd:MYQDGLOBALS 		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(SP)				move.w	#false,result(a6)		GotEvent			; ¢a y est nous avons un événement		; move window	?		move.l	The_Event(a6),a0		MOVE.W	evtNum(A0),D0				; get the event number		cmp.w	#1,d0					; Mouse down ?		beq 	Move_Window		cmp.w	#6,d0					; Update 		beq		Update		cmp.w	#3,d0					; key down		beq		KEYdOWN		cmp.w	#5,d0					; repeatkey down		beq		KEYdOWN		bra		Exit; -------KEYdOWN		move.l	The_Event(a6),a0		MOVE.l	evtMessage(A0),D0				; get the event number		and.l	#$ff,d0		case#.w	(d0,if),\		(13,Enter_1),\		(3,Enter_1),\		('',ANNULER)						move.l	The_Event(a6),a0		MOVE.w	evtMeta(a0),d0		; option key down ?		btst.l	#11,d0		beq		Exit				; non; oui pseudo move window 				move.l	The_Event(a6),a0		MOVE.l	evtMessage(A0),d0		and.l	#$ff,d0		case#.w	(d0,if),\		(30,up_1),\		(31,down_1),\		(28,left_1),\		(29,right_1)		bra		Exit	; on reboucle; ---------------------------------------------ANNULER		move.l	The_item(a6),a0		move.w	#2,(a0)				clr.l	-(sp)				import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		move.w	#2,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDitem		; on regarde si le 2 ème item est un bouton si oui on peut l'activé par ESC				CMP.W	# ctrlItem+btnCtrl,ItemType(a6)		bne 	exit						move.l	ItemHandle(a6),-(sp)		move.w	#2,-(sp)		_HiliteControl				move.l	#4,-(sp)		import	WaitTicks		jsr		WaitTicks				move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl				move.w	#true,result(a6)				bra		exit	; on reboucle; -----------------------------------------		Enter_1			move.l	The_item(a6),a0		move.w	#1,(a0)				clr.l	-(sp)				import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDitem				move.l	ItemHandle(a6),-(sp)		move.w	#1,-(sp)		_HiliteControl				move.l	#4,-(sp)		import	WaitTicks		jsr		WaitTicks				move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl				move.w	#true,result(a6)				bra		exit	; on reboucle; up_1		clr.l	-(sp)				import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal				sub.w	#1,top+Rectangle(a6)				move.l	The_Event(a6),a0		MOVE.w	evtMeta(A0),d0		btst.l	#9,d0		beq.S	up_1_1		sub.w	#20,top+Rectangle(a6)up_1_1							move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow				move.w	#true,result(a6)		bra		Exit	; on sort; -------down_1		clr.l	-(sp)				import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal				add.w	#1,top+Rectangle(a6)				move.l	The_Event(a6),a0		MOVE.w	evtMeta(A0),d0		btst.l	#9,d0		beq.S	down_1_1		add.w	#20,top+Rectangle(a6)down_1_1				move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		move.w	#true,result(a6)		bra		Exit	; on sort; -------left_1		clr.l	-(sp)				import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal		sub.w	#1,left+Rectangle(a6)				move.l	The_Event(a6),a0		move.w	evtMeta(A0),d0		btst.l	#9,d0				beq.S	left_1_1		sub.w	#20,left+Rectangle(a6)left_1_1			move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		move.w	#true,result(a6)		bra		Exit	; on sort; -------right_1				clr.l	-(sp)				import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portrect(a4),rectangle(a6)		move.l	4+portrect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal				add.w	#1,left+Rectangle(a6)				move.l	The_Event(a6),a0		MOVE.w	evtMeta(A0),d0		btst.l	#9,d0				beq.S	right_1_1		add.w	#20,left+Rectangle(a6)right_1_1		move.l	a4,-(sp)		move.w	left+Rectangle(a6),-(sp)		move.w	top+Rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		move.w	#true,result(a6)		bra		Exit	; on sort; -------		; peut ètre un update window pour les autre fenètresUpdate				move.l	the_dialog(A6),d0		move.l	The_Event(a6),a0		cmp.l	evtMessage(a0),d0		bne		pasfenetreencour		; 	on rafraichi le dialog (nous même); comme cela nous permet de passer le signal de refresh pour la code géra, le dialog; on met #-1 au retour pour indiquer qu'il faut updater la fenètre				move.L	The_item(a6),a0		move.w	#-1,(a0); on laisse false pour que le dialog soit redessiné					move.w	#true,result(a6)				bra		Exit			; pour le dialog en courpasfenetreencour		; oui pour les autres fenètres du programme				MOVE.L	evtMessage(a0),-(SP)	; pass the window pointer		import	DoUpdate						jsr		DoUpdate				; do the update		move.w	#true,result(a6)		bra		Exit		; --------------------------------------------------------------------------------		;  mouse window ?Move_Window		CLR.W	-(SP)								move.l	The_Event(a6),a0		MOVE.l	evtMouse(A0),-(sp)		; the mouse point		PEA		WindowPtr(A6)				; a local variable		_FindWindow							; put the result in a register		MOVE.W	(SP)+,D7				cmp.w	#InDrag,d7	; in drag region ?		bne		Exit		; no				move.l	WindowPtr(A6),d0		cmp.l	the_dialog(A6),d0	; Le dialog en cour ?		bne.s	Exit				; non on reboucle		MoveWindow_1; pass Window Pointer				move.l	WindowPtr(A6),-(sp)		move.l	The_Event(a6),a0		MOVE.l	evtMouse(A0),-(sp)		; Mouse coordinates and boundary		PEA		qd.ScreenBits.bounds			import	DragReferencedWindow		import	DragReferencedWindow		move.w	#true,result(a6)EXIT	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New			PrefAffFilter 		endp	* ================================================* PROCEDURE MakeTheBbdfMenu(); * ================================================**	Cette routine détermine les polices d'affichages présente dans le dossier * 	«police d'affichage»****MakeTheBbdfMenu 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointmenu		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rectrectangle	ds		RectthesearchNumber	ds.l	2;	LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon	pea		thesearchNumber(a6);		import	find_Bbof_File	jsr		find_Bbof_File		move.l	thesearchNumber(a6),d7	subq.l	#1,d7loop		move.l	4+thesearchNumber(a6),A0	move.l	(a0),a0	move.l	thesearchNumber(a6),d0	subq.l	#1,d0	sub.l	D7,d0	mulu	#70,d0	add.l	#6,d0	adda.l	d0,A0	; a0 pointe sur la chaine de caractères			move.l	menu(a6),-(sp)	move.l	a0,-(sp)	move.w	#1,-(sp)	_InsMenuItem		;InsItemMenu	dbra	D7,loop						UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)						DbgInfo.new	MakeTheBbdfMenu	; this name will appear in the debugger		align 4			ENDP		* ================================================* PROCEDURE draw_Frame_Curseur(); * ================================================**	Cette routine dessine le rectangle de télécommande du vtr***draw_Frame_Curseur 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointTheDialog	ds.l	1		; pointeur du dialogFLAG		DS.W	1		; FLAG POUR ALL DRAWTheItem		ds.w	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rectrectangle	ds		RectRGB_Color			ds.w	3RGB_Color2			ds.w	3LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon			IMPORT	qd:MYQDGLOBALS		movem.l d1-d7/a1-a4,-(sp)		; rafraichissement de la fenètre		; il faut dire à QUICKDRAW que le port de la fenètre est le port courant		move.l	TheDialog(a6),-(sp)		_SetPort		move.l	TheDialog(a6),-(sp)		move.w	TheItem(a6),-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem								pea		RGB_Color(a6)		_GetBackColor						move.w	#40000,RGB_Color2(a6)		move.w	#40000,2+RGB_Color2(a6)		move.w	#40000,4+RGB_Color2(a6)						pea		RGB_Color2(a6)		_RGBBackColor				pea		itemRect(a6)		_eraseRect				pea		RGB_Color(a6)		_RGBBackColor						tst.w	FLAG(a6)		beq		Exit				pea		itemRect(a6)		move.w	#-1,-(sp)		move.w	#-1,-(sp)		_InsetRect				pea		itemRect(a6)		_FrameRect				bra		Exit; ------------------------------------------------			pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_InsetRect				pea		qd.Gray		_penPat				move.w	#45000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#45000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForeColor		pea		itemRect(a6)		_PaintRect			_PenNormal			tst.w	flag(a6)		beq		Exit				pea		itemRect(a6)		move.w	#-1,-(sp)		move.w	#-1,-(sp)		_InsetRect;		move.w	#30000,RGB_Color(a6);		move.w	#30000,2+RGB_Color(a6);		move.w	#30000,4+RGB_Color(a6);		pea		RGB_Color(a6);		_RGBForeColor;		pea		itemRect(a6);		_FrameRect		move.w	#2,-(sp)		move.w	#2,-(sp)		_penSize				move.w	#65535,RGB_Color(a6)		move.w	#65535,2+RGB_Color(a6)		move.w	#65535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForeColor				add.w	#1,left+itemRect(a6);		add.w	#1,bottom+itemRect(a6)		add.w	#1,top+itemRect(a6);		add.w	#1,right+itemRect(a6)		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo								move.w	#10000,RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForeColor				sub.w	#3,left+itemRect(a6);		sub.w	#2,bottom+itemRect(a6)		sub.w	#3,top+itemRect(a6);		sub.w	#2,right+itemRect(a6)		move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineToExit				move.w	#000,RGB_Color(a6)		move.w	#00,2+RGB_Color(a6)		move.w	#000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForeColor		_PenNormal					movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new	draw_Frame_Curseur			; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE draw_Button_Display(); * ================================================**	Cette routine dessine le rectangle de télécommande du vtr***draw_Button_Display 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointTheDialog		ds.l	1		; pointeur du dialogtheValue		ds.w	1		; valeur du boutonflag			ds.w	1			; actif ou nonTheItem			ds.W	1		; item selectionnéParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rectrectangle	ds		RectRGB_Color			ds.w	3LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp)		; rafraichissement de la fenètre		; il faut dire à QUICKDRAW que le port de la fenètre est le port courant		move.l	TheDialog(a6),-(sp)		_SetPort		move.l	TheDialog(a6),-(sp)		move.w	TheItem(a6),-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		; on calcule la position de la molette		move.l	itemRect(a6),rectangle(a6)		move.l	4+itemRect(a6),4+rectangle(a6)		add.w	#1,left+rectangle(a6)		add.w	#1,top+rectangle(a6); on effectue un clip // rectangle fenètre							move.w	theValue(a6),d0		tst.w	d0		bgt.s	Dessine_LeBouton_0			move.w	#0,theValue(a6)		bra.s	Dessine_LeBouton_1	; pas de problèmeDessine_LeBouton_0	; pas de problème						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#11+2,d0				cmp.w	theValue(a6),d0		bhi.s	Dessine_LeBouton_1	; pas de problème		move.w	d0,theValue(a6)		Dessine_LeBouton_1			move.w	thevalue(a6),d0		add.w	left+rectangle(a6),d0				move.w	d0,left+rectangle(a6)		move.w	d0,right+rectangle(a6)				move.w	top+rectangle(a6),bottom+rectangle(a6)		add.w	#11,right+rectangle(a6)		add.w	#11,bottom+rectangle(a6)		tst.w	flag(a6)		bne.s	Bouton_Enfonce				move.w	#2000,d0		pea		rectangle(a6)		jsr		custom_PlotCIcon		bra.S	Exit		Bouton_Enfonce				move.w	#2001,d0		pea		rectangle(a6)		jsr		custom_PlotCIconExit			movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new	draw_Button_Display			; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE makeDisplayFontName(); * ================================================**	Cette routine créer un nom pour un police d'affichage*makeDisplayFontName 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointtheFontRecord	ds.l	1	; font recordfinalBuff		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256TextBuff1	ds.b	256TextBuff2	ds.b	256LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp); on recupère le nom de la font		move.l	theFontRecord(a6),a0				move.w	FontNumber(a0),-(sp)		pea		TextBuff(a6)		_GetFName  			move.l	theFontRecord(a6),a0		move.w	UseBold(a0),d0			; bold for normal ?		beq		@a						; non				move.b	#'.',d0		bsr		appendChar			; on place le B pour bold		move.b	#'B',d0		bsr		appendChar			; on place le B pour bold		move.b	#'o',d0		bsr		appendChar			; on place le B pour bold		move.b	#'l',d0		bsr		appendChar			; on place le B pour bold		move.b	#'d',d0		bsr		appendChar			; on place le B pour bold@a			; on ajoute un espace		move.b	#' ',d0		bsr		appendChar; on place la taille de la font			move.l	theFontRecord(a6),a0				move.w	FontSize(a0),d0			and.l	#$ffff,d0						and.l	#$ffff,d0		lea		TextBuff1(a6),a0		clr.w	-(sp)		_Pack7; on ajoute la taille à la chaine		lea		TextBuff1(a6),a0		lea		TextBuff(a6),a1		import	appendStr		jsr		appendStr; on regarde quel style est demandé		move.l	theFontRecord(a6),a4				move.b	#'N',d0		bsr		appendChar			; on place le N pour normal		move.w	FontStyle(a4),d0		and 	#2,d0				; italique ?		beq		@1		move.b	#'I',d0		bsr		appendChar			; on place le I pour italic@1				move.w	FontStyle(a4),d0		and 	#1,d0				; bold ?		beq		@2		move.b	#'B',d0		bsr		appendChar			; on place le B pour bold@2				move.w	FontStyle(a4),d0		and 	#4,d0				; underligne ?		beq		@3		move.b	#'U',d0		bsr		appendChar			; on place le U pour UnderLigne@3			move.b	#'_',d0		bsr		appendChar		move.w	FontRatio(a4),d0		cmp.w	#$403,d0		bne.s	SeizeNeuviemeQuatreTier		lea		Format1(pc),a0		bra.s	WriteFormatSeizeNeuvieme		cmp.w	#$1609,d0		bne.s	CinqQuart		lea		Format2(pc),a0		bra.s	WriteFormatCinqQuart		lea		Format3(pc),a0WriteFormat		lea		textBuff(a6),a1		import	appendStr		jsr		appendStr		bra		Exit_bis; #### pour l'instant on bypass le reste;--------- - - - -   - - - - - - - - - - -  - - - - 		; on place les valeurs face,bordure,shadow etc ...		; face 				move.b	#'_',d0		bsr		appendChar				move.w	FaceThickness(a4),d0		and.l	#$ff,d0				bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	FaceBlur(a4),d0		and.l	#$ff,d0				bsr		AppendNum; bordure ------------				move.b	#'_',d0		bsr		appendChar				move.w	BorderThickness(a4),d0		and.l	#$ff,d0				bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	BorderBlur(a4),d0		and.l	#$ff,d0				bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	BorderXoffset(a4),d0		ext.l	d0				bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	BorderYoffset(a4),d0		ext.l	d0		bsr		AppendNum		;shadow    ------------				move.b	#'_',d0		bsr		appendChar				move.w	ShadowThickness(a4),d0		and.l	#$ff,d0				bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	ShadowBlur(a4),d0		and.l	#$ffff,d0				bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	ShadowXoffset(a4),d0		and.l	#$ffff,d0		ext.l	d0		bsr		AppendNum				move.b	#',',d0		bsr		appendChar				move.w	ShadowYoffset(a4),d0		and.l	#$ffff,d0		ext.l	d0		bsr		AppendNum								; on recopie le textbuff dans le buffer demandéExit_bis		move.l	finalBuff(a6),a1			lea		Textbuff(a6),a0				import	CopySTR		jsr		CopySTR; ----------- - - - - - - -  - - - - - -   -		Exit			movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0); ----------------------------------; cette routine ajoute un caractère à une str255appendChar		lea		TextBuff(a6),a0		moveq	#0,d1		move.b	(a0),d1		move.b	d0,1(a0,d1.w)		add.b	#1,(a0)		rts; --------------------------------AppendNum			lea		TextBuff1(a6),a0		clr.w	-(sp)		_Pack7; on ajoute la taille à la chaine		lea		TextBuff1(a6),a0		lea		TextBuff(a6),a1		import	appendStr		jsr		appendStr				rts				Format1		dc.b	'4.3'Format2		dc.b	'16.9'		Format3		dc.b	'5.3'				DbgInfo.new	makeDisplayFontName		; this name will appear in the debugger		align 4			ENDP		* ================================================* PROCEDURE		SaveDisplayFont()* ================================================SaveDisplayFont	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointfontRecord	ds.l	1		; font recordThe_Ptr		ds.l	1		; ptr du bitmap de la fontThe_Size	ds.l	1		; size du bitmap de la fontParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkDialogStorage	ds	dWindLenreply		ds		StandardFileReplyfssSafeSave	ds.b	70	; fssRecordfsOpenErr	ds.w	1fsRefNum	ds.w	1seconds		ds.l	1Buffer		ds.l	1count		ds.l	1FileLenth	ds.l	1txtbuffer		ds.b	256itemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectItemchoisi		ds.w	1paramBlock		ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierparamBlockBak	ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierThe_Volume		ds.l	1LocalSize	EQU 	*			; size of all the local variables		endr				WITH	StackFrame,StandardFileReply,FSSpec,FontRenderRecord,HSLColor		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		IMPORT	ExportationDeFichierAscii,WaitTicks,CopySTR,AppendSTr,TraitementErreurFichier		; fonction de fichier 		clr.l	-(sp) ; file filter = none		Move.w	#-1,-(sp); on veut tous les TYPEs de fichiers		clr.l	-(sp)		Pea		reply(a6)		string Pascal				pea		#'Enregistrer la police :'		move.l	fontRecord(a6),a0		pea		FontName(a0)			; nom de la font		Pea		reply(a6)		_StandardPutFile		move.b	sfGood(a6),d0		beq		Exit2	; l'utilisateur à Cancelé				tst.b	sfReplacing(a6)  		bne		FileExistAlready; le fichier n'existe pas	; on commence par créer le fichier en question.		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		reply+sfFile+name(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		move.l	reply+sfFile+parID(a6),ioDirID(a0)		_HCreate		; maintenant le fichier éxiste FileExistAlready; on ouvre le fichier		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		reply+sfFile+name(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		move.b	#4,ioPermssn(a0)			;fsRWrShPerm			clr.l	ioOwnBuf(a0)		move.l	reply+sfFile+parID(a6),ioDirID(a0)		_HOpen		jsr		TraitementErreurFichier			tst.l	d1		bne		Exit2							lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		clr.w	28(a0)	;DirIndex		clr.l	ioOwnBuf(a0)		lea		reply+sfFile+name(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		_HGetFileInfo		jsr		TraitementErreurFichier	; OK FICHIER OUVERT ; ---------- on sauvegarde la police -----------------------------------				; on commence par sauvegarder le font record				lea		paramBlock(a6),a0		move.l	#FontRenderRecord_SizeOf,ioReqCount(a0)		move.l	fontRecord(a6),d0		move.l	d0,ioBuffer(a0)				move.w	#fsFromStart,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)				_Write		jsr		TraitementErreurFichier		; on sauvegarde le display font 				lea		paramBlock(a6),a0		move.l	The_Size(a6),d0			; taille du "handle"		move.l	d0,ioReqCount(a0)		move.l	The_ptr(a6),a1			; ptr du "handle"		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)				_Write		jsr		TraitementErreurFichier; on place le end of file à l'endroit où nous sommes			lea		paramBlock(a6),a0		move.l	46(a0),d0	;ioPosOffset		move.l	d0,28(a0)	; iomisc		_SetEOF		; on a fini de d'écrire dans le fichier, on actualise les info du film; on commence par lire les infos: 	; il faut maintenant créer les infos pour le finder		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		move.l	Time,ioFlMdDat(a0)		lea		reply+sfFile+name(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		Move.l	#'Bbdf',ioFlUsrWds(a0)				; type "bon bougre display font"		move.l	#'Bbou',4+ioFlUsrWds(a0)		move.l	reply+sfFile+parID(a6),ioDirID(a0)		_HSetFileInfo		jsr		TraitementErreurFichier		; on dit au dos de s'assurer que tous à bien été écrit sur le disque				clr.l	-(sp)		move.w	#140,-(sp)		pea		G.DialogStorage		move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_FlushFile						clr.w	-(sp)		lea		paramBlock(a6),a0		move.w	ioVrefNum(a0),-(sp)		pea		The_Volume(a6)		import	GetVRefNum		jsr		GetVRefNum		move.w	(sp)+,d0	; on se tape du resultat				clr.w	-(sp)		clr.l	-(sp)		move.w	The_Volume(a6),-(sp)		import	FlushVol		jsr		FlushVol		move.w	(sp)+,d0						jsr		TraitementErreurFichier		move.l	#60,-(sp)		import	WaitTicks		jsr		WaitTicks				closeFile			lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_CloseExit2			PEA	G.DialogStorage		_CloseDialog*   --------------------------------------------------------------------Exit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		align 4		DbgInfo.New	SaveDisplayFont		; this name will appear in the debugger		ENDP		* ..............................................................................................* .....********...*******.....*****...********...................................................* ........**......*..........*...........**.....................................................* ........**......****........****.......**.....................................................* ........**......*...............*......**.....................................................* ........**......*******....*****.......**.....................................................* * ================================================* PROCEDURE Test_FontRecord(); * ================================================** cette routine dessine la police d'écriture entière dans la VX**Test_FontRecord 	PROC	EXPORT		machine MC68030StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rectrectangle	ds		RectRGB_Color				ds.w	3CharW		ds.w	1faceW		ds.w	1Xpos			ds.w	1		; x en courYpos			ds.w	1		; y en courRow_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp); on récupère les coordonées de la carte VE;				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6)			move.w	#758,width(a6)			move.w	#576,height(a6); -------- on raz la V E ---------------------------------------------						move.l	Base_Adresse(a6),a0			move.w	#575,d7loop_1			move.l	Row_Bytes(a6),d6			lsr.l	#2,d6					;÷4  (long)loop_2					clr.l	(a0,d6.w*4)			dbra	d6,loop_2			add.l	Row_Bytes(a6),a0			; ligne suivante			dbra	d7,loop_1		; -------- on affiche dans une boucle les caractères du font record					lea		G.Display_Font,a0		move.w	#$21,CharW(a6)		move.w	#0,faceW(a6)				; ---- la boucle 				move.w	#20,ypos(a6)		; base line		move.w	#0,Xpos(a6)						Display_char_Loop		lea		G.Display_Font,a0		move.w	faceW(a6),d1		move.w	CharW(a6),d0		import	GiveDisplayFont_CharInfo		jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan		tst.w	d0		bne.s	PasExist				move.w	CharHeaderSize+right(a0),d0		; largeur du caractère		sub.w	CharHeaderSize+left(a0),d0		; largeur du caractère		beq 	fin_du_Caracteres	; si =0 pas de caratère		; on défini la position de recopie; on utilise les ≠ base line pour calculer la base line du 		move.w	CharHeaderSize+pi_Baseline(a0),d7		add.w	ypos(a6),d7		add.w	#20,d7		move.l	Row_Bytes(a6),d0		mulu	d0,d7		move.l	base_adresse(a6),a4					add.l	d7,a4				; y pos dans la vidéo explorer		; on recopie les plans					move.l	CharHeaderSize+pi_PlaneBase(a0),d1		; offset du plan//ptr absolu		move.l	a1,a2				; début du bitmap		add.l	d1,a2				; base ptr du plan		moveq	#0,d2		loop_recopie_loop1		moveq	#0,d3loop_recopie_loop2					move.b	(a2,d3.l),d0		; on étend la valeur sur 32 bits		move.b	d0,d4		lsl.l	#8,d4		move.b	d0,d4		lsl.l	#8,d4		move.b	d0,d4		lsl.l	#8,d4		move.b	d0,d4		lsl.l	#8,d4		move.b	d0,d4		move.w		d3,d0		add.w		Xpos(a6),d0		move.l		d4,(a4,d0.w*4)		; ecriture dans la vidéo explorer		add.w		#1,d3		move.w		CharHeaderSize+right(a0),d0		sub.w		CharHeaderSize+left(a0),d0		cmp.w		d0,d3		; largeur du caractère		bls			loop_recopie_loop2				moveq		#0,d0		move.w		CharHeaderSize+right(a0),d0				sub.w		CharHeaderSize+left(a0),d0			addq.w		#1,d0		add.l		d0,a2				; ligne suivante				add.l		Row_Bytes(a6),a4		; ligne suivante VE; ---		add.w		#1,d2		move.w		CharHeaderSize+bottom(a0),d0		sub.w		CharHeaderSize+top(a0),d0		cmp.w		d0,d2		; hauteur du caractère		bls			loop_recopie_loop1				PasExist				move.w		Xpos(a6),d0		add.w		CharHeaderSize+right(a0),d0		sub.w		CharHeaderSize+left(a0),d0			; largeur du caractère		addq.w		#8,d0		move.w		d0,Xpos(a6)				cmp.w		#746,d0		blo.s		fin_du_Caracteres				move.w		Ypos(a6),d0		add.w		#33,d0					; 33 au pif		move.w		d0,Ypos(a6)				move.w		#0,Xpos(a6)				cmp.w		#576,d0			; on 	arrive à la fin 		bhi			Exit					fin_du_Caracteres		move.w	CharW(a6),d0		add.w	#1,d0		move.w	d0,CharW(a6)		cmp.w	#255,d0			; fin des caractères ?		blo.s	Display_char_Loop; c'est finiExit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new	Test_FontRecord			; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE GiveDisplayFont_CharInfo(); * ================================================*** Cette routine donne les parramètres pour l'affichage d' un caractère* d'une display font** en entrée :  	a0	theFontrecord     	(ptr)*				d0	Char n°     		(word)		; n° du caractère*				d1	style n°			(word)		; n° du style***	en sortie :	a0	charRecordPtr		(ptr)*				a1	HandleduDisplayFontBitmap	(handle)	non locké par la routine*				d1	nb de plan par char	(word)**				d0	resultat			(word)		; ≠ 0 si erreur**GiveDisplayFont_CharInfo 	PROC	EXPORT		WITH	SOUSTITRERECORD,FontRenderRecord,HSLColor		;			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d2-d7/a2-a4,-(sp)				; on commence par tester si il y a bien un handle		tst.l	FontNumber(a0)		beq.s 	ExitErr			; non pas de handle; on teste si le caractère est contenue dans ce fontrecord;		cmp.w	First_Char(a0),d0;		blo.s	ExitErr;		cmp.w	last_Char(a0),d0;		bhi.s	ExitErr; on regarde si le n° de plan est compris dans le font record;		cmp.w	Face_Number(a0),d1;		bhi.s	ExitErr					; non erreur		;  sauvegarde des parramètres d'entrées		move.l	a0,a4		move.l	d0,d7		move.l	d1,d6		; on recupère le handle du font record		move.l	Render_handle(a0),a0		move.l	(a0),a1					; handle		;on récupère l'offset du style demandé		move.l	(a1,d1.w*styleHeaderSize),d5			; offset du plan style demandé	; boucle de recherche du caractère				move.w	d7,d2		sub.w	First_Char(a4),d2		; nombre de recherche dans le bitmap		Find_CharPtr_Loop				cmp.w	CH_CharNumber(a1,d5.l),d7			; le caractère demandé		beq.s	findCharPtr				; on a trouvé; non pas trouvé on continue		move.l	ch_NextChar(a1,d5.l),d5			; nextPtr				dbra 	d0,Find_CharPtr_Loop		bra 	Exiterr				; on n'a pas trouvé le caractère dans le bitmap		findCharPtr		; on transforme le ptr base + offset en absptr du caractère		move.l	a1,a0		; a1 base ptr du bitmap display font		add.l	d5,a0		; a0 = ptr du char; on recupère le nombre de plan par caractère		moveq	#0,d1		move.w	Plane_Number(a4),d1; code retour Ok		moveq	#0,d0Exit		movem.l	(sp)+,d2-d7/a2-a4		rtsExitErr	movem.l	(sp)+,d2-d7/a2-a4		moveq	#-1,d0		; non retour erreur		suba.l	a0,a0		moveq	#-1,d0		rts				DbgInfo.new	GiveDisplayFont_CharInfo			; this name will appear in the debugger		align 4			ENDP			 				* ================================================* PROCEDURE GiveDisplayFont_FastCharInfo(); * ================================================***	Cette routine donne les parramètres pour l'affichage d'un carctère* 	à partir d'un fast font; note: la structure en mémoire est quasiment la même qu'une display font standart; cette routine est semblable à sa soeur jumelle "GiveDisplayFont_CharInfo"** en entrée :  	a0	theFontrecord     	(ptr)*				d0	Char n°     		(word)		; n° du caractère*				d1	style n°			(word)		; n° du style***	en sortie :	a0	charRecordPtr		(ptr)*				a1	HandleduDisplayFontBitmap	(handle)	non locké par la routine*				d1	nb de plan par char	(word)* 				d0	resultat			(word)		; ≠ 0 si erreur**GiveDisplayFont_FastCharInfo 	PROC	EXPORT			WITH	SOUSTITRERECORD,FontRenderRecord,HSLColor		;			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d2-d7/a2-a4,-(sp)		; ------------------- inversion de style --------------------------------		; #### pour l'instant on effectue un changement de style :;					si=1 on fait italic;					si=2 on fait bold; ####			tst.w	d1		beq.s	GoGetIt				cmp.w	#1,d1		; bold => 2 ème style		bne.s	@1		moveq	#2,d1		bra.s	GoGetIt@1		cmp.w	#2,d1		; italic => 1 er style 		bne.s	GoGetIt		moveq	#1,d1		GoGetIt		; --------------------------------------------------------------------		; on commence par tester si il y a bien un handle		tst.l	FontNumber(a0)		beq.s 	ExitErr			; non pas de handle; on teste si le caractère est contenue dans ce fontrecord 		cmp.w	First_Char(a0),d0 		blo.s	ExitErr 		cmp.w	last_Char(a0),d0 		bhi.s	ExitErr; on regarde si le n° de plan est compris dans le font record 		cmp.w	Face_Number(a0),d1 		bhi.s	ya_Derr					; noerr		bra.s	pas_Derrya_Derr		moveq	#1,d1					; si style absent on utilise le normalpas_Derr		;  sauvegarde des parramètres d'entrées		move.l	a0,a4		move.l	d0,d7		move.l	d1,d6		; on recupère le handle du fast font 		move.l	RenderColor_handle(a0),a0		move.l	(a0),a1					; handle		;on récupère l'offset du style demandé		move.l	(a1,d1.w*styleHeaderSize),d5			; offset du plan style demandé	; boucle de recherche du caractère				move.w	d7,d2		sub.w	First_Char(a4),d2		; nombre de recherche dans le bitmap		Find_CharPtr_Loop				cmp.w	CH_CharNumber(a1,d5.l),d7			; le caractère demandé		beq.s	findCharPtr				; on a trouvé; non pas trouvé on continue		move.l	ch_NextChar(a1,d5.l),d5			; nextPtr				dbra 	d0,Find_CharPtr_Loop		bra 	Exiterr				; on n'a pas trouvé le caractère dans le bitmap		findCharPtr		; on transforme le ptr base + offset en absptr du caractère		move.l	a1,a0		; a1 base ptr du bitmap display font		add.l	d5,a0		; a0 = ptr du char; on recupère le nombre de plan par caractère		moveq	#0,d1		move.w	Plane_Number(a4),d1; code retour Ok		moveq	#0,d0Exit		movem.l	(sp)+,d2-d7/a2-a4		rtsExitErr	movem.l	(sp)+,d2-d7/a2-a4		moveq	#-1,d0		; non retour erreur		suba.l	a0,a0		moveq	#-1,d0		rts				DbgInfo.new	GiveDisplayFont_FastCharInfo			; this name will appear in the debugger		align 4			ENDP			* ================================================* PROCEDURE ColorMultiplicateur(); * ================================================***  		Cette routine calcule les couleurs finales d'un pixel*		en fonction de la couleurs des divers tranches (4) et du facteur de multiplication (0-255)**		en entrée:	d0= bgd		color		; RGBAlpha (32 bits)* 					d1= shadow	color		; RGBAlpha (32 bits)* 					d2= border	color		; RGBAlpha (32 bits)* 					d3= face	color		; RGBAlpha (32 bits)*					d4= bgd		factor		; facteur multiplicateur (0-255)*					d5= shadow	factor		;*					d6= border	factor		;*					d7= face	factor		;*		**		en sortie: d0= destination color	; RGBAlpha (32 bits)*ColorMultiplicateur	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkResultat				ds.l	1Factor_Bgd				ds.w	1inverseFactor_Bgd		ds.w	1Factor_Shadow			ds.w	1inverseFactor_Shadow	ds.w	1Factor_Border			ds.w	1inverseFactor_Border	ds.w	1Factor_Face				ds.w	1inverseFactor_Face		ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame; on calcule les facteur et inverses des facteurs				move.w	d4,Factor_Bgd(a6)		; sauvegarde 				move.w	d5,Factor_Shadow(a6)				move.w	d6,Factor_Border(a6)				move.w	d7,Factor_Face(a6)								sub.w	#255,d4				neg.w	d4				sub.w	#255,d5				neg.w	d5				sub.w	#255,d6				neg.w	d6				sub.w	#255,d7				neg.w	d7												move.w	d4,inverseFactor_Bgd(a6)		; sauvegarde 				move.w	d5,inverseFactor_Shadow(a6)				move.w	d6,inverseFactor_Border(a6)				move.w	d7,inverseFactor_Face(a6)							clr.l	Resultat(a6)				; on calcule 1er passage bleu dans le resultat								clr.w	d4				clr.w	d5				clr.w	d6				clr.w	d7								move.b	d0,d4				move.b	d1,d5				move.b	d2,d6				move.b	d3,d7								mulu	Factor_Bgd(a6),d4				; bgd 				divu	#255,d4								mulu	inverseFactor_Shadow(a6),d4				mulu	Factor_Shadow(a6),d5				add.l	d4,d5				divu	#255,d5							; bgd + shadow 								mulu	inverseFactor_Border(a6),d5				mulu	Factor_Border(a6),d6				add.l	d5,d6				divu	#255,d6							; bgd + shadow + border				mulu	inverseFactor_Face(a6),d6				mulu	Factor_Face(a6),d7								add.l	d6,d7				divu	#255,d7							; bgd + shadow + border + face								move.b	d7,3+resultat(a6)								ror.l	#8,d0				ror.l	#8,d1				ror.l	#8,d2				ror.l	#8,d3; on calcule 2 éme passage (vert dans le resultat)								clr.w	d4				clr.w	d5				clr.w	d6				clr.w	d7				move.b	d0,d4				move.b	d1,d5				move.b	d2,d6				move.b	d3,d7								mulu	Factor_Bgd(a6),d4				; bgd 				divu	#255,d4								mulu	inverseFactor_Shadow(a6),d4				mulu	Factor_Shadow(a6),d5				add.l	d4,d5				divu	#255,d5							; bgd + shadow 								mulu	inverseFactor_Border(a6),d5				mulu	Factor_Border(a6),d6				add.l	d5,d6				divu	#255,d6							; bgd + shadow + border				mulu	inverseFactor_Face(a6),d6				mulu	Factor_Face(a6),d7								add.l	d6,d7				divu	#255,d7							; bgd + shadow + border + face								move.b	d7,2+resultat(a6)								ror.l	#8,d0				ror.l	#8,d1				ror.l	#8,d2				ror.l	#8,d3; on calcule 3 éme passage (rouge dans le resultat)								clr.w	d4				clr.w	d5				clr.w	d6				clr.w	d7				move.b	d0,d4				move.b	d1,d5				move.b	d2,d6				move.b	d3,d7								mulu	Factor_Bgd(a6),d4				; bgd 				divu	#255,d4								mulu	inverseFactor_Shadow(a6),d4				mulu	Factor_Shadow(a6),d5				add.l	d4,d5				divu	#255,d5							; bgd + shadow 								mulu	inverseFactor_Border(a6),d5				mulu	Factor_Border(a6),d6				add.l	d5,d6				divu	#255,d6							; bgd + shadow + border				mulu	inverseFactor_Face(a6),d6				mulu	Factor_Face(a6),d7								add.l	d6,d7				divu	#255,d7							; bgd + shadow + border + face								move.b	d7,1+resultat(a6)								ror.l	#8,d0				ror.l	#8,d1				ror.l	#8,d2				ror.l	#8,d3				; on calcule 4 éme passage (alpha dans le resultat)								clr.w	d4				clr.w	d5				clr.w	d6				clr.w	d7				move.b	d0,d4				move.b	d1,d5				move.b	d2,d6				move.b	d3,d7								mulu	Factor_Bgd(a6),d4				; bgd 				divu	#255,d4								mulu	inverseFactor_Shadow(a6),d4				mulu	Factor_Shadow(a6),d5				add.l	d4,d5				divu	#255,d5							; bgd + shadow 								mulu	inverseFactor_Border(a6),d5				mulu	Factor_Border(a6),d6				add.l	d5,d6				divu	#255,d6							; bgd + shadow + border				mulu	inverseFactor_Face(a6),d6				mulu	Factor_Face(a6),d7								add.l	d6,d7				divu	#255,d7							; bgd + shadow + border + face								move.b	d7,resultat(a6)																move.l	resultat(a6),d0					; RGB + alpha												UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)									DbgInfo.new	ColorMultiplicateur			; this name will appear in the debugger				align 4					ENDP													* ================================================* PROCEDURE Draw_A_Char(); * ================================================*** Cette routine dessine un caractère dans la ram de la VX**	entrée: 	FontRenderPTr 	(long)*				Char n°		 	(word)	*				style			(word)*				Facecolor		(long)*				bordercolor		(long)*				Shadowcolor		(long)*				Bgdcolor		(long)*				flags			(word)	; blend / opaque bgd; si blend regarde la couleur*										  en dessous du caractère *				x pos*				y pos*				basescreenptr*				Row_Bytes				ds.l	1		; rowbyte**	sortie:		Resultat		(word)	; 0= ok, ≠0 erreur**Draw_A_Char	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordLargeurChar		ds.w	1ParamBegin	EQU	*			; start parameters after this pointFontRenderPTr	ds.l	1Char			ds.w	1style			ds.w	1Faceclr			ds.l	1borderclr		ds.l	1Shadowclr		ds.l	1Bgdlr			ds.l	1flags			ds.w	1Xpos			ds.w	1Ypos			ds.w	1DisplayRamPtr			ds.l	1		; vidéo ramRow_Bytes				ds.l	1		; rowbyteParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkcharPtr					ds.l	1			; ptr du charBasePtr					ds.l	1			; base PtrplaneNumber				ds.l	1			; nombre de plan pour le charRectangleChar			ds		rect		; rectangle entourant le caractèreMinLeft					ds.w	1		; miminum leftMinTop					ds.w	1		; miminum topsparePtr				ds.l	1		; 4 ème plan du char (futur...)shadowPtr				ds.l	1borderPtr				ds.l	1FacePtr					ds.l	1DisplayRamRectangle		ds		rect		; ?spareRectangle			ds		rectshadowRectangle			ds		rectborderRectangle			ds		rectFaceRectangle			ds		rectwidth					ds.w	1		; largeur de la VXheight					ds.w	1		; hauteur de la VXX					ds.w		1Y					ds.w		1LocalSize	EQU 	*			; size of all the local variables			ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame			movem.l d1-d7/a1-a4,-(sp)	; sauvegarde des registres			move.w	#758,width(a6)			; largeur écran			move.w	#576,height(a6)			; hauteur écran; -----------------  on recupère les infos du caractère -------------------------------								move.l	FontRenderPTr(a6),a0				move.w	style(a6),d1						;				move.w	Char(a6),d0				import	GiveDisplayFont_CharInfo				jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan				tst.w	d0				bne  	Exit			; il y a une erreur; a0 = ptr du char info; a1 = abs ptr du font display bitmap; d1 = nombre de plan pour le caractère				move.l	a0,charPtr(a6)				move.l	a1,BasePtr(a6)				move.w	d1,planeNumber(a6); on regarde si c'est un caractère affichable				cmp.w	#$ca,Char(a6)				bne.s	@1@1								move.w	right+CH_Rect(a0),d0				sub.w	left+CH_Rect(a0),d0				move.w	d0,LargeurChar(a6)								bmi		Exit						; pas un caractère affichable; calcul position verticale dans la VX 					move.w	Ypos(a6),d0  				add.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0					; rapport de la base line								mulu	2+Row_Bytes(a6),d0			; row_byte sur .l donc pd faible => 2+				add.l	DisplayRamPtr(a6),d0		; base VX				move.l	d0,a4				; détermination des pointeurs				move.l	charPtr(a6),a3								move.l	CharHeaderSize+pi_PlaneBase(a3),a0				adda.l	BasePtr(a6),a0		; ptr de la face												move.l	PlaneInfoSize+CharHeaderSize+pi_PlaneBase(a3),a1						adda.l	BasePtr(a6),a1				; ptr de la bordure				suba.l	a2,a2			; ptr de l'ombre ShadowPtr(a6)							clr.w	d2							; compteur vertical* ------- vertical loopvertical_loop				clr.w	d3							; compteur horizontal* ------- horizontal loophorizontal_loop; --------- détermination de la couleur du fond 						cmp.w	#0,Flags(a6)					; black bgd				beq.s	BlackBgd										cmp.w	#1,Flags(a6)					; box color				beq.s	BoxBgd;				cmp.w	#2,Flags(a6)					; blend bgd;				beq.s	BlendBgd;  lecture pixels				BlendBgd				move.w		Xpos(a6),d1				add.w		d3,d1				move.l		(a4,d1.w*4),D0		; on écrit la valeur dans la ram				move.l	#$ff,d4							; fond opaque				bra.s	DoFaceColor		; --------- si black on met un noir absoluBlackBgd				move.l	#$00000000,d0				move.l	#$ff,d4							; fond transparent				bra.s	DoFaceColor; --------- si box color on met la couleur de la boiteBoxBgd				move.l	G.RGB_OutlineBoxColor,d0		; couleur du fond de l'outline box				move.l	#$ff,d4							; fond opaque; note on ne peut plus utiliser d4 et d0 car ils sont utilisé pour le BGD color et Bng factor; problème : il faut déterminer quand on peut prendre la valeur d'un pixel ou non; c.a.d. est ce que le pt à lire est dans le carré du plan ( pas très clair ...)DoFaceColor				movem.l	d0-d2,-(sp)			; sauvegarde des registres		  d0-d2				move.l	d2,d1				; Y				move.l	d3,d0				; X; dans le rectangle de la face ?				move.l	charPtr(a6),a3								cmp.w	left+CharHeaderSize+pi_Rect(a3),d3				blt.s	PasDansFace				cmp.w	right+CharHeaderSize+pi_Rect(a3),d3				bgt.s	PasDansFace				cmp.w	top+CharHeaderSize+pi_Rect(a3),d2				blt.s	PasDansFace				cmp.w	bottom+CharHeaderSize+pi_Rect(a3),d2				bgt.s	PasDansFace; oui dans rectangle, on lit la valeur 								sub.w	left+CharHeaderSize+pi_Rect(a3),d0					sub.w	top+CharHeaderSize+pi_Rect(a3),d1	; origin 0,0				move.w	right+CharHeaderSize+pi_Rect(a3),d2				sub.w	left+CharHeaderSize+pi_Rect(a3),d2	; rowbyte				addq.W	#1,d2				mulu	d2,d1						; y Pos				and.l	#$ffff,d0				add.l	d0,d1				moveq	#0,d7				move.b	(a0,d1.l),d7				; Facteur pour face				movem.l	(sp)+,d0-d2; note on ne peut plus utiliser d4,d0,d7								bra.s	DoBorderColor; -------------				; non pas dans la facePasDansFace		clr.w	d7			; pas de face				movem.l	(sp)+,d0-d2; ------------- on récupère la valeur de la bordure				DoBorderColor						movem.l	d0-d2,-(sp)			; sauvegarde des registres		  d0-d2				cmpa.l	#$0000000,a1		; il y a -til une bordure ?;				beq.s	PasDansBorder		; non, pas de bordure				move.l	d2,d1				; Y				move.l	d3,d0				; X; dans le rectangle de la bordure ?								cmp.w	left+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d0				blt.s	PasDansBorder				cmp.w	right+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d0				bgt.s	PasDansBorder				cmp.w	top+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d1				blt.s	PasDansBorder				cmp.w	bottom+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d1				bgt.s	PasDansBorder; oui dans rectangle, on lit la valeur 								sub.w	left+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d0					sub.w	top+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d1	; origin 0,0				move.w	right+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d2				sub.w	left+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d2	; rowbyte				addq.W	#1,d2				mulu	d2,d1						; y Pos				and.l	#$ffff,d0				add.l	d0,d1				moveq	#0,d6				move.b	(a1,d1.l),d6				; Facteur pour border				movem.l	(sp)+,d0-d2				; note on ne peut plus utiliser d4,d0,d7,d6								bra.s	DoShadowColor; -------------				; non pas dans la bordurePasDansBorder		clr.w	d6			; pas de face				movem.l	(sp)+,d0-d2; ------------- on récupère la valeur de la shadow			DoShadowColor					movem.l	d0-d2,-(sp)			; sauvegarde des registres		  d0-d2				cmpa.l	#$0000000,a2		; il y a -til une ombre ?				beq.s	PasDansShadow		; non, pas de ombre				move.l	d2,d1				; Y				move.l	d3,d0				; X; dans le rectangle de la Shadow ?				cmp.w	left+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d3				blt.s	PasDansShadow				cmp.w	right+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d3				bgt.s	PasDansShadow				cmp.w	top+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2				blt.s	PasDansShadow				cmp.w	bottom+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2				bgt.s	PasDansShadow; oui dans rectangle, on lit la valeur 				sub.w	left+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d0					sub.w	top+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d1	; origin 0,0				move.w	right+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2				sub.w	left+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2	; rowbyte				addq.W	#1,d2				mulu	d2,d1						; y Pos				and.l	#$ffff,d0				add.l	d0,d1				moveq	#0,d5				move.b	(a2,d1.l),d5				; Facteur pour shadow				movem.l	(sp)+,d0-d2				; note on ne peut plus utiliser d4,d0,d7,d6,d5								bra.s	DoMultiplyColor; -------------				; non pas dans l'ombrePasDansShadow	clr.w	d5			; pas de face				movem.l	(sp)+,d0-d2DoMultiplyColor				movem.l		d1-d7/a0-a7,-(sp)				; sauvegarde x,y en cour			; on récupère les couleurs face,border,shadow;				move.l		G.RGB_FaceColor,d3	;				move.l		G.RGB_BorderColor,d2;				move.l		G.RGB_ShadowColor,d1								move.l		Faceclr(a6),d3							move.l		borderclr(a6),d2					move.l		Shadowclr(a6),d1	; d0= bgdcolor, d1= shadowbgd, d2= bordercolor, d3= face color; d4= bgdfactor , d5= shadow factor , d6= border factor, d7= face factor   				import		ColorMultiplicateur  				jsr			ColorMultiplicateur		; résultat dans d0								movem.l		(sp)+,d1-d7/a0-a7				; on récupére les registres				; on écrit le résultat dans la ram				move.w		Xpos(a6),d1				add.w		d3,d1				move.l		d0,(a4,d1.w*4)			; on écrit la valeur dans la ram; fin boucle X				addq.w		#1,d3				cmp.w		right+CH_Rect(a3),d3				bls			horizontal_loop								add.l		Row_Bytes(a6),a4				; fin boucle Y				addq.w		#1,d2				cmp.w		bottom+CH_Rect(a3),d2				bls			vertical_loopExit			movem.l (sp)+,d1-d7/a1-a4	; sauvegarde des registres								UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)									DbgInfo.new	Draw_A_Char			; this name will appear in the debugger				align 4					ENDP				* ================================================* PROCEDURE FastDraw_A_Char(); * ================================================*** Cette routine dessine un caractère dans la ram de la VX**	entrée: 	FontRenderPTr 	(long)*				Char n°		 	(word)	*				style			(word)*				x pos			(word)*				y pos			(word)*				basescreenptr	(long)*				Row_Bytes		(long)		*				bits/pixel		16 ou 32 (word)*	sortie:		Resultat		(word)	; 0= ok, ≠0 erreur*FastDraw_A_Char	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordLargeurChar		ds.w	1ParamBegin	EQU	*			; start parameters after this pointFontRenderPTr	ds.l	1Char			ds.w	1style			ds.w	1Xpos			ds.w	1Ypos			ds.w	1DisplayRamPtr			ds.l	1		; vidéo ramRow_Bytes				ds.l	1		; rowbytedestination_size	ds.w	1		; taille des pixelsParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkmultiplieurinverse	ds.w	1multiplieur			ds.w	1LocalSize	EQU 	*			; size of all the local variables			ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame				movem.l d1-d7/a1-a4,-(sp); -----------------  on recupère les infos du caractère -------------------------------; du fast char info !												move.l	FontRenderPTr(a6),a0				move.w	style(a6),d1						;				move.w	Char(a6),d0				import	GiveDisplayFont_FastCharInfo				jsr		GiveDisplayFont_FastCharInfo			; a0 char info , d1 nb de plan				tst.w	d0				bne  	Exit			; il y a une erreur								; a0 = ptr du char info; a1 = abs ptr du font display bitmap; d1 = nombre de plan pour le caractère				move.l	#CharHeaderSize,d0				move.l	a0,a2				adda.l	d0,a2			;CharHeaderSize ptr du bitmap								; on regarde si c'est un caractère affichable				cmp.w	#$ca,Char(a6)				bne.s	@1@1								move.w	right+CH_Rect(a0),d0				sub.w	left+CH_Rect(a0),d0				move.w	d0,LargeurChar(a6)				bmi		Exit						; pas un caractère affichable; on regarde si c'est un italique ; si oui on prend la largeur des caractères normaux; #########  mode spécial pour italique #############								cmp.w	#2,style(a6)	; si style italique on prend la largeur du style normal				bne		PasItalique								movem.l	a0-a4,-(sp)		; on sauvegarde les registres				move.l	FontRenderPTr(a6),a0				move.w	style(a6),d1					and.w	#$FFFD,D1		; on masque l'italique				move.w	Char(a6),d0				import	GiveDisplayFont_FastCharInfo				jsr		GiveDisplayFont_FastCharInfo			; a0 char info , d1 nb de plan				tst.w	d0								move.l	#CharHeaderSize,d0				move.l	a0,a2				adda.l	d0,a2			;CharHeaderSize ptr du bitmap				move.w	right+CH_Rect(a0),d0				sub.w	left+CH_Rect(a0),d0				move.w	d0,LargeurChar(a6)		; on renvoie cette valeur								movem.l	(sp)+,a0-a4 		; on récupère les registres				PasItalique							; calcul position verticale dans la VX 					move.w	Ypos(a6),d0  				add.w	ch_spare(a0),d0				; rapport de la base line								mulu	2+Row_Bytes(a6),d0			; row_byte sur .l donc pd faible => 2+				add.l	DisplayRamPtr(a6),d0		; base VX				move.l	d0,a4; il faut tenir compte de la taille en pixel de la carte d'affichage; 16 ou 32 bits	;				cmp.w	#32,destination_size(a6);				bne.s	bits_Mode16					; ----------------------------; boucle de recopie 32 bits/ pixels; calcul row byte source				moveq	#0,d5				move.w	right+CH_Rect(a0),d5				addq.w	#1,d5				lsl.l	#2,d5		; *4								moveq	#0,d2vertical_loop_mode32				clr.w	d3horizontal_loop_mode32				move.l		(a2,d3.w*4),d0				; on regarde si l'adresse d'écriture < base ram vidéo 				move.w		d3,d1				add.w		Xpos(a6),d1				lsl.w		#2,d1				lea			(a4,d1.w),a1				cmp.l		DisplayRamPtr(a6),a1				blo 		nextX_mode32							; test si écriture ou non; si le dernier pixel ≠0 =>; si RGB = 0 on n'écrit pas			; nouveau pixel transparent ?				move.l		d0,d1				and.l		#$ff000000,d1				beq 		nextX_mode32	; oui=> on ne change pas ce pixel;	ancien pixel transparent ? 					 				move.l		(a1),d1		  				and.l		#$ff000000,d1		 				beq 		YsiGo		; oui transparent on peut remplacer le pixel; nous sommes dans le cas ou deux caractères se chevauchent.; il faut calculer le nouveau pixel en fonction de l'alpha du nouveau pixel; mélange en fonction de l'alpha de d0				move.l		(a1),d1		 				movem.l	d2-d3,-(sp)				move.l	d0,d2								rol.l	#8,d2					; l'alpha channel				and.w	#$ff,d2				move.w	d2,multiplieur(a6)		; l'alpha channel				neg.w	d2				add.w	#255,d2				move.w	d2,multiplieurinverse(a6)	; 255-l'alpha channel; bleu								moveq	#0,d2				moveq	#0,d3								move.b	d1,d3				mulu	multiplieurinverse(a6),d3				move.b	d0,d2				mulu	multiplieur(a6),d2				add.w	d3,d2								lsr.w	#8,d2		; ÷256				cmp.b	d1,d0		; d0 >d1 ?				bhi		@BB1				move.b	d1,d2@BB1								move.b	d2,d0				ror.l	#8,d0				ror.l	#8,d1				; vert												moveq	#0,d2				moveq	#0,d3								move.b	d1,d3				mulu	multiplieurinverse(a6),d3				move.b	d0,d2				mulu	multiplieur(a6),d2				add.w	d3,d2								lsr.w	#8,d2		; ÷256								cmp.b	d1,d0		; d0 >d1 ?				bhi		@BB2				move.b	d1,d2@BB2								move.b	d2,d0				ror.l	#8,d0				ror.l	#8,d1; rouge								moveq	#0,d2				moveq	#0,d3								move.b	d1,d3				mulu	multiplieurinverse(a6),d3				move.b	d0,d2				mulu	multiplieur(a6),d2				add.w	d3,d2								lsr.w	#8,d2		; ÷256								cmp.b	d1,d0		; d0 >d1 ?				bhi		@BB3				move.b	d1,d2@BB3								move.b	d2,d0				ror.l	#8,d0				ror.l	#8,d1					moveq	#0,d2				moveq	#0,d3; l'alpha								move.b	d1,d3				mulu	multiplieurinverse(a6),d3				move.b	d0,d2				mulu	multiplieur(a6),d2				add.w	d3,d2								lsr.w	#8,d2		; ÷256								cmp.b	d1,d0		; d0 >d1 ?				bhi		@BB4				move.b	d1,d2@BB4								move.b	d2,d0				ror.l	#8,d0				ror.l	#8,d1									movem.l	(sp)+,d2-d3				; pas de problème on y va YsiGo			move.l		d0,(a1)			; on écrit la valeur dans la ram; fin boucle XnextX_mode32				addq.w		#1,d3				cmp.w		right+CH_Rect(a0),d3				bls.s		horizontal_loop_mode32				add.l		Row_Bytes(a6),a4		; destination											add.l		d5,a2		; source			; fin boucle Y				addq.w		#1,d2				cmp.w		bottom+CH_Rect(a0),d2				bls.s		vertical_loop_mode32				bra.s		Exit				; -------------------------------; boucle de recopie 16_bits_Mode				bits_Mode16				; calcul row byte source				moveq	#0,d5				move.w	right+CH_Rect(a0),d5				lsl.l	#1,d5								clr.w	d2vertical_loop_mode16				clr.w	d3				horizontal_loop_mode16				move.w		(a2,d3.w*4),d0				bpl.s		NextX_mode16			; on n'écrit pas si alpha=0				move.w		Xpos(a6),d1				add.w		d3,d1				move.w		d0,(a4,d1.w*2)			; on écrit la valeur dans la ram; fin boucle XNextX_mode16					addq.w		#1,d3				cmp.w		right+CH_Rect(a0),d3				bls.s		horizontal_loop_mode16				add.l		Row_Bytes(a6),a4		;destination				add.l		d5,a2					;source; fin boucle Y				addq.w		#1,d2				cmp.w		bottom+CH_Rect(a0),d2				bls.s		vertical_loop_mode16				Exit			movem.l	(sp)+,d1-d7/a1-a4				UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)									DbgInfo.new	FastDraw_A_Char			; this name will appear in the debugger				align 4					ENDP				* ================================================* PROCEDURE Test_FontRecord2(); * ================================================** cette routine teste la routine draw_a_Char**Test_FontRecord2	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rectrectangle	ds		RectRGB_Color				ds.w	3CharW		ds.w	1faceW		ds.w	1Xpos			ds.w	1		; x en courYpos			ds.w	1		; y en courRow_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp); on récupère les coordonées de la carte VE										clr.l	-(sp)					_GetDeviceList			; à changer 				move.l	(sp)+,d0 			move.l	d0,-(sp) 				move.l	d0,-(sp) 				_GetNexTDevice				move.l	(sp)+,a0		; le handle				move.l	(a0),a0			; handle => pointeur				move.w	gdID(a0),d0		;				move.l	gdPMap(a0),a1				move.l	(a1),a1			; handle => pointeur				move.l	baseAddr(a1),Base_Adresse(a6)								move.w	rowBytes(a1),d0				and.l	#$7fff,d0		; seulement b0-b14 et extension sur 32 bits				move.l	d0,Row_Bytes(a6);				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6)			move.w	#758,width(a6)			move.w	#576,height(a6); -------- on raz la V E ---------------------------------------------						move.l	Base_Adresse(a6),a0			move.w	#575,d7loop_1			move.l	Row_Bytes(a6),d6			lsr.l	#2,d6					;÷4  (long)loop_2					clr.l	(a0,d6.w*4)			dbra	d6,loop_2			add.l	Row_Bytes(a6),a0			; ligne suivante			dbra	d7,loop_1		; -------- on affiche dans une boucle les caractères du font record					lea		G.Display_Font,a0		move.w	#$21,CharW(a6)		move.w	#0,faceW(a6)						; ---- la boucle 				move.w	#40,ypos(a6)		; base line		move.w	#0,Xpos(a6)Display_char_Loop* Draw_A_Char*	entrée: 	FontRenderPTr 	(long)*				Char n°		 	(word)	*				style			(word)*				Facecolor		(long)*				bordercolor		(long)*				Shadowcolor		(long)*				Bgdcolor		(long)*				flags			(word)	; blend / opaque bgd; si blend regarde la couleur*										  en dessous du caractère *				xPos*				YPos**	sortie:		Resultat		(word)	; 0= ok, ≠0 erreur		clr.w -(sp)		pea		G.Display_Font		move.w	CharW(a6),-(sp)		move.w	faceW(a6),-(sp)		move.l	G.RGB_FaceColor,-(sp)			move.l	G.RGB_BorderColor,-(sp)		move.l	G.RGB_ShadowColor,-(sp)		move.l	#0,-(sp)		;Bgdcolor				move.w	#2,-(sp)		;flags					move.w	Xpos(a6),-(sp)	;		move.w	Ypos(a6),-(sp)		move.l	Base_Adresse(a6),-(sp)		move.l	Row_Bytes(a6),-(sp)		import		Draw_A_Char		jsr			Draw_A_Char				move.w	(sp)+,d1				beq 	fin_du_Caracteres	; si =0 pas de caratère		PasExist				move.w		Xpos(a6),d0		add.w		d1,d0			; largeur du caractère		add.w		#3,d0		move.w		d0,Xpos(a6)				cmp.w		#746,d0		blo.s		fin_du_Caracteres				move.w		Ypos(a6),d0		add.w		#33,d0					; 33 au pif		move.w		d0,Ypos(a6)		move.w		#0,Xpos(a6)		cmp.w		#576,d0			; on 	arrive à la fin 		bhi			Exit	fin_du_Caracteres		move.w	CharW(a6),d0		add.w	#1,d0		move.w	d0,CharW(a6)				cmp.w	#255,d0			; fin des caractères ?		blo.s	Display_char_Loop				move.w	#33,CharW(a6)		clr.w	Xpos(a6)		add.w	#33,Ypos(a6)		fin_du_style				add.w	#1,faceW(a6)		lea		G.Display_Font,a0		move.w	faceW(a6),d0		cmp.w	Face_Number(a0),d0		blo		Display_char_Loop		; c'est finiExit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new	Test_FontRecord2			; this name will appear in the debugger		align 4			ENDP					* ================================================* PROCEDURE TestDrawFastChar(); * ================================================** cette routine teste la routine Fastdraw_a_Char**TestDrawFastChar	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		Rectrectangle	ds		RectRGB_Color				ds.w	3CharW		ds.w	1faceW		ds.w	1Xpos			ds.w	1		; x en courYpos			ds.w	1		; y en courRow_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp); on récupère les coordonées de la carte VE;				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6)			move.w	#758,width(a6)			move.w	#576,height(a6); -------- on raz la V E ---------------------------------------------						move.l	Base_Adresse(a6),a0			move.w	#575,d7loop_1			move.l	Row_Bytes(a6),d6			lsr.l	#2,d6					;÷4  (long)loop_2					clr.l	(a0,d6.w*4)			dbra	d6,loop_2			add.l	Row_Bytes(a6),a0			; ligne suivante			dbra	d7,loop_1		; -------- on affiche dans une boucle les caractères du font record					lea		G.Display_Font,a0		move.w	#$21,CharW(a6)		move.w	#0,faceW(a6)						; ---- la boucle 				move.w	#40,ypos(a6)		; base line		move.w	#0,Xpos(a6)Display_char_Loop		cmp.w	#$ca,CharW(a6)		bne.s	Do_drawChar; $ ca ? oui						Lea		G.Display_Font,a0		move.w	faceW(a6),d1			move.w	#'a',d0		import	GiveDisplayFont_FastCharInfo		jsr		GiveDisplayFont_FastCharInfo			; a0 char info , d1 nb de plan		tst.w	d0		bne  	Exit			; il y a une erreur				move.w	right+Ch_Rect(a0),d1		mulu	#3,d1		divu	#4,d1				bra.S	PasExist				* Draw_A_Char*	entrée: 	FontRenderPTr 	(long)*				Char n°		 	(word)	*				style			(word)*				Facecolor		(long)*				bordercolor		(long)*				Shadowcolor		(long)*				Bgdcolor		(long)*				flags			(word)	; blend / opaque bgd; si blend regarde la couleur*										  en dessous du caractère *				xPos*				YPos**	sortie:		Resultat		(word)	; 0= ok, ≠0 erreurDo_drawChar		clr.w -(sp)		pea			G.Display_Font		move.w		CharW(a6),-(sp)		move.w		faceW(a6),-(sp)				move.w		Xpos(a6),-(sp)	;		move.w		Ypos(a6),-(sp)		move.l		Base_Adresse(a6),-(sp)		move.l		Row_Bytes(a6),-(sp)		move.w		#32,-(sp)		import		FastDraw_A_Char		jsr			FastDraw_A_Char				move.w	(sp)+,d1				beq 	fin_du_Caracteres	; si =0 pas de caratère		PasExist				move.w		Xpos(a6),d0		add.w		d1,d0			; largeur du caractère		add.w		#3,d0		move.w		d0,Xpos(a6)				cmp.w		#746,d0		blo.s		fin_du_Caracteres				move.w		Ypos(a6),d0		add.w		#33,d0					; 33 au pif		move.w		d0,Ypos(a6)		move.w		#0,Xpos(a6)		cmp.w		#576,d0			; on 	arrive à la fin 		bhi			Exit	fin_du_Caracteres		move.w	CharW(a6),d0		add.w	#1,d0		move.w	d0,CharW(a6)				cmp.w	#255,d0			; fin des caractères ?		blo.s	Display_char_Loop				move.w	#33,CharW(a6)		clr.w	Xpos(a6)		add.w	#33,Ypos(a6)		fin_du_style				add.w	#1,faceW(a6)		lea		G.Display_Font,a0		move.w	faceW(a6),d0		cmp.w	Face_Number(a0),d0		blo		Display_char_Loop		; c'est finiExit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new	TestDrawFastChar			; this name will appear in the debugger		align 4			ENDP							* ================================================* PROCEDURE Draw_A_Line(); * ================================================** Cette routine dessine une ligne sur l'écran * Draw_A_Line	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointThe_Font		ds.l	1		; identifiant de la police d'affichageChar_Ptr	ds.l	1		; pointeur des caractèreschar_Lenth	ds.l	1		; longueur à afficherStartXpos	ds.w	1		; x,y original StartYpos	ds.w	1VarEndXpos	ds.w	1		; x,y finalVarEndYpos	ds.w	1theStyle	ds.w	1		; le style pour l'instantTheJustify	ds.w	1		; justification 0=left, 1=centrée, 2= à droiteParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		RectStringLenth	ds.w	1		; longueur totale de la ligneA_width		ds.w	1		; largeur d'un A (pour connaitre la largeur d'un espace rectangle	ds		RectCharW		ds.w	1faceW		ds.w	1RGB_Color			ds.w	3Row_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireSavePort		ds.l	1Kerning			ds.w	1Spacing			ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp)		; on récupère les coordonées de la carte VE										clr.l	-(sp)					_GetDeviceList			; à changer 				move.l	(sp)+,d0 			move.l	d0,-(sp) 				move.l	d0,-(sp) 				_GetNexTDevice				move.l	(sp)+,a0		; le handle				move.l	(a0),a0			; handle => pointeur				move.w	gdID(a0),d0		;				move.l	gdPMap(a0),a1				move.l	(a1),a1			; handle => pointeur				move.l	baseAddr(a1),Base_Adresse(a6)								move.w	rowBytes(a1),d0				and.l	#$7fff,d0		; seulement b0-b14 et extension sur 32 bits				move.l	d0,Row_Bytes(a6)				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6)		; on commence par déterminer la longueur de la ligne		move.l	char_Lenth(a6),d7		subq.l	#1,d7					; nombre de caractère		clr.w	StringLenth(a6)			; raz longueur		move.l	Char_Ptr(a6),a4		move.l	The_Font(a6),a0		move.w	NormalKerning(a0),Kerning(a6)		move.w	spaceWidth(a0),Spacing(a6)	; ---------------------------Calcule_longueur_String; lecture du caractère		moveq	#0,d0		move.b	(a4)+,d0			; the char				cmp.w	#$20,d0		beq		Space		cmp.w	#$ca,d0		beq		Space				move.l	The_Font(a6),a0 		move.w	theStyle(a6),d1		import	GiveDisplayFont_CharInfo		jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan		tst.w	d0		beq.s	CalcLargeur		; si pas erreur on additionne ; ----Space		move.w	spacing(a6),d0		move.W	d0,A_width(a6); ----		CalcLargeur		move.w	right+CH_Rect(a0),d0		sub.w	left+CH_Rect(a0),d0		add.w	Kerning(a6),d0				add.w	d0,StringLenth(a6)		; largeur du caractère en plus		dbra	d7,Calcule_longueur_String		; ----------------------------------------------		; maintenant on connait la largeur de la phrase on peut la centrer si nécessaire		cmp.w	#0,TheJustify(a6)		beq		Doleft_justify		cmp.w	#1,TheJustify(a6)		beq		DoCenter_justify		cmp.w	#2,TheJustify(a6)		beq		DoRight_justify		Doleft_justify				move.w	#768*10/100,StartXpos(a6)		; 10 % du bord gauche		bra		DrawTheStringDoCenter_justify		move.w	#768,d0		sub.w	StringLenth(a6),d0					lsr.w	#1,d0						; 1/2 largeur restante		move.w	d0,StartXpos(a6)			; x pos pour centré		bra		DrawTheStringDoRight_justify				move.w	#768*90/100,d0		sub.w	StringLenth(a6),d0					move.w	d0,StartXpos(a6)			; x pos pour justif droite; -----------------------------------------------------------------; on dessine la ligne; on dessine un ligne pour indiquer comment il calcule le centrageDrawTheString		pea		SavePort(a6)		_GetPort				pea		G.DisplayWindow		_SetPort		move.w	#$ffff,RGB_Color(a6)		move.w	#$ffff,2+RGB_Color(a6)		move.w	#$ffff,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RgbForeColor				move.w	StartXpos(a6),d0		subq.w	#2,d0; 		add.w	#640,d0								; largeur du main screen		move.w	d0,left+rectangle(a6)		add.w	StringLenth(a6),d0		addq.w	#2,d0		move.w	d0,right+rectangle(a6)  		move.w	StartYpos(a6),d0		sub.w	#30,d0		move.w	d0,top+rectangle(a6)		add.w	#60,d0		move.w	d0,bottom+rectangle(a6)		pea		rectangle(a6)		_FrameREct				move.l		SavePort(a6),-(sp)		_SetPort				move.l	char_Lenth(a6),d7		subq.l	#1,d7					; nombre de caractère		move.l	Char_Ptr(a6),a4DrawString_Loop				moveq	#0,d0		move.b	(a4)+,d0			; the char				cmp.w	#$20,d0		beq		Draw_Space		cmp.w	#$ca,d0		beq		Draw_Space		movem.l	d7/a4,-(sp)				clr.w	-(sp)				move.l	The_Font(a6),-(sp)		move.w	d0,-(sp)		move.w	theStyle(a6),-(sp)		move.l	G.RGB_FaceColor,-(sp)			move.l	G.RGB_BorderColor,-(sp)		move.l	G.RGB_ShadowColor,-(sp)		move.l	#0,-(sp)		;Bgdcolor				move.w	#2,-(sp)		;flags					move.w	StartXpos(a6),-(sp)	;		move.w	StartYpos(a6),-(sp)		move.l	Base_Adresse(a6),-(sp)		move.l	Row_Bytes(a6),-(sp)		import		Draw_A_Char		jsr			Draw_A_Char				move.w		(sp)+,d0				movem.l		(sp)+,d7/a4				bra.s	End_Draw; --- dessin d'un espaceDraw_Space				move.w	spacing(a6),d0End_Draw			add.w	kerning(a6),d0		add.w	d0,StartXpos(a6)		dbra	d7,DrawString_Loop			; c'est finiExit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new	Draw_A_Line			; this name will appear in the debugger		align 4			ENDP									* ================================================* PROCEDURE Test_draw_string(); * ================================================** Cette routine dessine un string  * Test_draw_string	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		RectStringLenth	ds.w	1		; longueur totale de la ligneA_width		ds.w	1		; largeur d'un A (pour connaitre la largeur d'un espace rectangle	ds		RectCharW		ds.w	1faceW		ds.w	1Row_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp)			lea		G.Display_Font,a0						tst.l	Render_handle(a0)		; il y a t-il un bitmap  font ?			beq		Exit					; non; on appelle la routine  			pea		G.Display_Font			;The_Font		ds.l	1		; identifiant de la police d'affichage			lea		testString(pc),a0			moveq	#0,d0			move.b	(a0)+,d0			move.l	a0,-(sp)	;Char_Ptr	ds.l	1		; pointeur des caractères			move.l	d0,-(sp)	;char_Lenth	ds.l	1		; longueur à afficher			move.W	G.X_Offset,-(sp)		;StartXpos	ds.w	1		; x,y original 			move.W	G.Y_Offset,-(sp)	;	StartYpos	ds.w	1			clr.w	-(sp)		;VarEndXpos	ds.w	1		; x,y final			clr.w	-(sp)		;VarEndYpos	ds.w	1			move.w	#0,-(sp)	;theStyle	ds.w	1		; le style pour l'instant			move.w	#1,-(sp)	;TheJustify	ds.w	1		; justification 0=left, 1=centrée, 2= à droite						import	Draw_A_Line				jsr		Draw_A_Line				Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)testString		dc.b	'Ceci est une chaine de Test'				DbgInfo.new	Test_draw_string			; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE Test_Fastdraw_string(); * ================================================** Cette routine dessine un string  *Test_Fastdraw_string	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		RectStringLenth	ds.w	1		; longueur totale de la ligneA_width		ds.w	1		; largeur d'un A (pour connaitre la largeur d'un espace rectangle	ds		RectCharW		ds.w	1faceW		ds.w	1Ypos		ds.w	1Xpos		ds.w	1Row_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireTotalChar		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp); on récupère les coordonées de la carte VE										clr.l	-(sp)					_GetDeviceList			; à changer 				move.l	(sp)+,d0 				move.l	d0,-(sp) 				move.l	d0,-(sp) 				_GetNexTDevice				move.l	(sp)+,a0		; le handle				move.l	(a0),a0			; handle => pointeur				move.w	gdID(a0),d0		;				move.l	gdPMap(a0),a1				move.l	(a1),a1			; handle => pointeur				move.l	baseAddr(a1),Base_Adresse(a6)								move.w	rowBytes(a1),d0				and.l	#$7fff,d0		; seulement b0-b14 et extension sur 32 bits				move.l	d0,Row_Bytes(a6)				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6);			move.w	#758,width(a6)			move.w	#576,height(a6); -------- on raz la V E ---------------------------------------------						move.l	Base_Adresse(a6),a0			move.w	#575,d7loop_1			move.l	Row_Bytes(a6),d6			lsr.l	#2,d6					;÷4  (long)loop_2					clr.l	(a0,d6.w*4)			dbra	d6,loop_2			add.l	Row_Bytes(a6),a0			; ligne suivante			dbra	d7,loop_1		; -------- on affiche dans une boucle les caractères du font record					lea		G.Display_Font,a0		move.w	#0,CharW(a6)		move.w	#0,faceW(a6)						; ---- la boucle 				move.w	#480,ypos(a6)		; base line		move.w	#130,Xpos(a6)		moveq	#0,d0		; on regarde le nombre de caractère à afficher		lea		testString(pc),a0		move.b	(a0),d0		move.w	d0,TotalChar(a6)				Display_char_Loop		lea		testString(pc),a0		move.w	CharW(a6),d1		moveq	#0,d0		move.b	1(a0,d1.w),d0		cmp.w	#$20,d0		beq.s	Space		cmp.w	#$CA,d0		beq.s	Space		* Draw_A_Char*	entrée: 	FontRenderPTr 	(long)*				Char n°		 	(word)	*				style			(word)*				Facecolor		(long)*				bordercolor		(long)*				Shadowcolor		(long)*				Bgdcolor		(long)*				flags			(word)	; blend / opaque bgd; si blend regarde la couleur*										  en dessous du caractère *				xPos*				YPos**	sortie:		Resultat		(word)	; 0= ok, ≠0 erreur		clr.w -(sp)		pea			G.Display_Font		move.w		d0,-(sp)		move.w		#0,-(sp)				move.w		Xpos(a6),-(sp)	;		move.w		Ypos(a6),-(sp)		move.l		Base_Adresse(a6),-(sp)		move.l		Row_Bytes(a6),-(sp)		move.w		#32,-(sp)		import		FastDraw_A_Char		jsr			FastDraw_A_Char				move.w	(sp)+,d1				beq 	fin_du_Caracteres	; si =0 pas de caratère			bra.s	PasExistSpace		Lea		G.Display_Font,a0		move.w	#0,d1						; style		move.w	#'a',d0		import	GiveDisplayFont_FastCharInfo		jsr		GiveDisplayFont_FastCharInfo			; a0 char info , d1 nb de plan		tst.w	d0		bne  	Exit			; il y a une erreur				move.w	right+Ch_Rect(a0),d1		mulu	#3,d1		divu	#4,d1		PasExist				move.w		Xpos(a6),d0		add.w		d1,d0			; largeur du caractère		move.w		d0,Xpos(a6)				cmp.w		#746,d0		blo.s		fin_du_Caracteres				move.w		Ypos(a6),d0		add.w		#33,d0					; 33 au pif		move.w		d0,Ypos(a6)		move.w		#0,Xpos(a6)		cmp.w		#576,d0			; on 	arrive à la fin 		bhi			Exit	fin_du_Caracteres		add.w	#1,CharW(a6)		move.w	TotalChar(a6),d0		cmp.w	CharW(a6),d0		bhi		Display_char_Loop					Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)testString		dc.b	'Ceci est une chaine de Test'				DbgInfo.new	Test_Fastdraw_string			; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE clr_VX(); * ================================================** Cette routine dessine un string  * clr_VX	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		RectStringLenth	ds.w	1		; longueur totale de la ligneA_width		ds.w	1		; largeur d'un A (pour connaitre la largeur d'un espace rectangle	ds		RectCharW		ds.w	1faceW		ds.w	1Row_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		movem.l d1-d7/a1-a4,-(sp)				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6);			move.w	#758,width(a6)			move.w	#576,height(a6); -------- on raz la V E ---------------------------------------------						move.l	Base_Adresse(a6),a0			move.w	#575,d7loop_1			move.l	Row_Bytes(a6),d6			lsr.l	#2,d6					;÷4  (long)loop_2					clr.l	(a0,d6.w*4)			dbra	d6,loop_2			add.l	Row_Bytes(a6),a0			; ligne suivante			dbra	d7,loop_1			Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		clr_VX			; this name will appear in the debugger		align 4			ENDP			* ================================================* PROCEDURE Load_A_Font():* ================================================		Load_A_Font	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkreply		ds		StandardFileReplyparamBlock	ds.b	ioFlClpSiz	; parameter block pour les fonction de fichierfsOpenErr	ds.w	1fsRefNum	ds.w	1seconds		ds.l	1Buffer		ds.l	1count		ds.l	1FileLenth	ds.l	1SaveNewHandle	ds.l	1DialogStorage	ds	dWindLenTextBuff	ds.b	256LocalSize	EQU 	*			; size of all the local variables		ENDR; LE FAit de déclarer reply dans With,; fait que reply devient un offset utilisable pour cette procedure; comme reply est un record on peut utiliser les offsets défini dans ce record,`; par example : sfGood(a6) équivalent à   Reply+sfGood(a6)		WITH	StackFrame,StandardFileReply,FSSpec,FontRenderRecord	; cover our local stack frame		import	ImportationFichierAscii,TraitementErreurFichier,\		AFFICHENUMSAISIE,TransfertMemoireSaisie,CalculDuree,\		CopyStr,ReadBonBougreFormat				LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d1-d7/a1-a4,-(sp)						clr.l	-(sp) ; file filter = none		Move.w	#1,-(sp)		; on veut les  fichiers bon_bougre		pea		TYPELYST(pc)		Pea		reply(a6)		_StandardGetFile		move.b	sfGood(a6),d0		bEQ		Exit	; l'utilisateur à CanceléOuvrirLeFichier					lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		reply+sfFile+name(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		move.b	#4,ioPermssn(a0)			;fsRWrShPerm			clr.l	ioOwnBuf(a0)		move.l	reply+sfFile+parID(a6),ioDirID(a0)		_HOpen		jsr		TraitementErreurFichier			tst.l	d1		beq		OpenFile_Suite		move.l	#-1,d0		bra	Exit; on recherche le eof du fichier; pour connaitre la longueur du fichierOpenFile_Suite				lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)	; pas de routine de fin d'execution		lea		reply+sfFile+name(a6),a1			; cf (standartfile.a)		move.l	a1,ioNamePtr(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		_GetEOF		jsr		TraitementErreurFichier		lea.l	paramBlock(a6),a0		move.l	ioLEOF(a0),FileLenth(a6)		; on effectue un aiguillage en fct de type de fichier		move.l	sfType(a6),d0		case#.l	(d0,if),\		('Bbdf', DoTypeDisplayFont); pas fichier bon bougre		clr.w	-(sp)		move.w	#143,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		cmp.w	#1,d0		bne.s	HaveAlook				lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_Close				move.w	#false,G.ChangeSinceLastSave			move.l	#-1,d0		bra	Exit* ------------------------------------------------HaveAlook		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		move.l	G.BufferTransfert,ioBuffer(a0)		move.l	G.SIZEBufferTransfert,ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)		clr.l	ioPosOffset(a0)		_Read		jsr		TraitementErreurFichier		tst.l	d1		bne		CLOSEFILE		move.l	G.BufferTransfert,a0		move.l	G.SIZEBufferTransfert,d1		break				bra		CLOSEFILE		* --------------------------------------------------* ------- récupération d'une police d'affichageDoTypeDisplayFont; on regarde s'il y déja une police en mémoire; si oui on dispose la mémoire		lea		G.Display_Font,a1		move.l	Render_handle(a1),a0		cmpa.l	#00000,a0		beq.S	NotDispose				_Hunlock		lea		G.Display_Font,a1		move.l	Render_handle(a1),a0		_DisposHandle;on regarde s'il y a un fast font pour la police, si oui on le dispose 		lea		G.Display_Font,a1		move.l	RenderColor_handle(a1),d0		beq.s	NotDispose					; pas de fast font		move.l	d0,a0						; oui on dispose le handle		_DisposHandle				lea		G.Display_Font,a1		move.l	#0,RenderColor_handle(a1)	; on met la case à zéro pour indiquer qu'il ny en a plusNotDispose			; on ouvre un nouveau handle pour stocker la font			move.l	FileLenth(a6),d0		sub.l	#FontRenderRecord_SizeOf,d0		_NewHandle			move.l	a0,SaveNewHandle(a6)		tst.w	d0		bne		CLOSEFILE			; il n'a pas assez de mémoire pour lire la police; ok on a le handle		move.l	SaveNewHandle(a6),a0		_MoveHHI									move.l	SaveNewHandle(a6),a0		_Hlock						; on lock le handle	; on lit le font record		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)		lea		G.Display_Font,a1		move.l	a1,ioBuffer(a0)		move.l	#FontRenderRecord_SizeOf,ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)		clr.l	ioPosOffset(a0)		_Read						lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.w	reply+sfFile+vRefnum(a6),ioVrefNum(a0)  		move.l	SaveNewHandle(a6),a1		move.l	(a1),a1							; ptr du font record		move.l	a1,ioBuffer(a0)		move.l	FileLenth(a6),d0		sub.l	#FontRenderRecord_SizeOf,d0		move.l	d0,ioReqCount(a0)				; nombre d'octets à lire		move.w	#fsAtMark,ioPosMode(a0)		clr.l	ioPosOffset(a0)		_Read		 		move.l	SaveNewHandle(a6),a0		_HUnlock				lea		G.Display_Font,a1		move.l	a0,Render_handle(a1)			; on place le handle; on calcul l'interspacing des caractères et l'espacement d'un espace				lea		G.Display_Font,a0		move.w	#0,d1		move.w	#'a',d0		import	GiveDisplayFont_CharInfo		jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan				move.w	right+pi_Rect+CharHeaderSize(a0),d0						sub.w	left+pi_Rect+CharHeaderSize(a0),d0					mulu	#3,d0		divu	#4,d0				lea		G.Display_Font,a1		move.w	d0,spaceWidth(a1)			; largeur d'un espace		and.l	#$ffff,d0		divu.w	#3,d0						; largeur entre caractère		sub.w	BorderThickness(a1),d0		; la largeur de la bordure		cmp.w	#2,d0				bhi.s	kerningOk		move.w	#2,d0						; au minimum 2 pixelkerningOk				move.w	#0,NormalKerning(a1); on recopie le nom de la display font dans le texte  block note; on recopie le nom de la dernière police d'affichage utilisée (si elle existe)		lea 	G.LastFontUsed,a1		clr.w	(a1)		lea 	G.Display_Font,a0		lea		FontName(a0),a0		moveq	#0,d0		move.b	(a0),d0		beq		Pasrecopie		addq.l	#1,d0		cmp.l	#32,d0		blo		recopieStringlastfont		move.l	#32,d0	; on limite à 32 caractèresrecopieStringlastfont		_BlockMovePasrecopieCLOSEFILE		lea		paramBlock(a6),a0		clr.l	ioCompletion(a0)		_Close		jsr		TraitementErreurFichier; on créé un fichier de préf qui contient un alias du fichier police d'affichage; ce qui permettra d'ouvrir automatiquement la dernière police utilisée				clr.w	-(sp)		Pea		reply+sfFile+vRefnum(a6)	; pour créer l'alias		clr.l	-(sp)	; pour les réglage de la police		import	MakePrefFileLastDisplayFontUsed		jsr		MakePrefFileLastDisplayFontUsed		move.w	(sp)+,d0						moveq	#0,d0		move.w	#True,G.ChangeSinceLastSave		import	UpdateGeneralValueExit	jsr		UpdateGeneralValue		;on actualise le premier et le dernier Ptr				pea		G.listingWindow		_Setport		lea		G.listingWindow,a0		pea		PortRect(a0)		_InvalRect		pea		G.DialogSaisie		_Setport		lea		G.DialogSaisie,a0		pea		PortRect(a0)		_InvalRect				movem.l	(sp)+,d1-d7/a1-a4						UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		STRING	ASISTYPELYST	dc.l	'Bbdf'		; bon bougre display font		DbgInfo.New	Load_A_Font		; this name will appear in the debugger		align 4			ENDP			* ================================================* PROCEDURE Draw_SousTitre(); * ================================================** 	Cette routine dessine un sous-titre à partir d'une FastFont**	*	entrée:	*SousTitrePtr	(long)		; pointeur du  sous-titre*			Xpos			(word)		; X,Y coordonnée  nb: Y= base line*			Ypos			(word)		; *			*ScreenBase		(long)		; adresse base de l'écran de dessin	*			RowByte			(long)		; largeur en octets de l'écran*			*Rectangle		(Long)		; adresse du rectangle en retour**	sortie: Result			(word)		; resultat 	*										; 0= noerr	; -1= can't find fast font*			+ le rectangle *Draw_SousTitre	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult		ds.w	1ParamBegin	EQU	*			; start parameters after this pointStPtr		ds.l	1Xpos		ds.w	1Ypos		ds.w	1ScreenBase	ds.l	1Row_byte	ds.l	1TheRectPtr	ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkStartY		ds.w	1StartX		ds.w	1lineWidth	ds.w	1			; largeur d'une lignethejust		ds.w	1thestyle	ds.w	1			; le style en coursNextStyle	ds.l	1			; pointeur du prochain style theChar		ds.w	1startChar	ds.w	1			; n° du caractère de départ de la lignetheFont		ds.w	1;endChart	ds.w	1			;	n° du caractère de fin de la ligne	end_Char	ds.w	1CharPos		ds.w	1			; position // au texteTextePtr	ds.l	1			; pointeur du texteintercharSpace	ds.w	1		; espace entre deux caractèresLastWidth	ds.w	1NombreLigne	ds.w	1OutlineREct	ds		REct		; rectangle pour le outlineOutlineBox2	ds		rectOutlineBox3	ds		rectLigne_En_COur		ds.w	1		; n° de la ligne en cour de traitementTotal_Ligne			ds.w	1		; nombre total de ligneMax_DisplayWidth	ds.w	1		; largeur maximum du sous-titreDisplayHeight		ds.w	1		DisplayWidth		ds.w	1		; largeur de la ligne en courRowWidth_Table		ds.l	128		; table de la largeur des lignes + START CHAR+end charMaxwidth_Table		ds.w	1		; largeur maximum d'une ligneBoxing_rectangle	ds		rectMasKType			ds.w	1		; type  de maskageJustification		ds.w	1		; type  de justificationFlagLineNonDraw		ds.w	1		; flag pour indiquer q'une ligne n'est pas dessinéLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame				movem.l d1-d7/a1-a4,-(sp)		machine MC68020; 1er travail on regarde s'il y a display font + FastFont présent 		IF demo=1 THEN		MOVE.l	G.democount,d0		sub.L	#1,d0		move.l	D0,G.democount		bne.s	@a		import	Terminate		JSR		terminate		ENDIF@a				move.l	TheRectPtr(a6),a0		move.l	#-1,(a0)				; top+left		clr.l	4(a0)					; bottom+Right		lea		G.Display_Font,a0				tst.l	Render_handle(a0)		beq		ExitErr				tst.l	RenderColor_handle(a0)		beq		ExitErr						; on place noerr dans result				move.w	#0,result(a6)		; on récupère les infos justification + mask		move.l	StPtr(a6),a0		moveq	#0,d0		move.b	st_MasKType(a0),d0	; valeur d'entrée		move.w	d0,MasKType(a6)		move.b	st_Justification(a0),d0	; valeur d'entrée		move.w	d0,Justification(a6); mode overrriding ?				tst.w	G.Overriding_All_Attribute		bra		PasOverridingAtribute	; non; oui on remplace les valeurs par les valeurs dans préférence affichage		move.w	G.Outline_Box,d0		move.w	d0,MasKType(a6)		move.w	G.Justification,d0		move.w	d0,Justification(a6)		PasOverridingAtribute				; ok on, peut afficher		; --------------------------- on affiche ---------------------------; on récupère les coordonnées de la carte d'affichage; ON CHANGE LE CURSEUR POUR DIRE QUE L'ON TRAVAILLE			move.l	G.CurseurDessineST,-(sp)			_SetCCursor			move.l	G.VE_GDHandle,a0			cmpa.l	#000000,a0			beq		ExitErr			; pas de carte d'affichage						move.l	(a0),a0			; handle => pointeur			move.l	gdPMap(a0),a1			move.l	(a1),a1			; handle => pointeur; on calcule les dimensions de l'écran			move.w	pmBounds+right(a1),d0			sub.w	pmBounds+left(a1),d0			move.w	d0,DisplayWidth(a6)						move.w	pmBounds+bottom(a1),d1			sub.w	pmBounds+top(a1),d1			move.w	d1,DisplayHeight(a6)			move.w	#0,Max_DisplayWidth(a6)			clr.l	Boxing_rectangle(a6)			clr.l	4+Boxing_rectangle(a6)			; on raz le outline rectange									clr.l	OutlineREct(a6)			clr.l	4+OutlineREct(a6)						; --- on détermine la position verticale de départ en fonction du nombre de ligne de texte		move.l	StPtr(a6),a0		move.w	st_Nlines(a0),d0				move.w	d0,NombreLigne(a6)		move.w	d0,Total_Ligne(a6)		subq.w	#1,d0		bpl.s	@1		moveq 	#0,d0@1 		lea		G.Display_Font,a1		move.w	interligne(a1),d1		; hauteur maximum d'une ligne de texte	 		add.w	#6,D1				; INTERLIGNE  		add.w	G.Display_interligne,d1									mulu	d0,d1					; hauteur des lignes		move.w	YPos(a6),d0		sub.w	d1,d0		move.w	d0,StartY(a6)		sub.w	interligne(a1),d0		; point le + haut du rectangle du caractère  		sub.w	G.Display_interligne,d0				move.l	TheRectPtr(a6),a0			 			move.w	d0,top(a0)				; minY => top.rectangle		move.w	#1,Ligne_En_COur(a6)		; --------------------------- boucle de dessin ----------------------; on initialise les pointeur pour la première ligne		move.l	Stptr(a6),a4		move.l	a4,a1		move.l	#st_sizeOf,d1		adda.l	d1,a1				; pointeur du texte		move.l	a1,TextePtr(a6)		moveq 	#-1,d7					; compteur de caractère			move.w	#0,startchar(a6)		clr.l	NextStyle(a6)		lea		G.Display_Font,a0		move.w	NormalKerning(a0),intercharSpace(a6)		clr.w	lineWidth(a6)		bra.S	Loop_Find_end_Of_Line				; ----- loop de détermination de la largeur des lignes du sous-titre		loop_longueur_texte; on reset l'inter char space etc ...		move.w	d7,startChar(a6)			; caractère de début		addq.w	#1,startChar(a6)			; celui après le char de controle		lea		G.Display_Font,a0		move.w	NormalKerning(a0),intercharSpace(a6)		clr.w	lineWidth(a6); boucle déterminant la largeur de la ligne		Loop_Find_end_Of_Line		add.l	#1,d7		move.l	d7,d0				bsr		GiveChar_et_style		cmp.w	#-1,d0		beq		Fin_dela_ligne_1			; on à trouvé la fin de la ligne ou du texte				cmp.b	#$0d,d0					; retour chariot		beq		Fin_dela_ligne_1		cmp.b	#$ca,d0					; espace insécable		beq.S	Space		cmp.b	#$20,d0					; espace		beq.S	Space		blo.s	Loop_Find_end_Of_Line	; si caractère de contrôle on ne fait rien					movem.l	d7,-(sp)		lea		G.Display_Font,a0				; si le style demandé est italique on prend la largeur des caractères normaux	; ###################		move.w	TheStyle(a6),d1			; style demandé		cmp.w	#2,d1		bne.s	PasItalique		moveq 	#0,d1					; on passe en mode normal#########PasItalique				import	GiveDisplayFont_FastCharInfo		jsr		GiveDisplayFont_FastCharInfo		move.w	right+Ch_Rect(a0),d0				movem.l	(sp)+,d7		bra.s	Add_largeur		; largeur dela ligneSpace		lea		G.Display_Font,a0		move.w	spaceWidth(a0),d0		Add_largeur		add.w	intercharSpace(a6),d0		; interchar space				cmp.w	#2,theStyle(a6)		; si italique 2 pixel en moins		bne.s	@1		subq.w	#2,d0@1				move.w	d0,LastWidth(a6)		add.w	d0,lineWidth(a6)				bra		Loop_Find_end_Of_Line				; -------------Fin_dela_ligne_1; on enlève un interspace		move.w	lineWidth(a6),d0		beq.s	LigneNule 		sub.w	intercharSpace(a6),d0LigneNule			lea		RowWidth_Table(a6),a3		move.w	total_ligne(a6),d1		sub.w	NombreLigne(a6),d1		; pointeur dans la table		move.w	d0,(a3,d1.w*8)			; on stocke la largeur de la ligne		move.w	startChar(a6),d2		move.w	d2,2(a3,d1.w*8)			; on stocke le start char		move.w	d7,4(a3,d1.w*8)			; on stocke le end char		;		on compare cette valeur // au paramètre général				cmp.w	Max_DisplayWidth(a6),d0		blo.s	Pas_supMaxLargeur		; pas plus grand		move.w	d0,Max_DisplayWidth(a6)	; on place la nouvelle valeur largeur maximumPas_supMaxLargeur				sub.w	#1,NombreLigne(a6)		bne.s	loop_longueur_texte				; on a fait toute les lignes; ----- loop de dessin	-----------------------------------------------------		; maintenant on dessine le sous-titre 		; on raz les paramètres de la boucle		move.w	#0,startchar(a6)		clr.l	NextStyle(a6)		lea		G.Display_Font,a0		move.w	NormalKerning(a0),intercharSpace(a6)		clr.w	lineWidth(a6)		move.w	total_ligne(a6),NombreLigne(a6)				;-------------------------------------------------------------------		Loop_NextLine		; on reset l'inter char space etc ...		lea		G.Display_Font,a0		move.w	NormalKerning(a0),intercharSpace(a6); on récupère la largeur de la ligne en courLoop_NextLine_1				lea		RowWidth_Table(a6),a3		move.w	total_ligne(a6),d1		sub.w	NombreLigne(a6),d1		; pointeur dans la table		move.w	(a3,d1.w*8),d0			; on récupère la largeur de la ligne		move.w	d0,lineWidth(a6)		move.w	2(a3,d1.w*8),d2			; on récupère le start char		move.w	d2,startChar(a6)		move.w	4(a3,d1.w*8),d7			; on récupère le end char		move.w	d7,end_Char(a6); -------------------------------------------------------------------; mode de justification		move.w	Justification(a6),d0				case#.W	(d0,if),\		(0,Center_Justif),\		(1,left_Justif),\		(2,right_Justif)		bra	Center_Justif		; ------------     justification à gauche   -------------------------left_Justif			moveq	#0,d0		move.w	DisplayWidth(a6),d0		divu	#10,d0					; 10% du bord gauche				add.w	G.Offset_JustifRL,d0		bpl.s		LJ_1		; <0 ?		moveq 		#1,d0		; oui donc =0LJ_1; on vérifie que cela ne sort pas de l'écran		move.w	DisplayWidth(a6),d1		sub.w	lineWidth(a6),d1		; ce qui reste		cmp.W	d1,d0		blo.s	LJ_2		move.w	d1,d0LJ_2	move.w	d0,StartX(a6)		move.w	d0,d3		bra		LookRectangle; ------------     justification à droite   -------------------------right_Justif		move.w	DisplayWidth(a6),d0		mulu	#9,d0		divu	#10,d0			; 10% du bord droit		add.w	G.Offset_JustifRL,d0		sub.w	lineWidth(a6),d0				bpl		RJ_1		moveq	#0,d0RJ_1				move.w	d0,StartX(a6)		move.w	d0,d3		bra		LookRectangle; ----------test si cela rentre dans une largeur d'écran - safe titleCenter_Justif		moveq	#0,d1		move.w	DisplayWidth(a6),d0			; largeur 		ext.l	d0		lsl.l	#3,d0		;*8		divu	#10,d0		; /10				sub.w	lineWidth(a6),d0		; ce qui reste		bpl.s	PasDeProbleme			; c'est bon cela rentre;problème: cela ne rentre pas dans le "safe title"		TST.W	G.Preference_KernCheck		bne.S	Kerningautomatique	; on kern automatiquement		; on desside de ne pas effectuer un kerningPasDeProbleme; on ne fait pas de kerning auto				move.w	DisplayWidth(a6),d0			; largeur 		sub.w	lineWidth(a6),d0		; ce qui reste		lsr.w	#1,d0		bpl.s	@pka1					move.w	#0,StartX(a6)		moveq	#0,d2		bra		LookRectangle		@pka1	move.w	d0,StartX(a6)		move.w	d0,d2		bra		LookRectangle		; ----------------Kerningautomatique		; cela ne rentre pas 		; on calcule de combien de pixel par caractère cela ne rentre pas; et on réduit l'interspace entre les caractères pour que cela rentre dans le «safe area»		neg.w	d0		move.w	d0,d1	; l'erreur		sub.w	d0,lineWidth(a6)		; on ajuste la longueur de la ligne pour le cache 		move.w	end_Char(a6),d2		sub.w	startChar(a6),d2	; nombre de caractères dans la ligne		subq.w	#1,d2	; nombre de char-1		ext.l	d0		divu	d2,d0					; espace manquant// caractère		sub.w	d0,intercharSpace(a6)						move.w	DisplayWidth(a6),d2		ext.l	D2		divu	#10,d2					; 10% du bord		move.w	d2,StartX(a6); -------------------- on regarde le rectangle du ST -------------------------; on update le rectangle  en fonction des dimension de la ligne; on regarde si cela est < au bord gauche du rectangle 		LookRectangle		move.l	TheRectPtr(a6),a0		move.w	d2,D3				; sauvegarde de la position gauche		cmp.w	left(a0),d2		bhi.s	PasInfBordGauche		move.w	d2,left(a0)		moveq	#0,d1		PasInfBordGauche		; on regarde si cela est > au bord droit du rectangle 				add.w	lineWidth(a6),d2		sub.w	d1,d2				; si interspace <0		cmp.w	right(a0),d2		blo.s	PassupBorddroit		move.w	d2,right(a0)PassupBorddroit						move.w	startY(a6),d0		lea		G.Display_Font,a1		add.w	max_descent(a1),d0		add.w	#10,d0				; 8 pixel en dessous		move.w	d0,bottom(A0)		; le bas du rectangle				sub.W	#4,top(a0)			; par mesure de précaution		; -----------   gestion du maskage      ------------------------		  		move.w	MasKType(a6),d1		case#.w	(d1,if),\		(0,PasOutlineBox),\		; pas de maskage		(1,boxing_mask),\		(2,line_Masking),\		(3,AllThe_Line_Masking)				bra		PasOutlineBox		; ------------------------------		; on effectue le dessin d'un rectangle de la largeur correspondant au st le plus long  		boxing_mask		; on regarde si nous sommes en centré		move.w	startX(a6),d0		; position de départ de la ligne en cours		move.w	Justification(a6),d1		cmp.w	#1,d1		beq.s	pas_CenterBM		; si left justification, on ne fait rien						move.w	left+Boxing_rectangle(a6),d0	; on regarde si l'on a déjà calculée rectangle		bne.s	pas_CenterBM			; oui déja calculé				tst.w	d1		bne.s	DoRightJustifForMask		; pour un alignement centré; on affine la position de départ du rectangle en fct de la largeur de la ligne en cour ; et de la largeur maximum du sous-titre				moveq	#0,d1		move.w	Max_DisplayWidth(a6),d1		; largeur maxi du sous-titre		sub.w	lineWidth(a6),d1			; largeur de la ligne en cour		lsr.l	#1,d1		; ÷2				sub.w	d1,d0				; position de départ du rectangle		add.w	startX(a6),d0		move.w	d0,left+Boxing_rectangle(a6)	; on stocke cette valeur		bra.s	pas_CenterBM;  Dans le cas de justification à droiteDoRightJustifForMask					moveq	#0,d1		move.w	Max_DisplayWidth(a6),d1		; largeur maxi du sous-titre		sub.w	lineWidth(a6),d1			; largeur de la ligne en cour;		asr.w 	#1,d1		; ÷2 signé		sub.w	d1,d0				; position de départ du rectangle		add.w	startX(a6),d0		move.w	d0,left+Boxing_rectangle(a6)	; on stocke cette valeur; ---		pas_CenterBM 		add.w	Xpos(a6),d0				; x offset sur le plan		move.w	d0,left+OutlineREct(a6)				add.w	Max_DisplayWidth(a6),d0		move.w	D0,right+OutlineREct(a6); on prend la valeur basse du dernier rectangle pour la valeur haute du nouveau; note: dans le premier cas cette valeur est fausse mais cela sera corrigé par la suite par le test; première ligne de texte				move.w	bottom+OutlineREct(a6),d1		move.w	d1,top+OutlineREct(a6)		; on effectue le calcul du pt bas		move.w	bottom(a0),bottom+OutlineREct(a6)		move.w	G.Display_interligne,d0		addq.w	#6,d0 		add.w	d0,bottom+OutlineREct(a6)		add.w	d0,bottom(a0); si le rectangle est nul en largeur on ne dessine pas la ligne courante		move.w	lineWidth(a6),d0		bne		DrawCache_1		move.w	#1,FlagLineNonDraw(a6)		bra		PasOutlineBox ; on ne dessine pas le rectangle		DrawCache_1	; on dessine le  rectangle 				move.w	#10,d0		add.w	G.Boxing_Size,d0				add.w	d0,right+OutlineREct(a6)	;largeur de la bordure		add.w	d0,right(a0)				;largeur de la bordure		sub.w	d0,left+OutlineREct(a6)		;largeur de la bordure		sub.w	d0,left(a0)					;largeur de la bordure; on regarde si nous sommes sur la première ligne; ou bien que la ligne suivante à été effacé		cmp.w	#1,Ligne_En_COur(a6)		beq.s	PremiereLigne_1				TST.W	FlagLineNonDraw(a6)	; ligne précédent effacée ?		beq.S	PasPremiereLigne_1	; non pas effacé		PremiereLigne_1			move.w	startY(a6),d0		sub.w	max_Ascent(a1),d0 		move.w	d0,top+OutlineREct(a6)				move.w	G.Display_interligne,d0		addq.w	#6,d0				cmp.w	#1,Ligne_En_COur(a6)		bne.s	NotSubTop_1		sub.w	d0,top(a0)		NotSubTop_1				ext.l	D0		divu	#4,d0		sub.w	d0,top+OutlineREct(a6)			PasPremiereLigne_1				moveq	#0,d0		add.w	G.Boxing_SizeV,d0		add.w	d0,bottom+OutlineREct(a6)	;hauteur, de la bordure		add.w	d0,bottom(a0)				;hauteur de la bordure		sub.w	d0,top+OutlineREct(a6)		;hauteur de la bordure		sub.w	d0,top(a0)					;hauteur de la bordure		pea		OutlineREct(a6)		move.l	G.RGB_OutlineBoxColor,-(sp)	; la couleur		move.l	ScreenBase(a6),-(sp)		; la base écran		move.l	Row_byte(a6),-(sp)			; le row byte		move.w	#32,-(sp)					; largeur sur 32 bits		import	Paint_Rect		  		jsr		Paint_Rect						clr.w	FlagLineNonDraw(a6)		bra		PasOutlineBox; ------------------------------		AllThe_Line_Masking								move.w	D0,left+OutlineREct(a6)				add.w	Max_DisplayWidth(a6),d0		move.w	D0,right+OutlineREct(a6)	; on prend la valeur basse du dernier rectangle pour la valeur haute du nouveau; note: dans le premier cas cette valeur est fausse mais cela sera corrigé par la suite par le test; première ligne de texte				move.w	bottom+OutlineREct(a6),d1		move.w	d1,top+OutlineREct(a6)		; on effectue le calcul du pt bas		move.w	bottom(a0),bottom+OutlineREct(a6)		move.w	G.Display_interligne,d0		addq.w	#6,d0 		add.w	d0,bottom+OutlineREct(a6)		add.w	d0,bottom(a0); si le rectangle est nul en largeur on ne dessine pas la ligne courante		move.w	lineWidth(a6),d0		bne		DrawCache_2		move.w	#1,FlagLineNonDraw(a6)		bra		PasOutlineBox ; on ne dessine pas le rectangle		DrawCache_2	; toute la largeur de la fenètre						move.w	DisplayWidth(a6),right(a0)				move.w	DisplayWidth(a6),right+OutlineREct(a6)		move.w	#0,left(a0)							move.w	#0,left+OutlineREct(a6)					; on regarde si nous sommes sur la première ligne; ou bien que la ligne suivante à été effacé		cmp.w	#1,Ligne_En_COur(a6)		beq.s	PremiereLigne_2		bra		PasPremiereLigne_2				TST.W	FlagLineNonDraw(a6)	; ligne précédent effacée ?		beq.S	PasPremiereLigne_2	; non pas effacé		PremiereLigne_2			move.w	startY(a6),d0		sub.w	max_Ascent(a1),d0 		move.w	d0,top+OutlineREct(a6)				move.w	G.Display_interligne,d0		addq.w	#6,d0		sub.w	d0,top(a0)		ext.l	D0		divu	#4,d0		sub.w	d0,top+OutlineREct(a6)			PasPremiereLigne_2				clr.w	FlagLineNonDraw(a6)		pea		OutlineREct(a6)		move.l	G.RGB_OutlineBoxColor,-(sp)	; la couleur		move.l	ScreenBase(a6),-(sp)		; la base écran		move.l	Row_byte(a6),-(sp)			; le row byte		move.w	#32,-(sp)					; largeur sur 32 bits		import	Paint_Rect		  		jsr		Paint_Rect						bra		PasOutlineBox		; ------------		; masquage ligne à ligne façons ARTEline_Masking		move.w	startX(a6),d0		; position de départ de la ligne en cours		move.w	D0,left+OutlineREct(a6)				add.w	lineWidth(a6),d0		move.w	D0,right+OutlineREct(a6); on prend la valeur basse du dernier rectangle pour la valeur haute du nouveau; note: dans le premier cas cette valeur est fausse mais cela sera corrigé par la suite par le test; première ligne de texte				move.w	bottom+OutlineREct(a6),d1		move.w	d1,top+OutlineREct(a6)		; on effectue le calcul du pt bas		move.w	bottom(a0),bottom+OutlineREct(a6)		move.w	G.Display_interligne,d0		addq.w	#6,d0 		add.w	d0,bottom+OutlineREct(a6)		add.w	d0,bottom(a0); si le rectangle est nul en largeur on ne dessine pas la ligne courante		move.w	lineWidth(a6),d0		bne		DrawCache_3		move.w	#1,FlagLineNonDraw(a6)		bra		PasOutlineBox ; on ne dessine pas le rectangle		DrawCache_3	; on dessine le(s)s rectangle(s)				move.w	#10,d0		add.w	G.Boxing_Size,d0				add.w	d0,right+OutlineREct(a6)		;largeur de la bordure		add.w	d0,right(a0)					;largeur de la bordure		sub.w	d0,left+OutlineREct(a6)		;largeur de la bordure		sub.w	d0,left(a0)					;largeur de la bordure		move.w	Xpos(a6),d0		add.w	d0,left+OutlineREct(a6)		add.w	d0,right+OutlineREct(a6)		; on regarde si nous sommes sur la première ligne; ou bien que la ligne suivante à été effacé		cmp.w	#1,Ligne_En_COur(a6)		beq.s	PremiereLigne_3				TST.W	FlagLineNonDraw(a6)	; ligne précédent effacée ?		beq.S	PasPremiereLigne_3	; non pas effacé		PremiereLigne_3			move.w	startY(a6),d0		sub.w	max_Ascent(a1),d0 		move.w	d0,top+OutlineREct(a6)				move.w	G.Display_interligne,d0		addq.w	#6,d0				cmp.w	#1,Ligne_En_COur(a6)		bne.s	NotSubTop		sub.w	d0,top(a0)		NotSubTop				ext.l	D0		divu	#4,d0		sub.w	d0,top+OutlineREct(a6)					moveq	#0,d0		add.w	G.Boxing_SizeV,d0		add.w	d0,bottom+OutlineREct(a6)	;hauteur, de la bordure		add.w	d0,bottom(a0)				;hauteur de la bordure		sub.w	d0,top+OutlineREct(a6)		;hauteur de la bordure		sub.w	d0,top(a0)					;hauteur de la bordure		pea		OutlineREct(a6)		move.l	G.RGB_OutlineBoxColor,-(sp)	; la couleur		move.l	ScreenBase(a6),-(sp)		; la base écran		move.l	Row_byte(a6),-(sp)			; le row byte		move.w	#32,-(sp)					; largeur sur 32 bits		import	Paint_Rect		  		jsr		Paint_Rect						bra		NOt_AddSmallRectangle; ----		PasPremiereLigne_3				moveq	#0,d0		add.w	G.Boxing_SizeV,d0		add.w	d0,bottom+OutlineREct(a6)	;hauteur, de la bordure		add.w	d0,bottom(a0)				;hauteur de la bordure		sub.w	d0,top+OutlineREct(a6)		;hauteur de la bordure		sub.w	d0,top(a0)					;hauteur de la bordure		pea		OutlineREct(a6)		move.l	G.RGB_OutlineBoxColor,-(sp)	; la couleur		move.l	ScreenBase(a6),-(sp)		; la base écran		move.l	Row_byte(a6),-(sp)			; le row byte		move.w	#32,-(sp)					; largeur sur 32 bits		import	Paint_Rect		  		jsr		Paint_Rect			; on regarde s'il faut ajouter des petits rectangle de part et d'autre de la ligne en cour		; la condition c'est que le rectangle précedent soit moins large que celui en cours	et; que la ligne précédente est été dessiné.				tst.w	FlagLineNonDraw(a6)		bne 	NOt_AddSmallRectangle				move.w	right+OutlineREct(a6),d0		sub.w	Left+OutlineREct(a6),d0		move.w	right+OutlineBox2(a6),d1		sub.w	Left+OutlineBox2(a6),d1		cmp.w	d0,d1		bhi		NOt_AddSmallRectangle; on dessine le rectangle de gauche						move.w	Left+OutlineBox2(a6),right+OutlineBox3(a6)				move.w	left+OutlineREct(a6),left+OutlineBox3(a6)				move.w	top+OutlineREct(a6),bottom+OutlineBox3(a6)							move.w	startY(a6),d0		sub.w	max_Ascent(a1),d0 		move.w	d0,top+OutlineBox3(a6)				move.w	G.Display_interligne,d0		addq.w	#6,d0		ext.l	D0		divu	#4,d0		sub.w	d0,top+OutlineBox3(a6)	; la hauteur du cache		moveq	#0,d0		add.w	G.Boxing_SizeV,d0		add.w	d0,bottom+OutlineBox3(a6)	;hauteur, de la bordure		sub.w	d0,top+OutlineBox3(a6)		;hauteur de la bordure		pea		OutlineBox3(a6)		move.l	G.RGB_OutlineBoxColor,-(sp)	; la couleur		move.l	ScreenBase(a6),-(sp)		; la base écran		move.l	Row_byte(a6),-(sp)			; le row byte		move.w	#32,-(sp)					; largeur sur 32 bits		import	Paint_Rect		  		jsr		Paint_Rect					; celui de droite		move.w	Right+OutlineRect(a6),right+OutlineBox3(a6)				move.w	right+OutlineBox2(a6),left+OutlineBox3(a6)						pea		OutlineBox3(a6)		move.l	G.RGB_OutlineBoxColor,-(sp)	; la couleur		move.l	ScreenBase(a6),-(sp)		; la base écran		move.l	Row_byte(a6),-(sp)			; le row byte		move.w	#32,-(sp)					; largeur sur 32 bits		import	Paint_Rect		  		jsr		Paint_Rect													NOt_AddSmallRectangle		clr.w	FlagLineNonDraw(a6); on sauvegarde les coordonnées du rectangle pour le prochain au cas où		move.l	OutlineREct(a6),OutlineBox2(a6)		move.l	4+OutlineREct(a6),4+OutlineBox2(a6)		; -------------- on dessine la ligne PasOutlineBox		clr.l	NextStyle(a6)		move.w	startChar(a6),d6			; caractère de début		and.l	#$ffff,d6; d7= end char				Draw_A_Line_loop				move.l	d6,d0		bsr		GiveChar_et_style		cmp.w	#-1,d0		beq		Fin_DU_texte			; on a trouvé la fin du texte				cmp.w	#$0d,d0				beq 	NewLine		cmp.w	#$ca,d0				beq.s	Drawspace		cmp.w	#$20,d0				beq.s	Drawspace		blo		finLoop_A_Line		; on ne s'occupe pas des caractères de contrôle; on a le char et le style du carctère			movem.l	d6-d7,-(sp)				; sauvegarde des pointeurs		clr.w	-(sp)					; pour le resultat		pea		G.Display_Font		move.w	d0,-(sp)		move.w	theStyle(a6),-(sp)				move.w	StartX(a6),d0		add.w	Xpos(a6),d0				; x offset sur le plan		move.w	d0,-(sp)				; x pos		move.w	StartY(a6),-(sp)		; y base line		move.l	ScreenBase(a6),-(sp)		move.l	Row_byte(a6),-(sp)		move.w	#32,-(sp)				; largeur sur 32 bits		import	FastDraw_A_Char		jsr		FastDraw_A_Char			; on dessine le caractère		move.w	(sp)+,d0				movem.l	(sp)+,d6-d7 			; récupération des pointeurs				cmp.w	#2,theStyle(a6)		bne		pasitalic;		subq.w	#2,d0			; ############################### pour italiquepasitalic				add.w	intercharSpace(a6),d0		add.w	d0,StartX(a6)					bra.s	finLoop_A_Line			; -------		; si c'est un espace on ne dessine pas, on incrémente juste les coordonnées en XDrawspace				lea		G.Display_Font,a0		move.w	spaceWidth(a0),d0			; largeur d'un espace		add.w	intercharSpace(a6),d0		; interspace		add.w	d0,StartX(a6); -----		finLoop_A_Line				addq.l	#1,d6		move.l	end_Char(a6),d7					cmp.l	d7,d6					; fin de la ligne ?		blo.s	Draw_A_Line_loop		; non on continue; on a fini de dessiner la ligne sur l'écran; on passe à la suivanteNewLine				add.w	#1,Ligne_En_Cour(a6)		sub.w	#1,NombreLigne(a6)		beq.s	Fin_DU_texte				; on a fait toute les lignes		lea		G.Display_Font,a0		move.w	interligne(a0),d0 		add.w	#6,d0					; interligne   		add.w	G.Display_interligne,d0		add.w	d0,startY(a6)				; ligne suivante (en Y)		bra		Loop_NextLine; ça y est on a fini de dessiner le sous-titreFin_DU_texte				bra.s	Exit; ------------------------------------------------------------------ExitErr		move.w	#-1,result(a6); on place la largeur par défaut du rectangle		move.l	TheRectPtr(a6),a0		move.w	#1023,right(a0)				 		move.w	#575,bottom(a0)				 		move.w	#0,top(a0)				 		move.w	#0,left(a0)				 		Exit	move.w	#$0505,-(sp)		import	Show_Cursor		jsr		Show_Cursor		movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0); -------------------------------------------------------------------;  sous-routine qui donne l'ascii et le style d'un caractère	GiveChar_et_style		; d0 = indice du caractère 0 ≈ Nmax		movem.l	d1-d2/a1-a2,-(sp)		move.l	Stptr(a6),a0		cmp.l	st_TexteLenth(a0),d0	; dans le st ?		blo.S	Char_Exist		move.w	#-1,d0					; caractère pas dans la liste		move.w	d0,theChar(a6)			movem.l	(sp)+,d1-d2/a1-a2		rts; ---------------------------------------		Char_Exist				move.l	a0,a1		move.l	#st_sizeOf,d1		adda.l	d1,a1				; pointeur du texte					move.l	d0,d1				; sauvegarde du n° de char			tst.l	st_StylePtr(a0)		; il y a -til des style dans ce sous-titre ?			bne.s	RechercheProchainStyle;non, pas de style => parramètre par défaut				clr.w	thestyle(a6)			; style normal 		move.w	#1,theJust(a6)			; centrée		move.w	#0,theFont(a6)			; 1 ère font de la liste		move.l	#-1,NextStyle(a6)		; pas de prochain style		bra.s	PasDeStyle RechercheProchainStyle		move.l	NextStyle(a6),d2		beq.s	RechercheCont			; il n'y en a pas il faut le rechercher		cmp.l	d2,d1					; char pos <inférieur au prochain style ?		blo.s	PasDeStyle				; on ne change pas; -------------------		; on détermine quel style appartient au caractèreRechercheCont		move.l	st_StylePtr(a0),a2		; pointeur du style		move.w	(a2)+,d2				; nombre de style		subq.w	#1,d2		move.l	#20,d0		sub.l	d0,a2		LoopStyle			move.l	#20,d0		add.l	d0,a2			;scrpRecSize (décimal 20) on est obligé de forcé l'ASM en Long mode		cmp.l	(a2),d1		blo.s	FoundNext		move.w	scrpFont(a2),theFont(a6)		moveq	#0,d0		move.b	scrpFace(a2),d0		move.w	d0,thestyle(a6); style suivant				dbra	d2,LoopStyle				move.w	#-1,NextStyle(a6)			; pour indiquer qu'il n'y a plus de style		bra.s	PasDeStyle		FoundNext		move.l	(a2),NextStyle(a6); ---------PasDeStyle; on récupère le caractère		moveq	#0,d0		move.b	(a1,d1.w),d0					; caractère (long)		move.w	d0,thechar(a6)			movem.l	(sp)+,d1-d2/a1-a2		rts; --------------------------------------------------------------------				DbgInfo.new		Draw_SousTitre			; this name will appear in the debugger		align 4			ENDP			* ================================================* PROCEDURE Paint_Rect(); * ================================================** 	Cette routine rempli un rectangle par une couleur ARGB (32 bits)**	entrée:	*TheRect		(ptr )		; le rectangle*			the color		(long)		; argbcolor*			*ScreenBase		(long)		; adresse base de l'écran de dessin	*			RowByte			(long)		; largeur en octets de l'écran*			bit detph		(word)		; 16 ou 32 bits*Paint_Rect	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult		ds.w	1ParamBegin	EQU	*			; start parameters after this pointTheRectangle	ds.l	1TheColor		ds.l	1ScreenBase		ds.l	1Row_byte		ds.l	1BitDepth		ds.w	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame				movem.l d1-d7/a1-a4,-(sp)		; mode 32 uniquement pour l'instants; on calcule le top du rectangle		Move.l	TheRectangle(a6),a4				move.l	Row_byte(a6),d0		mulu	top(a4),d0			; offset// screenbase		add.l	ScreenBase(a6),d0		move.l	d0,a0				; a0= top du rectangle				move.w	left(a4),d5			; left		ext.l	d5		asl.l	#2,d5				;1 pixel= 4 octets (32 bits) 				move.w	right(a4),d4		sub.w	left(a4),d4			; d4=largeur du rectangle				move.w	bottom(a4),d6		sub.w	top(a4),d6			; d6=hauteur du rectangle				move.l	TheColor(a6),d0		; la couleur				loop1	move.w	d4,d7		; left maxloop2	move.w	d7,d3		asl.l	#2,d3		; 		add.w	d5,d3		move.l	d0,(a0,d3.w)		dbra	d7,loop2		adda.l	Row_byte(a6),a0		dbra	d6,loop1Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.new		Paint_Rect			; this name will appear in the debugger		align 4			ENDP										* ================================================* PROCEDURE test_draw_A_ST(); * ================================================** Cette routine dessine un string  *test_draw_A_ST			PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256itemType	ds.w	1		; stockage du type de ItemitemHandle	ds.L	1		; stockage	du handle du itemitemRect	ds		RectStringLenth	ds.w	1		; longueur totale de la ligneA_width		ds.w	1		; largeur d'un A (pour connaitre la largeur d'un espace RGB_Color			ds.w	3rectangle	ds		RectCharW		ds.w	1faceW		ds.w	1Row_Bytes		ds.l	1		; rowbyte de la vidéo exploreurHeight			ds.w	1		; hauteur de la vidéo explorerwidth			ds.w	1		; largeur de la vidéo explorerBase_Adresse	ds.L	1		; base du plan mémoireLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame,\					ConversionNumeroSTPointeur		movem.l d1-d7/a1-a4,-(sp)				move.l   	G.Base_Adresse,Base_Adresse(a6)				move.l		G.Row_Bytes,Row_Bytes(a6);			move.w	#758,width(a6)			move.w	#576,height(a6); -------- on raz la V E ---------------------------------------------						move.l	Base_Adresse(a6),a0			move.w	#575,d7loop_1			move.l	Row_Bytes(a6),d6			lsr.l	#2,d6					;÷4  (long)loop_2					clr.l	(a0,d6.w*4)			dbra	d6,loop_2			add.l	Row_Bytes(a6),a0			; ligne suivante			dbra	d7,loop_1			; on affiche le sous-titre en cour;result		ds.w	1;ParamBegin	EQU	*			; start parameters after this point;StPtr		ds.l	1;Xpos		ds.w	1;Ypos		ds.w	1;ScreenBase	ds.l	1;Row_byte	ds.l	1;TheRectPtr	ds.l	1; on affiche le sous-titre en cour		pea	G.DisplayWindow		_SetPort						move.w	#$ffff,RGB_Color(a6)		move.w	#$ffff,2+RGB_Color(a6)		move.w	#$ffff,4+RGB_Color(a6)				pea		RGB_Color(a6)		_RGBForeColor		clr.w	-(sp)		move.w	G.General_SousTitreEncour,d0		and.l	#$ffff,d0		jsr		ConversionNumeroSTPointeur		move.l	a0,-(sp)		move.w	G.X_OFFSET,-(sp)		; X pos		move.w	G.Y_OFFSET,-(sp)		; YPOS		move.l	Base_Adresse(a6),-(sp)		move.l	Row_Bytes(a6),-(sp)		pea		rectangle(a6)					import	Draw_SousTitre		jsr		Draw_SousTitre					move.w	(sp)+,d0								pea	G.DisplayWindow		_SetPort						move.w	#$ffff,RGB_Color(a6)		; RGB_Color==0x0fff 		move.w	#$ffff,2+RGB_Color(a6)		move.w	#$ffff,4+RGB_Color(a6)				pea		RGB_Color(a6)		_RGBForeColor			 		pea		rectangle(a6) 		_FrameRect						Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		test_draw_A_ST				; this name will appear in the debugger		align 4			ENDP						* ================================================* PROCEDURE Hand_EraseRect(); * ================================================** Cette routine efface le rect dans le plan memoire * Hand_EraseRect	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointBase_Adresse	ds.l	1Row_Bytes		ds.l	1rectangleSoustitre		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		machine	MC68020				movem.l d0-d7/a1-a4,-(sp)		move.l	G.CurseurClearBuffer,-(sp)		_SetCCursor		move.l	rectangleSoustitre(a6),a4		; on regarde si la valeur est cohérente		move.w	top(a4),d0		bpl		NOT_infZeroTop		moveq	#0,d0		move.w	d0,top(a4)NOT_infZeroTop		move.w	right(a4),d0		cmp.w	left(a4),d0		blt.s	ErrorREct				move.w	bottom(a4),d0		cmp.w	top(a4),d0		blt.s	ErrorREct		bra.s	NOT_errorRect		ErrorREct				clr.l	(a4)		move.w	#575,bottom(a4)		move.w	#1023,right(a4)				NOT_errorRect		move.l	Row_Bytes(a6),d0		mulu	top(a4),d0		move.l	d0,a0			move.w	left(a4),d0		mulu	#4,d0					; si mode 32 bits		adda.l	d0,a0		adda.l	Base_Adresse(a6),a0		; point de départ				move.w	bottom(a4),d6		sub.w	top(a4),d6				; nombre de ligne à effacer 		addq.W	#2,d6loop1		move.w	right(a4),d7		sub.w	left(a4),d7		addq.W	#1,d7loop2		clr.l	(a0,d7.w*4)		dbra	d7,loop2		adda.l	Row_Bytes(a6),a0		dbra	d6,loop1			Exit	move.w	#$0505,-(sp)		import	Show_Cursor		jsr		Show_Cursor		movem.l	(sp)+,d0-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		Hand_EraseRect			; this name will appear in the debugger		align 4			ENDP					* ================================================* PROCEDURE  CLEARBUFFER(); * ================================================** Cette routine efface le rect dans le plan memoire * à l'aide des processeurs de la vidéo explorer*CLEAR_BUFFER		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkREctangle			ds.w	4spare				ds.l	1theChannel			ds.l	1theCaptureChannel	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize		machine	MC68020					movem.l d0-d7/a1-a2,-(sp)			move.l	G.CurseurClearBuffer,-(sp)			_SetCCursor			cmp.w	#$118,G.VE_BoardID		;  vista classic			beq.s	vista				cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq.s	vista			cmp.w	#$346,G.VE_BoardID		; nu vista+ ?			bne.s	VideoExplorer	vista				; Nu vista + ==> on effectue le raz à la main; on regarde s'il y a un rectangle cohérent pour le buffer d'affichage; si oui on n'efface que cette portion pour gagner du temps; note on utilise la fonction ecrite en C			import	C_ClrEcran			jsr		C_ClrEcran				bra		Exit					; -------------------------------------------						VideoExplorer									move.l		#0,rectangle(a6)			move.l  	#$04000400,4+rectangle(a6)		; taille maximum d'une VE                							MOVE.W    G.Ve_RefNum,D7                     							pea       theChannel(A6)                            			MOVEQ      #$00,D0         			MOVE.L     D0,-(A7)			EXT.L      D7                                      			MOVE.L     D7,-(A7)   			import 		VEGetChannel   			jsr     	VEGetChannel   			;short VEGetCaptureChannel(short theDriver, short theCaptureBox,short* theChannel);									MOVE.W     D0,D6      						PEA        theCaptureChannel(A6)                           			MOVEQ      #$00,D0 			MOVE.L     D0,-(A7)			EXT.L      D7        			MOVE.L     D7,-(A7) 			import      VEGetCaptureChannel  			JSR         VEGetCaptureChannel  									;short VEGetCaptureChannel(short theDriver, short theCaptureBox,short* theChannel);												MOVE.W     D0,D6                                   			lea			REctangle(A6),a0			MOVE.L     4+REctangle(A6),-(A7)                          			MOVE.L     REctangle(A6),-(A7)                            			MOVEQ      #$00,D0                                			MOVE.L     D0,-(A7)                               			EXT.L      D7                                     			MOVE.L     D7,-(A7)                               			import     VESetCaptureWindow    			JSR        VESetCaptureWindow    			; short VESetCaptureWindow(short theDriver, short theCaptureBox, Rect theRect);						MOVE.W     D0,D6                                  			MOVEQ      #$00,D0                                			MOVE.L     D0,-(A7)                               			MOVE.L     D0,-(A7)                              			EXT.L      D7                                      			MOVE.L     D7,-(A7)                              			import     VESetCaptureFormat    			JSR        VESetCaptureFormat    			;short VESetCaptureFormat(short theDriver, short theCaptureBox,short theCaptureFormat);								MOVE.W     D0,D6                                  			clr.L     -(A7)    				; the color			EXT.L      D7                              			MOVE.L     D7,-(A7)                               			import     VESetCaptureColor    			JSR        VESetCaptureColor 			;short VESetCaptureColor(short theDriver,unsigned long theColor)									MOVE.W     D0,D6                                			MOVEQ      #$10,D0                                			MOVE.L     D0,-(A7)       			MOVEQ      #$00,D1               			MOVE.L     D1,-(A7)			EXT.L      D7 			MOVE.L     D7,-(A7)  			import     VESetCaptureChannel			JSR        VESetCaptureChannel			;short VESetCaptureChannel(short theDriver, short theCaptureBox,short theChannel);									MOVE.W     D0,D6  									MOVEQ      #$01,D0 			MOVE.L     D0,-(A7) 			MOVEQ      #$02,D1 			MOVE.L     D1,-(A7)			MOVEQ      #$00,D0   			MOVE.L     D0,-(A7)  			MOVEQ      #$0F,D0 			MOVE.L     D0,-(A7)    			MOVEQ      #$00,D0                            			MOVE.L     D0,-(A7)  			EXT.L      D7                                 			MOVE.L     D7,-(A7)                       			import     VESetCaptureState      			JSR        VESetCaptureState      ; ------------------------------------------------------									MOVE.W  	D0,D6                     			MOVE.W    	theChannel(A6),D0           			EXT.L  		D0              			MOVE.L  	D0,-(A7) 			MOVEQ 		#$00,D0 			MOVE.L  	D0,-(A7) 			MOVE.W    G.Ve_RefNum,D7 			EXT.L    	D7                                  			MOVE.L   	D7,-(A7)                               			import    	VESetChannel			JSR     	VESetChannel			; short VESetChannel(short theDriver, short	thePriorityControl,short theChannel);								MOVE.W     D0,D6                                			MOVE.W     theCaptureChannel(A6),D0			EXT.L      D0    			MOVE.L     D0,-(A7) 			MOVEQ      #$00,D0 			 MOVE.L     D0,-(A7) 			EXT.L      D7 			MOVE.L     D7,-(A7) 			import     VESetCaptureChannel 			JSR        VESetCaptureChannel 				Exit	move.w	#$0505,-(sp)		import	Show_Cursor		jsr		Show_Cursor		movem.l	(sp)+,d0-d7/a1-a2		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		CLEAR_BUFFER			; this name will appear in the debugger		align 4			ENDP	             		* ================================================* PROCEDURE Not_Display_Buffer(); * ================================================** Cette routine efface le rect dans le plan memoire * Not_Display_Buffer	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkAreaBlock	ds.b	48DataArea	ds.b	48LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame			machine	MC68020							cmp.w	#$118,G.VE_BoardID			beq		Exit				; vista classic carte pas bonne pour nous			move.w	G.VE_BoardID,d0			cmp.w	#$346,d0		; nu vista ou vx			beq 	Nuvista			cmp.w	#$28C,d0		;vista+ ?			beq 	Nuvista; c'est une vidéo explorer	; on active les rectangle									move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a0			; base des registres de la Video Explorer						move.w		#$0,VX_Rectangle1YStart(a0)			move.w		#$0,VX_Rectangle1XStart(a0)			move.w		#0,VX_Rectangle1YEnd(a0)			move.w		#0,VX_Rectangle1XEnd(a0)			move.w		#$5,VX_Rectangle2YStart(a0)			move.w		#$0,VX_Rectangle2XStart(a0)			move.w		#1023,VX_Rectangle2YEnd(a0)			move.w		#1023,VX_Rectangle2XEnd(a0); on coupe le signal de key			move.l	G.Base_Adresse,d0			and.l	#$ff000000,d0			or.l	#$F00661,d0		; défault alpha channel			move.l	d0,a0			move.b	#$ff,(a0)			bra		Exit; --------------------------------------------------------------; code pour la nu vista+; --------------------------------------------------------------Nuvista					lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwWriteRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct			move.l    	a1,csParam(a0)       ; faut voir .....		; on ne modifie que le mixer			lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer						move.b		#0,(a2)			move.b		#0,1(a2)			move.b		#1,2(a2)			move.b		#1,3(a2)			move.b		#0,4(a2)			move.b		#1,5(a2)			move.b		#0,6(a2)			move.b		#0,7(a2)						move.b		#0,8(a2)			move.b		#0,9(a2)			move.b		#0,10(a2)			move.b		#0,11(a2)			move.b		#0,12(a2)			move.b		#0,13(a2)			move.b		#0,14(a2)			move.b		#0,15(a2)						move.b		#$0,16(a2)			move.b		#$0,17(a2)			move.b		#1,18(a2)			move.b		#1,19(a2)			; alpha key			move.b		#1,20(a2)			move.b		#0,21(a2)			move.b		#0,22(a2)			move.b		#0,23(a2)				; 0 pour pas incrust						move.b		#0,24(a2)			move.b		#0,25(a2)			move.b		#0,26(a2)			move.b		#0,27(a2)			move.b		#0,28(a2)			move.b		#0,29(a2)			move.b		#3,30(a2)			move.b		#0,31(a2)						clr.l		AnalogCtlPtr(a1)		; adresse de la structure analog			clr.l		VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec			clr.l		PhasePtr(a1)			; hphase = null			_Control				Exit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.new		Not_Display_Buffer			; this name will appear in the debugger				align 4			ENDP* ================================================* PROCEDURE Display_Buffer(); * ================================================** Cette routine efface le rect dans le plan memoire *  Display_Buffer	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkAreaBlock	ds.b	48DataArea	ds.b	48LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		machine	MC68020			cmp.w	#$118,G.VE_BoardID			beq		Exit				; vista classic carte pas bonne pour nous			cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq 	Nuvista			cmp.w	#$346,G.VE_BoardID		; nu vista+ ou vx			beq 	Nuvista; c'est une vidéo explorer			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a0			; base des registres de la Video Explorer						move.w		#$0,VX_Rectangle1YStart(a0)			move.w		#$0,VX_Rectangle1XStart(a0)			move.w		#1023,VX_Rectangle1YEnd(a0)			move.w		#1023,VX_Rectangle1XEnd(a0)			move.w		#$0,VX_Rectangle2YStart(a0)			move.w		#$0,VX_Rectangle2XStart(a0)			move.w		#0,VX_Rectangle2YEnd(a0)			move.w		#0,VX_Rectangle2XEnd(a0)			; on active le signal de key			move.l	G.Base_Adresse,d0			and.l	#$ff000000,d0			or.l	#$F00661,d0		; défault alpha channel			move.l	d0,a0			move.b	#$0,(a0)	; same channel			bra		Exit; ----------------------------------------------------------------; code pour la nu vista+; ----------------------------------------------------------------Nuvista				lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwWriteRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct			move.l    	a1,csParam(a0)       ; faut voir .....		; on ne modifie que le mixer			lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer						move.b		#0,(a2)			move.b		#0,1(a2)			move.b		#1,2(a2)			move.b		#1,3(a2)			move.b		#0,4(a2)			move.b		#1,5(a2)			move.b		#0,6(a2)			move.b		#0,7(a2)						move.b		#0,8(a2)			move.b		#0,9(a2)			move.b		#0,10(a2)			move.b		#0,11(a2)			move.b		#0,12(a2)			move.b		#0,13(a2)			move.b		#0,14(a2)			move.b		#0,15(a2)						move.b		#$0,16(a2)			move.b		#$0,17(a2)			move.b		#1,18(a2)			move.b		#1,19(a2)			; alpha key			move.b		#1,20(a2)			move.b		#0,21(a2)			move.b		#0,22(a2)			move.b		#1,23(a2)				; 1 pour incrust						move.b		#0,24(a2)			move.b		#0,25(a2)			move.b		#0,26(a2)			move.b		#0,27(a2)			move.b		#0,28(a2)			move.b		#0,29(a2)			move.b		#3,30(a2)			move.b		#0,31(a2)						clr.l		AnalogCtlPtr(a1)		; adresse de la structure analog			clr.l		VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec			clr.l		PhasePtr(a1)			; hphase = null			_Control			Exit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		Display_Buffer			; this name will appear in the debugger		align 4			ENDP	* ================================================* PROCEDURE VBLMainTask(); * ================================================** Routine VBL sous intérruption*VBLMainTask	PROC	EXPORT			WITH	SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame,\					Display_Buffer,Not_Display_Buffer		machine	MC68020				cmp.w	#$118,G.VE_BoardID		beq		Exit				; vista classic carte pas bonne pour nous		cmp.w	#$346,G.VE_BoardID		beq		CutEffect			; seulement cut pour nuvista+		cmp.w	#$28C,G.VE_BoardID		beq		CutEffect			; seulement cut pour nuvista+   		move.w	G.EffectMode,d0 		cmp.w	#1,d0 		beq		FonduEffect; c'est un cutCutEffect		move.w	G.DrawState,d1		and.w	#$8000,d1		beq 	exit				; si bit 15=0 on ne fait rien		move.w	G.DrawState,d1		tst.b	d1					; que faire ?		beq  	effacecarteCut			; on efface après le fondu			; on affiche la ram				move.l	G.Base_Adresse,d0		beq		Exit		cmp.w	#$346,G.VE_BoardID		;vista+ ?		beq.s	touchapasAmonIcf		cmp.w	#$118,G.VE_BoardID		;vista ?		beq.s	touchapasAmonIcf		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq.s	touchapasAmonIcf		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		move.w	#$40,VX_ICFScaleFactor(a0)		; on reset le icf de la valeur d'incrémentationtouchapasAmonIcf		bsr		Display_Buffer					; on active l'affichage		bra 	exiteffacecarteCut; on affiche la ram				move.l	G.Base_Adresse,d0		beq		Exit		cmp.w	#$346,G.VE_BoardID		;nuvista+ ?		beq.s	touchapasAmonIcf1		cmp.w	#$118,G.VE_BoardID		;nuvista ?		beq.s	touchapasAmonIcf1		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq.s	touchapasAmonIcf1		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		move.w	#$40,VX_ICFScaleFactor(a0)		; on reset le icf de la valeur d'incrémentationtouchapasAmonIcf1		bsr		NOt_Display_Buffer		bra 	exit; ------------------------------------------; c'est un fonduFonduEffect				tst.w	G.FadeTime		beq		CutEffect	; si durée=0 c'est un cut		move.w	G.DrawState,d1		and.w	#$4000,d1		bne		PourIncDEc			; faire incrémentation décrémentation icf factor ?;	non pas inc dec car premier appel ou rien à faire				move.w	G.DrawState,d1				and.w	#$8000,d1		bne		PremierPassageDanslaRoutine						bra		exit				; si bit 15=0 on ne fait rien; ---PourIncDEc; on regarde pour faire fondu ; est-ce une vidéo explorer ?		cmp.w	#$346,G.VE_BoardID		; nu vista+ ou vx 		beq 	Exit		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq 	Exit; on calcule l'adresse des registres		move.l	G.Base_Adresse,d0	; carte présente ?		beq		Exit		and.l	#$ff000000,d0				add.l	#registerSpaceStart,d0		move.l	d0,a0			; base des registres de la Video Explorer; Inc ou Dec		move.w	G.DrawState,d1		tst.b	d1		beq.s		doDisDown	; decdoDisUp ; inc		move.w	G.FadeFactor,d0		addq.w	#1,d0		cmp.w	G.FadeTime,d0		bls		doDisUp1		move.w	G.FadeTime,d0		move.w	d0,G.FadeFactor		bra 	ExitdoDisUp1		move.w	d0,G.FadeFactor		move.w	G.FadeFactor,d0		mulu	#$40,d0		divu	G.FadeTime,d0		move.w	d0,VX_ICFScaleFactor(a0)		bra 	exitpasFini; --------------doDisDown ; out		move.w	G.FadeFactor,d0		subq.w	#1,d0		cmp.w	#0,d0		bhi		doDisDown1		clr.w	G.FadeFactor		bsr		Not_Display_Buffer		;on désactive l'affichage du buffer		bra 	ExitdoDisDown1		move.w	d0,G.FadeFactor		move.w	G.FadeFactor,d0		mulu	#$40,d0		divu	G.FadeTime,d0		move.w	d0,VX_ICFScaleFactor(a0) 		bra		exitpasFini; ---------------------------PremierPassageDanslaRoutine		; on regarde si nu vista classic ?; si oui on ne fait rien		cmp.w	#$118,G.VE_BoardID		beq		Exit		cmp.w	#$346,G.VE_BoardID		beq		Exit		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq 	Exit		move.w	G.DrawState,d1		tst.b	d1					; que faire ?		beq.s	DissolveOut			; on commence par le début		move.l	G.Base_Adresse,d0		beq		Exit		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		; on commence par la valeur 1		move.w	#1,G.FadeFactor		move.w	#64,d0		divu	G.FadeTime,d0		move.w	d0,VX_ICFScaleFactor(a0)		bsr		Display_Buffer					; on active l'affichage		bra		exitpasFini						; ; en fait on ne fait rien , mais on place le icf au maximumDissolveOut		move.w	G.FadeTime,d0		move.w	d0,G.FadeFactor		move.l	G.Base_Adresse,d0		beq		Exit		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		move.w	#$40,VX_ICFScaleFactor(a0)		; on démarre de pleine ouverture		bra		exitpasFini; ----------------------------------------; on affiche la ram; au prochain appel de la VRAM on incrémente le icf factor; carte présente ?; on calcule l'adresse des registres		move.l	G.Base_Adresse,d0		beq		Exit		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0						; base des registres de la Video Explorer		clr.w	VX_ICFScaleFactor(a0)		; on démarre de zéro		bsr		Display_Buffer		bra.s	exitpasFini; ---------------------------------------Exit; on à fini le travail; on sort de la routine, on raz le bit 15			move.w	G.DrawState,d0		and.w	#$0f,d0		move.w	d0,G.DrawState		rts; on dit que l'on doit faire le fonduexitpasFini		move.w	G.DrawState,d1		or.w	#$C000,d1		move.w	d1,G.DrawState		rts						DbgInfo.new		VBLMainTask			; this name will appear in the debugger		align 4			ENDP					* ================================================* PROCEDURE TransfertOffscreen_Vram(); * ================================================** Cette routine recopie le contenu du buffer offscreen dans la vram*  TransfertOffscreen_Vram	PROC	EXPORT			WITH	SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame,\					Display_Buffer,Not_Display_Buffer		machine	MC68020				move.l	G.CurseurTransfert,-(sp)		_SetCCursor		lea		G.OffscreenRenderedRect,a2				move.l	G.Row_Bytes,d0			;		mulu	top(a2),d0				; offset // au début de la ram		move.l	G.OffscreenDisplayBase,a0	;ram du buffer offscreen (source)		add.l	d0,a0				move.l	G.Base_Adresse,a1		;ram de la VRAM (Destination)			add.l	d0,a1 		; on vérifie le rectangle		move.w	right(a2),d1				cmp.w	left(a2),d1			 		bls.s	Exit 				; <0 erreur !				move.w	bottom(a2),d1		; point bas du dessin		sub.w	top(a2),d1			; point haut du dessin		blt.s	Exit 				; erreur !				addq.w	#2,d1				; on ne tient pas compte des position horizontale 		move.l	G.Row_Bytes,d0			; taille du transfert nb on ne tient pas compte de l'horizontal		mulu	d1,d0				_BlockMoveExit	move.w	#$0505,-(sp)		import	Show_Cursor		jsr		Show_Cursor		rts				DbgInfo.new		TransfertOffscreen_Vram			; this name will appear in the debugger		align 4			ENDP	* ====================================* PROCEDURE 	ConfigurationCarteAffichage()* ====================================**   Cette procédure ouvre un dialog pour déterminer une zone d'action*  	dans laquelle on effectue un offset sur les times codes**ConfigurationCarteAffichage 		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkWindowPtr	DS.L	1			; local Window pointer variableWichControl	DS.L	1			; control en cour de traitementTheDialogSel ds.l	1			; le dialog en questionTheItemHit	ds.w	1			; le item frappéTheItemHitalert	ds.w	1			; le item frappéTheDialogPtr	DS.l	1		; le pointeur local du dialogItemchoisi		DS.W	1		; Item choisi par l'utilisateuritemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectPictHandle		ds.l	1		; picture du dessinsaveVE_Mode		ds.w	1		;sauvegarde du modeDialogStorage			ds	dWindLensaveResourceRef			ds.w	1PrefFileId				ds.w	1Buffer					ds.b	256saveeffectmode			ds.w		1savevalue				ds.w		1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD,PREF_AFF_REC		; cover our local stack frame		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(sp)		clr.l	-(sp)		move.w	#174,-(sp)	; id number		pea		DialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog  ;		; on trace le contour du bouton rechercher				pea		DialogStorage(a6)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		DialogStorage(a6)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect					pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect			pea		DialogStorage(a6)		move.w	#6,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem					move.w	#1,-(sp)		move.w	#1,-(sp)		_PenSize				pea		itemRect(a6)		_FrameRect		move.w	G.VE_Mode,saveVE_Mode(a6)		bsr	ConfigRoutine		move.w	G.EffectMode,saveeffectmode(a6)		move.w	G.FadeTime,savevalue(a6)		bsr configuretransition		; on place le facteur de transition		moveq	#0,d0		move.w	G.FadeTime,d0		divu	#2,d0		clr.w	-(sp)		lea		buffer(a6),a0		_Pack7		pea		DialogStorage(a6)		move.w	#15,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			move.l		ItemHandle(a6),-(sp)		pea			buffer(a6)		_SetItext*******************Rechercher_Oncontinu:				clr.l	-(sp)		pea		Itemchoisi(a6)		_ModalDialog		move.w	Itemchoisi(A6),d0					case#.w	(d0,IF), \		(1,ok),\		(2,Annuler),\		(3,upstreamkeyer ),\			(4,downstreamkeyer),\		(8,cut),\		(9,dissolve),\		(16,TimeUp),\		(17,TimeDown)		bra		Rechercher_Oncontinudownstreamkeyer		move.w	#1,G.VE_Mode		bsr	ConfigRoutine		bra		Rechercher_Oncontinuupstreamkeyer		move.w	#0,	G.VE_Mode		bsr	ConfigRoutine		bra		Rechercher_Oncontinucut		move.w	#0,G.EffectMode		bsr configuretransition		bra		Rechercher_Oncontinudissolve		move.w	#1,G.EffectMode		bsr 	configuretransition		bra		Rechercher_OncontinuTimeUp		clr.l	-(sp)		pea		DialogStorage(a6)		move.w	#16,-(sp)		move.w	#15,-(sp)		move.l	#2,-(sp)		move.l	#37,-(sp)		move.l	#1,-(sp)		import	 C_IncDecValue		jsr		 C_IncDecValue		move.l	(sp)+,d0		bra		Rechercher_OncontinuTimeDown		pea		DialogStorage(a6)		move.w	#17,-(sp)		move.w	#15,-(sp)		move.l	#2,-(sp)		move.l	#37,-(sp)		move.l	#-1,-(sp)		import	 C_IncDecValue		jsr		 C_IncDecValue		move.l	(sp)+,d0		bra		Rechercher_Oncontinu; -------------------------------------ok		; on stocke le mode dans le fichier préférence		pea		DialogStorage(a6)		move.w	#15,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		buffer(a6)		_GetItext				lea		buffer(a6),a0		move.w	#1,-(sp)		_pack7		mulu	#2,d0		move.w	d0,G.FadeTime		import	PutPrefAffInGeneralPref		jsr		PutPrefAffInGeneralPref		bra.s	Exit		; ---------------		Annuler				move.w	saveVE_Mode(a6),G.VE_Mode		bsr	ConfigRoutine		move.w	saveeffectmode(a6),G.EffectMode		move.w	savevalue(a6),G.FadeTimeExit		pea		DialogStorage(a6)		_CloseDialog			movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ConfigurationCarteAffichage		; this name will appear in the debugger		align 4ConfigRoutine				; on affecte l'etat en cour du mode d'affichage				tst.w	G.VE_Mode		beq 	Do_UpstreamKeyer		; mode downstream keyer				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				pea		DialogStorage(a6)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue		; on affiche le pict		pea		DialogStorage(a6)		move.w	#7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	#133,d7		clr.l	-(sp)		move.w	d7,-(sp)		_GetPicture		move.l	(sp)+,pictHandle(a6)		; picture handle; on affiche le "picture"		move.l	pictHandle(a6),-(sp)		pea		itemRect(a6)		_drawPicture				move.l	pictHandle(a6),-(sp)		_ReleaseResource						import		ConfigureVX_DownStreamKeyer		jsr			ConfigureVX_DownStreamKeyer						rts; ---------------------     mode upstream keyerDo_UpstreamKeyer			; mode downstream keyer				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue				pea		DialogStorage(a6)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				; on affiche le pict		pea		DialogStorage(a6)		move.w	#7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	#132,d7		clr.l	-(sp)		move.w	d7,-(sp)		_GetPicture		move.l	(sp)+,pictHandle(a6)		; picture handle; on affiche le "picture"		move.l	pictHandle(a6),-(sp)		pea		itemRect(a6)		_drawPicture				move.l	pictHandle(a6),-(sp)		_ReleaseResource						import		ConfigureVX_UpStreamKeyer		jsr			ConfigureVX_UpStreamKeyer		rts		; ---------------------------				configuretransition; on configure le transition mode		pea		DialogStorage(a6)		move.w	#8,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem					move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue		move.w	G.EffectMode,d0		bne	@azert		move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue@azert		pea		DialogStorage(a6)		move.w	#9,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			move.l	ItemHandle(a6),-(sp)		move.w	G.EffectMode,-(sp)		_SetCtlValue		rts		ENDP* ================================================* PROCEDURE ConfigureVX_UpStreamKeyer;* ================================================* configure la vidéo exploreur dans le mode Upstram keyerConfigureVX_UpStreamKeyer	PROC		EXPORT		StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAreaBlock			ds.l	80DataArea			ds.l	80LocalSize			EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,WaitTicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,C_DoFileOpen,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO,VtrTimedTask,\			AdjustMenus	; linked in with Interface.o		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,\				VDInterruptMode,MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec		WITH	HSLColor,VDChannelColorState,VDControlState,\				VDLineControl,VDRectangleState,VDAlphaDisplaySource																		LINK	A6,#LocalSize		; allocate our local stack frame					; on configure le mode des rectangles 1 et 2			cmp.w	#$118,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$346,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq 	Exit 			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a4			; base des registres de la Video Explorer						add.l	#$300,d0			move.l	d0,a0						move.l	#$80/4,d0	; on erase 128 octetsClearVXMemory_loop			clr.l	(a0,d0.W*4)			dbra 	d0,ClearVXMemory_loop; on position les valeurs de configuration								move.b	#$40,VX_PixelControlMode(a4)			; 			move.b	#2,VX_Pixel0MultiplierInputSource1(a4)			move.b	#2,VX_Pixel1MultiplierInputSource1(a4)			move.b	#2,VX_Pixel0MultiplierInputSource2(a4)			move.b	#2,VX_Pixel1MultiplierInputSource2(a4)			move.b	#2,VX_Pixel0MultiplierInputSource3(a4)			move.b	#2,VX_Pixel1MultiplierInputSource3(a4)			move.w	#$0040,VX_ICFScaleFactor(a4)						move.w	#$0204,VX_DefaultDisplaySource(A4)			move.l	#$00000000,VX_DisplayOutputColor1(A4)			move.l	#$00000000,VX_DisplayOutputColor2(A4)			move.b	#$09,VX_MultiplierMode(A4)			move.b	#$0f,VX_MultiplierBWNoiseGenerator(a4)			move.w	#$0080,VX_BlendRatioTotal(a4)			move.w	#$0008,$330(A4)						move.w		#$0,VX_Rectangle1YStart(a4)			move.w		#$0,VX_Rectangle1XStart(a4)			move.w		#0,VX_Rectangle1YEnd(a4)			move.w		#0,VX_Rectangle1XEnd(a4)			move.b		#6,VX_Rectangle1DisplaySource(a4)		; source 6 (blender?)			move.b		#1,VX_Rectangle1PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle1IOControl(a4)			; configuration rectangle 2			move.w		#0,VX_Rectangle2YStart(a4)			move.w		#0,VX_Rectangle2XStart(a4)			move.w		#1023,VX_Rectangle2YEnd(a4)			move.w		#1023,VX_Rectangle2XEnd(a4)			move.b		#6,VX_Rectangle2DisplaySource(a4)		; source 0 (default?)			move.b		#1,VX_Rectangle2PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle2IOControl(a4)			bra			Exit;------------------------------------------------------------------; vieux code pour configuration vx			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a4			; base des registres de la Video Explorer; paramètre par défaut						move.w	#$0300,VX_DefaultDisplaySource(A4)	; alpha off			move.l	#$00000000,VX_DisplayOutputColor1(A4)			move.l	#$00000000,VX_DisplayOutputColor2(A4)			move.b	#$09,VX_MultiplierMode(A4)			move.b	#$0f,VX_MultiplierBWNoiseGenerator(a4)			move.w	#$0080,VX_BlendRatioTotal(a4)			move.w	#$0008,$330(A4)						move.w		#$0,VX_Rectangle1YStart(a4)			move.w		#$0,VX_Rectangle1XStart(a4)			move.w		#1023,VX_Rectangle1YEnd(a4)			move.w		#1023,VX_Rectangle1XEnd(a4)			move.b		#2,VX_Rectangle1DisplaySource(a4)		; source 2 video bus 2			move.b		#1,VX_Rectangle1PriorityLevel(a4)		;priority 1			move.b		#0,VX_Rectangle1IOControl(a4)			; configuration rectangle 2			move.w		#0,VX_Rectangle2YStart(a4)			move.w		#0,VX_Rectangle2XStart(a4)			move.w		#1023,VX_Rectangle2YEnd(a4)			move.w		#1023,VX_Rectangle2XEnd(a4)			move.b		#3,VX_Rectangle2DisplaySource(a4)		; source 3 default color 0			move.b		#1,VX_Rectangle2PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle2IOControl(a4)			Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.new		ConfigureVX_UpStreamKeyer		endP				* ================================================* PROCEDURE ConfigureVX_DownStreamKeyer;* ================================================* configure la vidéo exploreur dans le mode Downstream keyerConfigureVX_DownStreamKeyer	PROC	EXPORT			StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAreaBlock			ds.l	80DataArea			ds.l	80Data_Aray			ds.l	16			; pour le valeurs du multiplierHatcheck			ds.l	1			; le hatcheck pour le blend modeLocalSize			EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,WaitTicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,DoFileOpen,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO,VtrTimedTask,\			AdjustMenus	; linked in with Interface.o		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,\				VDInterruptMode,MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec		WITH	HSLColor,VDChannelColorState,VDControlState,\				VDLineControl,VDRectangleState,VDAlphaDisplaySource																		LINK	A6,#LocalSize		; allocate our local stack frame																			cmp.w	#$118,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$346,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq 	Exit			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a4			; base des registres de la Video Explorer						add.l	#$300,d0			move.l	d0,a0						move.l	#$80/4,d0	; on erase 128 octetsClearVXMemory_loop			clr.l	(a0,d0.W*4)			dbra 	d0,ClearVXMemory_loop; on position les valeurs de configuration								move.b	#$40,VX_PixelControlMode(a4)			; 			move.b	#02,VX_Pixel0MultiplierInputSource1(a4)			move.b	#02,VX_Pixel1MultiplierInputSource1(a4)			move.b	#00,VX_Pixel0MultiplierInputSource2(a4)			move.b	#00,VX_Pixel1MultiplierInputSource2(a4)			move.b	#00,VX_Pixel0MultiplierInputSource3(a4)			move.b	#00,VX_Pixel1MultiplierInputSource3(a4)			move.w	#$0040,VX_ICFScaleFactor(a4)						move.w	#$0204,VX_DefaultDisplaySource(A4)			move.l	#$00000000,VX_DisplayOutputColor1(A4)			move.l	#$00000000,VX_DisplayOutputColor2(A4)			move.b	#$09,VX_MultiplierMode(A4)			move.b	#$0f,VX_MultiplierBWNoiseGenerator(a4)			move.w	#$0080,VX_BlendRatioTotal(a4)			move.w	#$0008,$330(A4)						move.w		#$0,VX_Rectangle1YStart(a4)			move.w		#$0,VX_Rectangle1XStart(a4)			move.w		#0,VX_Rectangle1YEnd(a4)			move.w		#0,VX_Rectangle1XEnd(a4)			move.b		#6,VX_Rectangle1DisplaySource(a4)		; source 6 (blender?)			move.b		#1,VX_Rectangle1PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle1IOControl(a4)			; configuration rectangle 2			move.w		#0,VX_Rectangle2YStart(a4)			move.w		#0,VX_Rectangle2XStart(a4)			move.w		#1023,VX_Rectangle2YEnd(a4)			move.w		#1023,VX_Rectangle2XEnd(a4)			move.b		#0,VX_Rectangle2DisplaySource(a4)		; source 0 (default?)			move.b		#1,VX_Rectangle2PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle2IOControl(a4)					Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller		; on configure le multiplier pour faire du alpha blend			; on passe en mode alpha blend			clr.l	-(sp)			MOVE.W   G.Ve_RefNum,-(sp)			move.w	#$0,-(sp)			move.w	#videoBus2Channel,-(sp)	; channel 1			move.w	#inputModuleChannel,-(sp)	; channel 2			move.w	#inputModuleChannel,-(sp)	; channel 3			move.l	#$00010000,-(sp)			; blend total=1			move.l	#$00000000,-(sp)			; icf3 =0			import	AlphaBlendSetup			jsr		AlphaBlendSetup			move.l	(sp)+,G.VE_HATCHECK						clr.l	-(sp)			move.l	G.VE_HATCHECK,-(sp)			move.w	#-1,-(sp)				; blend indéfini dans le temps			import	AlphaBlendRun			jsr		AlphaBlendRun			move.l	(sp)+,d0						DbgInfo.new		ConfigureVX_DownStreamKeyer		endP						* ================================================* PROCEDURE ConfigureNuVista+;* ================================================* configure la carte Nu vista+ pour l'incrustation downstream keyerConfigureNuVistaplus	PROC	EXPORT			StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAreaBlock			ds.l	80DataArea			ds.l	80LocalSize			EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,WaitTicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,DoFileOpen,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO,VtrTimedTask,\			AdjustMenus	; linked in with Interface.o		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,\				VDInterruptMode,MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec		WITH	HSLColor,VDChannelColorState,VDControlState,\				VDLineControl,VDRectangleState,VDAlphaDisplaySource																		LINK	A6,#LocalSize		; allocate our local stack frame					; on passe en  mode incrustation (alpha blend); lecture du hardware de la nu vista +						lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwReadRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct						move.l    	a1,csParam(a0)       ; faut voir .....					lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer;			lea			G.NuvistaAnalog,a2			move.l		#0,AnalogCtlPtr(a1)		; adresse de la structure analog			;			lea			G.nuvistaCltReg,a2			move.l		#0,VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec						clr.l		PhasePtr(a1)			; hphase = null			_Control			; passage en mode  alpha blendzobuy			lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwWriteRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct			move.l    	a1,csParam(a0)       ; faut voir .....		; on ne modifie que le mixer			lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer			move.b		#0,(a2)			move.b		#0,1(a2)			move.b		#1,2(a2)			move.b		#1,3(a2)			move.b		#0,4(a2)			move.b		#1,5(a2)			move.b		#0,6(a2)			move.b		#0,7(a2)			move.b		#0,8(a2)						move.b		#0,9(a2)			move.b		#0,10(a2)			move.b		#0,11(a2)			move.b		#0,12(a2)						move.b		#0,13(a2)			move.b		#0,14(a2)			move.b		#0,15(a2)						move.b		#$0,16(a2)			move.b		#$0,17(a2)			move.b		#1,18(a2)			move.b		#1,19(a2)			; alpha key						move.b		#1,20(a2)			move.b		#0,21(a2)			move.b		#0,22(a2)			move.b		#1,23(a2)			move.b		#0,24(a2)			move.b		#0,25(a2)						move.b		#0,26(a2)			move.b		#0,27(a2)			move.b		#0,28(a2)			move.b		#0,29(a2)						move.b		#3,30(a2)			move.b		#0,31(a2)						clr.l		AnalogCtlPtr(a1)		; adresse de la structure analog			clr.l		VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec			clr.l		PhasePtr(a1)			; hphase = null			_Control						Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.new		ConfigureNuVista+		endP		* ================================================* PROCEDURE Affichage_soustitre;* ================================================Affichage_soustitre	PROC	Export		; any source file can use this routineStackFrame			RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start listing parameters hereParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkTheEvent 			DS	EventRecord 		; local copy of the event recordMouseMvdRgn			DS.L	1			; local region for MouseMoved eventsMousePos			DS.L	1			; local point for mouse positionRectfenetre			DS 	rect			; de la fenètreMouseLoc			ds.l	1			; point de la sourisbuffer				ds.b	256itemType			ds.w	1			; stockage du type de ItemitemHandle			ds.L	1			; stockage	du handle du itemitemRect			ds		Rect		; rectangleVisRect				ds	RectIconHandle			ds.l	1TEHandle			ds.l	1texteStyle			ds.b	256		; style pour texte tesaved0				ds.l	1		; sauvegarde de la valeur de d0 dans le recherche st courantChgFlag				ds.w	1rgb					ds.w	6rectangle_Soustitre		ds	Rectrectangle_Soustitre2	ds	Rectrgb2				ds.w	6rectangle			ds		RectsavedTC				ds.l	1mustbeep			ds.w	1Buff2				ds.l	8oldPseudoTC			ds.l	1oldport				ds.l	1oldforeColor		ds.w	3oldbackcolor		ds.w	3whitec				ds.w	3blackc				ds.w	3LastTicks				ds.l	1DernierTCTraiteParAffST	ds.l	1NombreDepassage			ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	AdjustCursor,GetGlobalMouse,DoEvent,TransfertMemoireSaisie,CalculDuree,\				TransfertSaisieMemoire		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord		; cover our local stack frame		clr.w	mustbeep(a6); pas de a6 link car on utilise le stack frame du main loop				; cela nous permet de garder des valeurs entre chaque appels; une sorte de globals variables			IF demo=0 THEN 		TST.W	G.FindFirstKey_error		; TEST PROTECTION LOGICIEL ;		BNE		Exit_AFF; --------		; on récupère le pointeur du sous-titre en cour		ENDIFDoTestDisplayST		move.l	G.General_TCCourant,d0		and.l	#$3f7f7f3f,d0		move.l	d0,savedTC(a6)	; on sauvegarde cette valeur de tc		import	ConversionTimeCodePointeur		jsr		ConversionTimeCodePointeur		move.l	a0,G.General_SousTitreCourantPtr				cmpa.l	#00000000,a0			beq		Exit_AFF			; pas de st en cours on ne fait rien		move.l	St_AbsNumST(a0),d0		move.w	d0,G.General_SousTitrecourant		move.l	d0,saved0(a6)				move.l	savedTC(a6),d0	; le tc courant		move.l	G.General_SousTitreCourantPtr,a0		import	TestSiDansST		jsr		TestSiDansST		move.l	d0,d7		; sauvegarde du resultat				cmp.l	#-1,d0			beq		Exit_AFF			; pas de st en cours on ne fait rien; ### est ce qu'il ne faudrait pas désafficher l'écran ?		move.w	G.TravailAFaire_Affichage,d0		cmp.w	#2,d0		beq		AfficheParInterruption				cmp.w	#4,d0		beq		EffacerParInterruption		; on regarde si nous sommes dans le sous-titre				tst.l	d7		beq 	DoDisplay		; -------------------------------------------------------------------------------; non nous ne sommes pas dans le sous-titreDoErase			move.w	G.DrawState,d0		; déja effacé ?				tst.b	d0					; .b ≠0 si dessiné		bne.s 	OnEfface	;on desactive l'affichage de la vram; il n'y a pas de sous-titre actuellement affiché à l'écran; on regarde si tout est près pour le prochain sous-titre		cmp.l	#100,d7		; au dessus du tc courant ?		bne.s	pasSupCourant	; non en dessous ; oui au dessus, on passe au suivant		move.l	G.General_SousTitreCourantPtr,a0		move.l	st_NextST(a0),d0		beq 	Exit_AFF 				; pas de sous-titre à la suite		move.l	d0,a0		bra.s	faireComparaison; on est en dessouspasSupCourant 		move.l	G.General_SousTitreCourantPtr,a0faireComparaison 		move.l	G.Sous_titre_dessined,a1 		cmpa.l	a0,a1		beq		Exit_AFF ; oui		; maintenant on regarde si l'on a déjà traité ce timecode courant; car si c'est le cas on ne fait rien car il arrive que nous partions dans une boucle folle,; ce qui est très désagréable pour l'utilisateur !		move.l	savedTC(a6),d0	; le tc courant		cmp.l	DernierTCTraiteParAffST(a6),d0 		beq		MemeTimeCode		; c'est le meme		move.l	d0,DernierTCTraiteParAffST(a6)			move.w	#2,NombreDepassage(a6)		; 2 essais		bra		DessineleprochainSoustitre 	; on le dessineMemeTimeCode	; c'est le  même time code		move.w	NombreDepassage(a6),d0				beq		Exit_AFF				; fini on n'a plus le droit		sub.w	#1,d0		move.w	d0,NombreDepassage(a6)		cmp.w	#0,d0		bhi		DessineleprochainSoustitre	; on dessine		clr.w	NombreDepassage(a6)			; c'est fini on ne fera plus rien la prochaine fois		bra		DessineleprochainSoustitre	; non on dessine le prochain		; ---; il faut effacer le sous-titre qui est actuellement à l'écranOnEfface				move.w	#$8000,ChgFlag(a6)	; on indique que l'on sort d'un ST 		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq		PasOnEfface_1		tst.l	RenderColor_handle(a0)		beq		PasOnEfface_1 		tst.l	G.Base_Adresse		; y a t-il une carte d'affichage ? 		bne.s	PasOnEfface_2PasOnEfface_1	 		move.w	#$0000,G.DrawState		; on raz le DrawState 		bra 	EndOfClearDisplay	  ; on désactive l'affichage de la VRAM; le travail est effectué par la VBL TASKPasOnEfface_2		move.w	#$8000,G.DrawStateOnEfface_1@zerty	move.w	G.DrawState,d0		and.w	#$ff00,d0		bne.s	@zerty; on efface la vram  		move.w	#0,G.TravailAFaire_Affichage 	; on attend le prochain  dessiner prochain sous-titre		import	Clear_Buffer		jsr		Clear_Buffer; on dessine le prochain sous-titreDraw_nextSubTitle			move.l	G.Sous_titreInOffscreen,d0			; est ce le bon sous-titre ? 		bne.s	DNST_1		move.w	#1,mustbeep(a6) 		bra.s	DessineleprochainSoustitre; ---------				; c'est le bon pointeur	; on recopie le offscreen dans la VRAMDNST_1 		import	TransfertOffscreen_Vram 		jsr		TransfertOffscreen_Vram		; on indique que le prochain st est dans le buffer d'écran	 		lea.l	G.OffscreenRenderedRect,a0		lea.l	G.ScreenRenderedRect,a1 		move.l	4(a0),4(a1) 		move.l	(a0),(a1)		move.l	G.Sous_titreInOffscreen,a0		move.l	a0,G.Sous_titre_dessined			move.l	G.Sous_titre_dessined,a0		move.l	ST_TimecodeIn(a0),d0		and.l	#$3f7f7f3f,d0		move.l	#1,D1		import	soustractionTimeCode		jsr		soustractionTimeCode		move.l	d0,G.TcInaAttendre						move.l	G.Sous_titre_dessined,a0		move.l	st_TimeCodeOut(a0),d0		and.l	#$3f7f7f3f,d0		moveq	#1,d1		jsr		soustractionTimeCode		move.l	d0,G.TcOutaAttendre					  		move.w	#1,G.TravailAFaire_Affichage 	; on attend le prochain  dessiner prochain sous-titre; on positionne les autres indicateur 		clr.w	G.OffscreenRendered	 		move.w	#1,G.ScreenRendered		bra		Exit_AFF; ----------------; il faut dessiner le prochain st directement dans la vram DessineleprochainSoustitre					tst.l	G.Base_Adresse		; y a t-il une carte d'affichage ? 		beq 	Exit_AFF	; non il n'y en n'a pas									import	Clear_Buffer					jsr		Clear_Buffer				DessineleprochainSoustitre_1			clr.l	G.Sous_titreInOffscreen		; on l'inibhe  		move.l	G.General_SousTitreCourantPtr,a4			cmpa.l	G.General_PremierSTPtr,a4		blo		EndOfClearDisplay		cmpa.l	G.General_DernierSTPtr,a4		bhi		EndOfClearDisplay					; on regarde si le pointeur que nous avons correspond bien au prochain sous-titre		move.l	a4,a0		move.l	savedTC(a6),d0			import	TestSiDansST		jsr		TestSiDansST		cmp.l	#-100,d0		beq.s	SommePresPourDessine	; oui nous sommes avant ce st		cmp.l	#0,d0		beq.s	SommePresPourDessine	; oui nous sommes après ce st; non il faut prendre le suivant		move.l	(a4),a4SommePresPourDessine		cmpa.l	#0000000,a4		blo		EndOfClearDisplay		cmpa.l	G.General_PremierSTPtr,a4		blo		EndOfClearDisplay		cmpa.l	G.General_DernierSTPtr,a4		bhi		EndOfClearDisplay		clr.w	-(sp)		move.l	a4,G.Sous_titre_dessined		move.l	a4,-(sp)		move.w	G.X_Offset,-(sp)		; base line		move.w	G.Y_Offset,-(sp)		; base line		move.l	G.Base_Adresse,-(sp)		move.l	G.Row_Bytes,-(sp)		pea		G.ScreenRenderedRect					import	Draw_SousTitre		jsr		Draw_SousTitre					move.w	(sp)+,d0		clr.w	G.OffscreenRendered			move.w	#1,G.ScreenRendered			clr.l	G.Sous_titreInOffscreen				move.l	G.Sous_titre_dessined,a0		move.l	st_TimeCodeIn(a0),d0		and.l	#$3f7f7f3f,d0		move.l	#1,D1		import	soustractionTimeCode		jsr		soustractionTimeCode		move.l	d0,G.TcInaAttendre						move.l	G.Sous_titre_dessined,a0		move.l	st_TimeCodeOut(a0),d0		and.l	#$3f7f7f3f,d0		moveq	#1,d1		jsr		soustractionTimeCode		move.l	d0,G.TcOutaAttendre					  		move.w	#1,G.TravailAFaire_Affichage 	; on attend le tc in du sous-titre; -----------------------------------------------------	EndOfClearDisplay				bra		Exit_AFF; -------------------------------------------------------		DoDisplay		move.w	G.DrawState,d0		tst.b	d0					; si .b=0 st effacé		bne		Exit_AFF			; on ne fait rien		lea		G.Display_Font,a0		tst.l	Render_handle(a0)		beq		PasDoDisplay_1		tst.l	RenderColor_handle(a0)		beq		PasDoDisplay_1 		tst.l	G.Base_Adresse			; il y a t-il une carte d'affichage 		bne.s	DoDisplay_1PasDoDisplay_1		; on il n'y en a pas on se contente d'affecter le flag 		move.w	#$8001,ChgFlag(a6)	; on indique que l'on entre dans un ST  		move.w	#$0001,G.DrawState 		bra 	Exit_AFF			; non; ---; il y a une carte d'affichage ,; on regarde si le sous-titre dessiné correspond à celui qui doit ètre affiché DoDisplay_1		move.w	#$8001,ChgFlag(a6)	; on indique que l'on entre dans un ST 		move.l	G.General_SousTitreCourantPtr,a0		move.l	G.Sous_titre_dessined,a1		;est ce le bon dans la VRAM ?		cmp.l	a0,a1		beq		AfficheLaVram					; oui c'est le bon;non, on regarde s'il est dans le buffer offscreen		cmp.l	G.Sous_titreInOffscreen,a0		bne.s	IlfautDessinerleSousTitre		; non pas dans le buffer offscreen;oui, on recopie le offscreen dans le buffer 		import	TransfertOffscreen_Vram 		jsr		TransfertOffscreen_Vram; on actualise le rectangle 		lea.l	G.OffscreenRenderedRect,a0		lea		G.ScreenRenderedRect,a1 		move.l	4(a0),4(a1) 		move.l	(a0),(a1)		move.l	G.Sous_titreInOffscreen,G.Sous_titre_dessined				bra.s	AfficheLaVram; ----------  le sous-titre prédessiné n'est pas le bon,;	il faut dessiner le bon st		IlfautDessinerleSousTitre; on efface la vram		move.w	#1,mustbeep(a6)		import	Clear_Buffer					jsr		Clear_Buffer		clr.l	G.Sous_titre_dessined		clr.l	G.Sous_titreInOffscreen		; on l'inibhe; on dessine le sous-titre		move.l	G.General_SousTitreCourantPtr,a0		cmpa.l	G.General_PremierSTPtr,a0		blo		Exit_AFF		cmpa.l	G.General_DernierSTPtr,a0		bhi		Exit_AFF		clr.w	-(sp)		move.l	G.General_SousTitreCourantPtr,a0		move.l	a0,G.Sous_titre_dessined		move.l	a0,-(sp)		move.w	G.X_Offset,-(sp)		; base line		move.w	G.Y_Offset,-(sp)		; base line		move.l	G.Base_Adresse,-(sp)		move.l	G.Row_Bytes,-(sp)		pea		G.ScreenRenderedRect	; rectangle du sous-titre					import	Draw_SousTitre		jsr		Draw_SousTitre		move.w	(sp)+,d0		;------------------ on affiche la VRAMAfficheLaVram		move.w	#$8001,G.DrawState	; travail effectué par la VBL taskAfficheLaVram_1@azert	move.w	G.DrawState,d0	; travail effectué par la VBL task		and.w	#$ff00,d0		bne.s	@azert; on place les valeurs à attendre; en fait, seul le tc out nous interrese		move.l	G.Sous_titre_dessined,a0		move.l	st_TimeCodeIn(a0),d0		and.l	#$3f7f7f3f,d0		move.l	#1,D1		import	soustractionTimeCode		jsr		soustractionTimeCode		move.l	d0,G.TcInaAttendre						move.l	G.Sous_titre_dessined,a0		move.l	st_TimeCodeOut(a0),d0		and.l	#$3f7f7f3f,d0		moveq	#1,d1		jsr		soustractionTimeCode		move.l	d0,G.TcOutaAttendre					; on dessine le prochain sous-titre dans le offscreen; on efface le offscreen buffer; on efface toute la ligne sur la largeur		lea		G.OffscreenRenderedRect,a0		move.l	G.OffscreenDisplayBase,-(sp)	;ram du buffer offscreen 		move.l	G.Row_Bytes,-(sp) 		lea		G.OffscreenRenderedRect,a0		move.w	#0,left(a0)		move.w	#1023,right(a0)		move.l	a0,-(sp) 		import	Hand_EraseRect 		jsr		Hand_EraseRect					; ON dessine le prochain sous-titre dans le offscreen; filtre pour les erreurs eventuelles sur les pointeurs						clr.l	G.Sous_titreInOffscreen		move.l	G.Sous_titre_dessined,a0		cmpa.l	G.General_PremierSTPtr,a0		blo		Exit_AFF		cmpa.l	G.General_DernierSTPtr,a0		bhi		Exit_AFF		cmp.l	#000000,a0		beq 	Exit_AFF				; erreur		; on vérifie que le prochain st correspond au prochain au next de Sous_titre_dessined			move.l	G.Sous_titre_dessined,a0		move.l	st_NextST(a0),d0	; le prochain sous-titre; on dessine dans le buffer offscreen le prochain sous-titre		cmp.l	G.General_PremierSTPtr,d0		blo		Exit_AFF		cmp.l	G.General_DernierSTPtr,d0		bhi		Exit_AFF						move.l	d0,G.Sous_titreInOffscreen		tst.l	D0		beq 	Exit_AFF				; il n'y a plus de sous-titre après, on ne fait rien		clr.w	-(sp)		move.l	d0,-(sp)		move.w	G.X_Offset,-(sp)		; base line		move.w	G.Y_Offset,-(sp)		; base line 		move.l	G.OffscreenDisplayBase,-(sp)	;ram du buffer offscreen		move.l	G.Row_Bytes,-(sp)		pea		G.OffscreenRenderedRect		import	Draw_SousTitre		jsr		Draw_SousTitre		move.w	(sp)+,d0				move.w	#3,G.TravailAFaire_Affichage 	; on attend le tc out		bra		Exit_aff;------------------------------; quand la routine d'interuption nous dit de dessine le prochain sous-titreAfficheParInterruption		move.w	#$8001,G.DrawState	; travail effectué par la VBL taskAPI_1	move.w	G.DrawState,d0	; travail effectué par la VBL task		and.w	#$ff00,d0		bne.s	API_1		; on efface le offscreen buffer		lea		G.OffscreenRenderedRect,a0		move.l	G.OffscreenDisplayBase,-(sp)	;ram du buffer offscreen 		move.l	G.Row_Bytes,-(sp)		; on efface toute la ligne sur la largeur 		lea		G.OffscreenRenderedRect,a0		move.w	#0,left(a0)		move.w	#1023,right(a0)		move.l	a0,-(sp) 		import	Hand_EraseRect 		jsr		Hand_EraseRect					; ON dessine le prochain sous-titre dans un buffer offscreen; filtre pour les erreurs eventuelles sur les pointeurs						clr.l	G.Sous_titreInOffscreen		move.l	G.Sous_titre_dessined,a0		cmpa.l	G.General_PremierSTPtr,a0		blo		Exit_AFF		cmpa.l	G.General_DernierSTPtr,a0		bhi		Exit_AFF		cmp.l	#000000,a0		beq 	Exit_AFF				; erreur		; on vérifie que le prochain st correspond au prochain au next de Sous_titre_dessined			move.l	G.Sous_titre_dessined,a0		move.l	st_NextST(a0),D0	; le prochain sous-titre; on dessine dans le buffer offscreen le prochain sous-titre		cmp.l	G.General_PremierSTPtr,d0		blo		Exit_AFF		cmp.l	G.General_DernierSTPtr,d0		bhi		Exit_AFF						move.l	d0,G.Sous_titreInOffscreen		clr.w	-(sp)		move.l	G.Sous_titreInOffscreen,-(sp)		move.w	G.X_Offset,-(sp)		; base line		move.w	G.Y_Offset,-(sp)		; base line 		move.l	G.OffscreenDisplayBase,-(sp)	;ram du buffer offscreen		move.l	G.Row_Bytes,-(sp)		pea		G.OffscreenRenderedRect					import	Draw_SousTitre		jsr		Draw_SousTitre					move.w	(sp)+,d0				move.w	#3,G.TravailAFaire_Affichage 	; on attend la fin du st en cours 		bra		Exit_AFF;--------------------------------------; quand la routine d'interuption nous dit d'effacer EffacerParInterruption	EPI_1	move.w	G.DrawState,d0		and.w	#$ff00,d0		bne.s	EPI_1		; on efface la vram 		move.w	#0,G.TravailAFaire_Affichage 	; desactive le check de la routine serie		import	Clear_Buffer		jsr		Clear_Buffer; on recopie le offscreen dans le buffer d'ecran		move.l	G.Sous_titreInOffscreen,a1			; existe t-il ?		cmpa.l	#00000,a1 		beq.s 	DessineleprochainSoustitre			; non donc on dessine					; on recopie le offscreen dans la VRAM 		import	TransfertOffscreen_Vram 		jsr		TransfertOffscreen_Vram		; on indique que le prochain st est dans le buffer d'écran	 		lea.l	G.OffscreenRenderedRect,a0		lea.l	G.ScreenRenderedRect,a1 		move.l	4(a0),4(a1) 		move.l	(a0),(a1)		move.l	G.Sous_titreInOffscreen,a0		move.l	a0,G.Sous_titre_dessined	; on positionne les autres indicateur 		clr.w	G.OffscreenRendered	 		move.w	#1,G.ScreenRendered; on calcule les time codes d'attente pour la routine serie		move.l	G.Sous_titreInOffscreen,a0		move.l	st_TimeCodeIn(a0),d0		and.l	#$3f7f7f3f,d0		move.l	#1,D1		import	soustractionTimeCode		jsr		soustractionTimeCode		move.l	d0,G.TcInaAttendre						move.l	G.Sous_titreInOffscreen,a0		move.l	st_TimeCodeOut(a0),d0		and.l	#$3f7f7f3f,d0		moveq	#1,d1		jsr		soustractionTimeCode		move.l	d0,G.TcOutaAttendre					 		move.w	#1,G.TravailAFaire_Affichage 	; on attend le prochain dessiner prochain sous-titre; on demande à la routine série d'attendre le prochain tc in 		move.w	#1,G.TravailAFaire_Affichage 			clr.l	G.Sous_titreInOffscreenExit_AFF				IF demo=1 THEN			MOVE.L	TICKS,D0			CMP.L	G.StartTicks,d0			blo		@b						import	Terminate			jsr		terminate@b			ENDIF			; si erreur sur buffer on beep un peu			tst.w	MustBeep(a6)			beq		pasBeep;			move.w	#1,-(sp);			_SysBeeppasBeep			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.New	Affichage_soustitre		; this name will appear in the debugger			align 4				ENDP* ================================================* PROCEDURE GetKernTable;* ================================================GetKernTable	Proc	ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointthe_FontNumber	ds.w	1		; n° de la policethe_Size		ds.w	1		; taille de la policethe_face		ds.w	1		; style du caractèreVar_Handle		ds.l	1		; adresse de retour du handle de la kern tableParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkthe_input	ds.b	24		; fm input recordLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc,doupdate		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(sp)		lea		the_input(a6),a0		move.w	the_FontNumber(a6),fmInFamily(a0)		; le n° de la font		move.w	The_Size(a6),fmInSize(a0)		move.w	The_Face(a6),fmInFace(a0)		move.b	#false,fmInNeedBits(a0)		move.b	#0,fmInDevice(a0)		move.l	#$1000,fmInNumer(a0)		move.l	#$1000,fmInDenom(a0)			clr.l	-(sp)		move.l	a0,-(sp)		_FMSwapFont				move.l	(sp)+,d0				beq		Exit_Err		; on a un resultat				move.l	d0,a0		move.l	fmOutFontH(a0),a0	; on récupère le font handle		move.l	(a0),a1		move.l	Var_Handle(a6),a0		move.l	a1,(a0)		bra 	Exit	Exit_Err		move.l	Var_Handle(a6),a0		clr.l	(a0)		Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller					; return to the caller					DbgInfo.New	GetKernTable		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE Create_FastFont(); * ================================================**	Cette routine effectue le rendu d'une police d'affichage colorée*  à partir d'une font déjà calculée, pour une grande rapiditée d'affichage*  *Create_FastFont 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFontRender			ds.l	1		; record pour le passage des parramètres de rendusDestinationSize		ds.w	1		; 16 ou 32 bits mode ?RenderEffect		ds.l	1		; effet de rendu ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256XOffset					ds.w	1YOffset					ds.w	1Pointeur				ds.l	1			; déréférence du handlehandle					ds.l	1			; handle pour le dessinRGB_Color				ds.W	3Itemchoisi				DS.w	1		; Item choisi par l'utilisateuritemType				ds.w	1		; stockage du type de ItemitemHandle				ds.L	1		; stockage	du handle du itemitemRect				ds		Rect	DialogStorage			ds		dWindLenWaitingDialogStorage	ds		dWindLenThepoint				ds.l	1TotalChar				ds.w	1		; nb total de caractère à rendreCharCounter				ds.w	1		; total de caractère rendubaseLine				ds.w	1		; cf Render sub routineStyleType				ds.w	1		; style en cour	type style MAC   (cf Quick Draw)theStyle				ds.w	1		; style en cour compteur 0....nTheChar					ds.w	1		; caractère en courThePlane				ds.w	1		; plan en cour (face/bordure/ombre)CharRect				ds		Rect	; carré du plan dessinéFontBitmapPtr			ds.l	1		; pointeur du début du bitmap de la policeFontBitmapSize			ds.l	1		; taille du "font bitmaps"  FontBitmapHimem			ds.l	1		; pointeur de la fin du bitmap de la police n.u.FontCurrentPtr			ds.l	1		; pointeur relatif positiion dans  le handleFontStylePtr			ds.l	1		; pointeur relatif du styleFontCharPtr				ds.l	1		; pointeur relatif du caractère (Charheader) dans le stylePreviousFontCharPtr		ds.l	1		; pointeur relatif au précédent caarctèreFontPlanePtr 			ds.l	1		; pointeur relatif du plan dans le caractèreSavePort				ds.l	1		; save portsaveD1					ds.l	1		;Row_Bytes				ds.l	1Base_Adresse 			ds.l	1	Row_BytesVX				ds.l	1spare					ds.l	2ItemHit		ds.w	1CurrentcharRect	ds		rect		;LocalSize	EQU 	*			; size of all the local variables		ENDR		SEG	'Rendering'			; case sensitive			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor	;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,Rendering_font_SubRoutine; 		movem.l d1-d7/a1-a4,-(sp)	; sauvegarde des registres* ----- pour les tests on dessine également dans la vidéo explorer; on recherche la base adresse et le rowbyte								clr.l	-(sp)					_GetDeviceList			; à changer 				move.l	(sp)+,d0 				move.l	d0,-(sp) 				move.l	d0,-(sp) 				_GetNexTDevice				move.l	(sp)+,a0		; le handle				move.l	(a0),a0			; handle => pointeur				move.w	gdID(a0),d0		;				move.l	gdPMap(a0),a1				move.l	(a1),a1			; handle => pointeur				move.l	baseAddr(a1),Base_Adresse(a6)				move.w	rowBytes(a1),d0				and.l	#$7fff,d0		; seulement b0-b14 et extension sur 32 bits				move.l	d0,Row_BytesVX(a6)		; on regarde s'il y a un font bitmap en mémoire									move.l	FontRender(a6),a0		; taille de la police		tst.l	Render_handle(a0)		beq		Exit_Err					; il n'éxiste pas de font bitmap					; on demande une zone mémoire pour pouvoir dessiner un caractère dans un plan		; on reserve un espace mémoire =4 fois la taille de la lettre 		; pour permettre le rendu d'un plan		move.l	FontRender(a6),a0		; taille de la police		move.w	FontSize(a0),d0		mulu	#32,d0				; 4* la taille mots long		move.w	d0,d1						mulu	d1,d0								add.l	#10240,d0			; en sécuritée		_NewHandle		move.l	a0,handle(a6)		_Hlock						; on locked le handle		move.l	handle(a6),a0				move.l	(a0),a0				; handle => pointeur		move.l	a0,Pointeur(a6); on effectue un calcul préalable de l'espace mémoire nécessaire pour contenir; la police	d'affichage.; on récupère la taille du handle display font; on ouvre un dialog pour indiquer que nous recherchons de la mémoire		clr.l	-(sp)		move.w	#176,-(sp)	; id number		pea		WaitingDialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog		move.l	FontRender(a6),a0				move.l	Render_handle(a0),a0		; display font handle		_GetHandleSize		tst.l	d0		bmi		Exit_err1		; on s'arrète on ferme le dialog recherche mémoire; d0 contient la taille du display font; on demande un handle de 3 fois la taille 				mulu.l	#4,d0		;  ; on tente une allocation de mémoire				move.l	d0,d7		; on sauvegarde la valeur		move.l	d0,FontBitmapSize(a6)		_NewHandle		tst.w	d0			; demande satisfaite ? 		beq		AllRight_EnoughtMemory	; oui tout va bien		; il n'y a pas assez de mémoire		; on indique la quantité de mémoire dispo; on regarde s'il y a déja un handle aloué si oui on le dispose		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		cmpa.l	#00000000,a0		beq.S	non_pas_deja_0; oui , on le dispose		_DisposHandle		move.l	FontRender(a6),a1		; font record		clr.l	RenderColor_handle(a1)		; on place le handle dans le font recordnon_pas_deja_0				_PurgeSpace		move.l	a0,d0		sub.l	#32*1024,d0		; on est bien obligé de laisser de la place		divu	#1024,d0		and.l	#$ffff,d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7		; on ouvre un dialog pour indiquer le problème		OpenDialog	(166)		pea		DialogStorage(a6)		_DrawDialog				pea		DialogStorage(a6)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)			_SetItext				move.l	d7,d0		; on recupère la valeur		divu	#1024,d0		and.l	#$ffff,d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)			_SetItext	WaitEvent		import	SpecialModalDialogFilter		pea	SpecialModalDialogFilter		pea	ItemHit(a6)		_ModalDialog		move.w	ItemHit(a6),d0				cmp.w	#1,d0		beq		Exit_bis		; on s'arrète		cmp.w	#2,d0		bne		WaitEvent; l'utilisateur tente de continuer				pea		DialogStorage(a6)		_CloseDialog						_PurgeSpace		move.l	a0,d0		sub.l	#32*1024,d0		; on est bien obligé de laisser de la place		move.l	d0,FontBitmapSize(a6)	; on sauvegarde la taille du handle		_NewHandle						tst.w	d0		beq.s	AllRight_EnoughtMemory			; alert ce n'est pas possible		clr.w	-(sp)		move.w	#159,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		bra		Exit_err1		; -----------------------------------------------------------------------		; ok il y a assez de mémoire 		AllRight_EnoughtMemory			move.l	a0,a4		; sauvegarde de a0		; on regarde s'il y a déja un handle aloué		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		cmpa.l	#00000000,a0		beq.S	non_pas_deja; oui , on le dispose		_DisposHandle		; on place le handle dans le font recordnon_pas_deja				move.l	FontRender(a6),a1		; font record		move.l	a4,RenderColor_handle(a1)		move.l	a4,a0		_MoveHHI		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		move.l	(a0),a1					; handle => pointeur		move.l	a1,FontBitmapPtr(a6); on locked le handle		_HLock; on déréférence le handle				pea		WaitingDialogStorage(a6)		_CloseDialog				; on ferme le dialog demande de mémoire		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		move.l	(a0),a1					; handle => pointeur		move.l	a1,FontBitmapPtr(a6)		move.l	FontRender(a6),a1		move.w	#1,interligne(a1); on initialise le  Font record de la police		move.l	FontRender(a6),a1		; font record		move.w	#33,First_Char(a1)		move.w	#255,last_Char(a1); ---; on reserve de la place pour le header du font bitmaps;; rappel  :     	ptr style 1		<-  début du font bitmaps	);				  / / / / 									) header font bitmap;				ptr style n									) ;;				headerCharN°1	<- début 1 er style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn;				    / / / /;				headerCharN°1	<- début n ème style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn; (il faut réserver un  long ptr pour chaque style) ; il faudra changer le nom face number par style number (nombre de style dans le bitmap); initialisation du Displayfont header en tête 	move.l	FontBitmapPtr(a6),a0		; abs ptr du Displayfont		move.l	FontRender(a6),a1			; pointeur du fontRecord	moveq	#0,d0	move.w	Face_Number(a1),d0			; nombre de style à rendre	mulu	#styleHeaderSize,d0			; taille du "styleHeaderSize"	move.l	d0,FontCurrentPtr(a6)		; réservation de la place				;  ----------------------------------------------------------------------------;  c'est partie pour la grande boucle; on ouvre un dialog pour indiquer l'état de rendu		clr.l	-(sp)		move.w	#168,-(sp)	; id number		pea		DialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		_setPort		pea		DialogStorage(a6)			_DrawDialog		pea		DialogStorage(a6)		move.w	#2,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_frameRect		; on dessine la reglette		pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#-1,-(sp)		move.w	#-1,-(sp)		_insetRect		pea		itemRect(a6)		_frameRect				move.w	#32000,RGB_Color(a6)		move.w	#32000,2+RGB_Color(a6)		move.w	#32000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect		pea		itemRect(a6)		_PaintRect						move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor; on calcule le nombre de caractère à rendre; pour l'indicateur d'état.		move.l	FontRender(a6),a0		; font record		move.w	Face_Number(a0),d0		mulu.w	#255-33,d0				; nombre total de caractère à rendre (sauf espace)		move.w	d0,TotalChar(a6)				move.w	#0,CharCounter(a6)		; reset du compteur			move.l	FontRender(a6),a1		clr.w	max_descent(a1)		clr.w	max_Ascent(a1); calcul de l'espace; -------------------------	 boucle 1 : boucle	style	-------------------;( normal, gras, italique ); initialisation boucle style		move.w	#0,TheStyle(a6)		; initialisation	Style_Loop; initialisation pointeurs "Display font" boucle style		move.l	FontBitmapPtr(a6),a0		; abs ptr du Displayfont	move.l	FontCurrentPtr(a6),d0		; on calcule l'adresse du style	import	aligneD0	jsr		aligneD0	move.l	d0,FontStylePtr(a6)				; adresse du "style"	move.l	d0,FontCurrentPtr(a6)			; aligné sur dc.l	move.l	#0,d1	move.w	theStyle(a6),d1	move.l	d0,(a0,d1.l*styleHeaderSize)		; on stocke l'adresse du style dans l'en tête	move.l	#0,PreviousFontCharPtr(a6)	; raz; on indique le style du caractère				move.w	TheStyle(a6),d0			case#.w	(d0,if),\ 			(0,Normal_style),\			(1,Italique_style),\			(2,Bold_style) 			bra		EndLoop_Style			; style pas connu on ne le fait pas		Normal_style					clr.w	StyleType(a6)					bra		start_CharLoop		; on y va; ------------ Bold_style; on regarde si le style italique est demandé										move.l	FontRender(a6),a0		; font record					move.w	FontStyle(a0),d0					and.w	#1,d0					beq		EndLoop_Style			;pas bold donc ?: on passe au suivant					move.w	#1,StyleType(a6)					bra		start_CharLoop		; on y va; ------------Italique_style; on regarde si le style italique est demandé					move.l	FontRender(a6),a0		; font record					move.w	FontStyle(a0),d0					and.w	#2,d0					beq		Bold_style				; pas italique , bold ?					move.w	#2,StyleType(a6); ------------------------start_CharLoop		; boucle 2 : boucle caractères ; de 33 à 255 pour l'instant							move.w	#33,TheChar(a6)		; initialisation		Loop__Char; initialisation des pointeurs "Display font" boucle caractères	move.l	FontBitmapPtr (a6),a0		; abs ptr du Displayfont	move.l	FontCurrentPtr(a6),d0		; pointeur courant	move.l	d0,FontCharPtr(a6)			; pointeur courant => fontchar	add.l	#CharHeaderSize,d0			; header du caractère	move.l	d0,FontCurrentPtr(a6)		; réservation de l'espace; on update les pointeurs de cet en tête		move.l	PreviousFontCharPtr(a6),d0	move.l	FontCharPtr(a6),d1	move.l	d0,CH_PreviousChar(a0,d1.l)					; previous Ptr	clr.l	CH_NextChar(a0,d1.l)						; next Ptr		move.w	TheChar(a6),CH_CharNumber(a0,d1.l)		; n° de caractère rendu 												move.w	#$caca,CH_Spare(a0,d1.l)			; le spare je met $caca pour mieux identifier cette position; on raz le rectangle 			move.w	#32000,left+CH_Rect(a0,d1.l)	; ≈ valeur maximum		move.w	#32000,top+CH_Rect(a0,d1.l)		; ≈ valeur maximum		move.w	#0,right+CH_Rect(a0,d1.l)	; ≈ valeur maximum		move.w	#0,bottom+CH_Rect(a0,d1.l)		; ≈ valeur maximum	; on update le nextPtr du char précédent (s'il existe)														move.l	PreviousFontCharPtr(a6),d0	beq.s	PasPreviousChar				; nous sommes au premier caractère	move.l	FontCharPtr(a6),CH_NextChar(a0,d0.l)		; ptr next du précédent	PasPreviousChar				move.l	FontCharPtr(a6),PreviousFontCharPtr(a6)		; l'actuel char devient le précédent 															; au prochain passage																																				; ----- on dessine le caractère dans un buffer -------------				move.l	FontRender(a6),a0		move.w	theStyle(a6),d1		move.w	TheChar(a6),d0		import	GiveDisplayFont_CharInfo		jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan		tst.w	d0		bne  	fin_loop_char			; il y a une erreur			move.w	right+CH_Rect(a0),d0		addq.w	#1,d0		mulu	#4,d0					; row bytes (mot long)		move.l	d0,Row_Bytes(a6)				move.l	FontBitmapPtr (a6),a1		; abs ptr du Displayfont		move.l	FontCharPtr(a6),d2				move.w	top+CH_Rect(a0),top+CH_Rect(a1,d2.l)		move.w	left+CH_Rect(a0),left+CH_Rect(a1,d2.l)		move.w	right+CH_Rect(a0),right+CH_Rect(a1,d2.l)		move.w	bottom+CH_Rect(a0),bottom+CH_Rect(a1,d2.l)				move.l	CH_Rect(a0),CurrentcharRect(a6)		move.l	4+CH_Rect(a0),4+CurrentcharRect(a6); on test si rectangle coherent; pour la police		move.w	bottom+CH_Rect(a0),d0	; en hauteur		sub.w	top+CH_Rect(a0),d0		bmi     paschar		cmp.w	#300,d0		bhi		paschar		move.w	right+CH_Rect(a0),d0	; en largeur		sub.w	left+CH_Rect(a0),d0		bmi     paschar		cmp.w	#300,d0		bhi		paschar				cmp.w	#$ca,TheChar(a6)		bne.s	PasCapaschar				clr.l	CH_Rect(a1,d2.l)		clr.l	4*CH_Rect(a1,d2.l)		clr.w	CH_Spare(a1,d2.l)				bra		fin_loop_char		; on ne dessine pas le caractère $CA		PasCa		; on recupère le max base line; !!! note: la base line est une valeur négative !		move.w	pi_Baseline+CharHeaderSize(a0),d0	; base line de la face		cmp.w	#2,d1		; border ?			blo.s	FoundMaxBaseLine		cmp.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0	; base line border		blt.s	@shadowMax		move.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0	; base line border@shadowMax		cmp.w	#3,d1		; shadow ?			blo.s	FoundMaxBaseLine		cmp.w	pi_Baseline+PlaneInfoSize*2+CharHeaderSize(a0),d0	; base line border		blt.s	FoundMaxBaseLine		move.w	pi_Baseline+PlaneInfoSize*2+CharHeaderSize(a0),d0	; base line borderFoundMaxBaseLine						move.w	d0,CH_Spare(a1,d2.l)		; spare pour base ligne		neg.w	d0							; base line*-1 => ascent		move.l	FontRender(a6),a1; calcul de max Ascent				cmp.w	max_Ascent(a1),d0		blo.s	not_MaxAscent		move.w	d0,max_Ascent(a1)not_MaxAscent		; on calcule du descent du char		move.w	bottom+CH_Rect(a0),d1		add.w	pi_Baseline+CharHeaderSize(a0),d1	; descent= bottom-baseline (face)		cmp.w	max_descent(a1),d1		blo.s	not_Maxdescent		move.w	d1,max_descent(a1)		not_Maxdescent		move.w	max_Ascent(a1),d1		add.w	max_descent(a1),d1;		move.w	bottom+CH_Rect(a0),d1		cmp.w	interligne(a1),d1		blt.s	Not_MaxHeight		move.w	d1,interligne(a1)		Not_MaxHeight				; --------------------------------------------------						clr.w	-(sp)					move.l	FontRender(a6),-(sp)		move.w	TheChar(a6),-(sp)		move.w	theStyle(a6),-(sp)		move.l	G.RGB_FaceColor,-(sp)			move.l	G.RGB_BorderColor,-(sp)		move.l	G.RGB_ShadowColor,-(sp)		move.l	#0,-(sp)		; Bgdcolor				move.w	#0,-(sp)		; transparent black for bgd					move.w	#0,-(sp)	;x		move.w	d0,-(sp)	;y  ; base line 		move.l	Pointeur(a6),-(sp)		; block mémoire temporaire		move.l	Row_Bytes(a6),-(sp)		; largeur pour des long word		import		Draw_A_Char		jsr			Draw_A_Char				move.w		(sp)+,d0		; largeur du carctère (on s'en fout ici); ----- on recopie ce caractère dans le fast font bitmap --------; boucle de recopie		move.w	#0,d6						move.l	Base_Adresse(a6),a4		; base VX				move.l	Pointeur(a6),a0						;bitmap source		move.l	Row_Bytes(a6),d5		move.l	FontCurrentPtr(a6),a1		adda.l	FontBitmapPtr (a6),a1				; pointeur absolu pour recopie		; on calcule le row byte pour l'arrivée 16 ou 32 bits				move.l	Row_Bytes(a6),d4					;row byte source bitmap		cmp.w	#16,DestinationSize(a6)				; 16 ou 32 bits		bne.s	Boucle_recopieVerticale				; non, mode 32 bits		lsr.l	#1,d4								; row byte sur 16 bits		; d5 = row byte de la source; d4 = row byte de l'arrivée; a0 = ptr de la source; a1 = ptr de l'arrivée ; d7= X ; d6= Y		Boucle_recopieVerticale		move.w	#0,d7		; largeur (pts)Boucle_recopieHorizontale		move.l	(a0,d7.w*4),d0						; données de la source		; mode 16 ou 32 bits		cmp.w	#32,DestinationSize(a6)						beq.s	Mode32bits; -----   mode 16 bits; on convertie le mots long en word, pour les détails voir Color QuickDraw direct color ; RGB 8888 en   RGB1555 (alpha, red,green,blue)		move.l	d0,d2		clr.l	d0		; alpha channel		move.l	d2,d1		and.l	#$ff000000,d1		beq.s	MakeBlue					;  =0 => alphabit=0 		or.w	#$8000,d0					; ≠0 alphabit =1MakeBlue		; blue 						|... aaaaaaaa rrrrrrrr gggggggg (bbbbb)| bbb 		lsr.l	#3,d2		move.l	d2,d1		and.l	#%0000000000011111,d1				or.w	d1,d0; green 					|......	aaaaaaaa rrrrrrrr (ggggg)ggg bb| bbbbbb					lsr.l	#3,d2		move.l	d2,d1		and.l	#%0000001111100000,d1		or.w	d1,d0; red	 					|.........	aaaaaaaa (rrrrr)rrr ggggggg| g bbbbbbbb					lsr.l	#3,d2		move.l	d2,d1		and.l	#%0111110000000000,d1		or.w	d1,d0; on le place dans la mémoire		move.w	d0,(a1,d7.w*2)		; word		bra.s	finligne; ----Mode32bits; on le place dans la mémoire		move.l	d0,(a1,d7.w*4)		; long;		move.l	d0,(a4,d7.w*4)		; dans la VXfinligne		addq.W	#1,D7			cmp.w	right+CurrentcharRect(a6),d7		bls		Boucle_recopieHorizontale				add.l	d5,a1			; ligne suivante destination		add.l	d5,a0			; ligne suivante source		add.l	Row_BytesVX(a6),a4				addq.W	#1,D6			cmp.w	bottom+CurrentcharRect(a6),d6		bls		Boucle_recopieVerticale; ----- update du ptr de la zone mémoire --------------				move.w	bottom+CurrentcharRect(a6),d0				addq.w	#1,d0				move.w	right+CurrentcharRect(a6),d1				addq.w	#1,d1				mulu	d1,d0				lsl.l	#1,d0		; pour 16 bits				cmp.w	#16,DestinationSize(a6)				; mode 16 ou 32 bits				beq.s	M_16				lsl.l	#1,d0		; pour 32 bitsM_16					import	aligneD0				jsr		aligneD0				; il vaut mieux car si la base est dc.l												; on peut travailler en mot long (plus rapide) 				add.l	FontCurrentPtr(a6),d0	; "reservation de l'espace" 				move.l	d0,FontCurrentPtr(a6)				move.l	d0,FontPlanePtr(a6)		* -------- fin loop des plans incr loop caractèresfin_loop_char 		bsr		IncrementReglette		; pour indiquer la progression; on affiche les variables utilisées par le programme dans la fenètre Status		bsr		WriteSTate; on incrémente le compteur de boucle		move.w	TheChar(a6),d0		addq.w	#1,d0		move.w	d0,TheChar(a6)		cmp.w	#255,d0			; pour l'instant		blo		Loop__Char; -----------;fin boucle styleEndLoop_Style	move.w	TheStyle(a6),d0	addq.w	#1,d0	add.w	#1,TheStyle(a6)	move.l	FontRender(a6),a0			; pointeur du fontRecord	cmp.w	Face_Number(a0),d0	blo		Style_Loop	; le rendu est terminé; on l'indique à l'utilisateur; on taille le handle à la taille voulue			move.l	FontBitmapPtr(a6),a0	; a0= adresse absolue de l'espace  			move.l	FontRender(a6),a1		; font record			move.l	RenderColor_handle(a1),a0			_Hunlock			move.l	FontRender(a6),a1		; font record			move.l	RenderColor_handle(a1),a0			move.l	FontCurrentPtr(a6),d0			_SetHandleSize				Exit		pea		DialogStorage(a6)		_CloseDialog				move.l	handle(a6),a0		_HUnlock					; on unlocked le handle				move.l	handle(a6),a0		; on release la mémoire		_DisposHandle		bra		Exit_Err; --------------------------------Exit_bis						pea		DialogStorage(a6)		_CloseDialog				move.l	handle(a6),a0		_HUnlock					; on unlocked le handle				move.l	handle(a6),a0		; on release la mémoire		_DisposHandleExit_Err1		pea		WaitingDialogStorage(a6)		_CloseDialog				; on ferme le dialog demande de mémoireExit_Err				movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0); --------------------------IncrementReglette; cette routine rafraichie la reglette				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				add.w	#1,CharCounter(a6)		move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		;largeur reglette		mulu	CharCounter(a6),d0								divu	TotalChar(a6),d0		add.w	left+itemRect(a6),d0				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		move.w	#50000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#10000,RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		move.w	#35000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#55535,RGB_Color(a6)		move.w	#65535,4+RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#10000,RGB_Color(a6)		move.w	#20000,4+RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#55535,RGB_Color(a6)		move.w	#65535,4+RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#50000,4+RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts; --------------------------; cette routine transfère le texte dans le stat item déterminé par d1Str2StatItem				move.l	a0,d7			; sauvegarde de la chaine				pea		DialogStorage(a6)		move.w	d1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.w	#srcCopy,-(sp)				_textMode								move	Left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),d0		add.w	#9,d0		move.w	d0,-(sp)					; la hauteur top-baseline au pif		_MoveTo				move.l	d7,-(sp)		_drawString		_PenNormal		rts		; --------------------------; cette routine convertie la valeur contenue dans d0 en texte ; dans le stat item déterminé par d1Num2StatItem		 		move.w	d1,saveD1(a6)		lea		textBuff(a6),a0		bsr		num2StrWord		move.w	saveD1(a6),d1		move.w	d1,d7				pea		DialogStorage(a6)		move.w	d1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move	Left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),d0		add.w	#9,d0		move.w	d0,-(sp)					; la hauteur top-baseline au pif		_MoveTo		move.w	#srcCopy,-(sp)				_textMode		pea		TextBuff(a6)		_drawString		_PenNormal		rts		; -------------------------------------------------------		testUserStop; un event mouse down ?			clr.w	-(sp)		_button				move.w	(sp)+,d0		bne.s	@1				; ok mouse down		rts				 		@1		pea		Thepoint(a6)	; oui mais où ?		_GetMouse				clr.w	-(sp)		pea		DialogStorage(a6)		move.l	thePoint(a6),-(sp)		_FindDitem			move.w	(sp)+,d0		bmi.s	No_UserStop		; négatif pas dans item		bne		No_UserStop		 ; =0 donc item 1 = good, true, ok, youpi etc... ; on hilite le bouton		pea		DialogStorage(a6)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			wait_Up				pea		Thepoint(a6)	; oui mais où ?		_GetMouse				clr.w	-(sp)		move.l	thepoint(a6),-(sp)		pea		itemRect(a6)		_PtInRect		move.w	(sp)+,d0		beq.s	@1				move.l	ItemHandle(a6),-(sp)		move.w	#inButton,-(sp)		_HiliteControl		bra.s		@2		@1		move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl		@2				clr.w	-(sp)		_button				move.w	(sp)+,d0		bne.s	wait_Up			; user a laché dans bouton ?		pea		Thepoint(a6)	; oui mais où ?		_GetMouse		clr.w	-(sp)				move.l	thepoint(a6),-(sp)		pea		itemRect(a6)		_PtInRect		move.w	(sp)+,d0				beq.s		No_UserStop ; non		OkShoot_in						move.w	#1,d0			; on retourne ≠0		rts		No_UserStop		move.w	#0,d0			; non,non,non il n'y a rien à signaler ...		rts; --------------------------------------------------------------------WriteSTate		Pea		SavePort(a6)		_GetPort				pea		G.ServiceWindow		_SetPort						move.w	#4,-(sp)		move.w	#246,-(sp)		_MoveTo						pea		#'-------------------------------------------'		_DrawString				bsr		Newline				pea		#'Variables utilisées pour le rendu de police '		_DrawString		; ------  font bitmap Ptr		move.l	FontBitmapPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontBitmapPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  font bitmap Ptr		move.l	FontBitmapPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontBitmapPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  FontBitmapSize		move.l	FontBitmapSize(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontBitmapSize :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine		; ------  font FontCurrentPtr		move.l	FontCurrentPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontCurrentPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine		; ------  fFontStylePtr		move.l	FontStylePtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontStylePtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine		; ------  FontCharPtr		move.l	FontCharPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontCharPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  PreviousFontCharPtr		move.l	PreviousFontCharPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'PreviousFontCharPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  the stack		move.l	a7,d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'Stack :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  A6 link		move.l	a6,d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'A6 link :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine				move.l		SavePort(a6),-(sp)		_SetPort		rts		; -------------------------------------		Newline		pea	ThePoint(a6)		_GetPen				move.w	top+ThePoint(a6),d0		move.w	#4,-(sp)		add.w	#10,d0		move.w	d0,-(sp)		_moveTo				rts; ------------------------------------				num2StrLong; on effectue la conversion en hexa ascii d'un mot long		move.w	#7,d7		move.b	#9,(a0)+	; longueur de la chaine		move.b	#'$',(a0)+	; identifiant héxadécimalloop_num2StrLong		rol.l	#4,d0		; on commence par le poid le + fort		move.b	d0,d1		and.b	#$0f,d1		cmp.b	#09,d1		; si ≤9  => on ajoute $30 ('0') sinon 'A'-10		bhi.s	@1		add.b	#$30,d1		; nombre		bra.S	@2@1		add.b	#65-10,d1@2		move.b	d1,(a0)+		dbra	d7,loop_num2StrLong		rts; --------------------------------------------num2StrWord; on effectue la conversion en hexa ascii d'un mot		move.w	#3,d7		move.b	#5,(a0)+	; longueur de la chaine		move.b	#'$',(a0)+	; identifiant héxadécimalloop_num2StrWord		rol.w	#4,d0		; on commence par le poid le + fort		move.b	d0,d1		and.b	#$0f,d1		cmp.b	#09,d1		; si ≤9  => on ajoute $30 ('0') sinon 'A'-10		bhi.s	@1		add.b	#$30,d1		; nombre		bra.S	@2@1		add.b	#65-10,d1@2		move.b	d1,(a0)+		dbra	d7,loop_num2StrWord		rts				DbgInfo.new	Create_FastFont		; this name will appear in the debugger		align 4			ENDP					end				