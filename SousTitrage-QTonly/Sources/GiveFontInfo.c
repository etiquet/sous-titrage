#include 	"GiveFontInfo.h"		// cette routine nous donne le char record du caractre , theFont doit etre lockŽCharHeaderPtr C_GiveDisplayFont_FastCharInfo(FontRenderRecordPtr theFont,short thechar,short theStyle){long 			offsetstyle;long*		FontBitmapPtr;short		i,totallloop,style;CharHeaderPtr	currentchar;char			state;Ptr			AbsStylePtr;unsigned long	a;//on commence par tester si il y a bien un handle	HLock((Handle)theFont->RenderColor_handle);	if (!theFont->RenderColor_handle) return nil;	if (thechar>theFont->last_Char) return nil;	if (thechar<theFont->First_Char) return nil;	if (theStyle>theFont->Face_Number) theStyle=0;// on rŽcupre l'offset du style demandŽ	AbsStylePtr=*(theFont->RenderColor_handle); 					// on le garde	/*	FontBitmapPtr=(long*)AbsStylePtr;	FontBitmapPtr+=(unsigned long)(theStyle*8);				// pointeur de l'offset sur le style	offsetstyle=*(FontBitmapPtr); 						// l'offset sur le style	currentchar=(CharHeaderPtr)AbsStylePtr;	currentchar+=(unsigned long)offsetstyle; 			// le ptr du 1er char	*/// traitement de the style	style=theStyle;	switch(theStyle){		case 0:			style=0;		break;		case 1:			style=2;		break;				case 2:			style=1;		break;	}	a=(unsigned long)((MasterPlanePtr)AbsStylePtr)->styleoffset[style].offset;	a+=(unsigned long)AbsStylePtr;// le ptr du 1er char	currentchar=(CharHeaderPtr)a; 	totallloop=theFont->last_Char-theFont->First_Char;	// boucle de recherche du caractre		for (i=totallloop;i>=0;i--){			if (currentchar->CH_CharNumber==thechar) return currentchar;			a=(unsigned long)currentchar->CH_NextChar+(unsigned long)AbsStylePtr; // on calcule le pointeur du suivant			currentchar=(CharHeaderPtr)a; 		}			return nil;	HUnlock((Handle)theFont->RenderColor_handle);		}	//C_GiveDisplayFont_FastCharInfo// cette routine nous donne le char record du caractre , theFont doit etre lockŽCharHeaderPtr C_GiveDisplayFont_CharInfo(FontRenderRecordPtr theFont,short thechar,short theStyle){long 	offsetstyle;long*	FontBitmapPtr;short	i,totallloop,style;CharHeaderPtr	currentchar;char		state;Ptr	AbsStylePtr;unsigned long	a;//on commence par tester si il y a bien un handle	HLock((Handle)theFont->Render_handle);	if (!theFont->Render_handle) return nil;	if (thechar>theFont->last_Char) return nil;	if (thechar<theFont->First_Char) return nil;// on rŽcupre l'offset du style demandŽ	AbsStylePtr=*(theFont->Render_handle); 					// on le garde	/*	FontBitmapPtr=(long*)AbsStylePtr;	FontBitmapPtr+=(unsigned long)(theStyle*8);				// pointeur de l'offset sur le style	offsetstyle=*(FontBitmapPtr); 						// l'offset sur le style	currentchar=(CharHeaderPtr)AbsStylePtr;	currentchar+=(unsigned long)offsetstyle; 			// le ptr du 1er char	*/// traitement de the style	style=theStyle;/*	switch(theStyle){		case 0:			style=0;		break;		case 1:			style=2;		break;				case 2:			style=1;		break;	}*/	a=(unsigned long)((MasterPlanePtr)AbsStylePtr)->styleoffset[style].offset;	a+=(unsigned long)AbsStylePtr;// le ptr du 1er char	currentchar=(CharHeaderPtr)a; 	totallloop=theFont->last_Char-theFont->First_Char;	// boucle de recherche du caractre		for (i=totallloop;i>=0;i--){			if (currentchar->CH_CharNumber==thechar) return currentchar;			a=(unsigned long)currentchar->CH_NextChar+(unsigned long)AbsStylePtr; // on calcule le pointeur du suivant			currentchar=(CharHeaderPtr)a; 		}			return nil;		}	//C_GiveDisplayFont_CharInfo