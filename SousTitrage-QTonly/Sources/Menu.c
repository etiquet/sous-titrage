#include "BB.Globals_C.h"#include <Menus.h>#include <Devices.h>#include <Events.h>#include <Gestalt.h>#include <Palettes.h>#include <QuickTimeComponents.h>#include <ImageCompression.h>#include "E3DEMO.H"// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;	//#pragma segment Menuvoid 		FlashTracking(void);void		DoAppleMenu(short MenuItem);void		DoFileMenu(short MenuItem);void		DoEditMenu(short MenuItem);void 		DoListeMenu(short MenuItem);void		DoFenetreMenu(short MenuItem);void 		DoModeMenu(short	MenuItem);void 		DoQuickOpenMenu(short MenuItem);void 		DoDebugMenu(short MenuItem);void 		DoAffichageMenu(short	MenuItem);pascal Boolean 	AboutModalDialogFilter(DialogPtr theDialog ,EventRecord *event,short *itemhit);pascal void		DoInitSerial(void);		pascal Boolean 	QuitModalFilter(DialogPtr theDialog ,EventRecord *event,short *itemhit);int				VerifSTDlog(void);int 			VerifTexteDlog(SousTitreRecordPtr* Start,SousTitreRecordPtr* End );int     		Preferences(void);pascal OSErr	launchSFG(void);pascal void 	QuitSansFauteGrammaire(void);pascal void 	ActiveSansFauteGrammaire(void);pascal void	 	HandleMenuAV(short menuItem);void	 	DessineBarreControlListing(void);int			EnTeteDuFilm(void);int			DoRechercheST(short flag );int			C_ConfigureToucheFonctions(void);int			RechercheRemplacementTexte(void);int			C_Suppression_SousTitre(void);int	   		DecalageTexte(void);void 	  	ConcatenerFichier(void);void		GetMyMenuPrefFile(void );int 		OffsetLectureTC(void);int  		ChangeFontStylDlog(void);extern 		SeqGrabComponent 	gSeqGrabber;void 		FlashTrackingSaisie(void);void 		C_TestDrawFastChar(void);void 		C_TestDrawChar(long face, long border,long shadow, long mask);int       	ChangeJustifListDlog(void);void 		C_ClearVx (void);pascal void Test_Draw_String(void);DialogPtr 	OpenPreferenceAffichageDlog(void);void		QT_SetTC_Offset(void);void	 	QT_MenuCommand(long  myMenuItem);void		QT_UpdateQTList(void); // maj list quicktimeshort 		QT_UpdateQTCaption(long AbsStNum);int       	DoDialogCacheST(void);int 		DoDialogOffset(void);extern DialogPtr 	gDialogProchainSousTitre;extern Boolean 		gDone;/* ------------------------------*/pascal void	Adjust_BB_Menu(void){WindowPtr	FrontMost;MenuHandle	menu;EventRecord	event;short		TheRefNum;long			TheFreeByte,A;Boolean  		FlagEdit;TEHandle		te=nil;/* on regarde s'il y a des modifiers */		EventAvail(-1,&event);		FrontMost=(WindowPtr)BB_FrontNonFloatingWindow();				menu=GetMenuHandle(133);			CheckItem(menu,1,false);		CheckItem(menu,2,false);		CheckItem(menu,3,false);	/* on allume l'item choisi */		A=G.SaisieModePreferenciel;		if (A==3) A=2;		SetItemMark(menu,A,'');/* le hard tracking */		if (G.Preference_Tracking&1) 			CheckItem(menu,4,true);		else			CheckItem(menu,4,false);		if (G.Preference_Tracking&2) 			CheckItem(menu,5,true);		else			CheckItem(menu,5,false);											GetMyMenuPrefFile();/* menu fentre */		menu=GetMenuHandle(132);		CheckItem(menu,9,G.General_Preference_DessinGris);		if (G.General_Preference_DessinGris) 			CheckItem(menu,9,true);		else			CheckItem(menu,9,false);/* le menu fichier */		menu=GetMenuHandle(129);		EnableItem(menu,1);		DisableItem(menu,11);#ifndef  __NoProtect__		/*; $200 (N19) +$100(CMC) */		if (!G.FindFirstKey_error) 			if ( G.Options_dansLaClef&0x300)  EnableItem(menu,11);#endif#ifdef  __NoProtect__		EnableItem(menu,11);#endif	#ifdef  __Demo__		EnableItem(menu,11);#endif/* La fonction Eject */			DisableItem(menu,9);			if ( GetVInfo(1,nil,&TheRefNum,&TheFreeByte) )  DisableItem(menu,9);				else EnableItem(menu,9);			/* ------------- ADJUST THE EDIT MENU ------------- */		menu=GetMenuHandle(130);				DisableItem(menu,12);		DisableItem(menu,14);		DisableItem(menu,15);		if (G.General_NombreST ==1){			DisableItem(menu,12);			DisableItem(menu,14);			DisableItem(menu,15);		} else {			EnableItem(menu,12);			EnableItem(menu,14);			EnableItem(menu,15);		}/* on regarde s'il y a un texte edit ouvert */		FlagEdit=false;					if (  (G.BlockNoteTE)	||			 (G.saisieTE)	||			 (G.ListingTE)  ){			 			if ( 	FrontMost==(WindowPtr)G.BlockNoteWindow){	FlagEdit=true; 	te=G.BlockNoteTE; }			if ( 	FrontMost==(WindowPtr)&G.DialogSaisie)	{	FlagEdit=true;	te=G.saisieTE; }			if ( 	FrontMost==(WindowPtr)&G.ListingWindow){	FlagEdit=true;	te=G.ListingTE; }		} // s'il y a un te ouvert		if (FlagEdit){			EnableItem(menu,4);			EnableItem(menu,5);			EnableItem(menu,6);			EnableItem(menu,7);						if ((**te).selEnd-(**te).selStart){				EnableItem(menu,9);				EnableItem(menu,10);			} else {				DisableItem(menu,9);				DisableItem(menu,10);			}						} else {			DisableItem(menu,4);			DisableItem(menu,5);			DisableItem(menu,6);			DisableItem(menu,7);			DisableItem(menu,9);			DisableItem(menu,10);		}		/* ------------- ADJUSTEMENT DU MENU FENETRE ------------- */		menu=GetMenuHandle(132);						if (G.General_Preference_DessinGris)			CheckItem(menu,17,true);		else			CheckItem(menu,17,false);			if (G.affiche_CR_Flag)			CheckItem(menu,18,true);		else			CheckItem(menu,18,false);	AdjustMenuUndo();			DrawMenuBar();			} // adjust_Menu					pascal void DoMenuCommand( long  menuResult){GrafPtr	saveport;short	MenuItem=LoWord(menuResult);short	MenuID=HiWord(menuResult);		GetPort(&saveport);		switch(MenuID) {					case	128:	//AppleMenu					DoAppleMenu(MenuItem);			break;			case	129://FileMenu					DoFileMenu(MenuItem);			break;			case	130://EditMenu					DoEditMenu(MenuItem);			break;			case	131://DiversMenu					DoListeMenu(MenuItem);			break;			case	132://fenetreMenu					DoFenetreMenu(MenuItem);			break;			case	133://Mode					DoModeMenu(MenuItem);			break;			case	136://QuickMenu					DoQuickOpenMenu(MenuItem);			break;						case	137:// menu quicktime					QT_MenuCommand(MenuItem);			break;														// note : le menu 137 (Quicktime) est gŽrŽ directement dans la classe QT				} // switch		SetPort(saveport);	WaitTicks(4);	HiliteMenu(0);}void	DoAppleMenu(short MenuItem){DialogPtr	dialog;short		daRefNum;Str255		daName;		switch (MenuItem){		case	1:	// about				dialog=GetNewDialog(186,nil,(WindowPtr)-1);				DrawDialog(dialog);				do{}while(!Button());				DisposeDialog(dialog);		break;				case	2:	// block note				SelectReferencedWindow((WindowReference)G.BlockNoteWindow);				ShowReferencedWindow	((WindowReference)G.BlockNoteWindow);		break;					/*	case	3:	//  information de license existe 			// on demande les information de license			if (GetLicenseInfo()){			 	h=Get1Resource('STR#',136);				if (h)  ReleaseResource(h);			}			UpdateResFile(gCurResNum);			w=(WindowPtr)&G.BackDropWindow;			SetPort((GrafPtr)w);			InvalRect(&w->portRect);			DoUpdate((WindowPtr)w);			SetPort(StartUpDialog);		break;		*/				default:	/* all non-About items in this menu are DAs */				GetMenuItemText(GetMenuHandle(mApple), MenuItem, &daName);				daRefNum = OpenDeskAcc(daName);		break;			} // switch}	// about menu/*		Menu file*/void	DoFileMenu(short MenuItem){Boolean			doit;short			itemhit;		switch (MenuItem){			case	1:	//new				/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();								/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/			doit=false;			  if (G.ChangeSinceLastSave&0x7fff) { 				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(142,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);					  if (itemhit!=3)	doit=true;				}		  else doit=true;								if (doit) {						EffaceTouslesSousTitres(nil); 						G.CurrentFileType=nil;				// on erase le alias en cours						if (G.aliashandle ) {								DisposeHandle((Handle)G.aliashandle );								G.aliashandle=nil;					  	}					  				// on redessine les fentres					 	SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						DoUpdate((WindowPtr)&G.ListingWindow);					 						 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);								DoUpdate((WindowPtr)&G.DialogSaisie);												if (G.ChenilleWindow){							SetPort((WindowPtr)G.ChenilleWindow);							InvalRect((Rect*)&((GrafPtr)G.ChenilleWindow)->portRect);									DoUpdate((WindowPtr)G.ChenilleWindow);						}						QT_UpdateQTList(); // maj list quicktime																	 	C_SaveData(2);						Alert(154,(ModalFilterProcPtr)nil);	// n'oubliez pas de dŽfinir ....				  } 			break;						case	2:	//file open				/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();									/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/					  if (G.ChangeSinceLastSave&0x7fff) {				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(142,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);					  if (itemhit!=3)	C_DoFileOpen(nil); 				  } else C_DoFileOpen(nil); 			break;						case	5:	//save				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				//SaveData(0);				C_SaveData(0);						break;			case	6:	//save as				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				G.CurrentFileType=nil;				C_SaveData(2);			break;						case	7:	//copie fichier				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				C_FaireCopie_Fichier(&G.CurrentFileName);			break;									case	9:	//eject disquette				  FlushVol(nil,1);				  UnmountVol(nil,1);				  Eject(nil,1);			break;									case	11://export fichier						if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				C_ExportFichier();			break;								case	12://concatŽner avec...				ConcatenerFichier();			break;										case	14://page setup				PageSetup();			break;							case	15://imprime				Imprimer();			break;							case	17://ferme fentre			/* on regarde si c'est une action pour la fentre block note */		 		if ( (BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) &&(G.BlockNoteTE)	)	Close_BlockNoteTE();					if (BB_FrontNonFloatingWindow() ) HideReferencedWindow(BB_FrontNonFloatingWindow());			break;							case	19://quitter					/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();							/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/					  if (G.ChangeSinceLastSave&0x7fff) { 				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(152,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	     C_SaveData(nil);  					  if (itemhit!=3)		 gDone=true; 			  } else gDone=true; 						break;			}// switch}// file menu/* menu Ždition prŽfŽrences etc... */void	DoEditMenu(short MenuItem){Str255		st0;long			offset,longueur;Handle		hDest;		switch (MenuItem) {			 case	1:	// annuler			 		DoUseUndo();			 break;			 case	2:	// refaire			 		DoUseRedo();			 break;			 			 case	4:	//couper				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow ) 					if (G.ListingTE)						if (	(**G.ListingTE).selEnd-(**G.ListingTE).selStart) {									TECut(G.ListingTE);									ZeroScrap();									TEToScrap();									G.ChangeSinceLastSave=1;							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE)						if (	(**G.saisieTE).selEnd-(**G.saisieTE).selStart) {									TECut(G.saisieTE);									ZeroScrap();									TEToScrap();									G.ChangeSinceLastSave=1;									Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractres							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow ) 					if (G.BlockNoteTE)						if (	(**G.BlockNoteTE).selEnd-(**G.BlockNoteTE).selStart) {									TECut(G.BlockNoteTE);									ZeroScrap();									TEToScrap();									G.ChangeSinceLastSave=1;							}			 break;			 case	5:	// copier			 				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow ) 					if (G.ListingTE)						if (	(**G.ListingTE).selEnd-(**G.ListingTE).selStart) {									TECopy(G.ListingTE);									ZeroScrap();									TEToScrap();							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE)						if (	(**G.saisieTE).selEnd-(**G.saisieTE).selStart) {									TECopy(G.saisieTE);									ZeroScrap();									TEToScrap();							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow ) 					if (G.BlockNoteTE)						if (	(**G.BlockNoteTE).selEnd-(**G.BlockNoteTE).selStart) {									TECopy(G.BlockNoteTE);									ZeroScrap();									TEToScrap();							}			 break;			 case	6:	// coller (/!\faire undo SVP)			 				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 					if (G.ListingTE){									hDest=NewHandle(8);									longueur=GetScrap(hDest,'styl',&offset);									if (longueur) TEStylePaste(G.ListingTE);									DisposeHandle(hDest);									G.ChangeSinceLastSave=1;							}				if( BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE){									hDest=NewHandle(8);									longueur=GetScrap(hDest,'styl',&offset);									if (longueur) TEStylePaste(G.saisieTE);									DisposeHandle(hDest);									G.ChangeSinceLastSave=1;									Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractres							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 					if (G.BlockNoteTE){									hDest=NewHandle(8);									longueur=GetScrap( hDest,'styl',&offset);									if (longueur) TEStylePaste(G.BlockNoteTE);									DisposeHandle(hDest);									G.ChangeSinceLastSave=1;							}			 break;			 			 case	7:	// tout sŽlectionner			 	if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 						if (G.ListingTE){									TESetSelect(0,32767,G.ListingTE);							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE){									TESetSelect(0,32767,G.saisieTE);							}				if(  BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 					if (G.BlockNoteTE){									TESetSelect(0,32767,G.BlockNoteTE);						}			 break;			 			 //------------------------------			 			 case 9: // passez la sŽlection en majuscule			 if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 						if (G.ListingTE)ChangeSelectionEnCoursMajuscule(G.ListingTE);				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 						if (G.saisieTE)ChangeSelectionEnCoursMajuscule(G.saisieTE);				if(  BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 						if (G.BlockNoteTE)ChangeSelectionEnCoursMajuscule(G.BlockNoteTE);			 break;			 			 			 case 10: // passez la sŽlection en majuscule			 	if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 						if (G.ListingTE)ChangeSelectionEnCoursMinuscule(G.ListingTE);				if(  BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 						if (G.saisieTE)ChangeSelectionEnCoursMinuscule(G.saisieTE);				if(  BB_FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 						if (G.BlockNoteTE)ChangeSelectionEnCoursMinuscule(G.BlockNoteTE);			 break;			 			 			 //------------------------------			 			 case	12:	// insŽrer en tte de film						if (G.ListingTE) {								  SetPort((WindowPtr)&G.ListingWindow);								  TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);								  TEDispose(G.ListingTE);								  G.ListingTE=nil;								  InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						 }		  						TransfertSaisieMemoire();						DrawSt_enCourDansListing();			 			Insert_Before();										/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);											 break;			 case	13:	// insŽrer un sous-titre			 			if (G.ListingTE) {								 SetPort((WindowPtr)&G.ListingWindow);								 TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);								 TEDispose(G.ListingTE);								 G.ListingTE=nil;								 InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						 }						TransfertSaisieMemoire();							C_InsertSt(C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour),32);							CentreListingWindow();							UpdateSaisie();				 break;			 			 case	14:	// effacer un sous-titre							C_ConvertiNumST_String( (C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour))->st_NumeroST,&st0);			 				ParamText(&st0,nil,nil,nil);			 				if (Alert(203,(ModalFilterProcPtr)nil)==2) {				  								 if (G.ListingTE) {									 SetPort((WindowPtr)&G.ListingWindow);									 TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);									 TEDispose(G.ListingTE);									 G.ListingTE=nil;									 InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);								 }	 								 TransfertSaisieMemoire();								 C_DeleteST(C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour));								 								 QT_UpdateQTCaption(G.General_SousTitreEncour); // on actualise la liste								 CentreListingWindow();								 UpdateSaisie();															}			 break;			 case	15:	// supprimer un groupe de sous-titre			 			if (G.ListingTE) {							SetPort((WindowPtr)&G.ListingWindow);							TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);							TEDispose(G.ListingTE);							G.ListingTE=nil;							InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						}						TransfertSaisieMemoire();						DrawSt_enCourDansListing();						C_Suppression_SousTitre();			 break;			 			 case	17:	// En tte du film						EnTeteDuFilm();		 					 	/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);											 break;			 case	18:	// prŽf de travail						Preferences();		 					 	/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);							 break;					 case 20: // configuration touche fonctions					 C_ConfigureToucheFonctions();			 break;		} // switch}/* menu listes de fonctions sur la liste de sous-titre */void DoListeMenu(short MenuItem){SousTitreRecordPtr start,end;		switch (MenuItem) {		case	1:	// recherche sous-titre			DoRechercheST(0); // selecteur sur saisie 0= listing 1= saisie		break;				case	3:	// recherche de texte			RechercheRemplacementTexte();		break;				case	5:		//	dŽcaler du texte			 DecalageTexte();		break;							case	7:	//	changer le style dans liste			//ChangeStyle_FontDialog();			 ChangeFontStylDlog();			QT_UpdateQTList();		break;							case	8:	//	changer la justification dans liste			ChangeJustifListDlog();			QT_UpdateQTList();		break;											case	9:	//	changer le cache dans liste			//!!!!!!!!! a refaire			//Configuration_CacheSurZone();			DoDialogCacheST();		break;							case	11:	//	offset			// a refaire			DoDialogOffset();			QT_UpdateQTList();		break;				/*case	12:	//	modifier durŽe st (fct supprimŽ pour l'instant)			AugmenteDureeTcListe();		break;	*/				case	13:	//	RenumŽroter la liste				if (Alert(135,(ModalFilterProcPtr)nil)==1) {						C_RenumerotationListeSousTitre(	G.General_PremierSTPtr);						G.ChangeSinceLastSave=true;						SetPort((GrafPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						SetPort((GrafPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);				}		break;						case 15:						VerifSTDlog();		break;										case 16:						/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();						if (VerifTexteDlog( &start,&end) )	VerifieTexteListeSousTitre( start, end);		break;					} // switch}/* ouvre la fentre sŽlectionnŽe */void	DoFenetreMenu(short MenuItem){Rect	rect;	WindowPtr	w1;short			i,j,x;		switch (MenuItem) {				case	1:		// home	on range les fentres					if (BB_FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) {											C_GETMAINSCREENRES(&rect);						w1=(WindowPtr)&G.DialogSaisie;						i=(w1->portRect.right)-(w1->portRect.left);						j=(w1->portRect.bottom)-(w1->portRect.top);						x=(rect.right-rect.left)-i;						x=x/2+rect.left;						MoveWindow((WindowPtr)&G.ListingWindow,x,40+rect.top,false);						SizeWindow((WindowPtr)&G.ListingWindow,i,rect.bottom-3-j-60,true);						Adjust_ListingScrollBar();								}					if (BB_FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie) {											C_GETMAINSCREENRES(&rect);						w1=(WindowPtr)&G.DialogSaisie;						i=(w1->portRect.right)-(w1->portRect.left);						j=(w1->portRect.bottom)-(w1->portRect.top);						x=(rect.right-rect.left)-i;						x=x/2+rect.left;						MoveWindow((WindowPtr)&G.DialogSaisie,x,rect.bottom-j-3,false);					}																break;				case	3:		// listing					SelectReferencedWindow((WindowReference)&G.ListingWindow);					ShowReferencedWindow	((WindowReference)&G.ListingWindow);				break;			case	4:		// saisie					SelectReferencedWindow((WindowReference)&G.DialogSaisie);					ShowReferencedWindow	((WindowReference)&G.DialogSaisie);				break;			case	5:		// ex simulation maintenant quictime					/*if (gMonitor) {						SelectReferencedWindow((WindowReference)gMonitor);						ShowReferencedWindow((WindowReference)gMonitor);					}*/		break;			case	6:		// Bloc-note					SelectReferencedWindow((WindowReference)G.BlockNoteWindow);					ShowReferencedWindow	((WindowReference)G.BlockNoteWindow);				break;			case	7:		// telecommande					SelectReferencedWindow((WindowReference)G.TELECOMMANDEWindow);					ShowReferencedWindow((WindowReference)G.TELECOMMANDEWindow);				break;			case	8:		// palette verification liste					SelectReferencedWindow((WindowReference)G.ErrorsWindow);					ShowReferencedWindow((WindowReference)G.ErrorsWindow);				break;							case	9:		// palette chenille					SelectReferencedWindow((WindowReference)G.ChenilleWindow);					ShowReferencedWindow((WindowReference)G.ChenilleWindow);				break;			case	10:		// palette prochain sous-titre					SelectReferencedWindow((WindowReference)gDialogProchainSousTitre);					ShowReferencedWindow((WindowReference)gDialogProchainSousTitre);				break;			case	11:		// infos techniques					SelectReferencedWindow((WindowReference)G.ServiceWindow);					ShowReferencedWindow((WindowReference)G.ServiceWindow);				break;							/*		case	12:		//ex  rŽglages simu // reglage quicktime					//SelectReferencedWindow((WindowReference)gDialogReglageSimu);					//ShowReferencedWindow((WindowReference)gDialogReglageSimu);				break;			*/				case	12/*13*/:		// logo Bon Bougre					SelectReferencedWindow((WindowReference)G.LogoWindow);					ShowReferencedWindow((WindowReference)G.LogoWindow);				break;							/*			case	14:		// palette karaoke					if (gPaletteKaraoke){					SelectReferencedWindow((WindowReference)gPaletteKaraoke);					ShowReferencedWindow((WindowReference)gPaletteKaraoke);						}			break;				case	15:		// palette gtestDecodageWindow					if (gtestDecodageWindow){					SelectReferencedWindow((WindowReference)gtestDecodageWindow);					ShowReferencedWindow((WindowReference)gtestDecodageWindow);						}			break;				*/// rŽglages pour la fentre listing						case	15:		// tracŽ des zones dans listing					if (G.General_Preference_DessinGris) G.General_Preference_DessinGris=0;					else	G.General_Preference_DessinGris=true;										SetPort((GrafPtr)&G.ListingWindow);					InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);		break;					case 16:					if (G.affiche_CR_Flag) G.affiche_CR_Flag=0;					else	G.affiche_CR_Flag=true;					SetPort((GrafPtr)&G.ListingWindow);					InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);		break;				}//switch} //DoFenetreMenuvoid DoModeMenu(short MenuItem){GrafPtr			savePort;		/* si choix mode de travail */		if (MenuItem>=1 && MenuItem<=2) {						if (G.ListingTE) {							SetPort((WindowPtr)&G.ListingWindow);							TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);							TEDispose(G.ListingTE);							G.ListingTE=nil;							InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						}						TransfertSaisieMemoire();	// patch pour comptabilitŽ avec ancien code ou aucun mode pref = 3						if (MenuItem==2) MenuItem=3;						G.SaisieModePreferenciel=MenuItem;		}				if (MenuItem==4) {			if (G.Preference_Tracking&1) {				G.Preference_Tracking=G.Preference_Tracking&2;			} else {				G.Preference_Tracking=G.Preference_Tracking|1;			}			GetPort(&savePort);			SetPort((GrafPtr)&G.ListingWindow);			FlashTracking();			AfficheTrackingStatus();			DessineBarreControlListing();			SetPort((GrafPtr)savePort);					}						if (MenuItem==5) {			if (G.Preference_Tracking&2) {				G.Preference_Tracking=G.Preference_Tracking&1;			} else {				G.Preference_Tracking=G.Preference_Tracking|2;			}						GetPort(&savePort);			SetPort((GrafPtr)&G.DialogSaisie);			FlashTrackingSaisie();			SetPort((GrafPtr)savePort);		}}void DoQuickOpenMenu(short MenuItem){Boolean		doit;short		itemhit;long			L;				/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();								/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/				doit=false;			  	if (G.ChangeSinceLastSave&0x7fff) { 				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(142,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);					  if (itemhit!=3)	doit=true;				}		  else	 doit=true;								if (doit) {						EffaceTouslesSousTitres(nil); 						G.CurrentFileType=nil;				// on erase le alias en cours						if (G.aliashandle ) {								DisposeHandle((Handle)G.aliashandle );								G.aliashandle=nil;					  	}					  					  /* on recupre le pointeur du fss dŽcrivant le fichier dŽsignŽ */						HLock(G.QuickOpenHandle);						L=( (MenuItem-1)*70 );					  	L=L+(long)*G.QuickOpenHandle;						C_DoFileOpen((FSSpecPtr)L);					  	HUnlock(G.QuickOpenHandle);				// on redessine le fentre					 	SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						DoUpdate((WindowPtr)&G.ListingWindow);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);								DoUpdate((WindowPtr)&G.DialogSaisie);				  } }pascal Boolean QuitModalFilter(DialogPtr theDialog ,EventRecord *event,short *itemhit){OSErr		result;short		the_itemType,part,dh,dv;Handle		the_Handle;Rect		Rectangle;WindowPtr	window;Point		The_point;unsigned char		key;		result=false;			switch (event->what ) {		case mouseDown:			part = FindWindow(event->where, &window);						switch ( part ) {			case inContent:			SystemClick	(event,window);  //let the system handle it			break;//						case inDrag:                /* pass screenBits.bounds to get all gDevices */					if	(window==(WindowPtr)BB_FrontNonFloatingWindow()) {					GivescreenBits(&Rectangle);	//QD.screenbit bounds					DragWindow(window, event->where,&Rectangle); //&QD.screenbit bounds); //					result=true;					}					break;			}							break;		case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;			if ( (event->modifiers & optionKey)&&(key<32)) {	/* option key down */				if ( (event->modifiers & (shiftKey))) {	/* shift key down */// on bouge la fentre par 20							switch	(key){					case 30:						dv=-20;						dh=0;					break;					case 31:						dv=20;						dh=0;					break;					case 28:						dv=0;						dh=-20;					break;					case 29:						dv=0;						dh=20;					break;					}				} else {// on bouge la fentre par 1								switch	(key){					case 30:						dv=-1;						dh=0;					break;					case 31:						dv=1;						dh=0;					break;					case 28:						dv=0;						dh=-1;					break;					case 29:						dv=0;						dh=1;					break;						}				}// on dŽplace la fentre				window=(WindowPtr)BB_FrontNonFloatingWindow();			SetPort(window);			The_point.v=window->portRect.top+dv;			The_point.h=window->portRect.left+dh; 			LocalToGlobal(&The_point);			MoveWindow(window,The_point.h,The_point.v,false);				result=false;				}	else {			switch(key) {			case 3:			case 13:			GetDialogItem((DialogPtr)BB_FrontNonFloatingWindow(),1,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=1;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);								}				break;				case 'N':			case 'n':			GetDialogItem((DialogPtr)BB_FrontNonFloatingWindow(),2,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=2;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);								}				break;												case 27:	// on vŽrifie que c'est un  bouton 				GetDialogItem((DialogPtr)BB_FrontNonFloatingWindow(),3,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=3;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);				}				break;						} //switch			} //else			break;														case activateEvt:			break;				case updateEvt:		if (event->message!=(long)theDialog)	 DoUpdate((WindowPtr)event->message);				// do the Bbou update		else {					DrawDialog(theDialog);				}		break;					}	//	switch		return (result);}		/*ce code permet de demander une valeur pour une fonctiondialog=GetNewDialog(170,nil,(WindowPtr)-1);					SetPort(dialog);										BeginUpdate(dialog);					DrawDialog(dialog);					EndUpdate(dialog);										GetDialogItem(dialog,1,&itemType,&item,&box);					InsetRect(&rect,-4,-4);					PenSize(3,3);					FrameRoundRect(&rect,16,16);					PenNormal();					NumToString((long)G.HauteurST,&st0);					GetDialogItem(dialog,2,&itemType,&item,&box);					SetDialogItemText(item,&st0);										do {						ModalDialog((ModalFilterProcPtr) nil,&itemhit);						}while (itemhit !=1);										GetDialogItem(dialog,2,&itemType,&item,&box);					GetDialogItemText(item,&st0);					StringToNum(&st0,&num);										G.HauteurST=(short)num;					DisposeDialog(dialog);							w=(WindowPtr)&G.ListingWindow;					SetPort(w);					InvalRect( &w->portRect);*/