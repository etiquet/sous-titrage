	PRINT	PUSH,OFF			 	INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a';	INCLUDE	'types.a' 	INCLUDE	'QuickEqu.a' 	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'	 	INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	PRINT	POP					IMPORT	QD:MyQDGlobals		IMPORT	G:AppGlobals		; cette routine permet de tester la validitée des import de reférence entre routine MPW_asm et Metrowerk_CTestAdresseGlobales_conv 	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointstructure		ds.l	1					; p2				ds.l	1					; ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR								WITH	StackFrame,Rect		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				move.l	structure(a6),a0				lea		QD.dkGray,a1				move.l	a1,(a0)				lea		G.spareForFutur,a1				move.l	a1,4(a0)				move.l	p2(A6),a2				lea		G.performanceTask,a1				move.l	A1,(a2)				lea		G.AskTcTask,a1				move.l	A1,4(a2)				lea		G.Rechercher_STR,a1				move.l	A1,8(a2)				lea		G.EveHandle,a1				move.l	A1,12(a2)				lea		G.versionLogiciel,a1				move.l	A1,16(a2)				lea		G.Justification,a1				move.l	A1,20(a2)				lea		G.SoftProtect,a1				move.l	A1,24(a2)				lea		G.CurrentFileName,a1				move.l	A1,28(a2)							UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)				DbgInfo.new	TestAdresseGlobales_conv			; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE		ImportationFichierAscii()* ================================================				StackFrameImportationFichier	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètreOpenErr				ds.W	1	; erreur retournée par read	BufferTransfer		ds.l	1	; Adresse du début	de la zone TemporaireBufferSize			ds.l	1	; taille de la zone temporaire SizeOfRead			ds.l	1	; Position du dernier caractètre luvRefNumstore		ds.l	1	; buffer reply ffsFileLenth			ds.l	1SpecialParamSize			EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkreply				ds.l	1TheDialogPtr		ds.l	1	; le dialogMaxBuffer			ds.l	1	; adresse haute du bufferPointeur			ds.l	1	; pointeur en coursDebutZoneTexte		ds.l	1	; FinDeZoneTexte		ds.l	1	; DebutHeader			ds.l	1	; adresse du début du Header en coursFinHeader			ds.l	1	;	pointeurFinHeaderCourantbuff1				ds.b	256	; buffer temporaire	n°1fichierType			ds.w	1	; type de fichierbuff2				ds.b	16	;16 octets pour le nombre st lusTcIn				ds.l	1	;stockage	du tc inTcOut				ds.l	1	;stockage	du tc outNumST				ds.l	1	;Numéro du sous-titreErreur				ds.w	1	;Type d'erreur dans sous-titreItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLongueurFichier		ds.w	1		; case pour stocker la longueur du fichier/256LastXpos			ds.w	1CursorCount			ds.w	1cursorLevel			ds.l	1TypeAscii			ds.w	1		; emplacement pour stocker le type de fichier ascii lutexteStyle			ds.b	12		; style pour texte tebuff3						ds.b	128		; buffer temporaire	n°3 ; pour stocker les commentairesbuffCommentaire				ds.b	128		; sauvegarde des commentairesTypeDeCreateurDuFichier		ds.w	1	; 0=mac 1=pc; variable pour la norme N19BlockGSI					ds.b	1024	; recopie block  gsi pour norme N19PopUp_PaysOrigine			ds.l	1		; menu pays d'origineNombreTotalDisquette		ds.w	1		; le nombre total de disquettes pour ce filmNombreTotalTTI				ds.w	1		; le nombre total de block TTI pour cette disquetteNombreTotalST				ds.w	1		; le nombre total de sous-titre pour cette disquetteNombreTotalGroupeST			ds.w	1		; le nombre total de Groupe de sous-titre ""      ""PointeurFichier				ds.l	1		; pointeur dans le fichierNumeroOrdreDisquette		ds.w	1		; le numéro d'ordre de la disquetteRGB_Color					ds.w	3		; pour gérer des couleursTotalLigneGSI				ds.w	1		; pour gérer des couleursSpecialLocalSize	EQU 	*			; size of all the local variables		ENDR		ImportationFichierAscii	 	PROC	EXPORT			; any source file can use this routine				WITH	StackFrameImportationFichier,StandardFileReply,SFReply,SOUSTITRERECORD		; cover our local stack frame				LINK	A6,#SpecialLocalSize		; allocate our local stack frame		clr.w	fichierType(a6)	; raz				import	EffaceTouslesSousTitres,FindFrameType_Ascii_CMC,\				ConversionNumeroSTPointeur,TraitementErreurFichier,InsertST,\				CentreListingWindow,AFFICHENUMSAISIE,\				TransfertMemoireSaisie,CalculDuree,Waitaicks,WaitTicks,DrawWindow,\				INITCURSORCTL,ROTATECURSOR,Show_cursor,SpinCursor,CONVERSIONChar,\				FindFrame_NormeN19,ConversionN19_bonBougre,Rafraichi_Curseur,\				ConversionFichierAscii_BonBougre		move.l	vRefNumstore(a6),a0		add.l	#6,a0		move.l	a0,Reply(a6)						move.l	FileLenth(a6),d0		lsr.l	#3,d0		move.w	d0,LongueurFichier(a6)						; on calcule l'adresse haute du buffer tampon		move.l	BufferTransfer(a6),d0		add.l	SizeOfRead(a6),d0		move.l	d0,MaxBuffer(a6)		; dans ce cas on ne dépasse pas la longueur lue; on commence par tester de quel format de fichier ascii,il s'agit; format CMC ou Ascii ?		move.l	BufferTransfer(a6),Pointeur(a6)			DetectionFormatType_Ascii_Cmc_Loop		move.l	Pointeur(a6),a0		move.l	a0,DebutHeader(a6)		bsr		FindFrameType_Ascii_CMC	; on cherche s'il s'agit d'un fichier de type traitement de texte		tst.l	d0		beq.s	TrouveAsciiType_2					move.l	Pointeur(a6),d0		add.l	#1,d0		cmp.l	MaxBuffer(a6),d0		bge.s	PasTrouveFormat_AScii				move.l	d0,Pointeur(a6)		bra.s	DetectionFormatType_Ascii_Cmc_Loop; ----; on n'a pas trouvé de header type ASCII ou CMC dans la liste 	PasTrouveFormat_AScii; est ce du N19 ?		move.l	BufferTransfer(a6),Pointeur(a6)	; on recommence au début		move.l	Pointeur(a6),a0		move.l	a0,DebutHeader(a6)		jsr		FindFrame_NormeN19	; on cherche s'il s'agit d'un fichier de type traitement de texte		cmp.l	#-1,d0		bne.s	Trouve_NormeN19		; N19 ok; ----		; pas N19;       on informe l'utilisateur que nous ne pouvons pas utiliser ce type de fichierPasTrouveFormat		clr.w	-(sp)		move.w	#143,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		bra		Exit		; …………………………………………………………………………………………………………………………; c'est la norme N19-1991; Il est préférable pour des raisons de lisibilité; que ce module de conversion soit dissocié de cette routineTrouve_NormeN19;		Pea		#'break conversion BB';  		_DebugSTR		;move.l	Paramblock(a6),-(sp)		;move.l	reply(a6),-(sp)				import	ConversionN19_bonBougre		jsr		ConversionN19_bonBougre		bra		Exit		; --------------------------------------------; C'est un fichier ASCII ou CMC on le convertiTrouveAsciiType_2:		jsr	ConversionFichierAscii_BonBougre; ----------------------------------------------		ExitDialog	; on rempli la colone jusqu'au bout	:				cmp.w	right+itemRect(a6),d1		subq.w	#2,d1		move.w	LastXpos(a6),d5		move.w	top+itemRect(a6),d7		add.w	#1,d7		move.w	bottom+itemRect(a6),d6		sub.w	#1,d6		loopfintracage		addQ.w	#1,d5		cmp.w	d1,d5		bgt.s	OnFerme		move.w	left+itemRect(a6),d2		add.w	d5,d2		add.w	#1,d2		; on dessine la reglette		move.l	#CyanColor,-(sp)		_ForeColor		move.w	d2,-(sp)		move.w	d7,-(sp)		_MoveTo		move.w	d2,-(sp)		move.w	d6,-(sp)		_LineTo				bra.s	loopfintracage; ----------------------------------------------------------OnFerme		move.l	TheDialogPtr(a6),-(sp)		_DisposDialogExit		pea		G.ListingWindow		_setPort				lea		G.ListingWindow,a0		pea		portRect(a0)		_InvalRect				pea		G.DialogSaisie		_setPort				lea		G.DialogSaisie,a0		pea		portRect(a0)		_InvalRect						moveq	#0,d1; on sort de la en remettant le curseur standart			move.l	d1,d7		move.w	#$0505,-(sp)			jsr		Show_cursor		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#SpecialParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ConversionAsciimemoire		; this name will appear in the debugger		align 4			ENDP* ===============================================*	Procedure	FindFrameType_Ascii_CMC()* ===============================================; Cette procédure recherche à partir du pointeur dans a0; une chaine de caractère correspondant à l'ascii type traitement de textes.; et retourne s'il elle est valide tous les paramètre dans les cases pointées par (a6); D0 contient 0 si chaine valide, si non <>0FindFrameType_Ascii_CMC	proc 	export						import	ConversionASCIIbcdTc,ConversionTimeCode_Trames,ConversionTrames_TimeCode			WITH	StackFrameImportationFichier,StandardFileReply,SFReply,SOUSTITRERECORD	; on utilise le même stackframe			lea		buff1(a6),a1			; on commence par regarder s'il y a des chiffres suivit d'un délimiteur	ou d'une lettre			moveq	#0,d2			loopNumeroST:			move.b	(a0,d2.w),d0			cmp.b	#'-',d0			beq.s	OnAtrouveNumeroSecondaire			cmp.b	#')',d0			beq 	OnAtrouveDelimiteurChiffre			cmp.b	#':',d0			beq 	OnAtrouveDelimiteurChiffre			cmp.b	#'.',d0			beq 	OnAtrouveDelimiteurChiffre			cmp.b	#' ',d0			beq 	OnAtrouveDelimiteurChiffre			; on regarde si c'est une lettre; lettre majuscule			cmp.b	#'A',d0			blo.s	loopNumeroST_NotfoundLettre			cmp.b	#'Z',d0			blt.s 	OnAtrouveNumeroSecondaire			; lettre minusclule			cmp.b	#'a',d0			blo.s	loopNumeroST_NotfoundLettre			cmp.b	#'z',d0			blt.s 	OnAtrouveNumeroSecondaire			loopNumeroST_NotfoundLettre						cmp.b	#'0',d0			blo 	Exit		; erreur de trame			cmp.b	#'9',d0			bhi 	Exit		; erreur de trame						move.b	d0,1(a1,d2.w)			addq.w	#1,d2			cmp.w	#6,d2			blo.s	loopNumeroST			moveq.l	#-1,d0			bra  	Exit	; trop de chiffres, donc n° pas valide					; on a trouver un numéro secondaire donc on effectue le traitement du n° principalOnAtrouveNumeroSecondaire											cmp.w	#4,d2			blo 	Exit			; si d2<4 => s'il y a moin de 3 chiffres à la suite, ce n'est pas le nul de sous-titre on ne fait rien, car sinon _Pack7 plante			move.b	d2,(a1)			move.l	d2,d7			move.l	a0,a4			move.l	a1,a0 			Move.w	#1,-(sp)	; selecteur StringToNum			_Pack7			move.l	d0,NumST(a6)	; on place le numéro de sous-titre						move.l   d7,d2    			move.l   a4,a0	; on récupère					add.l	#1,d2	; on passe au caractère suivant			moveq	#0,d6			loopNumeroSecondaireST:			move.b	(a0,d2.w),d0			cmp.b	#')',d0			beq.s	finNumSecondaire			cmp.b	#':',d0			beq.s	finNumSecondaire			cmp.b	#'.',d0			beq.s	finNumSecondaire			cmp.b	#' ',d0			beq.s	finNumSecondaire			cmp.b	#'A',d0			blo.s	pasUneLettre			and.b	#$5f,d0	; majuscule =minuscule			cmp.b	#'Z'+1,d0			blo.s	UneLettrepasUneLettre						cmp.b	#'0',d0			blo 	pblNumSecondaire						cmp.b	#'9',d0			bhi.s 	pblNumSecondaire	; donc un chiffre						move.b	d0,1(a1,d6.w)			addq.w	#1,d2			addq.w	#1,d6			bra  	loopNumeroSecondaireST				pblNumSecondaire											addq.w	#1,d2			blo.s	loopNumeroSecondaireST			; on a trouvé une lettre	on fait la conversion lettre => chiffre			UneLettre						sub.b	#$40,d0			ror.l	#8,d0			and.l	#$ff000000,d0			add.l	d0,NumST(a6)			bra		attendUnChiffre_1	; on cherche maintenant le tc infinNumSecondaire; nous somme à la fin du numéro secondaire donc on fait la conversion			move.b	d6,(a1)			move.l	d2,d7			move.l	a0,a4			move.l	a1,a0 			Move.w	#1,-(sp)	; selecteur StringToNum			_Pack7			ror.l	#8,d0			and.l	#$ff000000,d0			add.l	d0,NumST(a6)			move.l   d7,d2    			move.l   a4,a0	; on récupère				bra		attendUnChiffre_1							; on a trouvé une trame de type x...x) OU xxxxx: ou xxxxxx., où x = chiffre	 avec la possibilité de xxxxx-x+sépaprateur		; il y de forte chance que ce soit le n° de sous-titre; dans ce cas on effectu une conversion ascci => numOnAtrouveDelimiteurChiffre			cmp.w	#3,d2			blo 	Exit			; si d2<4 => s'il y a moin de 3 chiffres à la suite, ce n'est pas le nul de sous-titre on ne fait rien, car sinon _Pack7 plante			move.b	d2,(a1)						move.l	d2,d7			move.l	a0,a4						move.l	a1,a0 			Move.w	#1,-(sp)	; selecteur StringToNum			_Pack7			move.l	d0,NumST(a6)	; on place le numéro de sous-titre						move.l   d7,d2    			move.l   a4,a0	; on récupère; ok ; on attend le prochain chiffreattendUnChiffre_1									move.b	(a0,d2.w),d0			cmp.b	#$20,d0			blo		Exiterr		; ou là là,un  caractère de control, je ne comprend rien			cmp.b	#'*',D0			beq.s	trouveUnChiffre_1	; c'est un timecode nul ; on le traite quand même						cmp.b	#'0',d0			blo.s 	attendUnChiffre_1bis		 			cmp.b	#'9',d0			bhi.s 	attendUnChiffre_1bis			bra.s	trouveUnChiffre_1			attendUnChiffre_1bis						add.w	#1,d2			bra.s	attendUnChiffre_1	 ; ok premier chiffre, est-ce un time-code ?; pour le déterminer on regarde s'il y a un format de type: xx:xx:xx:xx  ou xx:xx:xx.xxtrouveUnChiffre_1						move.b	2(a0,d2.w),d0			cmp.b	#':',d0			bne		Exit	; pas un tc			move.b	5(a0,d2.w),d0			cmp.b	#':',d0			bne		Exit	; pas un tc			move.b	8(a0,d2.w),d0			cmp.b	#':',d0			beq.s	CopieTCin			cmp.b	#'.',d0			beq.s	CopieTCin0			bra		Exit	; pas un tc			; il y a une forte propabilité que ce soit un time-code (le gabarit est bon); on copie	le texte dans le bufferCopieTCin0			move.w	#Fichier_TypeCMC,fichierType(a6)CopieTCin			lea		buff1(a6),a1			move.l	#11,d3			move.b	d3,(a1)			lea		(a0,d2.w),a2			subq.w	#1,d3	; on recopie 11 caractères			loopRecopieTC_1							move.b	(a2,d3.w),d0			cmp.b	#':',d0			beq.s	CaractereSeparateurTC_1				cmp.b	#'.',d0			beq.s	CaractereSeparateurTC_1				cmp.b	#'*',d0			beq.s	CaractereSeparateurTC_1			cmp.b	#'0',d0						; on teste si tc valide			blo.s		OnSaitQueLeTcInEstInvalide			cmp.b	#'9',d0			bhi.s		OnSaitQueLeTcInEstInvalide			CaractereSeparateurTC_1						move.b	d0,1(a1,d3.w)			dbra	d3,loopRecopieTC_1; ok bien un format xx:xx:xx:xx; on fait la conversion ascii=> tc formatBcd			 				move.l	d2,d7			move.l	a0,a4	; sauvegarde 						move.l	a1,a0			jsr		ConversionASCIIbcdTc	; pas le même segment			jsr		ConversionTimeCode_Trames			cmp.l	#2160000,d0				; >24 heures ?			blo.s	RechercheTcOut			OnSaitQueLeTcInEstInvalide:; on sait que le tc in n'est pas bon donc on met -1			move.l	#-1,TcIn(a6); mettre à 1 le bit tcin invalide			bra.s	RechercheTcOut_2* -------------------------------------------------------------RechercheTcOut:			jsr		ConversionTrames_TimeCode			move.l	d0,TcIn(a6)RechercheTcOut_2									move.l 	d7,d2      			move.l	a4,a0	; on récupère						add.w	#11,d2; on attend le prochain chiffreattendUnChiffre_2									move.b	(a0,d2.w),d0			cmp.b	#$20,d0			blo		Exiterr		; ou là là,un  caractère de control, je ne comprend rien			cmp.b	#'*',d0			beq.s	trouveUnChiffre_2			cmp.b	#'0',d0			blo.s 	attendUnChiffre_2bis		 			cmp.b	#'9',d0			bhi.s 	attendUnChiffre_2bis						bra.s	trouveUnChiffre_2			attendUnChiffre_2bis						add.w	#1,d2			bra.s	attendUnChiffre_2			; ok premier chiffre, est-ce un time-code ?; pour le déterminer on regarde s'il y a un format de type: xx:xx:xx:xx  trouveUnChiffre_2						move.b	2(a0,d2.w),d0			cmp.b	#':',d0			bne		Exit	; pas un tc			move.b	5(a0,d2.w),d0			cmp.b	#':',d0			bne		Exit	; pas un tc			move.b	8(a0,d2.w),d0			cmp.b	#':',d0			beq.s	CopieTCOut			cmp.b	#'.',d0			beq.s	CopieTCOut			bra		Exit	; pas un tc			; il y a une forte propabilité que ce soit un time-code (le gabarit est bon); on copie	le texte dans le bufferCopieTCOut			lea		buff1(a6),a1			move.l	#11,d3			move.b	d3,(a1)			lea		(a0,d2.w),a2			subq.w	#1,d3loopRecopieTC_2						; on recopie 11 caractères			move.b	(a2,d3.w),d0			cmp.b	#':',d0			beq.s	CaractereSeparateurTC_2				cmp.b	#'.',d0			beq.s	CaractereSeparateurTC_2				cmp.b	#'*',d0			beq.s	CaractereSeparateurTC_2			cmp.b	#'0',d0						; on teste si tc valide			blo.s		OnSaitQueLeTcOutEstInvalide			cmp.b	#'9',d0			bhi.s		OnSaitQueLeTcOutEstInvalideCaractereSeparateurTC_2						move.b	d0,1(a1,d3.w)			dbra	d3,loopRecopieTC_2; ok bien un format xx:xx:xx:xx; on fait la conversion ascii=> tc formatBcd			 				move.l  d2,d7    			move.l 	a0,a4	; sauvegarde 						move.l	a1,a0			jsr		ConversionASCIIbcdTc	; pas le même segment			jsr		ConversionTimeCode_Trames			cmp.l	#2160000,d0			blt.s	RetourChariot			OnSaitQueLeTcOutEstInvalide:; on sait que le tc in n'est pas bon donc on met -1			move.l	#-1,TcOut(a6); mettre à 1 le bit tcin invalide			bra.s	RetourChariot_2; on attend un retour chariot, pour donner le pointeur du texteRetourChariot:			jsr		ConversionTrames_TimeCode			move.l	d0,TcOut(a6)			RetourChariot_2						move.l 	d7,d2    			move.l	a4,a0	; on récupère		 	add.w	#11,d2			move.l	maxBuffer(a6),d1									move.l	a0,a1AttenteRetourChariot:			move.b	(a0)+,d0			beq.s	FindeZoneOk			cmp.b	#$0d,d0			beq.s	FindeZoneOk			cmp.b	#$0a,d0			beq.s	FindeZoneOk			cmp.l	d1,a0						bhi.s	ErreurFinDeFichier			bra.s	AttenteRetourChariotErreurFinDeFichier:exiterr			move.l	#-1,d0			bra.s	ExitFindeZoneOk						; maintenant s'occupe de la chaine commentaire s'il y en a une; a0 pointe sur la fin de la chaine (s'il y en a une ...)									move.l	a0,a1; maintenant on recherche une Lettre comme début de chaine	après un chiffre (lisibilitée)				pasunchiffredanscommentaire						move.b	-(a1),d0 			cmp.b	#'-',d0			beq.s	DebutChaineCommentaire			cmp.b	#'+',d0			beq.s	DebutChaineCommentaire			cmp.b	#'9',d0			bhi.s	pasunchiffredanscommentaire			cmp.b	#'0',d0			blo.s	pasunchiffredanscommentaire; ok on est sur un chiffre; => a1 debut de la chaine commentaireDebutChaineCommentaire				lea.l	buff3(a6),a2		clr.l	(a2)	; on raz la chaine au cas où il n'y a rien; on cherche maintenant le premier caractères		moveq	#0,d1		moveq	#0,d2findFirstcharOfComm		move.b	(a1),d0		cmp.b	#' ',d0		; caractère de contrôle		blo.s	FinRecopieCommentaire		cmp.b	#$40,d0		; est-ce une lettre		bHI.s	loopRecopieCommentaire1	; oui		adda.l	#1,a1	; non on cherche encore		bra.s	findFirstcharOfCommloopRecopieCommentaire1			loopRecopieCommentaire					move.b	(a1,d1.w),d0		cmp.b	#' ',d0		blo.s	FinRecopieCommentaire			move.b	d0,1(a2,d2.w)				cmp.b	#63,d1		bgt.s	FinRecopieCommentaire		addq.b	#1,d1		addq.b	#1,d2		bra.s	loopRecopieCommentaire		FinRecopieCommentaire			move.b	d2,(a2)		moveq	#0,d0			exit	rts		DbgInfo.new		FindFrameType_Ascii_CMC	; this name will appear in the debugger		align 4						ENDP					* ================================================* PROCEDURE 	TraitementErreurFichier()* ================================================; AFFICHE UNE ALERT POUR INDIQUER LE N° D'ERREUR DE LECTURE SI DIFFÉRENT DE -39 ET 0TraitementErreurFichier		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkBuffer			ds.b	256ItemType 		ds.w	1ItemHandle 		ds.l	1itemRect 		ds		rectTheItemHitalert	ds.w	1TheDialogPtr	ds.l	1LocalSize		EQU 	*					ENDR										WITH	StackFrame,StandardFileReply,SFReply	; on utilise le même stackframe				LINK	A6,#LocalSize		; allocate our local stack frame							TST.W	D0				BEQ		exit2								CMP.W	#-39,D0				beq		exit2												LEA		BUFFER(A6),A0				CLR.W	-(SP)				_PACK7								; ON OUVRE UN DIALOG POUR DIRE À L'UTILISATEUR QU'IL Y A EU UNE ERREUR			clr.l	-(sp)			move.w	#137,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)  			_DrawDialog							move.l	TheDialogPtr(a6),-(sp)			move.w	#6,-(sp)			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	ItemHandle(a6),-(sp)			PEA		BUFFER(A6)			_SetItext			move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	TheDialogPtr(a6),-(sp)			_SetPort					move.w	#3,-(sp)			move.w	#3,-(sp)			_PenSize					pea		itemRect(a6)			move.w	#-4,-(sp)			move.w	#-4,-(sp)			_InsetRect					pea		itemRect(a6)			move.w	#16,-(sp)			move.w	#16,-(sp)			_FrameRoundRect		ModalErreurDisque			clr.l	-(sp)			pea		TheItemHitalert(a6)			_ModalDialog					move.w	TheItemHitalert(a6),d0			cmp.w	#2,d0			beq.s	OnContinuQuandMeme			cmp.w	#1,d0			bne.s	ModalErreurDisque			move.l	TheDialogPtr(a6),-(sp)			_DisposDialog						move.l	#-1,d1			bra.s	Exit			OnContinuQuandMemeOnContinuOk			move.l	TheDialogPtr(a6),-(sp)			_DisposDialogexit2						moveq	#0,d1			bra		exit			Exit					UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.new		TraitementErreurFichier		; this name will appear in the debugger			align 4				endp										* ========================================		* PROCEDURE	CONVERSIONChar(char)			* ========================================			*	D0 char à convertir*	D0 char converti*	si d1=0 pc => mac*   si d1=1 mac => pcCONVERSIONChar 		PROC	EXPORT		movem.l	d2-d3/a0,-(sp)		CMP.B	#126,D0		Blo.S	EXIT	; PAS BESOIN DE CONVERTIR ; gain de temps		cmp.w	#1,d1		bgt.s	Exit	; on ne connait pas ce type de conversion (pour l'instant)				move.l	G.ResourceDATA128,d2		beq.s	Exit		move.l	d2,a0		move.l	(a0),a0		cmp.l	#0,a0		beq.s	Exit		; ok a0 pointeur valide		;recherche du caractères équivalentLoopRecherche				move.b	(a0)+,d2		beq.s	Exit	; pas trouve		move.b	(a0)+,d3		tst.b	d1		bne.s	ConversionMacPc; conversion Pc=> mac		cmp.b	d0,d3		bne.s	LoopRecherche				move.b	d2,d0		bra.s	ExitConversionMacPc				cmp.b	d0,d2		bne.s	LoopRecherche		move.b	d3,d0Exit	movem.l	(sp)+,d2-d3/a0		rts				DbgInfo.new	CONVERSIONChar		align 4			ENDP		* ================================================* PROCEDURE		ExportationDeFichierAscii()* ================================================ExportationDeFichierAscii	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètrereply				ds.l	1ParamSize	EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkBuffer				ds.l	1	; adresse du bufferMaxBuffer			ds.l	1	; adresse haute du bufferPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	48	; buffer temporaire n°2NumST				ds.w	1	;Numéro du sous-titre en coursItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1DateTime			ds		DateTimeRecTheDialogPtr		ds.l	1	; le dialog pour cette routineLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				import	EffaceTouslesSousTitres,FindFrameType_Ascii_CMC,\				ConversionNumeroSTPointeur,TraitementErreurFichier,InsertST,\				CentreListingWindow,AFFICHENUMSAISIE,\				TransfertMemoireSaisie,CalculDuree,Waitaicks,WaitTicks,DrawWindow,\				INITCURSORCTL,ROTATECURSOR,Show_cursor,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR		; on met la date actuelle dans une chaine caractères (buff2)		moveq	#1,d7		move.l	 $20C,d0	; TIME		lea		DateTime(a6),a0		_Secs2Date; CONVERSIONDUJOUR				move.w	day(a6),d0		and.L	#$ff,d0		clr.w	-(sp)		lea		buff2(a6),a0		_Pack7		lea	buff2(a6),a0		lea	buff1(a6),a4		ADDA.L	#1,A4		move.b	(a0),d1		cmp.b	#2,d1		bhs.s	pasBesoinDunZeroEnTete				move.b	#'0',(a4)+				move.b	1(a0),(a4)+		bra.s	recopiemois		pasBesoinDunZeroEnTete			move.b	1(a0),(a4)+		move.b	2(a0),(a4)+ ; on ne prend que les 2 dernier chiffres			recopiemois					move.b	#'/',(a4)+		move.w	month(a6),d0		and.l	#$ff,d0		clr.w	-(sp)		lea		buff2(a6),a0		_Pack7		lea	buff2(a6),a0		move.b	(a0),d1		cmp.b	2,d1		bhs.s	pasBesoinDunZeroEnTetemois				move.b	#'0',(a4)+				move.b	1(a0),(a4)+		bra.s	recopieannee		pasBesoinDunZeroEnTetemois			move.b	1(a0),(a4)+		move.b	2(a0),(a4)+ ; on ne prend que les 2 dernier chiffresrecopieannee				move.b	#'/',(a4)+		move.w	year(a6),d0		and.l	#$FFFF,d0		lea		buff2(a6),a0		clr.w	-(sp)		_Pack7		lea	buff2(a6),a0		move.b	1(a0),(a4)+		move.b	2(a0),(a4)+		move.b	3(a0),(a4)+		move.b	4(a0),(a4)+				lea	Buff1(a6),a0		lea	buff2(a6),a1		suba.l	a0,a4		move.l	a4,d0		move.b	d0,(a0)		jsr		CopySTR	; resultat dans buff2		; on recherche une zone de travail			move.l	G.BufferTransfert,d0			move.l	d0,Buffer(a6)			add.l	G.SIZEBufferTransfert,d0			move.l	D0,MaxBuffer(a6); ok on peut bosser; on recherche quel type de conversion nous avons à exécuter		move.w	G.Preference_TypeExport,d0		case#.w	(d0,if),\		(Fichier_TypeTexte,ExportFichierTexte),\		(Fichier_TypeN19,ExporteFichierN19),\		(Fichier_TypeCMC,ExporteFichierCMC); fichier inconnue donc fichier texte		BRA	ExportFichierTexte		; ---------------------------------------------------------------		ExporteFichierCMC; on ouvre le dialog pour dire à l'utilisateur ce qu nous faisons; on utilise le même Dialogue pour importation fichier ascii				clr.l	-(sp)		move.w	#138,-(sp)		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)		_DrawDialog		move.l	TheDialogPtr(a6),-(sp)		_setPort		; on dit que c'est pour convertir un fichier ASCII				move.l	TheDialogPtr(a6),-(sp)		move.w	#5,-(sp)	; item 5		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea	#'Exportation de fichier au format CMC'		_SetItext; on affiche le type du créateur du fichier 0= mac 1= Ms Dos 						move.l	TheDialogPtr(a6),-(sp)		move.w	#9,-(sp)	; item 9		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem								tst.w	G.Preference_ConvertMsDos		beq.s	CMC_FichierTypeMac				move.l	ItemHandle(a6),-(sp)		pea		#'(Ms-Dos)'		_SetItext		bra.S	CMC_AfficheNomDeFichier		CMC_FichierTypeMac			move.l	ItemHandle(a6),-(sp)		pea		#'     (Mac)'		_SetItext						; on affiche le nom du fichierCMC_AfficheNomDeFichier		move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.l	Reply(a6),-(sp)		_SetItext			; on trace la ligne sous le titre		move.l	TheDialogPtr(a6),-(sp)		move.w	#4,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			_PenNormal			   	move.w	#SrcCopy,-(sp)	   	_TEXTMode			   	move.w	#SrcCopy,-(sp)	   	_PenMode				tst.b	G.Mac.HasCOloRQD 		bne.s	Zob1		_PenNormalZob1						pea		itemRect(a6)		_FrameRect			;on entoure la reglette		move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem						pea		itemRect(a6)		_FrameRect				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#6,d0		move.w	d0,LargeurReglette(a6)		clr.w	LastXpos(a6)				move.w	bottom+itemRect(a6),bottom+rectangle(a6)		subq.w	#2,bottom+rectangle(a6)		move.w	top+itemRect(a6),top+rectangle(a6)		addq.w	#2,top+rectangle(a6)				move.w	left+itemRect(a6),left+Rectangle(a6)		add.w	#2,left+rectangle(a6)		move.l	TheDialogPtr(a6),-(sp)		move.w	#2,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		NombreSTLusRect(a6)		_GetDItem				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem; ok le dialog est ouvert		move.l	paramBlock(a6),a0			move.w	#fsFromStart,ioPosMode(a0)		move.l	#1,ioPosOffset(a0)		_SetFPos; ok on est au début du fichier				move.l	G.General_PremierSTPtr,Pointeur(a6)		clr.w	NumST(a6)* ======================================================; on place le header pour le fichier cmc		move.l	Buffer(a6),a3		move.b	#'0',(a3)+		move.b	#' ',(a3)+		lea		G.Preference_TitreOriginal,a0		move.b	(a0)+,d1		and.l	#$ff,d1		subq.w	#1,d1CMC_RecopieNOmDeFichierLoop				move.b	(a0)+,(a3)+		dbra	d1,CMC_RecopieNOmDeFichierLoop			move.b	#$0d,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header1		move.b	#$0a,(a3)+CMC_PASCR_header1				move.b	#'1',(a3)+		MOVE.B	#$0D,(A3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header2		move.b	#$0a,(a3)+CMC_PASCR_header2				move.b	#'C',(a3)+		move.b	#'.',(a3)+		move.b	#'M',(a3)+		move.b	#'.',(a3)+		move.b	#'C',(a3)+		move.b	#'.',(a3)+		move.b	#$0d,(a3)+		beq.s	CMC_PASCR_header3		move.b	#$0a,(a3)+CMC_PASCR_header3				move.b	#' ',d0		move.w	#31,d1CMC_HeaderLoop3		move.b	d0,(a3)+		dbra	d1,CMC_HeaderLoop3				move.b	#$0D,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header4		move.b	#$0a,(a3)+CMC_PASCR_header4		move.b	#'F',(a3)+		move.b	#'R',(a3)+		move.b	#'A',(a3)+				move.b	#$0D,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header5		move.b	#$0a,(a3)+CMC_PASCR_header5; on place la date de création du fichier c à d maintenant .		LEA		BUFF2(A6),A0		MOVE.B	(a0)+,d1 		and.l	#$ff,d1		subq.w	#1,d1CMC_recopieChaineDATE1		MOVE.B	(A0)+,(A3)+		DBRA	D1,CMC_recopieChaineDATE1		move.b	#$0D,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header6		move.b	#$0a,(a3)+CMC_PASCR_header6		LEA		BUFF2(A6),A0		MOVE.B	(a0)+,d1 		and.l	#$ff,d1		subq.w	#1,d1CMC_recopieChaineDATE2		MOVE.B	(A0)+,(A3)+		DBRA	D1,CMC_recopieChaineDATE2				move.b	#$0D,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header7		move.b	#$0a,(a3)+CMC_PASCR_header7				move.w	#9,d2CMC_RECOPIEHEADERFRAMETCLOOP				LEA	CMC_ChaineTcErrone(PC),A0		MOVE.B	(a0)+,d1 		and.l	#$ff,d1		subq.w	#1,d1CMC_recopieChaineFormatLoop		move.b	(a0)+,(a3)+		dBra	d1,CMC_recopieChaineFormatLoop		move.b	#$0d,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PASCR_header8		move.b	#$0a,(a3)+CMC_PASCR_header8		dbra	d2,CMC_RECOPIEHEADERFRAMETCLOOP				MOVE.L	G.GENERAL_PREMIERSTPTR,Pointeur(a6)			CMC_TransfertFichierLoop		move.l	Pointeur(a6),a4		; on teste s'il il faut mettre le numéro secondaire			tst.w	G.Preference_InclureSousNumero		bne.s	CMC_NumeroSecondaire		; -------------- non pas numeroSecondaire		move.l	st_NumeroST(a4),d0		and.l	#$ffffff,d0		lea		Buff1(a6),a0		clr.w	-(sp)		_Pack7		; on recopie le numéro dans le buffer		lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1; on place en tête de 0		moveq	#4,d4		sub.w	d1,d4		blt.s	CMC_pasbesoindezero1		CMC_metdesZeroDevant1		move.b	#'0',(a3)+		dbra	d4,CMC_metdesZeroDevant1CMC_pasbesoindezero1				subq.w	#1,d1CMC_recopienumLoop1 				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop1		bra.s	CMC_Timecodein;-------------- numerosecondaireCMC_NumeroSecondaire		move.l	st_NumeroST(a4),d0		and.l	#$ffffff,d0		lea		Buff1(a6),a0		clr.w	-(sp)		_Pack7		; on recopie le numéro principal dans le buffer		lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation				and.l	#$ff,d1; on place en tête de 0		moveq	#4,d4		sub.w	d1,d4		blt.s	CMC_pasbesoindezero2		CMC_metdesZeroDevant2		move.b	#'0',(a3)+		dbra	d4,CMC_metdesZeroDevant2CMC_pasbesoindezero2		subq.w	#1,d1CMC_recopienumLoop2 				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop2; on prend le numero secondaire				move.l	st_NumeroST(a4),d0		rol.l	#8,d0		and.l	#$ff,d0		lea		Buff1(a6),a0		clr.w	-(sp)		_Pack7				lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		move.b	#'-',(a3)+CMC_recopienumLoop3				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop3						;----------------- tc inCMC_Timecodein; on place le )		move.b	#':',(a3)+		move.b	#' ',(a3)+;		move.b	#' ',(a3)+		move.l	st_TimeCodeIn(a4),d0		cmp.l	#-1,d0		beq		CMC_TCinInvalide; ok tc in valide				lea		Buff1(a6),a0		jsr		ConversionTCstASCII				lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1CMC_recopienumLoop4				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop4		bra.s	CMC_TimeCodeOut		CMC_TCinInvalide				lea		CMC_ChaineTcErrone(pc),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		CMC_recopienumLoop5				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop5				; ----------------- tc out		CMC_TimecodeOut			move.b	#'.',-3(a3)		move.b	#' ',(a3)+		move.l	st_TimeCodeOut(a4),d0		cmp.l	#-1,d0		beq		CMC_TCOutInvalide; ok tc out valide				lea		Buff1(a6),a0		jsr		ConversionTCstASCII				lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		CMC_recopienumLoop6				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop6			bra.s	CMC_commentaire		CMC_TCOutInvalide				lea		CMC_ChaineTcErrone(pc),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		CMC_recopienumLoop7				move.b	(a0)+,(a3)+		dbra	d1,CMC_recopienumLoop7					; ----------------- Commentaire ----------------CMC_commentaire		move.b	#'.',-3(a3)				tst.w	G.Preference_InclureCommentaire		beq.s	CMC_OnMetleCr	; non pas de commentaire		move.w	#' ',(a3)+		move.w	#' ',(a3)+		move.l	st_CommentairePtr(a4),a0		move.l	st_CommentaireLenth(a4),d2		beq.s	CMC_OnMetleCr	; il n'y a pas de commentaire		subq.w	#1,d2		move.b	#' ',(a3)+		CMC_RecopieCommentaireLoop		move.b	(a0)+,d0		cmp.b	#' ',d0		blo.s	CMC_OnMetleCr		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PasConvMSDOSCOmmentaire		moveq	#1,d1		jsr		CONVERSIONCharCMC_PasConvMSDOSCOmmentaire		move.b	d0,(a3)+		dbra	d2,CMC_RecopieCommentaireLoop		CMC_OnMetleCr		move.b	#$0d,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_Texte		move.b	#$0a,(a3)+		; ------------------ texte du sous titre		CMC_Texte		move.w	st_Nlines(a4),d7		cmp.w	#3,d7		bhi.s	CMC_SupDeuxLignes		moveq	#3,d7					; ?CMC_SupDeuxLignes		subq.w	#1,d7		move.l	a4,a0		adda.l	#st_SizeOf,a0		move.l	st_TexteLenth(a4),d2		beq 	CMC_ChaineVide		subq.w	#1,d2CMC_Attend1erChar			move.b	(a0),d0		cmp.b	#$0a,d0		blo.s	CMC_ChaineVide				cmp.b	#31,d0		bhi.s	CMC_RecopieTexte 		adda.l	#1,a0		subq.w	#1,d2		beq		CMC_ChaineVide		bra.s	CMC_Attend1erCharCMC_RecopieTexte 		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+CMC_RecopieTexteLoop				move.b	(a0)+,d0		cmp.b	#$0d,d0		bne.s	CMC_PasRetourChariot; il y a un CR		move.b	d0,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PasDeOa		move.b	#$a,(a3)+CMC_PasDeOa				tst.w	d7		beq.s	CMC_PasSubD7		subq.w	#1,d7	; 1 cr dans la listeCMC_PasSubD7; on place des espaces devant		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		Dbra	d2,CMC_RecopieTexteLoop		bra.s	CMC_UnCrAlaFin		CMC_PasRetourChariot		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_PasTexteEnMSDOS		moveq	#1,d1		jsr		CONVERSIONCharCMC_PasTexteEnMSDOS				move.b	d0,(a3)+		Dbra	d2,CMC_RecopieTexteLoopCMC_UnCrAlaFin		moveq	#0,d1	; compteur de rotationCMC_ChaineVide		move.b	#$0d,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	CMC_NoOaNeeded		move.b	#$0a,(a3)+CMC_NoOaNeeded		dbra	d7,CMC_ChaineVide 		; on écrit sur le disqueCMC_WriteThisOnDisk		move.l	a3,d0		sub.l	Buffer(a6),d0		move.l	paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	buffer(a6),a1		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)				_Write				jsr		TraitementErreurFichier						move.w	NumST(a6),d0		move.w	LargeurReglette(a6),d1		and.l	#$fff,d1			mulu.w	d1,d0; resultat sur 32 bits dans d0		move.l	G.General_NombreST,d1		divu	d1,d0; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	CMC_onnedessinepas		move.w	d0,LastXpos(a6); on dessine la reglette								add.w	Left+ItemRect(a6),d0		add.w	#2,d0		move.w	d0,Right+rectangle(a6)						move.l	#CyanColor,-(sp)		_ForeColor		tst.b	G.Mac.HasCOloRQD 		bne.s	Zob2		_PenNormal		pea		QD.gray		_PenPat		Zob2								pea		rectangle(a6)		_PaintRect				move.w	right+rectangle(a6),left+rectangle(a6)				move.w	#32,-(sp) 		JSR	SpinCursor	; spin the ball				_PenNormal		CMC_onnedessinepas:				; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.w	NumST(a6),d0		and.l	#$ffff,d0		lea		buff1(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff1(a6)		_DrawString						add.w	#1,NumST(a6); --------------------------------------------------------			move.l	pointeur(a6),d0		move.l	d0,a0		move.l	(a0),a0		cmp.l	#0,a0		beq		CMC_finEcriture		move.l	a0,Pointeur(a6)		move.l	Buffer(a6),a3		bra 	CMC_TransfertFichierLoop		; non on continu; oui on se casse de la			CMC_FinEcriture		; on place le end of file à l'endroit où nous sommes			move.l	paramBlock(a6),a0		move.l	46(a0),d0	;ioPosOffset		move.l	d0,28(a0)	; iomisc		_SetEOF			move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		bra	Exit* -----------------------------------------------------------------------	ExporteFichierN19	; fabrication de fichier N19.		move.l	Paramblock(a6),-(sp)		; le descripteur du fichier		move.l	Reply(a6),-(sp)				; le nom du fichier				import	ExportationDeFichier_N19		jsr		ExportationDeFichier_N19		bra	Exit; ------------------------------------------------------------------------ExportFichierTexte; on commence par placer le Mark du fichier au début; on ouvre le dialog pour dire à l'utilisateur ce qu nous faisons; on utilise le même Dialogue pour importation fichier ascii				clr.l	-(sp)		move.w	#138,-(sp)		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)		_DrawDialog			move.l	TheDialogPtr(a6),-(sp)		_setPort; on dit que c'est pour convertir un fichier ASCII				move.l	TheDialogPtr(a6),-(sp)		move.w	#5,-(sp)	; item 5		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea	#'Exportation de fichier au format Ascii'		_SetItext; on affiche le type du créateur du fichier 0= mac 1= Ms Dos 						move.l	TheDialogPtr(a6),-(sp)		move.w	#9,-(sp)	; item 9		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem								tst.w	G.Preference_ConvertMsDos		beq.s	FichierTypeMac				move.l	ItemHandle(a6),-(sp)		pea		#'(Ms-Dos)'		_SetItext		bra.	AfficheNomDeFichier		FichierTypeMac			move.l	ItemHandle(a6),-(sp)		pea		#'     (Mac)'		_SetItext						; on affiche le nom du fichierAfficheNomDeFichier		move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.l	Reply(a6),-(sp)		_SetItext						; on trace la ligne sous le titre		move.l	TheDialogPtr(a6),-(sp)		move.w	#4,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		   	_PenNormal			   	move.w	#SrcCopy,-(sp)	   	_TEXTMode				pea		itemRect(a6)		_FrameRect						;on entoure la reglette		move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem						pea		itemRect(a6)		_FrameRect				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#6,d0		move.w	d0,LargeurReglette(a6)		clr.w	LastXpos(a6)						move.w	bottom+itemRect(a6),bottom+rectangle(a6)		subq.w	#2,bottom+rectangle(a6)		move.w	top+itemRect(a6),top+rectangle(a6)		addq.w	#2,top+rectangle(a6)				move.w	left+itemRect(a6),left+Rectangle(a6)		add.w	#2,left+rectangle(a6)		move.l	TheDialogPtr(a6),-(sp)		move.w	#2,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		NombreSTLusRect(a6)		_GetDItem							move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem; ok le dialog est ouvert		move.l	paramBlock(a6),a0			move.w	#fsFromStart,ioPosMode(a0)		move.l	#1,ioPosOffset(a0)		_SetFPos; ok on est au début du fichier				move.l	G.General_PremierSTPtr,Pointeur(a6)		clr.w	NumST(a6)* ======================================================TransfertFichierLoop		move.l	Pointeur(a6),a4		move.l	Buffer(a6),a3; on teste s'il il faut mettre le numéro secondaire			tst.w	G.Preference_InclureSousNumero		bne.s	NumeroSecondaire		; -------------- non pas numeroSecondaire		move.l	st_NumeroST(a4),d0		and.l	#$ffffff,d0		lea		Buff1(a6),a0		clr.w	-(sp)		_Pack7		; on recopie le numéro dans le buffer		lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1; on place en tête de 0		moveq	#3,d4		sub.w	d1,d4		blt.s	pasbesoindezero1		metdesZeroDevant1		move.b	#'0',(a3)+		dbra	d4,metdesZeroDevant1pasbesoindezero1				subq.w	#1,d1recopienumLoop1 				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop1		bra.s		Timecodein;-------------- numerosecondaireNumeroSecondaire		move.l	st_NumeroST(a4),d0		and.l	#$ffffff,d0		lea		Buff1(a6),a0		clr.w	-(sp)		_Pack7		; on recopie le numéro principal dans le buffer		lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation				and.l	#$ff,d1; on place en tête de 0		moveq	#3,d4		sub.w	d1,d4		blt.s	pasbesoindezero2		metdesZeroDevant2		move.b	#'0',(a3)+		dbra	d4,metdesZeroDevant2pasbesoindezero2		subq.w	#1,d1recopienumLoop2 				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop2; on prend le numero secondaire				move.l	st_NumeroST(a4),d0		rol.l	#8,d0		and.l	#$ff,d0		beq.s	Timecodein		; pas besoin de n° secondaire puisque =0			lea		Buff1(a6),a0		clr.w	-(sp)		_Pack7				lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		move.b	#'-',(a3)+recopienumLoop3				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop3						;----------------- tc inTimecodein; on place le )		move.b	#')',(a3)+		move.b	#' ',(a3)+;		move.b	#' ',(a3)+		move.l	st_TimeCodeIn(a4),d0		cmp.l	#-1,d0		beq		TCinInvalide; ok tc in valide				lea		Buff1(a6),a0		jsr		ConversionTCstASCII				lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1recopienumLoop4				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop4		bra.s	TimeCodeOut		TCinInvalide				lea		ChaineTcErrone(pc),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		recopienumLoop5				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop5				; ----------------- tc out		TimecodeOut				move.b	#' ',(a3)+		move.l	st_TimeCodeOut(a4),d0		cmp.l	#-1,d0		beq		TCOutInvalide; ok tc in valide				lea		Buff1(a6),a0		jsr		ConversionTCstASCII				lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		recopienumLoop6				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop6			bra		Durie		TCOutInvalide				lea		ChaineTcErrone(pc),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		recopienumLoop7				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop7					; ----------------- durée & lisibititéDurie			move.b	#' ',(a3)+				lea		STRDuree(pc),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		recopienumLoop8				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop8				move.l	st_TimeCodeIn(a4),d1		move.l	st_TimeCodeOut(a4),d0		jsr	SoustractionTimeCode		jsr	ConversionTimeCode_Trames				tst.l	d0		bgt.s	DureeSupMinute				lea		MoinChaine(pc),a0		lea		1(a0),a0		moveq 	#3,d1recopienumLoop9 				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop9 		bra.s		Lisibilite		DureeSupMinute			cmp.l	#1500,d0		blo.s	DureeOk		; longueur > minute				lea		PlusChaine(pc),a0		add.l	#1,a0		moveq 	#3,d1recopienumLoop10				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop10		bra.s	Lisibilite		DureeOk							cmp.l	#-1,st_TimeCodeIn(a4)		beq.s	MetDureeSpace		cmp.l	#-1,st_TimeCodeOut(a4)		beq.s	MetDureeSpace		recopieDure				jsr		ConversionTrames_TimeCode		lea		Buff1(a6),a0		jsr		ConversionTCstASCII				lea		Buff1(a6),a0		lea		7(a0),a0		moveq 	#4,d1recopienumLoop11				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop11		bra.s	LisibiliteMetDureeSpace	; on ne peut pes afficher de durée puisque un des tc est invalides		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		; ------------------ calcul lisibilité Lisibilite; on affiche le mot lisibilité		move.b	#' ',(a3)+		lea		strLisibilite(pc),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1		recopienumLoop12				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop12;		move.l	st_TimeCodeIn(a4),d1		move.l	st_TimeCodeOut(a4),d0		jsr	SoustractionTimeCode		jsr	ConversionTimeCode_Trames		tst.l	d0		bgt.s	lisiSupMinute				lea		MoinChaine(pc),a0		lea		1(a0),a0		moveq 	#3,d1recopienumLoop13				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop13		bra.s	Commentaire		lisiSupMinute			cmp.l	#1500,d0		blo.s	lisiOk		; longueur > minute				lea		PlusChaine(pc),a0		add.l	#1,a0		moveq 	#3,d1recopienumLoop14				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop14		bra.s	commentairelisiOk					mulu	G.Preference_LisiValue,d0		divu	#25,d0		and.l	#$ffff,d0		lea		buff1(a6),a0		clr.w	-(sp)		_Pack7		lea		Buff1(a6),a0		move.b	(a0)+,d1	; compteur de rotation		and.l	#$ff,d1		subq.w	#1,d1recopienumLoop15				move.b	(a0)+,(a3)+		dbra	d1,recopienumLoop15		bra.s	commentairelisiPasBonne				move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+		move.b	#' ',(a3)+; ---------------- commentairecommentaire				tst.w	G.Preference_InclureCommentaire		beq.s	OnMetleCr	; non pas de commentaire				move.l	st_CommentairePtr(a4),a0		move.l	st_CommentaireLenth(a4),d2		beq.s	OnMetleCr	; il n'y a pas de commentaire		subq.w	#1,d2		move.b	#' ',(a3)+		RecopieCommentaireLoop		move.b	(a0)+,d0		cmp.b	#' ',d0		blo.s	OnMetleCr		tst.w	G.Preference_ConvertMsDos		beq.s	PasConvMSDOSCOmmentaire		moveq	#1,d1		jsr		CONVERSIONCharPasConvMSDOSCOmmentaire		move.b	d0,(a3)+		dbra	d2,RecopieCommentaireLoop		OnMetleCr		move.b	#$0d,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	Texte		move.b	#$0a,(a3)+		; ------------------ texte du sous titre		; formatage du nombre de ligne; si n ligne < 3 on place des cr pour compenser; si n ligne >3 on ne compense pasTexte	move.w	st_Nlines(a4),d7		cmp.w	#3,d7		bhi.s	SupDeuxLignes		moveq	#3,d7					; ?		subq.w	#1,d7SupDeuxLignes		move.l	a4,a0		adda.l	#st_SizeOf,a0			; pointeur du texte		move.l	st_TexteLenth(a4),d2	; longueur du texte		beq.s	ChaineVide		subq.w	#1,d2;--		Attend1erChar			move.b	(a0),d0		cmp.b	#$0a,d0		blo.s	ChaineVide				; code ascii < $OD on considère chaie vide				cmp.b	#31,d0					; > space		bhi.s	RecopieTexteLoop		; oui		adda.l	#1,a0					; non char suivant		subq.w	#1,d2		beq		ChaineVide				; finalement chaine vide		bra.s	Attend1erChar; --		RecopieTexteLoop				move.b	(a0)+,d0		cmp.b	#$0d,d0		bne.s	PasRetourChariot; il y a un CR $od/$OA ?		move.b	d0,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	PasDeOa		move.b	#$a,(a3)+	; ouiPasDeOa				tst.w	D7		beq.s	PasSub1D7		subq.w	#1,d7	; 1 cr dans la listePasSub1D7				Dbra	d2,RecopieTexteLoop		bra.s	UnCrAlaFin		PasRetourChariot		tst.w	G.Preference_ConvertMsDos		beq.s	PasTexteEnMSDOS		moveq	#1,d1		jsr		CONVERSIONCharPasTexteEnMSDOS				move.b	d0,(a3)+		Dbra	d2,RecopieTexteLoopUnCrAlaFin		moveq	#0,d1	; compteur de rotationChaineVide		move.b	#$0d,(a3)+		tst.w	G.Preference_ConvertMsDos		beq.s	NoOaNeeded		move.b	#$0a,(a3)+NoOaNeeded		dbra	d7,ChaineVide		; on écrit sur le disqueWriteThisOnDisk		move.l	a3,d0		sub.l	Buffer(a6),d0		move.l	paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	buffer(a6),a1		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)				_Write				jsr		TraitementErreurFichier						move.w	NumST(a6),d0		move.w	LargeurReglette(a6),d1		and.l	#$fff,d1			mulu.w	d1,d0; resultat sur 32 bits dans d0		move.l	G.General_NombreST,d1		divu	d1,d0; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas		move.w	d0,LastXpos(a6); on dessine la reglette								add.w	Left+ItemRect(a6),d0		add.w	#2,d0		move.w	d0,Right+rectangle(a6)						move.l	#CyanColor,-(sp)		_ForeColor					tst.b	G.Mac.HasCOloRQD 		bne.s	Zob3		_PenNormal		pea		QD.gray		_PenPat		Zob3				pea		rectangle(a6)		_PaintRect				move.w	right+rectangle(a6),left+rectangle(a6)				move.w	#32,-(sp) 		JSR	SpinCursor	; spin the ball				_PenNormal		onnedessinepas:				; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.w	NumST(a6),d0		and.l	#$ffff,d0		lea		buff1(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff1(a6)		_DrawString						add.w	#1,NumST(a6); --------------------------------------------------------			move.l	pointeur(a6),d0		move.l	d0,a0		move.l	(a0),a0		cmp.l	#0,a0		beq		finEcriture		move.l	a0,Pointeur(a6)		bra 	TransfertFichierLoop		; non on continu; oui on se casse de la			FinEcriture		; on place le end of file à l'endroit où nous sommes			move.l	paramBlock(a6),a0		move.l	46(a0),d0	;ioPosOffset		move.l	d0,28(a0)	; iomisc		_SetEOF			move.l	TheDialogPtr(a6),-(sp)		_DisposDialogExit	move.l	d1,d7		move.w	#$0505,-(sp)			jsr		Show_cursor		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		string	PASCALChaineTcErrone	DC.B	'00:00:00:00'CMC_ChaineTcErrone	DC.B	'**:**:**.**'STRDuree		dc.b	'Duree :'strLisibilite	dc.b	'Lisibilite :'PlusChaine		dc.b	'++++'MoinChaine		dc.b	'----'		DbgInfo.new		ExportationDeFichierAscii	; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE		WriteBonBougreFormat()* ================================================WriteBonBougreFormat	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètrereply				ds.l	1AutoSave			ds.w	1	; flag pour autosaveParamSize			EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkTheDialogPtr		ds.l	1Buffer				ds.l	1	; adresse du bufferMaxBuffer			ds.l	1	; adresse haute du bufferPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	48	; buffer temporaire n°2NumST				ds.w	1	;Numéro du sous-titre en coursItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1RGB_Color			ds.w	3DateTime			ds		DateTimeRecsecu				ds.l	2ResourceRefNum		ds.w	1saveResourceRef		ds.w	1oldport				ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD,\				SOUSTITREformat,FontRenderRecord ; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				import	EffaceTouslesSousTitres,FindFrameType_Ascii_CMC,\				ConversionNumeroSTPointeur,TraitementErreurFichier,InsertST,\				CentreListingWindow,AFFICHENUMSAISIE,\				TransfertMemoireSaisie,CalculDuree,Waitaicks,WaitTicks,DrawWindow,\				INITCURSORCTL,ROTATECURSOR,Show_cursor,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR		; on recherche une zone de travail			move.l	G.BufferTransfert,d0			move.l	d0,Buffer(a6)			add.l	G.SIZEBufferTransfert,d0			move.l	D0,MaxBuffer(a6); on arrète la lecture du port serie		tst.w	G.ModemInRefNum		beq.s	PasArreteLectureTC			 		;	lea		G.Rx_modem_paramblock,a0 		;	clr.w	22(a0) 		;	move.w	G.ModemInRefNum,ioRefNum(a0) 		;	clr.l	ioCompletion(a0) 		;	_KillIO	PasArreteLectureTC; on recopie le nom de la dernière police d'affichage utilisée (si elle existe)		lea 	G.LastFontUsed,a1		clr.w	(a1)		lea 	G.Display_Font,a0		lea		FontName(a0),a0		moveq	#0,d0		move.b	(a0),d0		beq		Pasrecopie		addq.l	#1,d0		cmp.l	#32,d0	; on limite à 32 caractères		blo		recopieStringlastfont		move.l	#32,d0recopieStringlastfont		_BlockMovePasrecopieNonFontName; ok on peut bosser; on ouvre un dialog			pea	oldport(a6)			_GetPort			clr.l	-(sp)			move.w	#154,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)			_SetPort			move.l	TheDialogPtr(a6),-(sp)			_DrawDialog			; on dit que c'est pour convertir un fichier ASCII					move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						pea		itemRect(a6)			_EraseRect						move.w	left+itemRect(a6),-(sp)			move.w	top+itemRect(a6),d0			add.w	#12,d0			move.w	d0,-(sp)			_moveTo						tst.w	AutoSave(a6)			bne.s	SayAutoSave							pea	#'Sauvegarde du fichier: '		_drawString		bra.s	NomDeFichierSayAutoSave				pea	#'Sauvegarde Automatique du fichier: '		_drawString; on affiche le nom du fichierNomDeFichier				move.l	Reply(a6),-(sp)		_drawString		; on dessine la réglette			move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem								_PenNormal						move.w	#SrcCopy,-(sp)			_TEXTMode						move.w	#SrcCopy,-(sp)			_PenMode						tst.b	G.Mac.HasCOloRQD			bne.s	Zob1					bra.s	Zob3Zob1													Zob3			;on entoure la reglette			move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem						_PenNormal				pea		itemRect(a6)		_FrameRect				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#6,d0		move.w	d0,LargeurReglette(a6)		clr.w	LastXpos(a6)				move.w	bottom+itemRect(a6),bottom+rectangle(a6)		subq.w	#2,bottom+rectangle(a6)		move.w	top+itemRect(a6),top+rectangle(a6)		addq.w	#2,top+rectangle(a6)				move.w	left+itemRect(a6),left+Rectangle(a6)		add.w	#2,left+rectangle(a6)		Start_theSave		; ok le dialog est ouvert; on se positionne au début du fichier		move.l	paramBlock(a6),a0			move.w	#fsFromStart,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)		_SetFPos; ok on est au début du fichier			move.l	G.General_PremierSTPtr,Pointeur(a6)		clr.w	NumST(a6)* ------------------------------------------------; on place l'en tête pour les fichiers bon bougre		clr.w	G.versionLogiciel		clr.l	-(sp)		move.l	#'vers',-(sp)		move.w	#1,-(sp)		_GetResource		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	PasResourcevers	; pas trouvé resource		move.l	(a0),a1		; handle		; on recopie la version du logiciel dans l'en tête du fichier ; pour de futur problèmes de compatibilitée		move.w	(a1),G.versionLogiciel		move.l	a0,-(sp)		_ReleaseResource; ---PasResourcevers; on écrit le header dans le fichier		lea.l	G.Preference_Header_SizeOf,a0	; fin du header		move.l	a0,d0		lea.l	G.preference,a1		; début du header		sub.l	a1,d0				; longueur à écrire				move.l	paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)		_Write		;		move.l	paramBlock(a6),a0;		clr.l	ioCompletion(a0);		_FlushFile				jsr		TraitementErreurFichier			* -------------------------------------------------				; on prépare l'écriture sur disque		move.l	Buffer(a6),a3	; début de la zone de travail		move.l	G.General_PremierSTPtr,pointeur(a6); ----		TransfertFichierLoop; on transfert le header dans la mémoire		move.l	pointeur(a6),a0		move.l	st_TimeCodeIn(a0),file_TimeCodeIn(a3) 		move.l	st_TimeCodeOut(a0),file_TimeCodeOut(a3) 		move.l	st_NumeroST(a0),file_NumeroST(a3) 		move.l	st_TexteLenth(a0),file_TexteLenth(a3)		move.l	st_StyleLenth(a0),file_StyleLenth(a3) 		move.l	st_CommentaireLenth(a0),file_CommentaireLenth(a3) 		move.w	st_XOffset(a0) ,file_XOffset(a3) 		move.w	st_YOffset(a0) ,file_YOffset(a3)		move.w	st_Error(a0) ,file_Error(a3) 		move.w	st_Flags(a0) ,file_Flags(a3)		move.w	st_Nlines(a0) ,file_Nlines(a3)		move.l	st_PosOffsetTable(a0),file_PosOffsetTable(a3)  		move.b	st_Justification(a0),file_Justification(a3)    		move.b	st_MasKType(a0),file_MasKType(a3)   		move.l	st_spare(a0),file_spare(a3) 		move.w	4+st_spare(a0),4+file_spare(a3)		move.l	#file_sizeOf,file_LenthST(a3)		; on place la longueur du header				add.l	#file_sizeOf,a3			move.l	a0,a4					; on sauvegarde le pointeur du sous-titre; -------; on recopie le texte		tst.l	st_TexteLenth(a4)		beq.s	RecopieCommentaire		; la chaine est vide donc pas de style		move.l	#st_sizeOf,d1		add.l	d1,a0					; a1 pointe sur le début du texte dans le sous-titre		move.l	a3,a1					; début du texte		move.l	st_TexteLenth(a4),d0	; longueur du texte				_blockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	st_TexteLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l			move.l	Buffer(a6),a1	; début de la zone de travail		add.l	d0,file_LenthST(a1)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone; ----------		; on recopie les styles		tst.l	st_StyleLenth(a4)		beq.s	RecopieCommentaire		; il n'y a pas de style		move.l	st_StylePtr(a4),a0		move.l	a3,a1		move.l	st_StyleLenth(a4),d0		_BlockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	st_StyleLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	Buffer(a6),a1	; début de la zone de travail		add.l	d0,file_LenthST(a1)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone		; -------RecopieCommentaire					tst.l	st_CommentaireLenth(a4)		beq.s	WriteThisOnDisk		; il n'y a pas de commentaire		move.l	st_CommentairePtr(a4),a0		move.l	a3,a1		move.l	st_CommentaireLenth(a4),d0		_BlockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	st_CommentaireLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	Buffer(a6),a1	; début de la zone de travail		add.l	d0,file_LenthST(a1)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone	; --------	; on écrit sur le disqueWriteThisOnDisk			move.l	a3,d0				; a3 = adresse de fin du sous-titre placer en mémoire		sub.l	Buffer(a6),d0		; longueur à écrire		move.l	paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	buffer(a6),a1		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)				_Write; ---		; on rafraichie la reglette, et le curseur		move.l	pointeur(a6),a0		move.l	st_AbsNumSt(a0),d0		move.w	LargeurReglette(a6),d1		and.l	#$fff,d1			mulu.w	d1,d0; resultat sur 32 bits dans d0		move.l	G.General_NombreST,d1		divu	d1,d0; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas		move.w	d0,LastXpos(a6); on dessine la reglette								add.w	Left+ItemRect(a6),d0		add.w	#2,d0		move.w	d0,Right+rectangle(a6)		 		bsr		Draw_Reglette						move.w	#32,-(sp) 		JSR	SpinCursor	; spin the ball				_PenNormal		onnedessinepas:				; --------------------------------------------------------	; on teste si l'écriture est terminée; on regarde si le next pointeur = 0 		move.l	pointeur(a6),a0		move.l	st_NextST(a0),a0		cmp.l	#0,a0		beq		finEcriture		; oui c'est le dernier sous-titre; non on continue		move.l	a0,Pointeur(a6)	; pointeur du sous-titre à traiter		move.l	Buffer(a6),a3	; début de la zone de travail		bra 	TransfertFichierLoop		; non on continu		; oui, on se casse de là			FinEcriture				; on place le end of file à l'endroit où nous sommes			;		clr.w	-(sp);		move.l	paramBlock(a6),a0;		move.w	ioVrefNum(a0),-(sp);		move.l	46(a0),-(sp)	;ioPosOffset;		import	SetEOF;		jsr		Seteof;		move.w	(sp)+,d0			 		move.l	TheDialogPtr(a6),-(sp) 		_SetPort	 		move.l	TheDialogPtr(a6),-(sp) 		_DisposDialog				move.l	oldport(a6),-(sp)		_SetPort		Exit	tst.w	G.ModemInRefNum		beq.s	PasDemandeLectureTC					;	lea		G.Rx_modem_paramblock,a0      	;	clr.w	22(a0)     	;	lea.l	G.Rx_Modem_Buffer,a1	      	;	move.l	a1,32(a0)      	;	move.l	#1,ioReqCount(a0)      	;	move.w	#fsfromStart,ioPosMode(a0)     	;	move.w	G.ModemInRefNum,ioRefNum(a0)      	;	clr.l	ioPosOffset(a0)     	;	import	SERIAL     	;	lea.l	SERIAL,a1					; routine de gestion du port serie     	;	move.l	a1,ioCompletion(a0)        ;	_Read ,asyncPasDemandeLectureTC				UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		string	PASCALGroundColor		dc.w	30962,20192,16402	Draw_Reglette; cette routine rafraichie la reglette		movem.l	d0-d7/a0-a4,-(sp)				move.l	TheDialogPtr(a6),-(sp)		_SetPort						move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	LastXpos(a6),d0		cmp.w	left+itemRect(a6),d0		bhi.s	@123		move.w	left+itemRect(a6),d0@123				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				movem.l	(sp)+,d0-d7/a0-a4		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						movem.l	(sp)+,d0-d7/a0-a4		rts						DbgInfo.new		WriteBonBougreFormat	; this name will appear in the debugger		align 4			ENDP		* ===============================================*	Procedure	transfertTexteBuffer_soustitre()* ===============================================; Cette procédure recherche à partir du pointeur dans a0; une chaine de caractère correspondant à l'ascii type traitement de textes.; et retourne s'il elle est valide tous les paramètre dans les cases pointées par (a6); D0 contient 0 si chaine valide, si non <>0transfertTexteBuffer_soustitre	proc 	export						import	ConversionASCIIbcdTc,ConversionTimeCode_Trames,ConversionTrames_TimeCode		WITH	StackFrameImportationFichier,StandardFileReply,SFReply,SOUSTITRERECORD	; on utilise le même stackframe;-------------   on recopie le texte du buffer dans le sous-titre -----------------; il y a-t-il du texte		tst.w	d2		bne.s	TypeAscii_Normal	; oui; non pas de texte		move.l	G.General_DernierStPtr,a0			clr.l	st_TexteLenth(a0)		clr.l	st_StylePtr(a0)		clr.l	st_StyleLenth(a0)	; pas de texte => pas de style, normal non!		bra		RecopieCommentaire		; il y a du texteTypeAscii_Normal; on prevois l'emplacement des style		move.l	G.General_DernierStPtr,a0		lea.L	st_SizeOf(a0),a2			; début zone texte		move.l	a2,a3		; on limite le texte à 511 caractéres				cmp.l	#511,d2		blo.s	@1		move.l	#511,d2@1; on calcule le pointeur éventuel de style; à partir de la longueur de d2				add.l	d2,a3		move.l	a3,d0		add.l	#4,d0		; marge de sécurité				import	aligneD0		jsr		aligneD0		; on place ce pointeur comme  ptr de style		move.l	d0,st_stylePtr(a0)		move.l	d0,a3		move.l	a3,a0; on place un style neutre		move.w	#1,(a3)		; 1 style				add.l	#2,a0						move.l	#0,scrpStartChar(a0)			move.w	#9,scrpSize(a0)					move.w	#9,scrpAscent(a0)		; au pif		move.w	#12,scrpHeight(a0)		; au pif		move.w	#monaco,scrpFont(a0)		; pour l'instant monaco				move.w	#0,scrpColor(a0)		move.w	#0,2+scrpColor(a0)		move.w	#0,4+scrpColor(a0)				move.b	#0,scrpFace(a0)		move.b	#0,1+scrpFace(a0)						move.l	G.General_DernierStPtr,a0		lea.L	st_SizeOf(a0),a2		moveq	#0,d1		clr.l	d4RecopieTexte_Loop_ascii 		move.b	(a1)+,d0		beq		FinDeRecopieTexte				cmp.w	#511,d1		beq 	FinDeRecopieTexte		 		cmp.b	#$0d,d0							; on compte le nombre de ligne		bne.s	@1		addq.w	#1,d4		; ---------- on regarde quel fichier on est en train de corriger@1		tst.w	fichierType(a6)		beq.s 	PasTypeCMC	; fichier texte CMC; on regarde s'il c'est le caractère '#' qui signifie italique/ pas italique		cmp.b	#'#',d0							; on compte le nombre de ligne		bne.s	PasTypeCMC; oui on a détecter le caractère # ; on ajoute un nouveau style		move.l	G.General_DernierStPtr,a0		move.l	st_stylePtr(a0),a3				move.w	(a3),d0		ext.l	d0; --------; doit-on remplacer le premier style ?		cmp.w	#1,d0				; premier style		bne.s	PasPremierStyle		; on regarde si nous sommes au dela du premier caractère du texte						tst.l	d1		bhi.s	PasPremierStyle		; oui c'est le cas		; nous sommes au début du texte: on remplace le premier style						moveq	#0,d0		move.w	d0,(a3)		; ----		PasPremierStyle				mulu	#20,d0		; largeur du scrpelement		add.l	#2,d0		move.l	d0,a0		; pointeur du sous-titre		add.l	a3,a0				add.w	#1,(a3)		; on incrémente le nombre de style		move.l	d1,scrpStartChar(a0)		; début du style				; caractéristique de la police	######## il faudrait prendre le current font				move.w	#9,scrpSize(a0)					move.w	#9,scrpAscent(a0)		; au pif		move.w	#12,scrpHeight(a0)		; au pif		move.w	#monaco,scrpFont(a0)		; pour l'instant monaco; couleur				move.w	#0,scrpColor(a0)		move.w	#0,2+scrpColor(a0)		move.w	#0,4+scrpColor(a0)		; on place le style// au style précédent		cmp.w	#2,(a3)		; premier style => italique		blo.s	italique		; pas le premier style	on regarde le style précédent					move.w	scrpFace-20(a0),d0		bne.s	Normal				; si ≠0 => on place style normal; italique	italique		move.b	#2,scrpFace(a0)		move.b	#2,1+scrpFace(a0)		bra		RecopieTexte_Loop_ascii		; en Normal		Normal	move.b	#0,scrpFace(a0)		move.b	#0,1+scrpFace(a0)		bra		RecopieTexte_Loop_ascii		; ---------- on regarde s'il y a une conversion msdos => mac à fairePasTypeCMC		move.l	d1,d2		; sauvegarde de d1 				tst.w	TypeDeCreateurDuFichier(a6)		beq.s	PasDeConversionaFaire_ascii		moveq 	#0,d1				import	CONVERSIONChar	; on effectue la conversion etc de		jsr		CONVERSIONChar	; on effectue la conversion etc de		PasDeConversionaFaire_ascii				move.b	d0,(a2)+		move.l	d2,d1		; récupèration de d1 		addq.l	#1,d1		; compteur de caractère 		bra.s	RecopieTexte_Loop_ascii		FinDeRecopieTexte				move.l	G.General_DernierStPtr,a0		addq.w	#1,d4						; nombre de ligne	 		move.w	d4,st_Nlines(a0)		move.l	d1,st_TexteLenth(a0)		; on regarde si l'on a effectivement placé des style		move.l	st_StylePtr(a0),a1		move.w	(a1),d0		bne.s	OnAmiDesStyles	; oui; ----------------------------------------				clr.l	st_StylePtr(a0)			clr.l	st_StyleLenth(a0)			bra		RecopieCommentaireOnAmiDesStyles			; -----------------------------------------------------------------		mulu	#20,d0		add.l	#8,d0		import	AligneD0		import	AligneD0		move.l	d0,st_StyleLenth(a0)		RecopieCommentaire		; maintenant on regarde s'il y a un commentaire dans le sous-titre						lea		buffCommentaire(a6),a1		move.b	(a1),d5		beq.s	pasdecommentaire_ZapZap		and.l	#$ff,d5; il y a une chaine commentaire donc on recopie								move.l	G.General_DernierStPtr,a0		lea.L	st_SizeOf(a0),a2				move.l	#st_SizeOf,d0		add.l	st_TexteLenth(a0),d0		import	Aligned0		jsr		Aligned0 		add.l	st_StyleLenth(a0),d0 		import	Aligned0 		jsr		Aligned0		add.l	#16,d0		adda.l	d0,a2						move.l	a2,st_CommentairePtr(a0)  ; a2 devient l'endroit de la chaine		move.l	d5,st_CommentaireLenth(a0)		SUBq.w	#1,D5		RecopieCommentaireDansSousTitreLoop:		move.b	1(a1,D5.w),d0		tst.w	TypeDeCreateurDuFichier(a6)		beq.s	PasDeConversioCommentaireaFaire		moveq 	#0,d1		jsr		CONVERSIONChar	; on effectue la conversion efc dePasDeConversioCommentaireaFaire				move.b	d0,(a2,d5.w)		dbra	d5,RecopieCommentaireDansSousTitreLoop				bra.s	calculLongueurST		; on aligne cette longueur sur un mot longpasdecommentaire_ZapZap		clr.l	st_CommentairePtr(a0)		clr.l	st_CommentaireLenth(a0)		; on calcule la longeur du sous titrecalculLongueurST		move.l	G.General_DernierStPtr,a0			move.l	St_texteLenth(a0),d0		import	AligneD0		jsr		AligneD0		add.l	st_StyleLenth(a0),d0		import	AligneD0		jsr		AligneD0			add.l	st_CommentaireLenth(a0),d0		import	AligneD0		jsr		AligneD0			add.l	#8,d0		; longueur ajustée sur dc.l		move.l	d0,st_LenthST(a0)	; ça y est, on a bouclé un sous-titre	exit	rts		DbgInfo.new		transfertTexteBuffer_soustitre	; this name will appear in the debugger		align 4						ENDP* ========================================		* PROCEDURE	ConversionFichierAscii_BonBougre()			* ========================================** Cette routine convertie le texte d'un fichier ASCII ou CMC* vers le format utilisé par le logiciel*ConversionFichierAscii_BonBougre 		PROC	EXPORT										with	StackFrameImportationFichier,N19_GSI,N19_TTI,SousTitreRecord										import	SpinCursor,Rafraichi_Curseur,insertST		cmp.w	#Fichier_TypeCMC,fichierType(a6)		bne.s	DuVraiTexte		move.w	fichierType(a6),TypeAscii(a6)				bra.s	lesuitedetexteDuVraiTexte				move.w	#AsciiType_TraitementDeTexte,TypeAscii(a6); on determine de queltype de fichier il s'agit pc ou maclesuitedetexte				move.l	BufferTransfer(a6),a0; on recherche dans une fenètre de 255 octets le caractère $0d; s'il est suivit d'un $0a => format ms-dos ,sinon MAC		moveq	#0,d1		move.w	#0,TypeDeCreateurDuFichier(a6)SearchOdOaLoop				move.b	(a0,d1.w),d0		cmp.b	#$0d,d0		beq.s	OdFoundInList		addq.w	#1,d1		bra.s	SearchOdOaLoopOdFoundInList				move.b	1(a0,d1.w),d0		cmp.b	#$0a,d0		bne.s	PasMsDos			move.w	#1,TypeDeCreateurDuFichier(a6)PasMsDos; on regarde si la liste des sous-titres est vide 		move.l	G.General_NombreST,d0		cmp.l	#1,d0		ble.s	Ok_PasDeProblemeOnEfface		; regarder le flag ChangesinceLastSave = true				clr.w	-(sp)		move.w	#144,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		cmp.w	#1,d0		bNE		Exit	; L'UTILISATEUR NE VEUT PAS CHANGER LA LISTE		Ok_PasDeProblemeOnEfface; onteste si ce fichier et un fichier CMC		tst.w	fichierType(a6)		bne.s 	RecopieNomCMC	; fichier texte CMC; on efface tous les sous titres		move.l	Reply(a6),-(sp)		import	EffaceTouslesSousTitres		jsr		EffaceTouslesSousTitres		bra		opendialogtype2; -------------------------------------		; on  recopie le nom du fichier CMCRecopieNomCMC		move.l	BufferTransfer(a6),a0		LEA		buff1(A6),A1 		moveq	#0,d1						CopieNomFilmCMCloop				move.b	(a0,d1.w),d0		cmp.b	#' ',d0		blo.s	FincopieNomCMC		move.b	d0,1(a1,d1.w)		addq.w	#1,d1		bra.s	CopieNomFilmCMCloop		FincopieNomCMC		move.b	d1,(a1)	; longueur du texte : str255		and.l	#$ff,d1		;--- on efface les espaces de fins de la chaîne nom CMC		LoopEnleveSpaceDefin		cmp.b	#' ',(a1,d1.w)		bne.s	FinEffaceSpaceDefin		subq.W	#1,d1		bra.s	LoopEnleveSpaceDefin		FinEffaceSpaceDefin		move.b	d1,(a1)		; on place la longueur				move.l	a1,-(sp)		import	EffaceTouslesSousTitres		jsr		EffaceTouslesSousTitres					* ---------------------- on convertie la liste de type 2 en sous-titre; on ouvre un dialog pour indiquer que nous faisons une conversionsopendialogtype2				clr.l	-(sp)		move.w	#138,-(sp)		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)		_DrawDialog		move.l	TheDialogPtr(a6),-(sp)		_setPort		; on dit que c'est pour convertir un fichier ASCII				move.l	TheDialogPtr(a6),-(sp)		move.w	#5,-(sp)	; item 5		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		cmp.w	#Fichier_TypeCMC,TypeAscii(a6)		beq.s	fichierTypeCmC		move.l	ItemHandle(a6),-(sp)		pea	#'Importation de fichier au format Ascii'		_SetItext		bra.s	PasCmC; nous sommes avec un fichier CMC; càd qu'il faut recopier le nom du film et attendre le premier sous-titre.fichierTypeCmC; on affiche l"type CMC", dans le dialog 		move.l	ItemHandle(a6),-(sp)		pea	#'Importation de fichier au format CMC'		_SetItextPasCmC	; on affiche le type de créateur du fichier 0= mac 1= Ms Dos 			move.l	TheDialogPtr(a6),-(sp)		move.w	#9,-(sp)	; item 9		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						tst.w	TypeDeCreateurDuFichier(a6)		beq.s	FichierTypeMac				move.l	ItemHandle(a6),-(sp)		pea	#'(Ms-Dos)'		_SetItext		bra.	AfficheNomDeFichier		FichierTypeMac			move.l	ItemHandle(a6),-(sp)		pea		#'     (Mac)'		_SetItext						; on affiche le nom du fichierAfficheNomDeFichier		move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.l	Reply(a6),-(sp)		_SetItext						; on trace la ligne sous le titre		move.l	TheDialogPtr(a6),-(sp)		move.w	#4,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						_penNormal			   	move.w	#SrcCopy,-(sp)	   	_TEXTMode			pea		itemRect(a6)		_FrameRect												;on entoure la reglette		move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem						_penNormal				pea		itemRect(a6)		_FrameRect				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#6,d0		move.w	d0,LargeurReglette(a6)								move.w	bottom+itemRect(a6),bottom+rectangle(a6)		subq.w	#2,bottom+rectangle(a6)		move.w	top+itemRect(a6),top+rectangle(a6)		addq.w	#2,top+rectangle(a6)				move.w	left+itemRect(a6),left+Rectangle(a6)		add.w	#2,left+rectangle(a6)		move.l	TheDialogPtr(a6),-(sp)		move.w	#2,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		NombreSTLusRect(a6)		_GetDItem									move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem* -----------------------------------------------------------------------;		move.l	BufferTransfer(a6),pointeur(a6)GrandeBoucleDeRecopie		move.l	pointeur(a6),a0				bsr		FindFrameType_Ascii_CMC		move.l	a0,DebutZoneTexte(a6); on recopie les valeurs trouvées dans le sous-titre en cour		move.l	G.General_DernierSTPtr,a0		move.l	NumST(a6),st_NumeroST(a0)		move.l	NumST(a6),st_OldNumeroST(a0); on compare si les tc sont identique , dans ce cas on met - 1				move.l	TcIn(a6),d0		cmp.l	TcOut(a6),d0		bne.s	@notEqual_TCin_tcout		move.l	#-1,TcIn(a6)		move.l	#-1,TcOut(a6)@notEqual_TCin_tcout		move.l	TcIn(a6),st_TimeCodeIn(a0)		move.l	TcOut(a6),st_TimeCodeOut(a0); on sauvegarde la chaine de commentaire		lea		buff3(a6),a0		lea		buffCommentaire(a6),a1		moveq	#0,d0		move.b	(a0)+,d0		move.b	d0,(a1)+		beq.s	@1		_blockMove@1	; on recherche le Header du prochain sous-titre, comme cela on connait; la limite où l'on doit s'arreter de recopier le texte du sous-titres				move.l	DebutZoneTexte(a6),FinDeZoneTexte(a6) ; on utilise FinDeZoneTexte comme pointeur pour cette opération* ----------------------------------------------------------------------------------------; on effectue le rafraichissement du dialog		bsr		Rafraichi_Curseur  		* -------------------------------------------------------------------------------------------------  RechercheHeaderSuivantLoop				move.l	FinDeZoneTexte(a6),a0					; nb pointe sur la zone préderminée pour un sous-titre		bsr		FindFrameType_Ascii_CMC		tst.l	d0		beq.s	TrouverHeaderSuivant			; •• hurray ! on a trouvé				move.l	FinDeZoneTexte(a6),d0	; on incrémente de 1 le pointeur		addq.l	#1,d0		move.l	d0,FinDeZoneTexte(a6)		cmp.l	MaxBuffer(a6),d0		blt.s	RechercheHeaderSuivantLoop		* -----------		; on n'a pas trouver le header suivant ; somme nous à la fin du fichier ?						move.w	OpenErr(a6),d0		 		cmp.w	#-39,d0		;(eofErr) a-t'on lu,la dernière fois, le fichier en entier?		bEQ 	FichierLuEnEntier	; oui donc forte chance pour ètre la fin du fichier		; non, lisons donc encore un peu du fichier		move.l	Paramblock(a6),a0		clr.l	ioCompletion(a0)		move.l	DebutHeader(a6),ioPosOffset(a0)	; on reli à partir du dernier header trouvé		move.l	BufferTransfer(a6),ioBuffer(a0)		move.l	BufferSize(a6),ioReqCount(a0)				move.w	#fsFromStart,ioPosMode(a0)				_Read				move.w	d0,OpenErr(a6)		bsr		TraitementErreurFichier		tst.l	d1		bne 	Exit  ; arrêt de la procédure et mise à jour du dernier sous-titre		move.l	paramBlock(a6),a0		move.l	ioActCount(a0),SizeOfRead(a6)		; on réinitialise les pointeurs, puisque nous sommes au début du buffer tampon		move.l	BufferTransfer(a6),a0		move.l	a0,Pointeur(a6)		move.l	a0,DebutHeader(a6)		bsr		FindFrameType_Ascii_CMC		; il ne doit pas y avoir d'erreurs puisque le texte a déja été analysé		move.l	a0,DebutZoneTexte(a6)		move.l	DebutZoneTexte(a6),FinDeZoneTexte(a6)		bra		RechercheHeaderSuivantLoop  ; on recommence la sérénade		* -------------------------------------------------------------------------------------------------TrouverHeaderSuivant; on a trouver le header suivant donc on connait la longueur du texte;	findezonetexte contient l'adresse  du header du prochain ST		; il n'y a pas de commentaires  { pour l'instant (•••• à changer) } et de styles; on effectue le travail de préprocessing , c'est à dire que l'on regarde combien de ligne de; texte sont présentes, et l'on ajoute des retours chariot, pour décaler le textes vers le bas.; on compte le nombre le nombre de lignes présentent dans le sous-titre; pour ce faire on détecte si il y 2 $0d , $0d cote à cote => 1 ligne vierge; Il faut effectuer ce test en même temps que l'on recopie le texte dans le buffer ; il faut compter le nombre de ligne du texte, pour ce faire on attend le premier caractère ; puis on recopie, caractères par caractère s'il y a 2 cr cote à cote suivi d'une autre chaine on laisse, sinon on; s'arrète.on met $00; puis on compte le nombre de caractères $0d; en fct de cela on en ajoute en tête pour décaler le texte vers le bas?.		bsr		transfertTexteBufferFichier_SousTitre				move.l	FinDeZoneTexte(a6),pointeur(a6); on en insère un autre		move.l	G.General_DernierSTPtr,a0		move.l	#0,d0		jsr		InsertST		; on affiche le sous-titre en question		; traitement erreur		Bra		GrandeBoucleDeRecopie* -----------------------------------------------	FichierLuEnEntier; on indique la fin du fichier comme fin de zone texte					move.l	SizeOfRead(a6),d0		add.L	BufferTransfer(a6),d0		move.l	d0,FinDeZoneTexte(a6)				bsr	transfertTexteBufferFichier_SousTitre		MOVE.L	G.GENERAL_DERNIERSTPTR,A0		MOVE.L	G.GENERAL_PREMIERSTPTR,A1		MOVE.L	G.GENERAL_NOMBREST,D0		; liste correctement convertie		bra		Exit* -------------------------------------------transfertTexteBufferFichier_SousTitre	; On recopie dans un buffer la chaine de caractères, on enlève les retours chariots, sauf s'il sont entre deux lignes de textes		move.L	DebutZoneTexte(a6),a0		lea		buff1(a6),a1		; on vérifie que la chaine n'est pas vide		move.l	FinDeZoneTexte(a6),d0		sub.l	DebutZoneTexte(a6),d0		subq.w	#1,d0		; on élimine les cr de fin						TestSiChaineVideLoop:		move.b	0(a0,d0.w),d1		cmp.b	#$1F,d1		bhi.s	rechercheLePremierCaractere	; il y a des caractères affichables or space;		cmp.b	#$0d,d1;		beq.s	rechercheLePremierCaractere	; il y a des caractères affichables or space		dbra	d0,TestSiChaineVideLoop		; la chaine st vide; donc on se casse		move.l	G.General_DernierStPtr,a0		clr.l	st_TexteLenth(a0)		moveq	#0,d2		bra		RecopieCommentaire		; -----		; on attend	le premier caractèrerechercheLePremierCaractere		move.b	(a0),d1		cmp.b	#$20,d1		bhi.s	trouver1erCaractereArecopier	; on a trouvé un caractères		adda.l	#1,a0		subq.w	#1,d0	; un char de moin		bra.s	rechercheLePremierCaractere; -----		; ici a0, pointe sur le premier caractère; on calcule le nombre de caractère, jusqu'au prochain STtrouver1erCaractereArecopier		addq.w	#1,d0			moveq	#0,d2	; compteur de caractères copiés		move.l	#-1,d1	; compteur	de caractères lus		moveq	#0,d3	; compteur de $od dans la chaine		cmp.w	#1,TypeDeCreateurDuFichier(a6)	; type ms dos ?		bne.s	recopieTexteDansBufferlooprecopieTexteDansBufferloop:		add.l	#1,d1		cmp.l	d0,d1		bge 	FinrecopieBuffer		move.b	(a0,d1.w),d5		cmp.b	#$0d,d5			; retour chariot ?		beq.s	OdTrouve		cmp.b	#' ',d5		blo.s	recopieTexteDansBufferloop	;PasCaractereAffichable		move.b	d5,(a1,d2.w)		addq.w	#1,d2		bra.s	recopieTexteDansBufferloop; ------------------------------------------;  on a trouvé un retour chariot on le traite  OdTrouve:		move.w	TypeDeCreateurDuFichier(a6),d7		case#.w	(d7,if),\		(0,FichierType_Mac),\		(1,FichierType_Pc); par défaut type mac			FichierType_Amiga		; ------------------------------------------FichierType_Mac			 ; on regarde si le prochain caractère est un cr		move.b	1(a0,d1.w),d4		cmp.b	#$0d,d4  		beq.s	ouiEncoreUnCr		; non, pas  un cr 		cmp.b	#1,d3	; on regarde si on a déja 2 cr   		bhi.s	recopieTexteDansBufferloop		; On Ne Recopie Pas Le Cr		move.b	#$0d,(a1,d2.w)		addq.w	#1,d2		addq.w	#1,d3				bra.s	AttendNextCharAfterSpace; -----ouiEncoreUnCr	; peut ètre un saut de ligne; on regarde s'il y a un caractères derrière		move.b	2(a0,d1.w),d4		cmp.b	#' ',d4		bge.s	SuiviParUnChar  ;  un caractère, donc on traite; donc pas un caractère			addq.l	#1,d1			; on saute le caractère en question si mac et 2 char si pc		bra.s	recopieTexteDansBufferloop	SuiviParUnChar				cmp.b	#2,d3	; on regarde si on a déja 2 cr  		blt.s	onrecopielecr_2	; dans ce cas on ne recopie pas le crAttendNextCharAfterSpace		addq.w	#1,d1			; on saute le caractère en question; maintenant on attend le 1er char > $20		move.b	(a0,d1.w),d5		cmp.b	#33,d5		blo.s	AttendNextCharAfterSpace		subq.w	#1,d1		bra.s	recopieTexteDansBufferloop		onrecopielecr_2				move.b	#$0d,(a1,d2.w)		addq.w	#1,d2		move.b	#$0d,(a1,d2.w)		addq.w	#1,d2		addq.w	#2,d3		bra.s	AttendNextCharAfterSpace; ------------------------------		FichierType_Pc				; on regarde si le caractère à suivre est un cr (après le $0a bien sûr)		move.b	2(a0,d1.w),d4		cmp.b	#$0d,d4		beq.s	Pc_ouiEncoreUnCr		; non, pas encore un cr 		cmp.b	#2,d3	; on regarde si on a déja 2 cr		bge.s	recopieTexteDansBufferloop		; On Ne Recopie Pas Le Cr		move.b	#$0d,(a1,d2.w)		addq.w	#1,d2		addq.w	#1,d3		bra 	AttendNextCharAfterSpacePc_ouiEncoreUnCr	; peut ètre un saut de ligne; on regarde s'il y a un caractères derrière (après le $0d0a bien sûr)		move.b	4(a0,d1.w),d4		cmp.b	#' ',d4		bge.s	Pc_SuiviParUnChar  ;  un caractère, donc on traite; donc pas un caractère, donc un cr			addq.l	#1,d1			; on saute 2 char 		bra 	AttendNextCharAfterSpace	Pc_SuiviParUnChar				cmp.b	#2,d3	; on regarde si on a déja 2 cr		blt.s	Pc_onrecopielecr_2	; dans ce cas on ne recopie pas le cr		addq.w	#1,d1			; on saute les $0d $0a en question		bra 	AttendNextCharAfterSpace		Pc_onrecopielecr_2				move.b	#$0d,(a1,d2.w)		addq.w	#1,d2		move.b	#$0d,(a1,d2.w)		addq.w	#1,d2		addq.w	#2,d3		addq.w	#2,d1			bra 	AttendNextCharAfterSpace; --------------------------------------------; on a recopié le texte dans le buffer; on place un zéro à la fin de la chaineFinrecopieBuffer				clr.b	(a1,d2.w); on transfère le texte et la chaîne de commentaire dans le sous titreRecopieCommentaire		import transfertTexteBuffer_soustitre		jsr	   transfertTexteBuffer_soustitre			rts; --------------------------------------------		Exit	rts				DbgInfo.new	ConversionFichierAscii_BonBougre		align 4			ENDP							* ===============================================*	Procedure	FindFrame_NormeN19()* ===============================================; Cette procédure détermine si le fichier présent en mémoire est un fichier de type N19; on détecte si l'on trouve la phrase  'STL25.01'FindFrame_NormeN19			PROC	EXPORT			WITH	StandardFileReply,SFReply	; on utilise le même stackframe						move.l	a0,a1			; début du fichier			lea		3(a1),a1			lea		string1(pc),a2			move.w	#7,d0Loop1		cmp.b	(a1)+,(a2)+			bne.s	Err			Dbra	d0,Loop1			move.l	#25,d0			bra.S	Exit						move.l	a0,a1			; début du fichier			lea		3(a1),a1			lea		string2(pc),a2			move.w	#7,d0Loop2		cmp.b	(a1)+,(a2)+			bne.s	Err			Dbra	d0,Loop2			move.l	#30,d0			bra.S	ExitErr			move.l	#-1,d0		; ce n'est pas un n19			rtsexit		move.l	#0,d0		; c'est un fichier n19			rts			string	Asisstring1		dc.b	'STL25.01'string2		dc.b	'STL30.01'			string	Pascal						DbgInfo.new		FindFrame_NormeN19	; this name will appear in the debugger			align 4				ENDP			* ===============================================*	Procedure	ConversionN19_bonBougre()* ===============================================; Cette procédure transfert un fichier de norme N19  en mémoire; ;;;;ConversionN19_bonBougre			PROC	EXPORT			WITH	StackFrameImportationFichier,StandardFileReply,SFReply,N19_GSI,N19_TTI,\					DateTimeRec; on utilise le même stackframe								import	Rafraichi_Curseur		; on ouvre un dialogue pour indiquer à l'utilisateur que nous sommes en train de lire; un fichier au norme N19						clr.l	-(sp)			move.w	#138,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)			_DrawDialog				move.l	TheDialogPtr(a6),-(sp)			_setPort			; on dit que c'est pour convertir un fichier ASCII					move.l	TheDialogPtr(a6),-(sp)			move.w	#5,-(sp)	; item 5			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	ItemHandle(a6),-(sp)			pea	#'Importation de fichier  N19-1991'			_SetItext					move.l	TheDialogPtr(a6),-(sp)			move.w	#9,-(sp)	; item 9			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem								move.l	ItemHandle(a6),-(sp)			pea	#'        '			_SetItext							; on affiche le nom du fichier			move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						move.l	ItemHandle(a6),-(sp)			move.l	Reply(a6),-(sp)			_SetItext										; on trace la ligne sous le titre			move.l	TheDialogPtr(a6),-(sp)			move.w	#4,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem										_penNormal						move.w	#SrcCopy,-(sp)			_TEXTMode					pea		itemRect(a6)			_FrameRect					;on entoure la reglette				move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem								_penNormal						pea		itemRect(a6)			_FrameRect						move.w	right+itemRect(a6),d0			sub.w	left+itemRect(a6),d0			sub.w	#6,d0			move.w	d0,LargeurReglette(a6)												move.w	bottom+itemRect(a6),bottom+rectangle(a6)			subq.w	#2,bottom+rectangle(a6)			move.w	top+itemRect(a6),top+rectangle(a6)			addq.w	#2,top+rectangle(a6)						move.w	left+itemRect(a6),left+Rectangle(a6)			add.w	#2,left+rectangle(a6)				move.l	TheDialogPtr(a6),-(sp)			move.w	#2,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		NombreSTLusRect(a6)			_GetDItem						move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem		; on commence par initialiser la liste de sous-titre;			Pea		#'break conversion befor efface st BB';  			_DebugSTR						move.l	Reply(a6),-(sp)			import	EffaceTouslesSousTitres			jsr		EffaceTouslesSousTitres					; lecture du block gsi update des attributs généraux			move.l	Paramblock(a6),a0			clr.l	ioCompletion(a0)			move.l	#0,ioPosOffset(a0)				lea		BlockGSI(a6),a1		; buffer pour le block gsi			move.l	a1,ioBuffer(a0)			move.l	#1024,ioReqCount(a0)					move.w	#fsFromStart,ioPosMode(a0)			_Read;------------ on transfère les attributs généraux; transfert des nom de film etc...						lea		BlockGSI(a6),a4		; buffer pour le block gsi; --- lecture code caractère			move.b	CCT+1(a4),d0			and.w	#$9,d0			add.w	#1,d0					move.w	d0,G.CodeCaractere			; --- lecture code de langue															move.w	LC(a4),d6; Recherche dans la table du code de langue			move.w	#90,d7	; nombre de code de langue dans la liste			loop_Code_de_langue			Pea		buff1(a6)			move.w	#130,-(sp)			move.w	d7,-(sp)			import	GetIndString			jsr		GetIndString						cmp.w	buff1+1(a6),d6			beq.s	Found_Code_de_Langue			dbra	d7,loop_Code_de_langue									Found_Code_de_Langue						move.w	d7,G.CodeLangue			; --- lecture du pays d'origine									; Recherche dans la table du pays d'origine	; recherche dans le menu  entre (); il faut rechercher dans chaque menu la parenthèse puis comparer les 3 caractères suivants			clr.l	-(sp)			move.w	#2007,-(sp)			_GetRMenu			move.l	(sp)+,PopUp_PaysOrigine(a6)						move.w	#1,d7	; à partir du premier item			loop_Code_du_pays_Origine; on récupère la chaine de caractère			move.l	PopUp_PaysOrigine(a6),-(sp)			move.w	d7,-(sp)			pea		Buff1(a6)			_GetItem						tst.b	Buff1(a6)			beq.s	Titre_original_Programme	; plus de menu on ne change rien			; on recherche la parenthèse			lea		buff1+1(a6),a0			moveq	#0,d6				move.b	buff1(a6),d6	; nombre max de char			RechercheParenthese_Loop						cmp.b	#'(',(a0,d6.w)			beq.s	Found_Parenthese			dbra	d6,RechercheParenthese_Loop				bra.s	Titre_original_Programme	; pas trouvé (			; On compare maintenant si les 3 lettres sont égalesFound_Parenthese								lea		1(a0,d6.w),a0			lea		CO(a4),a1			cmp.b	(a0)+,(a1)+			bne.s	Finloop_Pays_Origine			cmp.b	(a0)+,(a1)+			bne.s	Finloop_Pays_Origine			cmp.b	(a0)+,(a1)+			bne.s	Finloop_Pays_Origine						bra.s	Found_Code_du_pays_Origine	; c'est même code de char			Finloop_Pays_Origine				addq	#1,d7					; on incrémente le compteur			bra	loop_Code_du_pays_Origine							Found_Code_du_pays_Origine						move.w	d7,G.PaysOrigine		; -------- on recopie le titre original du programmeTitre_original_Programme			lea	OPT(a4),a0			LEA	G.Preference_TitreOriginal,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.Preference_TitreOriginal,A1			move.w	#32,d7			Loop_SearchLenth_TOP			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_TOP			dbra	d7,Loop_SearchLenth_TOP			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_TOP			move.b	d7,(a1)	; on place la longueur			; -------- on recopie le titre original de l'épisodeTitre_original_Episode			lea	OET(a4),a0			LEA	G.Preference_TitreEpisodeOriginal,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.Preference_TitreEpisodeOriginal,A1			move.w	#32,d7			Loop_SearchLenth_TOE			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_TOE			dbra	d7,Loop_SearchLenth_TOE			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_TOE			move.b	d7,(a1)	; on place la longueur; -------- on recopie la traduction titre original du programmeTraduction_Titre_original_programme			lea	TPT(a4),a0			LEA	G.Preference_TitreFrancais,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.Preference_TitreFrancais,A1			move.w	#32,d7			Loop_SearchLenth_TTOP			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_TTOP			dbra	d7,Loop_SearchLenth_TTOP			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_TTOP			move.b	d7,(a1)	; on place la longueur			; -------- on recopie la traduction titre original de l'épisodeTraduction_Titre_original_Episode			lea	TET(a4),a0			LEA	G.Preference_TitreEpisodeTraduit,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.Preference_TitreEpisodeTraduit,A1			move.w	#32,d7			Loop_SearchLenth_TTOE			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_TTOE			dbra	d7,Loop_SearchLenth_TTOE			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_TTOE			move.b	d7,(a1)	; on place la longueur					; -------- on recopie Le nom du traducteurNom_du_traducteur			lea	TN(a4),a0			LEA	G.Preference_NomAdaptateur,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.Preference_NomAdaptateur,A1			move.w	#32,d7			Loop_SearchLenth_NDT			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_NDT			dbra	d7,Loop_SearchLenth_NDT			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_NDT			move.b	d7,(a1)	; on place la longueur				; -------- on recopie Les coordonnées du traducteurCoordonnees_du_traducteur			lea	TCD(a4),a0			LEA	G.Preference_CoordonneesAdaptateur,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.Preference_CoordonneesAdaptateur,A1			move.w	#32,d7			Loop_SearchLenth_CDT			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_CDT			dbra	d7,Loop_SearchLenth_CDT			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_CDT			move.b	d7,(a1)	; on place la longueur					; -------- on recopie le code de référence de la liste des sous-titresCode_de_reference			lea	SLR(a4),a0			LEA	G.CodeDeReference,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.CodeDeReference,A1			move.w	#16,d7			Loop_SearchLenth_CDR			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_CDR			dbra	d7,Loop_SearchLenth_CDR			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_CDR			move.b	d7,(a1)	; on place la longueur								; ------- Date de création			lea		Buff1(A6),a0						move.b	CD(a4),d0			and.l	#$F,d0			mulu	#10,d0			move.b	CD+1(a4),d1			and.l	#$f,d1			add.b	d1,d0			add.w	#1900,D0			move.w	d0,Year(a0)						move.b	CD+2(a4),d0			and.l	#$f,d0			mulu	#10,d0			move.b	CD+3(a4),d1			and.l	#$f,d1			add.b	d1,d0			move.w	d0,Day(a0)	;!!!! erreur sur le REA pour la date normalement month			move.b	CD+4(a4),d0			and.l	#$f,d0			mulu	#10,d0			move.b	CD+5(a4),d1			and.l	#$f,d1			add.b	d1,d0			move.w	d0,Month(a0)	;!!!! erreur sur le REA pour la date normalement month						clr.w	minute(a0)			clr.w	second(a0)			clr.w	dayOfWeek(a0)					_Date2Secs			move.l	d0,G.DateDeCreation; ------- Date de révision			lea		Buff1(A6),a0			move.b	RD(a4),d0			and.l	#$F,d0			mulu	#10,d0			move.b	RD+1(a4),d1			and.l	#$f,d1			add.b	d1,d0			add.w	#1900,D0			move.w	d0,Year(a0)						move.b	RD+2(a4),d0			and.l	#$f,d0			mulu	#10,d0			move.b	RD+3(a4),d1			and.l	#$f,d1			add.b	d1,d0			move.w	d0,Day(a0)	;!!!! erreur sur le REA pour la date normalement month			move.b	RD+4(a4),d0			and.l	#$f,d0			mulu	#10,d0			move.b	RD+5(a4),d1			and.l	#$f,d1			add.b	d1,d0			move.w	d0,Month(a0)	;!!!! erreur sur le REA pour la date normalement month						clr.w	minute(a0)			clr.w	second(a0)			clr.w	dayOfWeek(a0)					_Date2Secs			move.l	d0,G.ModifieLe			; ------- Numéro de la révision			move.b	RN(a4),d0			and.l	#$f,d0			mulu	#10,d0			move.b	RN+1(a4),d1			and.l	#$f,d1			add.b	d1,d0			move.w	d0,G.Revision			; ------- nombre de ligne de sous-titres			move.b	MNR(a4),d0			and.l	#$F,d0			mulu	#10,d0			move.b	MNR+1(a4),d1			and.l	#$f,d1			add.b	d1,d0			addq.w	#1,d0			move.w	d0,TotalLigneGSI(a6);			; -------- on recopie l'éditeur de la liste des sous-titreEditeur_liste			lea	PUB(a4),a0			LEA	G.EditeurListe,A1			adda.l	#1,a1			move.l	#32,d0			_Blockmove			; on recherche le dernier caractère non espace			LEA	G.EditeurListe,A1			move.w	#32,d7			Loop_SearchLenth_LST			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_LST			dbra	d7,Loop_SearchLenth_LST			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_LST			move.b	d7,(a1)	; on place la longueur; -------- on recopie le nom du monteur de la liste des sous-titreMonteur_liste			lea	EN(a4),a0			LEA	G.NomDuMonteur,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.NomDuMonteur,A1			move.w	#32,d7			Loop_SearchLenth_ML			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_ML			dbra	d7,Loop_SearchLenth_ML			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_ML			move.b	d7,(a1)	; on place la longueur; -------- on recopie les coordonnées du monteur de la liste des sous-titreCoordonnee_Monteur_liste			lea	ECD(a4),a0			LEA	G.CoordonneeMonteur,A1			adda.l	#1,a1			move.l	#32,d0			import	Recopie_StringPCMac			jsr		Recopie_StringPCMac			; on recherche le dernier caractère non espace			LEA	G.CoordonneeMonteur,A1			move.w	#32,d7			Loop_SearchLenth_CML			cmp.b	#' ',(a1,d7.w)			bne.s	Find_Find_Letter_CML			dbra	d7,Loop_SearchLenth_CML			move.w	#0,d7	; pas de caractères trouvésFind_Find_Letter_CML			move.b	d7,(a1)	; on place la longueur			; --------- on affecte le titre original aux fenètres; fenètre saisie									Pea		Buff1(a6)		move.w	#129,-(sp)		move.w	#3,-(sp)		import	GetIndString		jsr		GetIndString						lea		G.Preference_TitreOriginal,a0		lea		Buff1(a6),a1		import	AppendStr		jsr		AppendStr			pea		G.DialogSaisie		Pea		Buff1(a6)		_SetWtitle		; fenètre listing							Pea		Buff1(a6)		move.w	#129,-(sp)		move.w	#4,-(sp)		import	GetIndString		jsr		GetIndString								lea		G.Preference_TitreOriginal,a0		lea		Buff1(a6),a1		jsr		AppendStr		pea		G.ListingWindow		Pea		Buff1(a6)		_SetWtitle		; ----   on regarde combien de disquettes doivent ètre lus		move.b	TND(a4),d0		and.l	#$F,d0		move.w	d0,NombreTotalDisquette(a6)		; ----   le numéro d'ordre de la disquette		move.b	DSN(a4),d0			and.l	#$F,d0		move.w	d0,NumeroOrdreDisquette(a6)		cmp.w	#1,d0		beq.s	PasErreurNumeroDisquette; il y a une erreur nous ne lisons pas la disquette n°1; on fait une alert où nous indiquons ce problème; 3 choix : 1) changer de disquette, 2) continuer, 3) annuler; ############### faire le code ici !!!!!!! ########@PasErreurNumeroDisquette; ----    Le nombre de block TTI pour cette disquette; on converti ascii décimal => binaire			move.b	TNB(a4),d0			and.w	#$f,d0			mulu	#10000,d0						move.b	TNB+1(a4),d1			and.w	#$f,d1			mulu	#1000,d1			add.l	d1,d0						move.b	TNB+2(a4),d1			and.w	#$f,d1			mulu	#100,d1			add.l	d1,d0						move.b	TNB+3(a4),d1			and.w	#$f,d1			mulu	#10,d1			add.l	d1,d0						move.b	TNB+4(a4),d1			and.l	#$f,d1			add.l	d1,d0						move.w	d0,NombreTotalTTI(a6)						; ----    Le nombre de sous-titre pour cette disquette; on converti ascii décimal => binaire			move.b	TNS(a4),d0			and.w	#$f,d0			mulu	#10000,d0						move.b	TNS+1(a4),d1			and.w	#$f,d1			mulu	#1000,d1			add.l	d1,d0						move.b	TNS+2(a4),d1			and.w	#$f,d1			mulu	#100,d1			add.l	d1,d0						move.b	TNS+3(a4),d1			and.w	#$f,d1			mulu	#10,d1			add.l	d1,d0						move.b	TNS+4(a4),d1									and.l	#$f,d1			add.l	d1,d0						move.w	d0,NombreTotalST(a6); ----    Le nombre de Groupe de sous-titre pour cette disquette; on converti ascii décimal => binaire						move.b	TNG+2(a4),d1			and.w	#$f,d1			mulu	#100,d1			add.l	d1,d0						move.b	TNG+3(a4),d1			and.w	#$f,d1			mulu	#10,d1			add.l	d1,d0						move.b	TNG+4(a4),d1			and.l	#$f,d1			add.l	d1,d0						move.w	d0,NombreTotalGroupeST(a6)			; ----   Le time code début du programme			move.b	TCP-1(a4),d7		; sauvegarde du caractères avant 						move.b	#8,TCP-1(a4)		; nombre de chiffre			Lea.l	TCP-1(a4),a0			import	ConversionchaineASCIITc			jsr		ConversionchaineASCIITc						move.l	d0,G.TcDebutFilm			move.b	d7,TCP-1(a4)		; on rend le contenu original; ----   Le premier st du programme; On ne récupère pas cette valeur car elle est automatiquement activée; par la vérification de la liste des sous-titres					; ---------  maintenant on effectue la lecture des blocks TTI disquette par disquette; ---------  Lecture du fichier ; boucle nombre de diskette ; boucle nombre de sous-titre par disquette; initialisation		move.l	BufferTransfer(a6),a0		adda.l	#1024-128,a0			; taille du block GSI- première incrémentation		move.l	a0,Pointeur(a6)			; adresse du premier block TTI		; -------		boucle de recopieLoop_Nombre_de_Block_TTI				add.l	#128,Pointeur(a6)	; block TTI suivant; on vérifie que le block TTI est contenu en entier dans le buffer tampon				move.l	Pointeur(a6),d0		sub.l	BufferTransfer(a6),d0		add.l	#128,d0		cmp.l	SizeOfRead(a6),d0		bls.s	TTI_EnEntier		; oui en entier; on effectue une relecture à partir de l'endroit où nous sommes				move.l	Paramblock(a6),a0		clr.l	ioCompletion(a0); position de lecture 				move.l	Pointeur(a6),d0		sub.l	BufferTransfer(a6),d0		move.l	d0,ioPosOffset(a0)	; on reli à partir du dernier header trouvé		move.l	BufferTransfer(a6),ioBuffer(a0)		move.l	BufferSize(a6),ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)		_Read				move.w	d0,OpenErr(a6)		bsr		TraitementErreurFichier		tst.l	d1		bne 	exit  ; arrêt de la procédure et mise à jour du dernier sous-titre				move.l	paramBlock(a6),a0		move.l	ioActCount(a0),SizeOfRead(a6)				move.l	BufferTransfer(a6),Pointeur(a6)	; initialisation		; -------------------------------------------------------------- ;le block TTI est entier donc nous le plaçons dans un sous-titreTTI_EnEntier					import	Transfert_BlockTTI_Soustitre		jsr		Transfert_BlockTTI_Soustitre		; incrémentation du curseur du dialogue		bsr		Rafraichi_Curseur; fin de boucle block TTI		Sub.w	#1,NombreTotalTTI(a6)		bne.s	Loop_Nombre_de_Block_TTI				; fin de boucle disquette		; ON élimine le dernier sous-titre									import	C_DeleteSt			move.l	G.General_DernierSTPtr,-(sp)			jsr		C_DeleteSt			exit					move.l	TheDialogPtr(a6),-(sp)			_DisposDialog			PEA	QD.Arrow		; got arrow cursor at InitGraf			_SetCursor								rts			DbgInfo.new		ConversionN19_bonBougre	; this name will appear in the debugger			align 4				ENDP			* ========================================		* PROCEDURE	Transfert_BlockTTI_Soustitre()			* ========================================**	Cette routine convertie les caractères de block TTI vers des caractères*	Utilisés par Bon Bougre™, Que faire des systèmes Double Hauteur etc.. ???.**	Entrée: A0 contient le pointeur sur un block TTI*			A1 pointeur du sous-titre de destination (qui doit ètre créer avant cette routine)*	*Transfert_BlockTTI_Soustitre 		PROC	EXPORT		with	StackFrameImportationFichier,N19_GSI,N19_TTI,SOUSTITRERECORD		move.l	G.General_DernierSTPtr,a2		; pointeur du sous-titre en cour 		move.l	Pointeur(a6),a3					; pointeur du block TTI;------- on récupère le handle de la table de conversion.		move.l	G.ResourceDATA1000,a4		cmpa.l	#00000,a4		bne		ResourceExiste		; la resource existe		; on récupère la resource puisqu'elle n'est pas en mémoire				clr.l	-(sp)		move.l	#'DATA',-(SP)		move.W	#1000,-(SP)		_GetResource		suba.l	a4,a4		; on raz a4		move.L	(SP)+,D0		beq.s	TexteOuCommentaire			; la resource n'est pas présente		move.L	D0,G.ResourceDATA1000			move.l	d0,a4		ResourceExiste				move.l	(a4),a4					; Handle		;-------  Texte ou commentaireTexteOuCommentaire						cmp.b	#01,CF(a3)		; Drapeau de remarque ?		beq 	Commentaire		cmp.b	#00,CF(a3)		; Drapeau de texte ?		bne 	Exit			; pas texte on ignore le block TTI; --------------------------------------------------------------------; traitement du texteTexte	; on initialise la couleur par défaut du texte (noir à l'affichage Blanc à l'incrustation);		lea		texteStyle(a6),a0		move.w	#0,tsColor+red(a0)			move.w	#0,tsColor+blue(a0)			move.w	#0,tsColor+green(a0)	; on initialise la police par défaut		move.w	G.General_FontNumber,tsFont(a0); le style par défaut		clr.w	tsFace(a0); la taille par défault			; note cette valeur est changée entre les deux fenêtres listing et saisie		move.w	#9,tsSize(a0)	; 9 pour la fenètre listing; on raz les flags	du sous-titres		clr.l	st_Flags(a2); un ligne de texte				move.w	#1,st_Nlines(a2)		; on  détermine la longueur max du texte; pour déterminer le pointeur du style 		lea		TF(a3),a0		move.w	#111,d7			; longueur maxRecherche_Longueur_Texte_Loop		cmp.b	#$8f,(a0,d7.w)	; $8f octets non utilisé		bne.s	Found_LongueurTexte		dbra 	d7,Recherche_Longueur_Texte_Loop		moveq	#0,d7	; pas de caractèresFound_LongueurTexte		move.w	d7,d0		addq.w	#1,d0		; longueur du texte		ext.l	d0		import	AligneD0		jsr		AligneD0	; longueur du texte aligné sur mots long			add.l	#st_sizeOf,d0	; longueur du header du sous-titre			move.l	a2,a0		adda.l	d0,a0		move.l	a0,st_StylePTR(a2)	; pointeur du style rec					move.l	#st_sizeOf,d0	; longueur du header du sous-titre			move.l	a2,a1		adda.l	d0,a1			; pointeur du texte dans le sous-titre; on place un style neutre au début de ligne				move.w	#-1,-(sp)		; tous les parramètres		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	#0,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style		; ---- on recopie le texte dans le sous-titre 						lea		TF(a3),a3		moveq	#0,d6			; compteur pour écriture dans sous-titre		RecopieTexte_Loop				move.b	(a3)+,d0	; lecture d'un octets		; on détermine la signification du caractères		cmp.b	#$20,d0		blo 	Code_Teletexte				cmp.b	#$8f,d0		beq 	fin_recopie_texte; code de fin du texte				cmp.b	#$A0,d0		bhi.s	Caracteres		cmp.b	#$80,d0		blo.s	Caracteres; --------------------; c'est un code de contrôle $80 -> $a0		cmp.b	#$8a,d0			; retour chariot ?		bne.s	PasCr			; non		move.b	#$0d,(a1,d6.w)	; on place le retour chariot		add.w	#1,D6; on regaarde s'il est suivi par un autre CR (dans le cas d'une double hauteur !); il faudra vérifier si double hauteur #########		cmp.b	#$8a,(a3)		bne 	Fin_loop_Recopie_Texte	; non ce nest pas le cas; oui il y a un autre CR		move.b	(a3)+,d0	; on l'élimine		bra 	Fin_loop_Recopie_Texte	; non ce nest pas le cas	; -----PasCr	cmp.b	#$80,d0			; début italique		bne.s	Pas_DebutItalique; c'est l'attribut pour les italiques, on ajoute un style				move.w	#2,tsFace+texteStyle(a6)		; style italic		move.w	#doFace+doColor+doFont,-(sp)	; la fonction		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style		bra 	Fin_loop_Recopie_Texte; -----Pas_DebutItalique				cmp.b	#$81,d0			; fin italique ?		bne.s	Pas_FinItalique				move.w	#0,tsFace+texteStyle(a6)		; plus style		move.w	#doFace+doColor+doFont,-(sp)	; la fonction		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style				bra 	Fin_loop_Recopie_Texte; -----Pas_FinItalique; on ne gère pas les autres attributs (sous-lignage, emboîtage)				bra 	Fin_loop_Recopie_Texte; ---------------------------------------------------------; c'est un caractères affichable $20 -> $7f et $a1-> $FFCaracteres			; si char < $80 sauf $ on ne change rien		cmp.b	#'$',d0		bne.s	PasCaractereSpecial_txt		move.b	#'€',(a1,d6.w)	; on place le caractère		add.w	#1,D6			bra 	Fin_loop_Recopie_Texte; -----PasCaractereSpecial_txt				cmp.b	#$7f,d0		bhi		Conversion_caractere_Txt		move.b	d0,(a1,d6.w)	; on place le caractère		add.w	#1,D6			bra 	Fin_loop_Recopie_Texte		; -----		; il faut effectuer une conversion Conversion_caractere_txt				bsr		ConversionChar		move.b	d0,(a1,d6.w)	; on place le caractère		add.w	#1,D6					bra 	Fin_loop_Recopie_Texte		; ---------------------------------------------------------; c'est un code de contrôle Teletexte >$20Code_Teletexte;		bra 	Fin_loop_Recopie_Texte	; ############ !!!!!!!!!!!!!!				cmp.b	#$07,d0			; alphaNoir ?		bra.s	Pas_Alpha;		bhi.s	Pas_Alpha	; ################; couleur des caractères		lea		tableCouleur(pc),a0		and.l	#$7,d0		mulu	#6,d0	; poiteur sur la couleur		move.w	red(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+red(a6)		move.w	green(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+green(a6)		move.w	blue(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+blue(a6)						move.w	#doColor,-(sp)	; uniquement couleur		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style				bset	#9,st_Flags(a2)	; couleur type teletext				bra.s		Fin_loop_Recopie_Texte; table de conversion couleurs ceefax => RBGColor 		tableCouleur			dc.w	$0000,$0000,$0000	; noir		dc.w	$8080,$0000,$0000	; rouge		dc.w	$0000,$8080,$0000	; vert		dc.w	$8080,$8080,$0000	; jaune		dc.w	$0000,$0000,$ffff	; bleu		dc.w	$8080,$0000,$8080	; magenta		dc.w	$0000,$8080,$8080	; cyan		dc.w	$ffff,$ffff,$ffff	; blanc; -------		Pas_Alpha				cmp.b	#$0c,d0					; hauteur normale ?		beq.s	Fin_loop_Recopie_Texte	; par défaut; -------				cmp.b	#$0d,d0					; double hauteur ?		bne.s	pas_DoubleHauteur		; non				bset	#11,st_Flags(a2)			; double hauteur 		bra.s	Fin_loop_Recopie_Texte	; -------		pas_DoubleHauteur			cmp.b	#$0e,d0					; double largeur ?		bne.s	pas_DoubleLargeur		; non				bset	#10,st_Flags(a2)			; double largeur		bra.s	Fin_loop_Recopie_Texte	; -------pas_DoubleLargeur		cmp.b	#$0e,d0					; double taille ?		bne.s	Fin_loop_Recopie_Texte	; non				bset	#10,st_Flags(a2)			; double largeur		bset	#11,st_Flags(a2)			; double hauteur Fin_loop_Recopie_Texte		dbra	d7,RecopieTexte_Loopfin_recopie_texte	; on regarde s'il y a des cr(s) à la fin du texte; si oui on l'élimine		cmp.b	#$0d,-1(a1,d6.w)		bne.s	PasDeCr_alafindutexte		move.b	#$00,-1(a1,d6.w)		; on remplace par zéroLaisseUneLigne				subQ.w	#1,d6						; on ne peut pas faire dbra		bne		fin_recopie_texte		PasDeCr_alafindutexte		and.l	#$ffff,d6		bne.s	ChainePAsVide		; si texte vide pas de style				clr.l	st_StyleLenth(a2)		clr.l	st_StylePtr(a2)		ChainePAsVide				move.l	d6,st_TexteLenth(a2)						; on compte maintenant le nombre de CR dans le texte,  ce qui donne le nombre de ligne					move.w	#1,st_Nlines(a2)		moveq	#0,d0		Loop_CompteLigne				cmp.b	#$0d,(a1,d0.w)		bne.s	PasCr_EN_Plus		add.w	#1,st_Nlines(a2)PasCr_EN_Plus		addq.w	#1,d0		cmp.w	d6,d0		blo		Loop_CompteLigne									bra		Fin_Block_TTI; -------------------------------------------------; traitement des commentaireCommentaire		bra		Fin_Block_TTI		; --------------------------------------------------------------; On regarde l'état du parramètre d'extension EBN du block TTIFin_Block_TTI; faut-il prendre le tc ; on prend le tc du premier block TTI ? 		move.l	Pointeur(a6),a3					; pointeur du block TTI		cmp.b	#1,CS(a3)		bhi 	PasPremier_BlockTTI; on récupère le tc in		lea		TCI(a3),a0		import	Conversion_TCN19__Bcd		jsr		Conversion_TCN19__Bcd		move.l	d0,st_TimeCodeIn(a2)		; on récupère le tc Out		lea		TCO(a3),a0		import	Conversion_TCN19__Bcd		jsr		Conversion_TCN19__Bcd		move.l	d0,st_TimeCodeOut(a2)		; on récupère la position verticale du sous-titre		moveq	#0,d0		move.b	VP(A3),d0		clr.w	st_YOffset(A2); ##		move.w	d0,st_YOffset(A2); on indique que c'est une position verticale télétexte				move.w	st_flags(a2),d0		bset	#12,d0		move.w	d0,st_flags(a2)				; on récupère la justification du sous-titre		lea 	tableConversionJustif(pc),a0		moveq	#0,D0		move.b	JC(A3),d0		cmp.b	#4,d0	; on prévient les erreurs		blo.s	@SupJustif		moveq	#2,D0@SupJustif				move.b	(a0,d0.w),d0		move.b	d0,st_Justification(a2)						; maintenant on regarde s'il faut remonter les sous-titres; c'est à dire que la position de départ est différentes		; on regarde si ce sont des caractères double-hauteur		; si double hauteur départ en ligne 22; si simple hauteur départ en ligne 23; 		string pascal;  		Pea		#'Verif hauteur soustitre';  		_DebugSTR		move.b	VP(A3),d0	; on vérifie que ce n'est pas nul		cmp.b	#1,d0		bgt		PAsChangeVP		move.b	#1,VP(A3)PAsChangeVP				btst	#11,st_Flags(a2)			; double hauteur 		beq.s	Pas_double_Hauteur		move.b	VP(A3),d0		; c'est une double hauteur		move.w	TotalLigneGSI(a6),D0	; nombre de rangée + 1		sub.b	VP(A3),d0		divu	#2,D0; nombre de ligne		sub.w	st_Nlines(a2),d0				bra.s	Add_CR; -----Pas_double_Hauteur		move.w	TotalLigneGSI(a6),D0	; nombre de rangée + 1 		sub.b	VP(A3),d0 		sub.w	st_Nlines(a2),d0	; on décompte le nombre de ligne				Add_CR; on additionne des cr à la fin du texte on vérifie qu'il n'y en a pas de trop		cmp.w	TotalLigneGSI(a6),d0		blo		Add_CR1		move.w	TotalLigneGSI(a6),d0	; on limite au nombre TotalLigneGSI		Add_CR1				tst.l	st_TexteLenth(a2)		beq		PasPremier_BlockTTI ; si pas de texte pas de cr en plus 				tst.w	d0		beq.S	PasPremier_BlockTTI; pas de cr		lea		(a1,D6.w),A1; on ajoute le nombre de ligne // nombre de cr				add.w	d0,st_Nlines(A2)		subq.w	#1,d0Add_CR_loop		addi.l	#1,st_TexteLenth(a2)		move.b	#$0d,(a1)+		dbra	d0,Add_CR_loop								PasPremier_BlockTTI		cmp.b	#$ff,EBN(a3)				; dernier Block TTI ?		bne.s	Exit						; non		; on calcule la taille du sous-titre		move.l	st_stylePtr(a2),d0		beq.s	pasdestyle		sub.l	a2,d0				; début du sous-titre		sub.l	#st_sizeOf,d0		; espace aloué au texte				move.l	st_styleLenth(a2),d1	; taille des styles		import	aligned1		jsr		aligned1		add.l	d1,d0pasdestyle		move.l	st_CommentaireLenth(a2),d1		import	aligned1		jsr		aligned1		add.l	d1,d0		add.l	#8,d0		; en secu			move.l	d0,st_LenthST(a2)	; longueur du sous-titre		; oui on insert un sous-titre	pour le prochain ST				move.l	a2,a0		move.l	#0,d0		import	InsertST		jsr		InsertSTExit	rts		; sous-routine de conversion caractère N19 => mac; a4 pointe sur la table de conversionConversionChar		movem.l	a4,-(sp)		; on sauvegarde a4		move.b	d0,d1				and.b	#$F0,d1		cmp.b	#$c0,d1		beq.s	accentuation; c'est un caractère simpleLoop_Recherche_Single_Char				move.w	2(a4),d1				; code n19			beq.s	Exit_Conv_char			; fin de la table pas trouvé on sort directement		cmp.b	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.S	Loop_Recherche_Single_CharFound_The_Char		move.b	1(a4),d0Exit_Conv_char		movem.l	(sp)+,a4		; récupération a4		rts; --------------------------------------	; c'est une accentuation		accentuation		; on lit le caractère suivant		asl.w	#8,d0		; code accent b15-b8		move.b	(a3)+,d0	; lecture d'un octets	(le caractère b7-b0)Loop_Recherche_double_Char				move.w	2(a4),d1				; code n19		beq.s	Exit_Conv_char			; fin de la table,on sort avec le caractère simple dans d0		cmp.w	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.S	Loop_Recherche_double_Char	tableConversionJustif			dc.b	00	; 0= centrée			dc.b	01	; gauche			dc.b	00	; centrée			dc.b	02	; justif droite						dc.b	02	; 0= centrée			dc.b	01	; 1= gauche			dc.b	03	; 2=Droite			dc.b	00	; 		DbgInfo.new	Transfer_BlockTTI_Soustitre		align 4			ENDP						* ================================================* PROCEDURE		Add_style()* ================================================; Cette routine ajoute un style dans un sous-titre; si le style existe déja, il change les  parramètres désignée par Fonct_demande;;Add_style	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFonct_demande		ds.w	1	; la fonctionThe_StyleRec		ds.l	1	; le recordSTPtr				ds.l	1	; le sous-titreStartChar			ds.w	1	; la position de départ du styleParamSize			EQU	ParamBegin-*				; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,SOUSTITRERECORD		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				import	ConversionTrames_TimeCode,CopySTR		movem.l	d0-d7/a1-a4,-(sp)	; sauvegarde des registres		; on commence par déterminer s'il ya un style à la position demandée			move.l	stPtr(a6),d0		beq		Exit			; Pas de pointeur de sous-titre on ne fait rien		move.l	d0,a4		move.l	st_StylePtr(A4),d0		beq		Exit			; pas de pointeur de style ; on ne fait rien pour l'instant		move.l	d0,A3			; pointeur du style; on regarde le nombre de style			tst.l	st_styleLenth(a4)		beq		Nouveau_Style_Vierge	; il n'y a pas de style on en ajoute 1				move.w	(a3),d7		; nombre de style en mémoire; on recherche s'il y a un style du même numéro		subq.w	#1,d7		move.w	d7,d0		mulu	#20,d0		; offset dans la table		move.l	a3,a2		adda.l	#0000002,a2			adda.l	d0,a2		; dernier styleLoop_recherche_Style				move.w	StartChar(a6),d6		and.l	#$ffff,d6		cmp.l	scrpStartChar(a2),d6		beq		Found_Same_style		bhi		Found_style_Sup				suba.l	#00000020,a2			; style précédent		dbra	d7,Loop_recherche_Style; si nous sommes ici dans la boucle c'est qu'il y a un pb; --------- on ajoute un nouveau style ---------------Nouveau_Style	; on créer un style		move.l	a3,a0	; pointeur de style		move.w	(a0),d0	; nombre de style		addq.w	#1,d0		move.w	d0,(a0)+	; nombre de style +1		; on recopie le style précédent		mulu	#20,d0		adda.l	d0,a0		move.l	a0,a3		; on sauvegarde le pointeur de style				move.l	a0,a1		; le nouveau style				sub.l	#00020,a0	; l'ancienne valeur		move.l	#20,d0		_BlockMove				move.l	a3,a0	;on récupère le pointeur de style		bsr		Fill_The_Style	; on place les attributs demandés		add.l	#20,st_StyleLenth(a4)	; longueur des styles		bra		Exit; --------- on créer un  style ---------------Nouveau_Style_Vierge		move.l	a3,a0	; pointeur de style		move.w	#1,(a0)+	; nombre de style		move.w	#-1,Fonct_demande(a6)		bsr		Fill_The_Style	; on place les attributs demandés		move.l	#22,st_StyleLenth(a4)	; longueur des styles+octet de nombre		bra		Exit; -----------------------------------------; il y a déja un style à cette position de style; on replace le par les nouvelles valeurs demandée; d7 contient le nombre de style à changer; a2 pointe sur le style en questionFound_Same_style		move.l	a2,a0		bsr		Fill_The_Style	; on place le style		bra		Exit; -----------------------------------------; la position du caractère n'existe pas dans les styles; Il faut insérer un style avant celui pointé par a2Found_style_Sup; on recopie le style précédent				move.l	a2,a0	; source		move.l	a2,a1			move.l	#20,d0		adda.l	d0,a1	; destination		move	#20,d0		; taille du déplacement				_BlockMove			; déplacement		add.w	#1,(a3)		; un style de plus		move.L	a1,a0		; on insère le style		bsr		Fill_The_Style	; on place le style		add.l	#20,st_StyleLenth(a4)	; longueur des styles				Exit	movem.l	(sp)+,d0-d7/a1-a4	; récupération des registres		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller; routine pour changer le style; A0 pointe sur le style Fill_The_Style		move.w	StartChar(a6),d6		and.l	#$ffff,d6		move.l	d6,scrpStartChar(a0)				move.l	The_StyleRec(a6),a1	; the style rec		; changement de font	?		move.w	Fonct_demande(a6),d0		and.w	#DoFont,d0		beq.s	Do_Size		; non		move.l	tsFont(a1),scrpFont(a0)			; Changement de tailleDo_Size			move.w	Fonct_demande(a6),d0		and.w	#DoSize,d0		beq.s	Do_Face		; non		move.w	tsSize(a1),scrpSize(a0)			; Changement de styleDo_Face			move.w	Fonct_demande(a6),d0		and.w	#DoFace,d0		beq.s	Do_Color		; non		move.b	tsFace+1(a1),scrpFace(a0)			move.b	tsFace+1(a1),scrpFace+1(a0)			; Changement de couleurDo_Color			move.w	Fonct_demande(a6),d0		and.w	#DoColor,d0		beq.s	Exit_sub		; non		 		move.w	tsColor+red(a1),scrpColor+red(a0) 		move.w	tsColor+green(a1),scrpColor+green(a0) 		move.w	tsColor+blue(a1),scrpColor+blue(a0)Exit_sub			move.w	scrpSize(a0),d0			move.w	d0,scrpAscent(a0)		; au pif		move.w	d0,d1		lsr.w	#1,d2		and.w	#$00ff,d1		add.w	d1,d0			move.w	d0,scrpHeight(a0)		; au pif		rts		DbgInfo.new		Add_style	; this name will appear in the debugger		align 4			ENDP* ========================================		* PROCEDURE	Rafraichi_Curseur()			* ========================================** Cette routine rafraichie le dialogue de progression de lecture du fichierRafraichi_Curseur 		PROC	EXPORT						with	StackFrameImportationFichier,N19_GSI,N19_TTI						import	SpinCursor; on effectue le rafraichissement du dialog; on calcule la position en x de la reglette		move.l	pointeur(a6),d0		SUB.L	BufferTransfer(A6),D0		lsr.l	#3,d0; multiplication 32*16 => 32 bits		move.l	d0,d1		move.w	LargeurReglette(a6),d2		and.l	#$fff,d2			swap	d1		and.l	#$ffff,d1		mulu.w	d2,d1		swap	d1		and.l	#$ffff0000,d1		and.l	#$ffff,d0		mulu	d2,d0		add.l	d1,d0		; resultat sur 32 bits dans d0		move.w	LongueurFichier(a6),d1		divu	d1,d0	; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas		move.w	d0,LastXpos(a6)				BSR		Draw_Reglette 		move.w	#32,-(sp)  		JSR	SpinCursor	; spin the ball		move.l	#BlueColor,-(sp)		_ForeColor				_PenNormal		:				; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.l	G.General_NombreSt,d0		cmp.l	#704,d0				lea		buff2(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff2(a6)		_DrawString					onnedessinepas		Exit	rts		Draw_Reglette; cette routine rafraichie la reglette				move.l	d0,d6		; sécu de la valeur				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	LastXpos(a6),d0		cmp.w	left+itemRect(a6),d0		bhi.s	@123		move.w	left+itemRect(a6),d0@123				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts						DbgInfo.new	Rafraichi_Curseur		align 4			ENDP				* ========================================		* PROCEDURE	Conversion_TCN19__Bcd()			* ========================================** Cette routine convertie le format de time code de la norme N19* vers le format utilisé par le logiciel** entrée: a0 pointe sur la chaîne tc N19	; * sortie: D0 contient le tc en BCD***Conversion_TCN19__Bcd 		PROC	EXPORT						with	StackFrameImportationFichier,N19_GSI,N19_TTI						import	SpinCursor		movem.l	d1,-(sp)						moveq	#0,d0; heure				moveq	#0,d1		move.b	(a0),d1				divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0		asl.l	#4,d0; minute				moveq	#0,d1		move.b	1(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0				asl.l	#4,d0;seconde				moveq	#0,d1		move.b	2(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0				asl.l	#4,d0				;images				moveq	#0,d1		move.b	3(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0		Exit	movem.l	(sp)+,d1		rts				DbgInfo.new	Conversion_TCN19__Bcd		align 4			ENDP								* ===============================================*	Procedure	ExportationDeFichier_N19()* ===============================================; Cette procédure exporte le fichier en cour dans la norme N19;StackFrameExportN19	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètreReply				ds.l	1	; nom du fichierParamSize	EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	256	; buffer temporaire	n°2ItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1DateTime			ds		DateTimeRecBlockGSI			ds.b	1028		; le block GSISTPtr				ds.l	1			; pointeur du sous-titre en courRGB_Color			ds.W	3			; pour la reglettePopUp_PaysOrigine	ds.l	1			; NombreTotalST		ds.w	1TheDialogPtr		ds.l	1; attributs caarctère// charactèresthejust			ds.w	1			; la justification du textethestyle		ds.w	1			; le style en courstheLaststyle	ds.w	1			; le dernier style utiliséNextStyle		ds.l	1			; pointeur du prochain style theChar			ds.w	1			; le caractèretheFont			ds.w	1			; la policeThe_color		ds.w	3			; rgbColorLocalSize	EQU 	*			; size of all the local variables		ENDRExportationDeFichier_N19			PROC	EXPORT		WITH	StackFrameExportN19,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame		with	N19_GSI,N19_TTI,DateTimeRec; on utilise le même stackframe		LINK	A6,#LocalSize		; allocate our local stack frame				import	ConversionNumeroSTPointeur,TraitementErreurFichier,\				AFFICHENUMSAISIE,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR					; on ouvre un dialogue pour indiquer à l'utilisateur que nous sommes en train d'Exporter; un fichier au norme N19									clr.l	-(sp)			move.w	#138,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)			_DrawDialog						move.l	TheDialogPtr(a6),-(sp)			_SetPort		; on dit que c'est pour exporter un fichier N19				move.l	TheDialogPtr(a6),-(sp)			move.w	#5,-(sp)	; item 5			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	ItemHandle(a6),-(sp)			pea	#'Exportation de fichier  N19-1991'			_SetItext					move.l	TheDialogPtr(a6),-(sp)			move.w	#9,-(sp)	; item 9			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem								move.l	ItemHandle(a6),-(sp)			pea	#'        '			_SetItext							; on affiche le nom du fichier				move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						move.l	ItemHandle(a6),-(sp)			move.l	Reply(a6),-(sp)			_SetItext							; on trace la ligne sous le titre			move.l	TheDialogPtr(a6),-(sp)			move.w	#4,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						_penNormal						move.w	#SrcCopy,-(sp)			_TEXTMode					pea		itemRect(a6)			_FrameRect				;on entoure la reglette				move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem								_penNormal						pea		itemRect(a6)			_FrameRect						move.w	right+itemRect(a6),d0			sub.w	left+itemRect(a6),d0			sub.w	#6,d0			move.w	d0,LargeurReglette(a6)									move.w	bottom+itemRect(a6),bottom+rectangle(a6)			subq.w	#2,bottom+rectangle(a6)			move.w	top+itemRect(a6),top+rectangle(a6)			addq.w	#2,top+rectangle(a6)						move.w	left+itemRect(a6),left+Rectangle(a6)			add.w	#2,left+rectangle(a6)				move.l	TheDialogPtr(a6),-(sp)			move.w	#2,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		NombreSTLusRect(a6)			_GetDItem						move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem		; on récupère la table de conversion mac N19;------- on récupère le handle de la table de conversion.		move.l	G.ResourceDATA1000,a4		cmpa.l	#00000,a4		bne		ResourceExiste		; la resource existe		; on récupère la resource puisqu'elle n'est pas en mémoire				clr.l	-(sp)		move.l	#'DATA',-(SP)		move.W	#1000,-(SP)		_GetResource		suba.l	a4,a4		; on raz a4		move.L	(SP)+,D0		move.L	D0,G.ResourceDATA1000			ResourceExiste				; On Génère le block d'information GSI;------------ on transfère les attributs généraux; transfert des nom de film etc...						lea		BlockGSI(a6),a4		; buffer pour le block gsi; on raz le block GSI			move.w	#1024,d0			subq.w	#1,d0LoopClearGSI			move.b	#' ',(a4)+			dbra	d0,LoopClearGSI						lea		BlockGSI(a6),a4		; buffer pour le block gsi; -------- on place le n° de page de code			move.b	#'8',cpn(a4)			move.b	#'5',cpn+1(a4)			move.b	#'0',cpn+2(a4)			; -------- on place le code du format de disquette DFC			move.b	#'S',3(a4)			move.b	#'T',3+1(a4)			move.b	#'L',3+2(a4)			move.b	#'2',3+3(a4)			move.b	#'5',3+4(a4)			move.b	#'.',3+5(a4)			move.b	#'0',3+6(a4)			move.b	#'1',3+7(a4); -------- on place le type norme d'affichage			move.b	#'0',DSC(a4)	; sous-titrage ouvert			move.w	G.Preference_N19_TypeTeletexte,d0			beq.S	@1						move.b	#'1',DSC(a4)	; télétexte niveau 1@1; --- on place le code caractère				move.w	G.CodeCaractere,d0						add.w	#$30-1,d0			move.b	d0,CCT+1(a4)			move.b	#'0',CCT(a4)			; --- lecture code de langue												Pea		buff1(a6)			move.w	#130,-(sp)			move.w	G.CodeLangue,-(sp)			import	GetIndString			jsr		GetIndString			move.w	buff1+1(a6),d0			move.w	d0,LC(a4)			; --- lecture du pays d'origine									clr.l	-(sp)			move.w	#2007,-(sp)			_GetRMenu			move.l	(sp)+,PopUp_PaysOrigine(a6)						move.w	G.PaysOrigine,d0						move.l	PopUp_PaysOrigine(a6),-(sp)			move.w	d0,-(sp)			pea		Buff1(a6)			_GetItem			; on recherche la parenthèse			lea		buff1+1(a6),a0			moveq	#0,d6				move.b	buff1(a6),d6	; nombre max de char			RechercheParenthese_Loop						cmp.b	#'(',(a0,d6.w)			beq.s	Found_Parenthese			dbra	d6,RechercheParenthese_Loop				bra.s	Titre_original_Programme	; pas trouvé (			; On place les trois lettres dans le block GSIFound_Parenthese								lea		1(a0,d6.w),a0			lea		CO(a4),a1			move.b	(a0)+,(a1)+			move.b	(a0)+,(a1)+			move.b	(a0)+,(a1)+			; -------- on recopie le titre original du programmeTitre_original_Programme			lea	G.Preference_TitreOriginal,a0			lea		OPT(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le titre original de l'épisodeTitre_original_Episode						lea	G.Preference_TitreEpisodeOriginal,a0			lea		OET(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie la traduction titre original du programmeTraduction_Titre_original_programme			lea	G.Preference_TitreFrancais,a0			lea		TPT(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie la traduction titre original de l'épisodeTraduction_Titre_original_Episode						lea	G.Preference_TitreEpisodeTraduit,a0			lea		TET(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC; -------- on recopie Le nom du traducteurNom_du_traducteur						lea	G.Preference_NomAdaptateur,a0			lea		TN(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie Les coordonnées du traducteurCoordonnees_du_traducteur						lea	G.Preference_CoordonneesAdaptateur,a0			lea		TCD(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le code de référence de la liste des sous-titresCode_de_reference			lea	G.CodeDeReference,a0			lea		SLR(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC						; ------- Date de création			move.l	G.DateDeCreation,d0			lea		Buff1(A6),a0			_Secs2Date			lea		Buff1(A6),a0			moveq	#0,D0			move.w	Year(a0),d0			lea		Buff2(A6),a0			clr.w	-(sp)			_PacK7						lea		Buff2(A6),a0			move.b	3(A0),CD(a4)			move.b	4(A0),CD+1(a4)						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Month(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+2(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+3(a4)						moveq	#0,D0			move.w	Day(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+4(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+5(a4); ------- Date de révision						move.l	G.ModifieLe,d0			lea		Buff1(A6),a0			_Secs2Date						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Year(a0),d0			lea		Buff2(A6),a0			clr.w	-(sp)			_PacK7						lea		Buff2(A6),a0			move.b	3(A0),RD(a4)			move.b	4(A0),RD+1(a4)						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Month(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+2(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+3(a4)						moveq	#0,D0			move.w	Day(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+4(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+5(a4)			; ------- Numéro de la révision			moveq	#0,d1			move.w	G.Revision,d1			divu.w	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RN(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RN+1(a4)			; -------- on recopie l'éditeur de la liste des sous-titreEditeur_liste						lea		G.EditeurListe,a0			lea		PUB(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le nom du monteur de la liste des sous-titreMonteur_liste						lea		G.NomDuMonteur,a0			lea		EN(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC; -------- on recopie les coordonnées du monteur de la liste des sous-titreCoordonnee_Monteur_liste						lea		G.CoordonneeMonteur,a0			lea		ECD(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			* ###* ###	Il faudrait en théorie faire du code pour gérer plusieures disquettes* ###		; ----   on place ne nombre de disquette		move.b	#'1',TND(a4)	; un disquette; ----   le numéro d'ordre de la disquette		move.b	#'1',DSN(a4)PasErreurNumeroDisquette; ----    on place Le nombre de block TTI pour cette disquette			move.l	G.General_NombreST,d0			lea		Buff1(a6),a0			clr.w	-(sp)			_Pack7						move.b	#'0',TNB(a4)			move.b	#'0',TNB+1(a4)			move.b	#'0',TNB+2(a4)			move.b	#'0',TNB+3(a4)			move.b	#'0',TNB+4(a4)			moveq	#0,d0			move.b	Buff1(a6),d0			beq		Nombre_ST						lea		TNB+5(a4),a1			lea		Buff1+1(a6),a0			adda.l	d0,a0			subq.W	#1,d0loop_NumberTTI			move.b	-(a0),-(a1)			dbra	d0,loop_NumberTTI							; ----    Le nombre de sous-titre pour cette disquette; on converti ascii décimal => binaireNombre_ST			move.l	G.General_NombreST,d0			lea		Buff1(a6),a0			clr.w	-(sp)			_Pack7						move.b	#'0',TNS(a4)			move.b	#'0',TNS+1(a4)			move.b	#'0',TNS+2(a4)			move.b	#'0',TNS+3(a4)			move.b	#'0',TNS+4(a4)			moveq	#0,d0			move.b	Buff1(a6),d0			beq		Nombre_ST			lea		TNS+5(a4),a1			lea		Buff1+1(a6),a0			adda.l	d0,a0			subq.W	#1,d0loop_NumberST			move.b	-(a0),-(a1)			dbra	d0,loop_NumberST@1			; ----    Le nombre de Groupe de sous-titre pour cette disquette; on converti ascii décimal => binaire						move.b	#'0',TNG(a4)			move.b	#'0',TNG+1(a4)			move.b	#'0',TNG+2(a4)			;Nombre maximum de lignes						move.b	#'2',MNR(a4)			move.b	#'3',MNR+1(a4)			;Nombre maximal de caractères par ligne			move.b	#'4',MNC(a4)			move.b	#'0',MNC+1(a4)			; ----   Le time code début du programme			move.l	G.TcDebutFilm,d0			lea		buff1(a6),A0			import	ConversionTCstASCII			jsr		ConversionTCstASCII			lea		buff1(a6),A0			Lea 	TCP(a4),a1			move.b	1(a0),(A1)			move.b	2(a0),1(A1)			move.b	4(a0),2(A1)			move.b	5(a0),3(A1)			move.b	7(a0),4(A1)			move.b	8(a0),5(A1)			move.b	10(a0),6(A1)			move.b	11(a0),7(A1); ----   Le premier st du programme			lea		buff1(a6),A0			move.l	G.General_PremierTC,d0			import	ConversionTCstASCII			jsr		ConversionTCstASCII 						lea		buff1(a6),A0			Lea 	TCF(a4),a1			move.b	1(a0),(A1)			move.b	2(a0),1(A1)			move.b	4(a0),2(A1)			move.b	5(a0),3(A1)			move.b	7(a0),4(A1)			move.b	8(a0),5(A1)			move.b	10(a0),6(A1)			move.b	11(a0),7(A1); ----  Le status du time code			move.b	#'1',TCS(a4)		; utilisation prévu du time code			; on écrit le block TTI dans le fichier						move.l	paramBlock(a6),a0			move.l	#1024,ioReqCount(a0)			move.l	a4,ioBuffer(a0)			move.w	#fsfromStart,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						; maintenant on effectue l'écriture des blocks TTI 			; ---------------- Ecriture du fichier ----------------------------						; boucle nombre de diskette ; boucle nombre de sous-titre ; initialisation			move.l	G.BufferTransfert,Pointeur(a6)			sub.l	#128,Pointeur(a6)	; pour la boucle						move.l	G.SIZEBufferTransfert,D7			move.l	G.General_PremierSTPtr,STPtr(a6)	; le premier sous-titre			move.l	st_AbsNUMST,d0			move.w	d0,NombreTotalST(a6)			; -------	boucle de recopie des sous-titresLoop_Nombre_de_Soustitre						add.l	#128,Pointeur(a6)	; block TTI suivant			; a t-on rempli le buffer de transfert ?			move.l	G.BufferTransfert,d0			add.l	G.SIZEBufferTransfert,d0			sub.l	#256,d0						; taille du buffer- 256 octets						cmp.l	Pointeur(a6),d0						bhi.s	PasRempliBuffer						; on écrit le buffer dans le fichier						move.l	paramBlock(a6),a0			move.l	Pointeur(a6),d0			;l'octet suivant le dernier block TTI fabriqué			sub.l	G.BufferTransfert,d0			move.l	d0,ioReqCount(a0)			move.l	G.BufferTransfert,ioBuffer(a0)			move.w	#fsatMark,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						move.l	G.BufferTransfert,Pointeur(a6)PasRempliBuffer			;le block TTI est entier donc nous le plaçons dans un sous-titreTTI_EnEntier 			import	Transfert_Soustitre_BlockTTI	; ## on utilise la même pile 			jsr		Transfert_Soustitre_BlockTTI		; incrémentation du curseur du dialogue			bsr		Rafraichi_Curseur_ExportN19; fin de boucle block TTI			move.l	STPtr(a6),a0			move.l	st_NextST(a0),d0			beq.S	PlusDeSous_titre	; c'est fini			move.l	d0,STPtr(a6)			Sub.w	#1,NombreTotalST(a6)			bne.s	Loop_Nombre_de_Soustitre		PlusDeSous_titre; fin de boucle disquette			move.l	paramBlock(a6),a0			move.l	Pointeur(a6),d0			sub.l	G.BufferTransfert,d0			add.l	#128,d0			move.l	d0,ioReqCount(a0)		; dernier block TTI +128 octets			move.l	G.BufferTransfert,ioBuffer(a0)			move.w	#fsatMark,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						move.l	paramBlock(a6),a0			move.l	46(a0),d0	;ioPosOffset			move.l	d0,28(a0)	; iomisc			_SetEOFexit		move.l	TheDialogPtr(a6),-(sp)			_DisposDialog			PEA	QD.Arrow		; got arrow cursor at InitGraf			_SetCursor								UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.new		ExportationDeFichier_N19	; this name will appear in the debugger			align 4				* --- Cette routine rafraichie le dialog de progression d'écriture du fichier type N19Rafraichi_Curseur_ExportN19 ; on effectue le rafraichissement du dialog; on calcule la position en x de la reglette		move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d0		mulu	LargeurReglette(a6),d0				move.l	G.General_NombreST,d1		divu	d1,d0	; resultat dans d0				cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas				move.w	d0,LastXpos(a6)		; on dessine la reglette								bsr		Draw_Reglette		; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d0				lea		buff2(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff2(a6)		_DrawString					onnedessinepas				rts						Draw_Reglette; cette routine rafraichie la reglette				move.l	d0,d6		; sécu de la valeur				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		;largeur reglette		move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d1		mulu	d1,d0				move.l	G.General_NombreST,d1		divu	d1,d0	; resultat dans d0		add.w	left+itemRect(a6),d0				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts				ENDP								* ==============================================*	Procedure	RECOPIE_STRINGMACPC()* ==============================================; cette routine convertie une chaîne Mac en une chaîne PC;;	entrée: D0 longueur;			A0 source ptr ;			A1 destination ptr RECOPIE_STRINGMACPC	proc export		movem.l	d7,-(sp)		move.w	d0,d7		beq.S	Exit	; rien à faire		subq.W	#1,d7Loop_recopieChar		move.b	(A0)+,d0		cmp.b	#$0d,d0		bne.s	LRC_PasOD		move.b	#$0d,(a1)+		move.b	#$0A,(a1)+		bra.s	LRC_FinRecopieLRC_PasOD				moveq	#1,d1	; conversion Mac => PC		bsr		CONVERSIONChar		move.b	d0,(a1)+LRC_FinRecopie			dbra	d7,Loop_recopieCharExit	movem.l	(sp)+,d7		rts		dbgInfo.new	RECOPIE_STRINGMACPC		endP		* ===============================================*	Procedure	Transfert_Soustitre_BlockTTI()* ===============================================; Cette procédure Fabrique un block TTI à partir d'un sous-titre; en fct des parramètres d'initialisation;Transfert_Soustitre_BlockTTI			PROC	EXPORT		WITH	StackFrameExportN19,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame		with	N19_GSI,N19_TTI,DateTimeRec; on utilise le même stackframe; on garde la même pile que la routine appelante		import	ConversionNumeroSTPointeur,TraitementErreurFichier,\				AFFICHENUMSAISIE,SpinCursor,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR,ConversionBcd_TCN19					; on commence par placer le n° de sous-titre						move.l	Pointeur(a6),A3			move.l	StPtr(a6),A4			move.l	st_ABSNUMST(A4),d0	;(LSB)			move.b	d0,SN(a3)	; poids faible			asr.l	#8,D0		; (MSB)			move.b	d0,SN+1(a3)	; poids fort								; numéro block st extension etc...			move.b	#0,SGN(a3)		; pas de groupe			move.b	#$FF,EBN(a3)	; pas de block d'extension			move.b	#0,CS(a3)		; pas état cumulatif (sous-titres ajouté)					; la justification	du texte 								lea 	tableConversionJustif(pc),a0			moveq	#0,D0			move.b	st_Justification(a4),d0			cmp.b	#3,d0	; on prévient les erreurs			blo.s	@SupJustif			moveq	#0,D0@SupJustif					move.b	(a0,d0.w),d0			move.b	d0,JC(A3)			; drapeau de remarque ######## pour l'instant pas de remarque			move.b	#0,CF(a3)					; position verticale			move.w	st_Nlines(a4),d0	; nombre de ligne			bne		do_vp	 			move.w	G.N19_VPStart,d1 ;			move.w	#21,d1			move.b	d1,VP(A3)			; si pas de ligne on ce place à la ligne 21			bra.s	doTCIndo_vp						tst.w	G.Preference_DoubleHauteur			beq.S	PasDoubleHauteur_1			tst.w	G.Preference_N19_TypeTeletexte			beq.S	PasDoubleHauteur_1			mulu	#2,d0PasDoubleHauteur_1 			move.w	G.N19_VPStart,d1 			add.w	#1,d1;			move.w	#22,d1			sub.w	d0,d1			cmp.b	#1,d1			bhi.s	PasInf_1			moveq	#1,d1PasInf_1						cmp.b	#23,d1			blo.s	Passup_23			moveq	#23,d1Passup_23						move.b	d1,VP(A3)			; time code in		doTCIn						move.l	st_TimeCodeIN(a4),d0			lea		TCI(a3),a0			jsr	ConversionBcd_TCN19			; time code out								move.l	st_TimeCodeOUT(a4),d0			lea		TCO(a3),a0			jsr	ConversionBcd_TCN19			; fini pour les attributs du sous-titre on passe au texte du sous-titre			move.l	a4,a2			move.l	#st_sizeOf,d0			adda.l	d0,a2			; pointeur du texte					lea		TF(a3),a3	; champ de texte; ------- on raz la zone de texte on place $8f partout			move.w	#111,d6LoopEraseTF	move.b	#$8F,(a3,d6.w)						dbra	d6,LoopEraseTF						clr.w	theLaststyle(a6)	; style normal			clr.w	thestyle(a6)		; style normal			clr.l	NextStyle(a6)			 			moveq 	#0,d7		; compteur de lecture de char dans ST			moveq	#0,d6		; compteur du nombre de char dans ce block TTI			; --------- boucle caractère//caractère	; on ouvre une première ligne; texte vide ?			move.l	StPTR(a6),a0			tst.l	st_texteLenth(a0)			beq		FinRecopieCaracteres	; texte vide									tst.w	G.Preference_N19_TypeTeletexte			beq.s	RecopieCaractere_LOOP			; non pas télétexte			bsr		NouvelleLigne	; on place les attributs d'une nouvelle ligne			RecopieCaractere_LOOP			move.l	d7,d0			bsr		GiveChar_et_style	; on récupère le style et le char			addq.w	#1,d7			move.w	theChar(a6),d0			cmp.w	#-1,d0			beq		FinRecopieCaracteres		; c'est fini								tst.w	G.Preference_N19_TypeTeletexte			bne 	PasGestionstyle			; mode télétexte	pas de style		; --- on gère les style	-------------------------------------------------------				move.w	thestyle(a6),d1			cmp.w	theLaststyle(a6),d1			beq		PasGestionstyle				;c'est le même on ne fait rien; - on change de style; on regarde ce qui change			move.w	theLaststyle(a6),d1	;			move.w	thestyle(a6),d2			eor.w	d1,d2	; ce qui change est à 1						btst	#1,d2		; changement dans les italiques			beq.s	PasChangementdansitalique; ----			; changement dans italique			moveq	#0,d1			move.w	thestyle(a6),d1			eor.w	#$2,d1			and.w	#$2,d1			lsr		#1,d1			move.w	#$80,d0			or.w	d1,d0				; 80 si italique, 81 si fin italique									move.b	d0,(a3)+			addq.W	#1,d6; -----PasChangementdansitalique						btst	#0,d2		; changement dans les gras			beq.s	PasChangementdansGras			; -----			; changement dans gras  ### (gras = emboitage ???)			move.w	thestyle(a6),d1			eor.w	#$1,d1			and.w	#$1,d1			move.w	#$82,d0			or.w	d1,d0				; 84 si emboitage, 85 si fin emboitage						move.b	d0,(a3)+			addq.W	#1,d6PasChangementdansGras			btst	#2,d2		; changement souligné			beq.s	PasGestionSouligne			; -----			; changement dans souligné			move.w	thestyle(a6),d1			eor.w	#$4,d1			and.w	#$4,d1			lsr		#2,d1			move.w	#$82,d0			or.w	d1,d0				; 82 si souligné, 83 si plus souligné						move.b	d0,(a3)+				; début des italiques			addq.W	#1,d6PasGestionSouligne			move.w	thestyle(a6),theLaststyle(a6)			move.w	theChar(a6),d0; -----------------------------------------------------------------------------PasGestionstyle		; gestion du saut dfe ligne			cmp.b	#$d,d0			; CR/LF	?			bne.s	Pas_findeligne; nous allons faire un retour chariot, on regarde si le prochain est un cr						move.l	d0,d1	; on sauvegarde le char			move.l	d7,d0			bsr		GiveChar_et_style	; on récupère le char suivant			move.w	theChar(a6),d0			cmp.b	#-1,d0						; fin de sous-titre ?			beq.s	FinRecopieCaracteres		; on file directement à la fin 			cmp.b	#$d,d0			; CR/LF	?			bne.s	findeligne		; non pas cr donc on fait cr			bra		FinBoucle_Char	; c'est un cr on ne fait rienPas_findeligne						cmp.b	#'$',d0 			bne.s	pasChar24			 			move.b	#$a4,d0			; conversion à la main du char '$'			move.b	d0,(a3)+			addq.w	#1,d6			bra		FinBoucle_CharpasChar24									cmp.b	#$7f,d0			bhi.s	ConverttheChar	; il faut convertir les caractères			move.b	d0,(a3)+			addq.w	#1,d6			bra		FinBoucle_Char			; il faut convertir les caractères	(accentuation ...)		ConverttheChar			bsr		conversion_Char				bra		FinBoucle_Char			;---------------- fin de la ligne en cour -------------findeligne		; sommes nous en mode télétexte ?			tst.w	G.Preference_N19_TypeTeletexte			bne.s	TeletexteFinligne			; nous ne sommes pas en télétexte 			move.b	#$8a,(a3)+	;CR/LF 			add.w	#1,d6		; 1 chars de plus						bra		FinBoucle_Char			; ---------			; oui nous sommes en telétexte; double hauteur ?TeletexteFinligne			tst.w	G.Preference_DoubleHauteur			beq.s	PasDoubleHauteur; ----------  nous sommes en double hauteur						move.b	#$0a,(a3)+	; fin incrustation			move.b	#$0a,(a3)+	; fin incrustation			move.b	#$8a,(a3)+	; CR/LF			move.b	#$8a,(a3)+	;CR/LF			add.w	#4,d6		; 4 chars de plus						bra		FinNouvelleLigne			; ---------- nous ne sommes pas en double hauteurPasDoubleHauteur			move.b	#$0a,(a3)+	; fin incrustation			move.b	#$8a,(a3)+	;CR/LF			add.w	#2,d6		; 1 chars de plusFinNouvelleLigne; on place les attributs d'une nouvelle ligne			bsr		NouvelleLigne			bra		FinBoucle_Char; ------------------------------------------------						FinBoucle_Char					cmp.w	#111,d6			bhi		SupauTTI						bra		RecopieCaractere_LOOP; c'est fini de recopié			FinRecopieCaracteres			; 			move.b	#$8a,(a3)+			; #### normalement pas besoin;			add.w	#1,d6		; 1 chars de plus						bra		Exit						; --------- il faut ajouter un block TTI car nous n'avons pas -----------; --------- assez de place pour tous nos caractères	---------------------						; c'est fini pour ce TTI #### attention pour ètre en règle avec N19; il faudrait prévoir la possibilité de créer des block TTI d'extensions; pour des sous-titres dépassant 112 chars; nb: avec les attributs télétexte cela peut aller vite; 3 lignes de 32 chars :;   96 (chars) +6*13 (attributs)  +4*2(fin de ligne) + 2 cr/lf =182; sans compter les caractères accentués cela peut ne pas rentrer dans un seul TTISupauTTI			move.w	#14,-(sp)			import Alertuser				jsr    Alertuser							; on retourne à l'appeleur; À TCIAO BONSOIR .....exit		rts			* ============================= SUB ROUTINES =============================; ----- routine pour créer une nouvelle ligne ----------------------------NouvelleLigne			tst.w	G.Preference_N19_TypeTeletexte			bne.s	NL_Teletexte			; pas mode télétexte			rts		; on ne fait rien si pas télétexte			; Mode télétexte on ajoute des codes d'attributs pour la ligne à venirNL_Teletexte			move.b	#$1c,(a3)+		; fond noir  ####(code inutile car valeur par defaut)			move.b	#$07,(a3)+		; charBlanc  ####(code inutile car valeur par defaut)						tst.w	G.Preference_DoubleHauteur			bne.s	NL_DoubleHauteur			tst.w	G.Preference_DoubleLargeur			bne.s	NL_DoubleLargeur			; donc simple hauteur simple largeur						move.b	#$0b,(a3)+	; début d'incrustation			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#2,d6				rts			; -------NL_DoubleHauteur			tst.w	G.Preference_DoubleLargeur			bne.s	NL_TailleDouble			move.b	#$0d,(a3)+	; double hauteur			move.b	#$0b,(a3)+	; début d'incrustation			move.b	#$0b,(a3)+	; début d'incrustation 	;#### (pourquoi en mettre 2 ?)			move.w	G.Preference_Couleur,d0				move.b	d0,(a3)+	; couleur du texte			addq.w	#4,d6				rts			; -------	; largeur double			NL_DoubleLargeur			move.b	#$0e,(a3)+	; double largeur			move.b	#$0b,(a3)+	; début d'incrustation			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#3,d6				rts; -------		; taille doubleNL_TailleDouble			move.b	#$0f,(a3)+	; double hauteur			move.b	#$0b,(a3)+	; début d'incrustation			move.b	#$0b,(a3)+	; début d'incrustation	;#### (pourquoi en mettre 2 ?)			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#4,d6				rts; -------------------------------------------------------------------;  sous-routine qui donne l'ascii et le style d'un caractère	GiveChar_et_style		; d0 = indice du caractère 0 ≈ Nmax		movem.l	d1-d2/a1-a2,-(sp)		move.l	StPtr(a6),a0		cmp.l	st_TexteLenth(a0),d0	; dans le st ?		blo.S	Char_Exist		move.w	#-1,d0					; caractère pas dans la liste		move.w	d0,theChar(a6)				movem.l	(sp)+,d1-d2/a1-a2		rts; ---------------------------------------		Char_Exist				move.l	a0,a1		move.l	#st_sizeOf,d1		adda.l	d1,a1				; pointeur du texte		move.l	d0,d1				; sauvegarde du n° de char			tst.l	st_StylePtr(a0)		; il y a t-il des styles dans ce sous-titre ?			bne.s	RechercheProchainStyle;non, pas de style => parramètre par défaut				clr.w	thestyle(a6)			; style normal 		move.w	#1,theJust(a6)			; centrée		move.w	#0,theFont(a6)			; 1 ère font de la liste		move.l	#-1,NextStyle(a6)		; pas de prochain style		bra.s	PasDeStyle RechercheProchainStyle		move.l	NextStyle(a6),d2		beq.s	RechercheCont			; il n'y en a pas il faut le rechercher		cmp.l	d2,d1					; char pos <inférieur au prochain style ?		blo.s	PasDeStyle				; on ne change pas; -------------------		; on détermine quel style appartient au caractèreRechercheCont		move.l	st_StylePtr(a0),a2		; pointeur du style		move.w	(a2)+,d2				; nombre de style		subq.w	#1,d2		move.l	#20,d0		sub.l	d0,a2		LoopStyle			move.l	#20,d0		add.l	d0,a2			;scrpRecSize (décimal 20) on est obligé de forcer l'ASM en Long mode		cmp.l	(a2),d1		blo.s	FoundNext		move.w	scrpFont(a2),theFont(a6)		moveq	#0,d0		move.b	scrpFace(a2),d0		move.w	d0,thestyle(a6); style suivant				dbra	d2,LoopStyle				move.w	#-1,NextStyle(a6)			; pour indiquer qu'il n'y a plus de style		bra.s	PasDeStyle		FoundNext		move.l	(a2),NextStyle(a6); ---------PasDeStyle; on récupère le caractère		moveq	#0,d0		move.b	(a1,d1.w),d0					; caractère (long)		move.w	d0,thechar(a6)			movem.l	(sp)+,d1-d2/a1-a2		rts; --------------------------------------------------------------------; sous-routine de conversion caractère mac => n19; a4 pointe sur la table de conversionconversion_Char		movem.l	d1-d2/a4,-(sp)		; on sauvegarde d1-d2/a4		move.l	G.ResourceDATA1000,d1		beq		pasDeResource1000		move.l	d1,a4				move.l	(a4),a4			; handle	Loop_Recherche_double_Char				move.w	(a4),d1				; code Mac dans la table de conversion		beq.s	pasDeResource1000	; fin de la table,on sort avec le caractère simple dans d0		cmp.w	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.s	Loop_Recherche_double_Char; erreur diverses on ne modifie pas le caractèrepasDeResource1000		move.b	d0,(a3)+		addq.w	#1,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rts		; -----Found_The_Char		move.w	2(a4),d1		asr.w	#8,d1		; 8bits poids fort		move.w	2(a4),d2		tst.b	d1			; accentutation ?		beq		PasAccentuation				move.b	d1,(a3)+		move.b	d2,(a3)+		addq.w	#2,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rtsPasAccentuation				move.b	d2,(a3)+		addq.w	#1,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rts		DbgInfo.new		Transfert_Soustitre_BlockTTI	; this name will appear in the debugger; -----------------------------------------------------------tableConversionJustif			dc.b	02	; 0= centrée			dc.b	01	; 1= gauche			dc.b	03	; 2=Droite			dc.b	00	; 			align 4				endp			* ========================================		* PROCEDURE	ConversionBcd_TCN19()			* ========================================** Cette routine convertie le time code bcd en format N19l** entrée: D0 contient le tc en BCD*		  A0 pointe sur letc n19 qui doit ètre rempli* sortie: D0 contient le tc N19**ConversionBcd_TCN19 		PROC	EXPORT		with	StackFrameImportationFichier,N19_GSI,N19_TTI		import	SpinCursor		movem.l	d1-d2,-(sp)						move.l	d0,d1	; sauvegarde du timecode		; si tc =-1 vide on place 00 00 00 00		cmp.l	#-1,d0		bne.s	DoConversionTC		move.b	#0,3(a0)		move.b	#0,2(a0)		move.b	#0,1(a0)		move.b	#0,0(a0)		movem.l	(sp)+,d1-d2		rtsDoConversionTC		; images				and.l	#$f,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,3(a0)				; secondes		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,2(a0)		; minutes		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,1(a0)		; heures		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,0(a0)							Exit	movem.l	(sp)+,d1-d2		rts				DbgInfo.new	ConversionBcd_TCN19		align 4			ENDP										** interface pour la routine en C		C_RecopieStringPC_MAC proc ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start listing parameters herefrom				ds.l	1to					ds.l	1longueur			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	from(a6),a0		move.l	to(a6),a1		adda.l	#1,a1		move.l	longueur(a6),d0		import	Recopie_StringPCMac		jsr		Recopie_StringPCMac; on recherche le dernier caractère non espace		move.l	to(a6),A1		move.l	longueur(a6),d0Loop_SearchLenth_TOP		cmp.b	#' ',(a1,d0.w)		bne.s	Find_Find_Letter_TOP		dbra	d0,Loop_SearchLenth_TOP		move.w	#0,d0	; pas de caractères trouvésFind_Find_Letter_TOP		move.b	d0,(a1)	; on place la longueur				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	RecopieStringPC_MAC			; this name will appear in the debugger		endP		* ==============================================*	Procedure	Recopie_StringPCMac()* ==============================================; cette routine convertie une chaîne pc en une chaîne mac;;	entrée: D0 longueur;			A0 source ptr ;			A1 destination ptr Recopie_StringPCMac	proc export		movem.l	d7,-(sp)		move.w	d0,d7		beq.S	Exit	; rien à faire		subq.W	#1,d7Loop_recopieChar		move.b	(A0)+,d0		cmp.b	#$0a,d0		beq.s	Loop_recopieChar		moveq	#0,d1	; conversion pc => mac		bsr		CONVERSIONChar		move.b	d0,(a1)+		dbra	d7,Loop_recopieCharExit		movem.l	(sp)+,d7		rts		dbgInfo.new	Recopie_StringPCMac		endP										end