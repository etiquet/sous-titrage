#include "BB.Globals_C.h"#include <Devices.h>// les globalsextern MyQDGlobals QD;extern AppGlobals G;extern WindowPtr 	gPaletteKaraoke;extern Boolean			gMaskingSousTitre;extern short gAntiAlias;	//#pragma segment FonctionsDeBaseListepascal void 	EcritPreferenceTravail(void);pascal void	CloseErrorWindow(DialogPtr dlog);pascal void 	UpdateTheErrorList(DialogPtr dlog);pascal void 	QuitMoniteurVideo();pascal void QuitSansFauteGrammaire(void);pascal void ManageUndoRedoListeForInsert(long AbsNum);pascal void ManageUndoRedoListeForDelete(long AbsNum);static long  gStartSecond;pascal long TestSiDansST(SousTitreRecordPtr ST_Ptr:__A0,unsigned long TC:__D0):__D0;pascal void C_FaitOffset(SousTitreRecordPtr start, SousTitreRecordPtr end	, long offset);Boolean  AskUserDelete(SousTitreRecordPtr  ST_Ptr ,DialogPtr dlog);void EndAskfDelete( DialogPtr dlog);short DoAskifDeleteST(DialogPtr dlog,Point pt) ;DialogPtr StartConfirmDialogST(short DialogId);void adjustPtToBeVisible(Point  *pt);pascal void UpdateErrorWindow(void);void RemplacePartout(long start,long end);pascal void RPDispose(Handle theRpd);pascal Boolean RPIdle(Handle theRpd,long value,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder);void  C_TransfertStyleTE_Memoire(TEHandle te,SousTitreRecordPtr ST_Ptr);pascal Boolean myStandartfilterproc(DialogPtr theDialog ,EventRecord *event,short *itemhit);pascal Boolean RPIsFrontProcess(Handle theRpd);void  CopieTexte(SousTitreRecordPtr source,SousTitreRecordPtr destination);void SauvegardeAutomatique_Idle(short type);Boolean CheckStyle(SousTitreRecordPtr ST_Ptr);Boolean MakeOneStyle(SousTitreRecordPtr ST_Ptr);short ValidST(SousTitreRecordPtr ST_Ptr);short CC_Draw_SousTitre(SousTitreRecordPtr Str,short X,short Y,Ptr ScreenBase,long RowBytes,Rect *rect);pascal void TRANSFERTTEXTE_MEMOIRE_STYLETE_SPECIAL (TEHandle	te,SousTitreRecordPtr  ST_Ptr,Rect* rect,short newsize);void QT_UpdateQTCaption(long StNum);pascal void C_EcarteSousTitre(SousTitreRecordPtr ST,long AskLongueur){SousTitreRecordPtr	P,P1; 		//offset absolu du sous-titreunsigned long	deplacement; 			//distance de déplacement pour insérer le sous-titreunsigned long	a,L;Ptr			P2;		// on ajuste la longueur sur un dc.l			if (AskLongueur>32){			a=AskLongueur;			AskLongueur=((a+3)/4)*4;		} else{			AskLongueur=32;		}				   if ( AskLongueur>ST->st_LenthST) { // on travaille seulement si c'est nécessaire	if (ST->st_NextST==nil) { // on détermine ce qu'il faut exécuter		// à la fin de la liste		// on regarde si l'on dépasse la fin de la liste			L=sizeof(SousTitreRecord)+(long)ST->st_LenthST;			L=(long)ST+L;			a=((L+3)/4)*4; // align modulo 4			L=a+AskLongueur+2;			if ( L>(long)G.General_HIMEMST ) {				AlertUser(5);	// on envoie un message pour le dire			} else {				// comme c'est le dernier sous-titre, il suffit de changer la valeur dela variable lenthst 				ST->st_LenthST=AskLongueur;			}				} else { 	//(ST.st_NextST!=nil) 			// il y a t-il assez de mémoire	pour écarter ce sous-titre ?			L=sizeof(SousTitreRecord)+(long)ST->st_LenthST;			L=L+(long)G.General_DernierSTPtr;			a=((L+3)/4)*4; // align modulo 4			L=a+AskLongueur+2;			P=(SousTitreRecordPtr)L;			if ( L>(long)G.General_HIMEMST ) {				AlertUser(5);	// on envoie un message pour le dire			} else {				//SysBreak();							// on déplace la mémoire vers le haut				deplacement=(unsigned long) ST->st_NextST-(unsigned long)ST-sizeof(SousTitreRecord); 				deplacement=AskLongueur-deplacement;				P1=(SousTitreRecordPtr)ST->st_NextST;				P2=(Ptr)P1+deplacement;					BlockMove((Ptr)P1,P2,(long) P -(long)P1 );						// on modifie le pointeur du dernier sous-titre				a=(unsigned long)G.General_DernierSTPtr+deplacement;				G.General_DernierSTPtr=(SousTitreRecordPtr)a;				G.General_DernierSTPtr->st_NextST=nil;								// on chaîne le reste de la liste				L=(long)ST->st_NextST+deplacement; 				P1=(SousTitreRecordPtr)L;							if (P1->st_PreviousST) 			P1->st_PreviousST-=/*(Ptr)*/deplacement; // cette valeur ne dois pas bouger , on compense				ST->st_NextST=(Ptr)P1;			// on chaîne le reste de la liste des sous-titres						do {					 if (P1>G.General_DernierSTPtr) DebugStr("\p ooops, erreur Ecarte ST (sup) prevenir Eric");					 if (P1<G.General_PremierSTPtr) DebugStr("\p ooops, erreur Ecarte ST (inf) prevenir Eric");					 if (P1->st_NextST) 					P1->st_NextST+=/*(Ptr)*/deplacement;					 if (P1->st_PreviousST) 			P1->st_PreviousST+=/*(Ptr)*/deplacement;					// if (P1->st_PosOffsetTable) 		P1->st_PosOffsetTable+=(Ptr)deplacement;					 if (P1->st_StylePtr) 				P1->st_StylePtr+=/*(Ptr)*/deplacement;					 if (P1->st_CommentairePtr) 	P1->st_CommentairePtr+=/*(Ptr)*/deplacement;		 			P2=(Ptr)P1;					 P1=(SousTitreRecordPtr)P1->st_NextST;					  if (P1)					 if (P1>G.General_DernierSTPtr || P1<G.General_PremierSTPtr){						P2=P2;						SysBeep(1);						}				} while (P1 !=nil);				}// il y a t-il assez de mémoire	?				} //(ST.st_NextST==nil)  else	/*  il faut invalider le cache du conversion num pointeur	et les caches du dernier sous-titre dessiné */		G.General_DernierNumConvertiPtr=nil;				G.Sous_titre_dessined=nil;			G.Sous_titreInOffscreen=nil;			G.TravailAFaire_Affichage=0; 	} //	if ( AskLongueur>ST->st_LenthST)	UpdateGeneralValue();}pascal void C_InsertSt(SousTitreRecordPtr ST,long AskLongueur){SousTitreRecordPtr	P,P1,next; 		//offset absolu du sous-titreunsigned long	deplacement; 			//distance de déplacement pour insérer le sous-titreunsigned long	a,L;Ptr					P2,P3,P4;		// on ajuste la longueur sur un dc.l		if (AskLongueur>32){			AskLongueur=((AskLongueur+3)/4)*4;		} else	{			AskLongueur=32;		}		next=(SousTitreRecordPtr)ST->st_NextST; // on sauvegarde le next/* oui, nous somme au dernier soustitre ;determiner fin dernier st, + alignement dc.l,+ test longueur rajouter<= hi-mem;si ok lincker nextST ancien dernier sous titre, avec nouveau st, puis nouveau;PREviousST avec ADDR debut ancien dernier ST.;mettre nextST à 0 */	// on détermine qu'elle type d'insersion il faut exécuter			if (next==nil) {		// à la fin de la liste		// on calcule le pointeur du prochain st		// il y a t-il assez de mémoire	pour écarter ce sous-titre ?			L=sizeof(SousTitreRecord)+(long)ST->st_LenthST;			L=(long)ST+L;			P=(SousTitreRecordPtr)L;			a=((L+3)/4)*4; // align modulo 4			L=a+AskLongueur+2;						if ( L>(long)G.General_HIMEMST )  {				AlertUser(5);	// on envoie un message pour le dire			} else {				// on initialise l'en tête du nouveau sous-titre				ST->st_NextST=(Ptr)P;	// on chaîne le nouveau st				P->st_PreviousST=(Ptr)ST;				P->st_NextST=nil;				G.General_DernierSTPtr=P;							P->st_LenthST=AskLongueur;				P->st_StyleLenth=nil;				P->st_TexteLenth=nil;				P->st_CommentairePtr=nil;				P->st_CommentaireLenth=nil;				P->st_StylePtr=nil;				P->st_TimeCodeIn=-1;				P->st_TimeCodeOut=-1;				P->st_Error=nil;				P->st_XOffset=nil;				P->st_YOffset=nil;				P->st_PosOffsetTable=nil;				P->st_Nlines=nil;				P->st_Justification=nil;		// justification du texte 0 centrée, 				P->st_MasKType=nil;		// type de mask box, line, rectangle; = rien						// le numéro du sous-titre							P->st_NumeroST=(ST->st_NumeroST & 0xFFFFFF)+1;				P->st_OldNumeroST=P->st_NumeroST;				P->st_AbsNUMST=ST->st_AbsNUMST+1;			// on ajoute 1 au nombre total de sous-titre							a=G.General_NombreST;				a=a+1;				G.General_NombreST=a;				G.General_SousTitreEncour=(short)a;			// On update le control de a fenêtre listing								SetControlMaximum(G.ListingVScroll,G.General_NombreST);						}				} else { 	//(ST.st_NextST==nil) 		// il y a t-il assez de mémoire	pour écarter ce sous-titre ?	// il y a t-il assez de mémoire	pour insérer ce nouveau sous-titre		L=G.General_DernierSTPtr->st_LenthST+2L+AskLongueur+sizeof(SousTitreRecord);		P=G.General_DernierSTPtr;		L=L+(long)P;		if ( L>(long)G.General_HIMEMST ) {				AlertUser(5);	// on envoie un message pour le dire			} else {				/*	in faut insérer le sous-titre à l'intérieur de la liste	 	on indique à la liste des undo que l'on insert un sous-titre		cela permet d'ajuster la liste des undos. */			ManageUndoRedoListeForInsert(ST->st_AbsNUMST);		// on déplace la mémoire vers le haut pour laisser la place pour le sous-titre		// on calcule le nouveau pointeur du next st					a=AskLongueur+sizeof(SousTitreRecord)+(unsigned long )next;			a=((a+3)*4)/4;	// on aligne sur mots long			P2=(Ptr)a;		// le nouveau pointeur du  next					/* on calcule la longueur à déplacer */			a=(unsigned long)G.General_DernierSTPtr+sizeof(SousTitreRecord);			a=a+G.General_DernierSTPtr->st_LenthST+4L;			a=a-(unsigned long)next;					// on deplace le block de memoire (le st suivant remplace le st (on l'écrase))			BlockMove((Ptr)next,P2,a );								// on modifie le pointeur du dernier sous-titre			deplacement=(unsigned long) P2-(unsigned long)next;			a=(unsigned long)G.General_DernierSTPtr+deplacement;			G.General_DernierSTPtr=(SousTitreRecordPtr)a;						G.General_DernierSTPtr->st_NextST=nil;						// on calcule les pointeurs de chaînage du nouveau sous-titre créé			P1=(SousTitreRecordPtr)next; 							P1->st_PreviousST=(Ptr)ST;			P1->st_NextST=(Ptr)P1+deplacement;						P1=(SousTitreRecordPtr)P1->st_NextST;			 if (P1->st_PreviousST) {			 			P1->st_PreviousST=(Ptr)ST->st_NextST;						P1->st_PreviousST-=/*(Ptr)*/deplacement;						}		// on chaîne le reste de la liste des sous-titres				do {				 if (P1>G.General_DernierSTPtr)	DebugStr("\p ooops, Erreur Insert ST(sup) prévenir Eric");				 if (P1<G.General_PremierSTPtr)	DebugStr("\p ooops, Erreur Insert ST(inf) prévenir Eric");				 if (P1->st_NextST) 				P1->st_NextST+=/*(Ptr)*/deplacement;				 if (P1->st_PreviousST) 			P1->st_PreviousST+=/*(Ptr)*/deplacement;				// if (P1->st_PosOffsetTable) 		P1->st_PosOffsetTable+=(Ptr)deplacement;				 if (P1->st_StylePtr) 			P1->st_StylePtr+=/*(Ptr)*/deplacement;				 if (P1->st_CommentairePtr) 		P1->st_CommentairePtr+=/*(Ptr)*/deplacement;	 			P2=(Ptr)P1;				 P1=(SousTitreRecordPtr)P1->st_NextST;				 if (P1>G.General_DernierSTPtr || P1<G.General_PremierSTPtr){					P2=P2;					}			} while (P1 !=nil);				// on gère le problème de renumérotation		// on incrémente le numéro secondaire		// on regarde si l'on est repassé par 0 si oui on place 255					P1=(SousTitreRecordPtr)next;		// le nouveau sous-titre		P1->st_NumeroST=ST->st_NumeroST;  // oui on l'incrémente		P1->st_NumeroST+=0x01000000;  // oui on l'incrémente		if ( P1->st_NumeroST & 0xFF000000 == 0)   P1->st_NumeroST=(P1->st_NumeroST & 0xFFFFFF) | 0xFF000000; 		P1->st_OldNumeroST=P1->st_NumeroST;		G.General_SousTitreEncour=P1->st_AbsNUMST;		G.General_NombreST+=1;		SetControlMaximum(G.ListingVScroll,G.General_NombreST);//on initialise l'en tête du nouveau sous-titre				P1->st_LenthST=AskLongueur;				P1->st_StyleLenth=nil;				P1->st_TexteLenth=nil;				P1->st_CommentairePtr=nil;				P1->st_CommentaireLenth=nil;				P1->st_StylePtr=nil;				P1->st_TimeCodeIn=-1;				P1->st_TimeCodeOut=-1;				P1->st_Error=nil;				P1->st_XOffset=nil;				P1->st_YOffset=nil;				P1->st_PosOffsetTable=nil;				P1->st_Nlines=nil;				P1->st_Justification=nil;	// justification du texte 0 centrée, 				P1->st_MasKType=nil;		// type de mask box, line, rectangle; = rien			// on renumérote tout les numéro absolu de la liste des sous-titres		RenumerationAbsST();				//  on appelle la liste pour renuméroter les n° secondaire s'ils existent		if (G.Preference_Renumerotation==0) 				C_RenumerotationSubNumero(P1);			}// il y a t-il assez de mémoire	?				} //(ST.st_NextST==nil)  else			// il faut renuméroter la liste ?	// appel de la routine de renumerotation (à partir du n° précedent)					if (G.Preference_Renumerotation) 				C_RenumerotationListeSousTitre(ST);		G.ChangeSinceLastSave=true;  //on indique qu'il y a eu modif	/*  il faut invalider le cache du conversion num pointeur	et les caches du dernier sous-titre dessiné */		G.General_DernierNumConvertiPtr=nil;				G.Sous_titre_dessined=nil;			G.Sous_titreInOffscreen=nil;			G.TravailAFaire_Affichage=0; 		UpdateGeneralValue();}pascal void C_DeleteST(SousTitreRecordPtr	ST_Ptr){unsigned long		longueur,deplacement,a;SousTitreRecordPtr	previous,next,P,P1,P2;Ptr							P3;short						s;				/* 			on sauvegarde les pointeur next et previous du sous-titre qui va ètre effacé		*/			previous=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;			next=(SousTitreRecordPtr)ST_Ptr->st_NextST;					/* on indique aux fonctions annuler et refaire ce que l'on fait		*/		/* on regarde si nous sommes à la fin de la liste ou non */	if (ST_Ptr->st_NextST==nil){			/* oui nous y sommes.				on vérifie que ce n'est pas le premier sous-titre,				car il faut laisser au moin 1 sous-titre dans la liste */			  	if (ST_Ptr!=G.General_PremierSTPtr){					ManageUndoRedoListeForDelete(ST_Ptr->st_AbsNUMST);			/* on efface par pointeur le dernier sous-titres */			G.General_DernierSTPtr=previous;			G.General_DernierSTPtr->st_NextST=nil;						/* 1 sous-titre de moins */				a=G.General_NombreST;				a=a-1;				G.General_NombreST=a;				G.General_SousTitreEncour=(short)a;				SetControlMaximum(G.ListingVScroll,G.General_NombreST);					/* 	on invalide un certain nombre de mémoire cache,				qui ne sont plus valides	*/			G.General_DernierNumConvertiPtr=nil; 	//raz du cache de recherche			G.Sous_titreInOffscreen=nil;			G.Sous_titre_dessined=nil; 				G.ChangeSinceLastSave=true;				// on indique qu'il y a eu changement				}// pas le premier sous-titre	} else {			ManageUndoRedoListeForDelete(ST_Ptr->st_AbsNUMST);			s=(short)ST_Ptr->st_AbsNUMST;			G.General_SousTitreEncour=s;			SetControlValue(G.ListingVScroll,s);			s=GetControlMaximum(G.ListingVScroll)-1;			/* 1 sous-titre de moins */			G.General_NombreST--;			a=G.General_NombreST&0xffff;			if (a!=(long )s) {					SysBeep(1);					}								s=a;			SetControlMaximum(G.ListingVScroll,s);	  		/*	nous ne sommes pas à la fin de la liste,				on déplace la mémoire vers le bas pour effacer le sous-titre			*/			/* on calcule la longueur à déplacer */				 		a=(unsigned long)sizeof(SousTitreRecord);	 		a=a+G.General_DernierSTPtr->st_LenthST;			a=a+(unsigned long)G.General_DernierSTPtr-(long)next;						// on deplace le block de memoire (le st suivant remplace le st (on l'écrase))			BlockMove((Ptr)next,(Ptr)ST_Ptr,a );			  			// on modifie le pointeur du dernier sous-titre  			deplacement=(unsigned long)next-(unsigned long)ST_Ptr;			a=(unsigned long)G.General_DernierSTPtr-deplacement;			G.General_DernierSTPtr=(SousTitreRecordPtr)a;						G.General_DernierSTPtr->st_NextST=nil;		  	G.General_PremierSTPtr->st_PreviousST=nil;			/* on place les pointeurs de chaînage du 1er sous titre déplacé*/			ST_Ptr->st_PreviousST=(Ptr)previous+deplacement;						    		/* on chaîne le reste de la liste des sous-titres				et on modifie les pointeurs des parramètres comme style, commentaire...			*/				 		P=ST_Ptr;			do {				if (P>G.General_DernierSTPtr) DebugStr("\p ooops, Erreur Delete ST(sup) prévenir Eric");				if (P<G.General_PremierSTPtr) DebugStr("\p ooops, Erreur Delete ST(inf) prévenir Eric");				if (P->st_NextST)						P->st_NextST-=/*(Ptr)*/deplacement;				if (P->st_PreviousST) 				P->st_PreviousST-=/*(Ptr)*/deplacement;				//if (P->st_PosOffsetTable) 		P->st_PosOffsetTable-=(Ptr)deplacement;				if (P->st_StylePtr) 					P->st_StylePtr-=/*(Ptr)*/deplacement;				if (P->st_CommentairePtr) 		P->st_CommentairePtr-=/*(Ptr)*/deplacement;									P1=P;				P=(SousTitreRecordPtr)P->st_NextST;				if (P>G.General_DernierSTPtr || P<G.General_PremierSTPtr) P1=P1;			} while (P !=nil & P<=G.General_DernierSTPtr);			// on renumérote tout les numéros absolus de la liste des sous-titres			RenumerationAbsST();				/* On regarde s'il y a un sous-numéro 			si oui, il faut renuméroter la liste des sub-numéro		*/					if (ST_Ptr->st_NumeroST&0xff000000) C_RenumerotationSubNumero(previous);			if (G.Preference_Renumerotation) C_RenumerotationListeSousTitre(previous);			RenumerationAbsST();					/* On invalide un certain nombre de mémoire cache,			 qui ne seront plus valides		*/					G.General_DernierNumConvertiPtr=nil; 	//raz du cache de recherche			G.Sous_titreInOffscreen=nil;			G.Sous_titre_dessined=nil; 				G.ChangeSinceLastSave=true;				// on indique qu'il y a eu changement	  }	UpdateGeneralValue();			} //C_deleteST						/* Cette fonction renumérote les numéro secondaire des sous-titre qui suivent */pascal void	C_RenumerotationSubNumero(SousTitreRecordPtr ST){SousTitreRecordPtr	P;unsigned long	a,b;		P=ST;			if (P==G.General_PremierSTPtr){			P->st_OldNumeroST=1;			P->st_NumeroST=1;		} else {			a=P->st_NumeroST&0xFF000000;						do{				P->st_OldNumeroST=P->st_NumeroST;				b=P->st_NumeroST&0xFF000000;								if (b) P->st_NumeroST= (P->st_NumeroST&0x00FFFFFF)  | a;				a+=0x01000000;				if (a==0) a=0xFF000000;				P=(SousTitreRecordPtr)P->st_NextST;						} while ((P !=nil) && (b !=nil) );				}} // C_RenumerotationSubNumeropascal short C_get_STJustification(SousTitreRecordPtr ST_Ptr){short	a;	a=(short)ST_Ptr->st_Justification;		switch(a){		case 1:			a=teJustLeft;		break;		case 0:			a=teJustCenter;		break;		case 2:			a=teJustRight;		break;		}	return a;	}/* Cette routine recherche le premier  et le dernier time code de la liste des sous-titres */ pascal void UpdateGeneralValue(void){SousTitreRecordPtr	ST_Ptr;Boolean			found;	long				a;GrafPtr			oldport;		short			type;Handle			itemH;Rect				rect;				G.General_PremierTC=-1;		G.General_DernierTC=-1;		G.General_PremierTCPtr=nil;		G.General_DernierTCPtr=nil;				/*on recherche le premier time code valide */		found=false;		ST_Ptr=G.General_PremierSTPtr;		do {		a=ST_Ptr->st_TimeCodeOut;		if (a!=-1) {			G.General_PremierTCPtr=ST_Ptr;			G.General_PremierTC=a;			found=true;						}								a=ST_Ptr->st_TimeCodeIn;		if (a!=-1) {			G.General_PremierTCPtr=ST_Ptr;			G.General_PremierTC=a;			found=true;						}				ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_NextST;		} while (ST_Ptr!=nil && found==false);/*on recherche le dernier time code valide */		found=false;		ST_Ptr=G.General_DernierSTPtr;		do {				a=ST_Ptr->st_TimeCodeIn;			if (a!=-1) {				if (G.General_PremierTC !=-1) 					if (a>G.General_PremierTC ) {						G.General_DernierTCPtr=ST_Ptr;						G.General_DernierTC=a;				found=true;					}				}										a=ST_Ptr->st_TimeCodeOut;			if (a!=-1) {				if (G.General_PremierTC !=-1) 					if (a>G.General_PremierTC ) {						G.General_DernierTCPtr=ST_Ptr;						G.General_DernierTC=a;				found=true;					}				}										ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;		} while (ST_Ptr!=nil && found==false);				// on force un update de la fenêtre Block-Note		if (  ( (WindowRecord*)(G.BlockNoteWindow) )->visible ) {			GetPort(&oldport);			SetPort((GrafPtr)G.BlockNoteWindow);			// 1er tc du film			GetDialogItem(G.BlockNoteWindow,34,&type,&itemH,&rect);			InvalRect(&rect);//  le dernier sous-titre du film			GetDialogItem(G.BlockNoteWindow,35,&type,&itemH,&rect);			InvalRect(&rect);			SetPort(oldport);		}		} // fin update general valuepascal void TransfertSaisieMemoire(void){GrafPtr					oldport;	SousTitreRecordPtr	ST_Ptr;			GetPort(&oldport);			SetPort((GrafPtr)&G.DialogSaisie);		/* s'il y a un te on le ferme */		if (G.saisieTE){				TransfertTE_Memoire(G.saisieTE,G.saisieTEStNum,G.saisieTEStItem);				TEDispose(G.saisieTE);				G.saisieTE=nil;		// on indique qu'il n'y a plus de TE dans saisie				/* si le sous-titre est en cours dans l'ecran on le rafraichi */			ST_Ptr=C_ConversionNumeroSTPointeur((long)G.saisieTEStNum);			QT_UpdateQTCaption(G.saisieTEStNum);		// on regarde si on est proche d'une sauvegarde automatique			SauvegardeAutomatique_Idle(1);		// on réactualise le sous-titre affiché sur l'écran			if (G.Sous_titre_dessined==ST_Ptr) 	 		G.Sous_titre_dessined=nil;			if (G.Sous_titreInOffscreen==ST_Ptr) 	 	G.Sous_titreInOffscreen=nil;		}			SetPort(oldport);}// cette routine appele la fonction qui suit en faisant un test de validité du pointeurpascal void TRANSFERTTEXTE_MEMOIRE_STYLETE(TEHandle	te,SousTitreRecordPtr  ST_Ptr,Rect* rect,short newsize){short	flag=0;SousTitreRecordPtr	ST1;	// protection de la routine				if (ST_Ptr>G.General_DernierSTPtr || ST_Ptr<G.General_PremierSTPtr)  flag=1;		ST1=(SousTitreRecordPtr)ST_Ptr->st_NextST;		if (ST1)  if(ST1->st_PreviousST != (Ptr)ST_Ptr)   flag=1;		ST1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;		if (ST1)  if(ST1->st_NextST !=  (Ptr)ST_Ptr)   flag=1;						if (!flag)			 			TRANSFERTTEXTE_MEMOIRE_STYLETE_SPECIAL(te,ST_Ptr,rect,newsize);		else SysBeep(1);}/* cette routine transfère le contenu d'un sous-titre dans un te*/pascal void TRANSFERTTEXTE_MEMOIRE_STYLETE_SPECIAL (TEHandle	te,SousTitreRecordPtr  ST_Ptr,Rect* rect,short newsize){TextStyle			newStyle;Handle			STScrp;unsigned long		texteLenth=ST_Ptr->st_TexteLenth&0xffff;unsigned long		styleLenth=ST_Ptr->st_StyleLenth&0xffff;SousTitreRecordPtr	ST1;			STScrp=nil;// on regard s'il y a déja un texte dans le sous-titre// on protège la fonction		if (te==nil) {  AlertUser(24);   return;  }				// on efface l'ancien contenu du te		TEDeactivate(te);		TESetSelect(0,32767,te);		TEDelete(te);								if( CheckStyle(ST_Ptr)) {					ST_Ptr->st_StylePtr=0;					ST_Ptr->st_StyleLenth=0;					styleLenth=0;					}		if (texteLenth){	/* 	On demande un handle pour le style			et on recopie le contenu du style dans le handle	*/						//if ( (ST_Ptr->st_StylePtr==nil) && styleLenth )   DebugStr("\p ooops, pb stylelength !=0 & st_StylePtr==nil");			if (texteLenth>4000) {					DebugStr("\p ooops, texteLenth>4000");					 texteLenth=4000;					 styleLenth=0; // il y a sûrement une erreur là aussi					 }					 			if (styleLenth>4000) {				DebugStr("\p ooops, styleLenth>4000");				styleLenth=0; // il y sûrement erreur				 }						if ( ST_Ptr->st_StylePtr==nil) {					styleLenth=0;					ST_Ptr->st_StyleLenth=0;					}			if (styleLenth) {				STScrp=NewHandleClear(styleLenth);				if (STScrp) {					HLock(STScrp);					BlockMove(ST_Ptr->st_StylePtr,*STScrp,styleLenth);					HUnlock(STScrp);			// on place le texte et le style 					TEStyleInsert((Ptr)ST_Ptr+sizeof(SousTitreRecord),texteLenth,(StScrpHandle)STScrp,te);					DisposeHandle(STScrp);				}  else {				// style nul					TEStyleInsert((Ptr)ST_Ptr+sizeof(SousTitreRecord),texteLenth,(StScrpHandle)nil,te);				}		} else  TEStyleInsert((Ptr)ST_Ptr+sizeof(SousTitreRecord),texteLenth,(StScrpHandle)nil,te);					TESetSelect(32767,32767,te);	}// (ST_Ptr->st_TexteLenth)			if (newsize!=-1) {		TESetSelect(0,32767,te);		newStyle.tsSize=newsize;		TESetStyle(doSize,&newStyle,true,te);	//on place le curseur à la fin du texte				TESetSelect(32767,32767,te);	} // (newsize!=-1) 	PenNormal();} // TRANSFERTTEXTE_MEMOIRE_STYLETE drawControls/*	Cette routine transfère le contenu du dialog saisie 	 dans le sous-titre en cour en mémoire*/pascal void PutStringInCommentaireST(SousTitreRecordPtr ST_Ptr,char* string){long	L;		// on calcule l'espace nécessaire dans le sous-titre pour stocker la chaîne de commentaire		L=(long)string[0]+ST_Ptr->st_TexteLenth+ST_Ptr->st_StyleLenth+16;// on calibre la longueur du sous-titre 		; a0 ptr st, d0 longueur demandée		C_EcarteSousTitre(ST_Ptr,L);//on calcule le pointeur du commentaire		L=(long)ST_Ptr+ST_Ptr->st_TexteLenth+sizeof(SousTitreRecord);		L=((L+3)/4)*4;		L=L+ST_Ptr->st_StyleLenth+4;		L=((L+3)/4)*4;		ST_Ptr->st_CommentairePtr=(Ptr)L;	// on le recpie dans le sous-titre				BlockMove((Ptr)&string[1],(Ptr)L,(long)string[0]);		ST_Ptr->st_CommentaireLenth=(long)string[0];}/* Cette fonction vérifie le contenu d'un sous-titre */pascal long VerifieSousTitre(SousTitreRecordPtr ST_Ptr,PrefVerifListeHandle PrefVerif){long ErrorST=0;SousTitreRecordPtr  st1;long a,b,c;unsigned char	ch;short	MaxLargeur,NBLigne,TotalChar,nbCharLigne,MaxChar,i;Ptr		P;	/* Vérification si tc in≠ vide et  tc out≠vide */	if (ST_Ptr-> st_TimeCodeIn==-1 || ST_Ptr-> st_TimeCodeOut==-1  ) ErrorST=ErrorST|4;		/* Vérification si tc in > tc out */	if  (ST_Ptr-> st_TimeCodeIn!=-1 && ST_Ptr-> st_TimeCodeOut!=-1  ){				 if (ST_Ptr-> st_TimeCodeOut<=ST_Ptr->st_TimeCodeIn) ErrorST=ErrorST|1;		 		 /* Vérification si tc in > tc out st précédent*/			 st1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST; // le sous-titre précédent	 		 if (st1){				 a=ST_Ptr->st_TimeCodeIn;				 b=st1->st_TimeCodeOut;				 if (b!=-1 && a!=-1) {					 if ( (ST_Ptr-> st_TimeCodeIn)<(st1->st_TimeCodeOut) )  ErrorST=ErrorST|2; //erreur si interval<=0					 		 /* si on nous le demande, on vérifie l'intervalle avec le sous-titre précédent */				 if ( (**PrefVerif).Preference_RespectIntervalMinimum) {					 c=C_SoustractionTimeCode(a,b);					 c=C_ConversionTimeCodeTrames(c);					 if (c<G.Preference_Interval) ErrorST=ErrorST|8;					 }//(**PrefVerif).Preference_RespectIn				 } // (b!=-1 && a!=-1) 		 } //(st1)	}//(ST_Ptr-> st_TimeCodeIn!=-1 && ST_Ptr-> st_TimeCodeOut!=-1  )	/* maintenant on effectue le boucle pour déterminer les ≠ valeurs liées au texte */	MaxLargeur=0;	NBLigne=1;	TotalChar=0;	nbCharLigne=0;	MaxChar=(short)ST_Ptr->st_TexteLenth;		if (MaxChar) {		P=(Ptr)ST_Ptr+sizeof(SousTitreRecord);		for (i=0;i<MaxChar;i++){			ch=*(P++);			if (ch>=' ') nbCharLigne++;			if (ch>' ' && ch!=' ') TotalChar++;			if (ch==13) {				NBLigne++;				if (nbCharLigne>MaxLargeur) MaxLargeur=nbCharLigne;				nbCharLigne=0;			}//(ch==13)		}// for (i=0;i				if (nbCharLigne>MaxLargeur) MaxLargeur=nbCharLigne;		// maintenant on vérifie les valeurs		/* la lisibilité */		if ( (**PrefVerif).Preference_RespectLisibilite){				a=ST_Ptr->st_TimeCodeIn;				b=ST_Ptr->st_TimeCodeOut;				if (b!=-1 && a!=-1) {						/* si on nous le demande, on vérifie l'intervalle avec le sous-titre précédent */					c=C_SoustractionTimeCode(b,a);					c=C_ConversionTimeCodeTrames(c);					c=(c*(long)G.Preference_LisiValue)/st_FramePerSeconds;					c=c*(100+(**PrefVerif).Preference_TolerenceLisibilite )/100;					if (TotalChar>=c)  ErrorST=ErrorST|16;					} // (b!=-1 && a!=-1) 			} // (**PrefVerif).Preference_RespectIntervalMinimum			/* on filtre maintenant le résultat*/			if ( !(**PrefVerif).Preference_CoherenceTimeCode) ErrorST=ErrorST&(0xfff9);				if(  (**PrefVerif).Preference_NombreCaractereLigne)					if (MaxLargeur> (**PrefVerif).Preference_NombreCaractereLigne) {						ErrorST=ErrorST|32;					}		if(  (**PrefVerif).Preference_RespectNombreLigne)					if ( (**PrefVerif).Preference_NombreLigne<NBLigne) ErrorST=ErrorST|64;								/* on regarde s'il faut indiquer que le sous-titre n'est pas calé en bas de cadre		   on teste s'il y a des CR en fin de ligne.*/				if(  (**PrefVerif).Preference_DecalageVerticale){			b=0;			P=(Ptr)ST_Ptr+ST_Ptr->st_TexteLenth-1;			P=P+sizeof(SousTitreRecord);				if (ST_Ptr->st_TexteLenth) {					a=ST_Ptr->st_TexteLenth;					do {						ch=*((Ptr)P);						if (ch ==0xd ) b++;						P--;						a--;						} while(a>0 && ch<32);				}					if ( b) ErrorST=ErrorST|128;			}// (**PrefVerif).Preference_DecalageVerticale)	} //if (MaxChar)	return ErrorST;}pascal void  DisplayErreur(long erreur){Str255		st0,st1;short i,dlgFont,itemHit;	for (i=7; i>=0;i--) {		if (erreur&(1<<i)) st0[8-i]='1' ; else st0[8-i]='0' ;	}	st0[0]=8;	NumToString(erreur,&st1);	SetCursor(&QD.arrow);	dlgFont=LMGetDlgFont();	LMSetDlgFont(kFontIDGeneva);	ParamText(&st0,&st1,nil,nil);	itemHit = Alert(254,(ModalFilterProcPtr)nil);	LMSetDlgFont(dlgFont);}/* Cette routine vérifie la liste des sous-titres et place dans un handle la liste des erreurs trouvées */void VerifieLaListe(SousTitreRecordPtr start,SousTitreRecordPtr end,PrefVerifListeHandle PrefVerif){SousTitreRecordPtr	ST_Ptr;long error,a;		if (start<G.General_PremierSTPtr) start=G.General_PremierSTPtr;		if (end>G.General_DernierSTPtr) end=G.General_DernierSTPtr;		ST_Ptr=start;				/* on regarde s'il y a une liste d'erreur */		if (G.ListeError) DisposeHandle((Handle) G.ListeError) ;		G.ListeError=(SousTitreErrorListeHandle) NewHandleClear(sizeof(SousTitreError)+2);		do{			error=VerifieSousTitre(ST_Ptr, PrefVerif);			if (error) {				a=(**G.ListeError).TotalErrorElement++;				SetHandleSize((Handle) G.ListeError,(a+1)*sizeof(SousTitreError)+2);				(**G.ListeError).Errors[a].AbsNum=ST_Ptr->st_AbsNUMST;				(**G.ListeError).Errors[a].Errors=error;				(**G.ListeError).Errors[a].datah=nil;				(**G.ListeError).Errors[a].spare=0;				}			C_SpinCursor(32);			ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_NextST;		} while (  (ST_Ptr!=nil) && (ST_Ptr<=end) );		SetCursor(&QD.arrow);		if (G.ErrorsWindow) UpdateTheErrorList(G.ErrorsWindow);}//void VerifieLaListepascal long TestSiDansST(SousTitreRecordPtr ST_Ptr:__A0,unsigned long TC:__D0):__D0{unsigned long in,out;	in=ST_Ptr->st_TimeCodeIn;	out=ST_Ptr->st_TimeCodeOut;	if (TC>=in && TC<=out) return 0;	if (TC<in) return -100; else return 100;}Boolean CheckStyle(SousTitreRecordPtr ST_Ptr){StScrpPtr StylePtr;ScrpSTElement	stelement;short	error=0;long a,b,c,i;	StylePtr=(StScrpPtr)ST_Ptr->st_StylePtr;		// si le style n'existe pas on n'effectue pas le reste du test.	if ( !StylePtr ) return 0;	/*  on regarde si la taille du scrapt est cohérente*/// on ne pas avoir de style supérieur à 100 elements 1600 en theorie// pas de style == 0	if (StylePtr->scrpNStyles>100 || StylePtr->scrpNStyles==0){ 		 error=-1;	     return error;	}		a=(StylePtr->scrpNStyles)*sizeof(ScrpSTElement)+2; // taille theorique du style		if (ST_Ptr->st_StyleLenth<a) {		error=1; // ->		return error;		}	// -> la taille du style est inferieure a sa taille théorique, il y a erreur	/* boucle de vérification des différents styles*/			for (i=0; i<StylePtr->scrpNStyles;i++) {			if (StylePtr->scrpStyleTab[i].scrpSize>14) {			StylePtr->scrpStyleTab[i].scrpSize=14;			error=error|2;				// erreur taille de la police on le corrigée			};		/* on filtre les styles*/		StylePtr->scrpStyleTab[i].scrpFace=				StylePtr->scrpStyleTab[i].scrpFace&(bold|italic);				/* on filtre les height ainsi que les ascent*/		if (StylePtr->scrpStyleTab[i].scrpHeight>20){			StylePtr->scrpStyleTab[i].scrpHeight=14;			error=error|4;				// erreur height de la ligne,  on le corrige			}		if (StylePtr->scrpStyleTab[i].scrpAscent>20){			StylePtr->scrpStyleTab[i].scrpAscent=20;			error=error|8;				// erreur taille ascent, on le corrige			}	/*maintenant on check si l'index du caractère n'est pas au dela le la taille du texte */			if (StylePtr->scrpStyleTab[i].scrpStartChar>ST_Ptr->st_TexteLenth) error=error|16;	}	//for i		return error;}short ValidST(SousTitreRecordPtr ST_Ptr){SousTitreRecordPtr ST1;short 		error=0; 			// protection de la routine				// en dehors des limites		if (ST_Ptr>G.General_DernierSTPtr || ST_Ptr<G.General_PremierSTPtr)  return 1;		ST1=(SousTitreRecordPtr)ST_Ptr->st_NextST;				// si next st on verifie		if (ST1){			if (ST1>G.General_DernierSTPtr || ST1<G.General_PremierSTPtr) return 1;			if (ST1)  if(ST1->st_PreviousST != (Ptr)ST_Ptr)  error=true;			}					ST1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;		// si previous st on verifie		if (ST1){			if (ST1>G.General_DernierSTPtr || ST1<G.General_PremierSTPtr)	 return 1;			if (ST1)  if(ST1->st_NextST !=  (Ptr)ST_Ptr)  return 1;			}					if( CheckStyle(ST_Ptr))  MakeOneStyle(ST_Ptr);		return error;	}Boolean MakeOneStyle(SousTitreRecordPtr ST_Ptr){StScrpPtr StylePtr;ScrpSTElement	stelement;short	error=0;long a,b,c,i;		StylePtr=(StScrpPtr)ST_Ptr->st_StylePtr;		StylePtr->scrpNStyles=1;/* boucle de vérification des différents styles*/			StylePtr->scrpStyleTab[0].scrpSize=14;		/* on filtre les styles*/		StylePtr->scrpStyleTab[0].scrpStartChar=0;		StylePtr->scrpStyleTab[0].scrpFace=0;		StylePtr->scrpStyleTab[0].scrpFont=0;			/* on filtre les height ainsi que les ascent*/		StylePtr->scrpStyleTab[0].scrpHeight=14;		StylePtr->scrpStyleTab[0].scrpAscent=14;				// la couleur			StylePtr->scrpStyleTab[0].scrpColor.blue=0;		StylePtr->scrpStyleTab[0].scrpColor.red=32000;		StylePtr->scrpStyleTab[0].scrpColor.green=0;				ST_Ptr->st_StyleLenth=sizeof(ScrpSTElement)+2;		return 0;}void  C_TransfertStyleTE_Memoire(TEHandle te,SousTitreRecordPtr ST_Ptr){Handle	text;long		nLigne,i;Ptr		P;Handle	commentaire;StScrpHandle	stScrap;unsigned long L;// on protège la routine			if (!te) return;			if (ST_Ptr>G.General_DernierSTPtr || ST_Ptr<G.General_PremierSTPtr)  return;						ST_Ptr->st_StylePtr=nil;			ST_Ptr->st_StyleLenth=nil;			ST_Ptr->st_TexteLenth=nil;/* on compte lenombre de ligne	on ne peut pas utiliser la variable TENLines 	dans le  te car elle enlève une ligne si cr à la fin seul sur une ligne	il faut compter à la main*/			text=(Handle)TEGetText(te);			if (!text) return;						HLock(text);			nLigne=1;			P=*text;						for (i=(**te).teLength;i>=0;i--){				if (*P==13) nLigne++;				P++;			}						HUnlock(text);			ST_Ptr->st_Nlines=nLigne;				ST_Ptr->st_TexteLenth=(**te).teLength;//on sauvegarde la chaine de commentaire			commentaire=nil;			if (ST_Ptr->st_CommentaireLenth){				PtrToHand(ST_Ptr->st_CommentairePtr,&commentaire,ST_Ptr->st_CommentaireLenth);			}			// on regarde récupère le style scrap			if ((**te).txSize==-1) { // vraiment un style te				TESetSelect(0, 32767,te);				stScrap = TEGetStyleScrapHandle(te);				ST_Ptr->st_StyleLenth=GetHandleSize((Handle)stScrap);			} else {				ST_Ptr->st_StyleLenth=nil;	// ce n'est pas un style te donc pas de style				ST_Ptr->st_StylePtr=nil;			}	/* on écarte maintemant le sous-titre pour que tout rentre; on calcule la longueur de la zone mémoire nécessaire */						L=((ST_Ptr->st_TexteLenth+3)/4)*4; 	   			// longueur du texte ajusté sur mot long 			L+=((ST_Ptr->st_StyleLenth+3)/4)*4; 			// longueur du style ajusté sur mot long 			L+=((ST_Ptr->st_CommentaireLenth+3)/4)*4;	// longueur du commentaire ajusté sur mot long 			L+=16;								// en marge de sécurite			C_EcarteSousTitre(ST_Ptr,L);// on recopie le texte dans le st			if (ST_Ptr->st_TexteLenth){				HLock(text);				BlockMove(*text,(Ptr)ST_Ptr+sizeof(SousTitreRecord),ST_Ptr->st_TexteLenth);				HUnlock(text);			}			// on recopie les style dans le sous-titre				if(stScrap) {				HLock((Handle)stScrap);				// on calcule le pointeur du style				L=(long)ST_Ptr+sizeof(SousTitreRecord);				L+=ST_Ptr->st_TexteLenth;				L=((L+3)/4)*4;				ST_Ptr->st_StylePtr=(Ptr)L;				BlockMove(*stScrap,(Ptr)L,ST_Ptr->st_StyleLenth);				HUnlock((Handle)stScrap);				DisposeHandle((Handle)stScrap);			}// on remet la chaîne de commentaire s'il elle existe						if (commentaire){				HLock(commentaire);				// on calcule le pointeur du commentaire				L=(long)ST_Ptr+sizeof(SousTitreRecord);				L+=ST_Ptr->st_TexteLenth;				L=((L+3)/4)*4;				L+=ST_Ptr->st_StyleLenth;				L=((L+3)/4)*4;										ST_Ptr->st_CommentairePtr=(Ptr)L;				BlockMove(*commentaire,(Ptr)L,ST_Ptr->st_CommentaireLenth);				DisposeHandle(commentaire);			}				G.ChangeSinceLastSave=true;  //on indique qu'il y a eu modif}