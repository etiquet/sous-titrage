/*CQuickTimeClass de gestion de la fenêtre de gestion quictimele 28/04/01*/#include "CQuicktime.h"#include "TimeCodeUtilities.h"#include "QTTimeCode.h"#include "QTTextTrack.h"#include "ISp_Sample.h"#include "IPsCR.h"// les globalsextern MyQDGlobals QD;extern AppGlobals G;extern long m_key_joy_flag;// Quelques Globalesvoid PPCDispatch_init(void);CQuicktimeClass*		CQuicktime=nil;ModalFilterUPP 		gModalFilterUPP=nil;	Boolean				gHasNewDialogCalls=false;		// are the new Dialog Manager functions available?static Handle			ISpCRH;static short			gAcceleratedResourceLoaded;Input_GameState 		igs;short 				initsprocket;void 					QT_PPCDispatch_init(void);long 					oldbuttonpress;long 					get_flag;//Fonctions Externespascal void DoUpdate(WindowPtr window);pascal unsigned long C_AdditionTimeCode(unsigned long tc1,unsigned long tc2);int DoDialogOffsetQT();short IsTeOpen();void DoActionJoyButton(long butaction);/////////////////////////////////////////////////////////////// //// Constructeur / destructeur///////////////////////////////////////////////////////////////// void QT_Constructor(void){GDHandle 	NextDevice;GDHandle 	gdliste[32];long 		gdnumber,a;OSErr 		nErr;EventRecord	event;// on initialise la classe	CQuicktime=0;	get_flag=0;	//on intialise le input sprocket	ISpCRH=nil;	gAcceleratedResourceLoaded=0;		igs.button=oldbuttonpress=igs.throttleInput=igs.yawInput=igs.pitchInput=igs.rollInput=0;	QT_PPCDispatch_init(); // intialisation de la code ressource	initsprocket=PPCDispatch_ISpCR(1,0xCACABEBEL,0); // init sproker// initialisation quicktime		nErr = EnterMovies();	if (nErr != noErr)					return;	//CQuicktime=(CQuicktimeClass*)malloc(sizeof(CQuicktimeClass));	CQuicktime=(CQuicktimeClass*)NewPtr(sizeof(CQuicktimeClass));	if (!CQuicktime) return;	CQuicktime->m_windows=nil;	CQuicktime->m_theMovie=nil;	CQuicktime->m_theMC=nil;	CQuicktime->m_movieOpened=nil;	CQuicktime->m_haveTCtrack=nil;;	CQuicktime->m_OriginalMovieRect.top=nil;CQuicktime->m_OriginalMovieRect.left=nil;CQuicktime->m_OriginalMovieRect.right=nil;CQuicktime->m_OriginalMovieRect.bottom=nil;	CQuicktime->m_theMovieRect.top=nil;CQuicktime->m_theMovieRect.left=nil;CQuicktime->m_theMovieRect.right=nil;CQuicktime->m_theMovieRect.bottom=nil;	CQuicktime->m_theMCRect.top=nil;CQuicktime->m_theMCRect.left=nil;CQuicktime->m_theMCRect.right=nil;CQuicktime->m_theMCRect.bottom=nil;	CQuicktime->m_dur=nil;	CQuicktime->m_tcpos=nil;	CQuicktime->m_ts=nil;	CQuicktime->m_tb=nil;	CQuicktime->m_pbRate=nil;	CQuicktime->m_CurrentTC=nil;	CQuicktime->m_CurrentTCAbs=nil;	CQuicktime->m_CurrentTCTracks=nil;	CQuicktime->m_MovieDuration=nil;	CQuicktime->m_MovieOffset=0x0; //00595804; //!!!!!!!!!!!!!!!!!!!!!!!!!! zero zero zero !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	CQuicktime->m_keytime=nil;	CQuicktime->m_AutoIncrtime=nil;	CQuicktime->m_AutoIncrFlag=nil;	CQuicktime->m_keyUp=nil;	CQuicktime->m_lastkeyUp=nil;	CQuicktime->m_keypress=nil;	CQuicktime->m_lastkeypress=nil;	CQuicktime->m_keyMovSpeed=nil;	CQuicktime->m_ObjectType;			// specific tag indicating that the window object belongs to our application	CQuicktime->m_FileResID=nil;	CQuicktime->m_FileRefNum=nil;	CQuicktime->m_Dirty=nil;				// has the movie data changed since the last save?	CQuicktime->m_Instance=nil;				// the QTVRInstance	CQuicktime->m_fAppData=nil;				// a handle to application-specific window data		// divers    	gModalFilterUPP = NewModalFilterProc(QT_StandardModalDialogEventFilter);		// on ouvre une fenêtre de type float		GetNewWindowReference((DialogPtr*)&CQuicktime->m_windows,260,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info		gHasNewDialogCalls = QTUtils_TrapAvailable(_DialogDispatch);	// on regarde combien d'écran(s) est(sont) disponible(s)	NextDevice =DMGetFirstScreenDevice(true);	gdnumber=0;		do {		gdliste[gdnumber++]=NextDevice;		NextDevice=DMGetNextScreenDevice(NextDevice,true);	} while (NextDevice);				// note : il faut regarder les préférences	// pour savoir ou placer la fenêtre initialement	// en attendant c'est forcé en dur	/*	EventAvail(-1,&event);		a=event.modifiers &(optionKey|controlKey|shiftKey);*/		//if ( gdnumber<2){	if (  (gdnumber>1)/* && ! a*/ ){		// plusieurs écrans		// on le positionne sur le 2 eme écran		// il faudriat faire une fenêtre de dialogue pour demander sur quel ecran		// doit-on placer la fenête sous-titre		// ChoisirEcran		QT_PositionneFenetre(gdliste[1],true);			CQuicktime->m_fullscreen=true;		// on montre la fenêtre		ShowWindow(CQuicktime->m_windows);	} else {		// un seul écran	    // s'il y en a qu'un seul on le positionne en petite fenêtre		QT_PositionneFenetre(gdliste[0],false);		CQuicktime->m_fullscreen=false;		// on cache la fenêtre		HideWindow(CQuicktime->m_windows);	}		// le refcon de la fenêtre	SetWRefCon(CQuicktime->m_windows, (long)CQuicktime);	// note: on n'ouvre pas le movie tout de suite 	CQuicktime->m_movieOpened = false;} // constructeur// destructeur de la classevoid QT_Destrutor(void){	// on dispose la classe	if (!CQuicktime) return;	// Backup des sous-titres dans le fichier dummy movie ?	// dispose des elements	if (CQuicktime->m_theMovie)		QT_DoDestroyMovieWindow (CQuicktime->m_windows);							if (CQuicktime->m_windows)						DisposeWindowReference(CQuicktime->m_windows);	// DisposeWindow(m_WindowQTObject->m_windows);	CQuicktime->m_windows=0;																									//free(CQuicktime);	DisposePtr(CQuicktime);		CQuicktime=0;		PPCDispatch_ISpCR(3,0xCACABEBEL,0);	HUnlock(ISpCRH);	ReleaseResource((Handle)ISpCRH); 	ISpCRH=nil;	gAcceleratedResourceLoaded=0;	ExitMovies();}/////////////////////////////////////////////////////////////// //// Gestion des Events///////////////////////////////////////////////////////////////// // le idlevoid QT_Idle(void){long res=0;long butaction;	if (!CQuicktime) return;		if( CQuicktime->m_theMovie)			MoviesTask(CQuicktime->m_theMovie,0);				res=PPCDispatch_ISpCR(2,0xCACABEBEL,&igs); // on pool le joystick	//on gère les bottons du joystick;	butaction=igs.button^oldbuttonpress;	if (igs.button&0x1800==0x1800 ){			DoActionJoyButton(0x1800);	} else 		if   (butaction&igs.button)					DoActionJoyButton(butaction);				oldbuttonpress=igs.button; // pour le n-1;		QT_ProcessJoystick(CQuicktime);	G.Serial_Main_rate=QT_GetMovieRate(0);	}	//setter et getter de vitesse movievoid	QT_SetMovieRate(short rate){	QT_MovieSpeed(CQuicktime,rate);}long	QT_GetMovieRate(short rate){	return CQuicktime->m_keyMovSpeed;}long 	GetCurrentSoundLevel(){Handle hdl;long a =get_flag;a=a+a;		/*	if (CQuicktime && get_flag){		 	hdl=QTUtils_GetSoundLevelAtTime(CQuicktime->m_theMovie,CQuicktime->m_tcpos,60*600);				if (hdl){			HUnlock(hdl);			DisposeHandle(hdl);				}	}*/	if (CQuicktime && get_flag){		return QTUtils_GetCurrentSoundLevel(CQuicktime->m_theMovie);	}	return 0;}void	QT_SetTimeCode(long tc){TimeRecord		my_tr; 	if (CQuicktime && CQuicktime->m_theMC && tc !=-1){		GetMovieTime(CQuicktime->m_theMovie,&my_tr); 		my_tr.value.lo = TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tc,CQuicktime->m_MovieOffset));		MCDoAction (CQuicktime->m_theMC, mcActionGoToTime,(void*)(&my_tr)); 		}}void	QT_MovieStep(short rate){	if(CQuicktime)			MCDoAction (CQuicktime->m_theMC, mcActionStep,(void*)(rate)); }void QT_PlayStop(void){	m_key_joy_flag=0;	if (QT_GetMovieRate(0) >0) QT_SetMovieRate(0);	else QT_SetMovieRate(4);	}void QT_PlayRStop(void){	m_key_joy_flag=0;	if (QT_GetMovieRate(0) <0) QT_SetMovieRate(0);	else QT_SetMovieRate(-4);	}short QT_UpdateQTCaption(long AbsStNum){		if (CQuicktime)			QT_UpdateOneCaption(CQuicktime,AbsStNum);}short QT_UpdateQTList(){		if (CQuicktime)				QTText_SetTextTrack(CQuicktime);}// renvoie la position temporelle du movie.// track=0 -> framecount// track=1 -> piste time code.long	QT_GetCurTimeCode(short track){TimeRecord tmrec;MediaHandler			myHandler = NULL;HandlerError			myErr = noErr;TimeCodeDef			myTCDef;TimeCodeRecord		myTCRec;TC_N19 n19;	if (!CQuicktime) return 0;	if( !CQuicktime->m_theMovie) return 0;	if( track==1){	myHandler = QTTC_GetTimeCodeMediaHandler(CQuicktime->m_theMovie);		if (myHandler != NULL) {		// get the timecode for the current movie time		myErr = TCGetCurrentTimeCode(myHandler, NULL, &myTCDef, &myTCRec, NULL);		if (myErr == noErr) {    			n19.h=myTCRec.t.hours;    			n19.mn=myTCRec.t.minutes;    			n19.s=myTCRec.t.seconds;    			n19.f=myTCRec.t.frames;			CQuicktime->m_CurrentTC=TimeCode_N19_2_long(&n19);							} else track=0; // problem donc frame count		} else track=0; //problem donc frame count	}//if( track==1)		if( track==0){		GetMovieTime (CQuicktime->m_theMovie,&tmrec); 		CQuicktime->m_tcpos=(long)tmrec.value.lo;		CQuicktime->m_pbRate=GetMovieRate (CQuicktime->m_theMovie);				// on converti en tc classique		CQuicktime->m_CurrentTCAbs=TimeCode_Converted_FrameCount_2_TimeCode(CQuicktime->m_tcpos);				//on fait l'offset pour trouver le timecode			CQuicktime->m_CurrentTC=C_AdditionTimeCode(CQuicktime->m_CurrentTCAbs,CQuicktime->m_MovieOffset);				}		return CQuicktime->m_CurrentTC;}// cette fonction permet de récupérer l'offset de la piste time-code et le place dans le frame countoffsetvoid QT_GetTimeCodeTrackOffset2FrameCount(void){long tc,curtc; TimeRecord origTime;TimeRecord my_tr;	if (!CQuicktime) return ;	if( !CQuicktime->m_theMovie) return;	if( !CQuicktime->m_theMC) return;	GetMovieTime (CQuicktime->m_theMovie,&origTime); 	GetMovieTime (CQuicktime->m_theMovie,&my_tr); 	// 1 ere image	my_tr.value.lo=0;	MCDoAction (CQuicktime->m_theMC, mcActionGoToTime,(void*)(&my_tr)); 		// on récuère le time code	tc=QT_GetCurTimeCode(1);	QT_SetTimeOffset(tc);		// on replace le movie à la position de départ	MCDoAction (CQuicktime->m_theMC, mcActionGoToTime,(void*)(&origTime)); 	}longQT_GetTimeOffset(void){		if (!CQuicktime) return 0;		return CQuicktime->m_MovieOffset;}voidQT_SetTimeOffset(long offset){	CQuicktime->m_MovieOffset=offset;}// gestion des évènements pour QTshort QT_EventMessage(EventRecord *event){GrafPtr			oldport;short 		flag=0,result=0;unsigned long 	key;	WindowPtr		window;short			part;		if (!CQuicktime){		 return result;	}		//event pour nous ?	part= FindWindow(event->where,&window); 	 	if ( event->what==keyDown ||	      event->what==autoKey ||	      event->what==keyUp)		      					flag=1;	       	if(!flag)		       	result = QT_CheckMovieControllers(event,window);  	 	if (result) return result;		switch ( event->what ) {				case mouseDown:			result=QT_MouseDown(event);		break;					case keyUp:				// getion des touches du clavier pour le movie			key = event->message & charCodeMask;			if ( (event->modifiers & controlKey)  ||  !IsTeOpen()) {					if (!(G.SaisieModePreferenciel==2 && key==0x20)) // space utilisé pour autre chose	  			result=QT_ProcessKey(event->message,event->what,event->modifiers,CQuicktime);			}//if ( (event->modifiers & controlKey)  ||  !IsTeOpen())		break;					case keyDown:		case autoKey:						/* check for menukey equivalents */			key = event->message & charCodeMask;			if ( event->modifiers & cmdKey ) {			/* Command key down */				if ( event->what == keyDown ) {						long menui;						short myMenuID,myMenuItem;												QT_AdjustMenu();	/* enable/disable/check menu items properly */						menui=MenuKey(key);						if (menui){							myMenuID = HiWord(menui);							myMenuItem = LoWord(menui);							if (myMenuID==137){								result=true;								QT_MenuCommand(myMenuItem);			  			}			  						  			}				}			} else {				// getion des touches du clavier pour le movie				if ( (event->modifiers & controlKey)  ||  !IsTeOpen()) {										if (!(G.SaisieModePreferenciel==2 && key==0x20))  //space utilisé pour autre chose						  result=QT_ProcessKey(event->message,event->what,event->modifiers,CQuicktime);			  		}	//if ( (event->modifiers & controlKey)  ||  !IsTeOpen()					}				break;		case activateEvt:   	 					if ((WindowPtr) event->message == CQuicktime->m_windows){					GetPort(&oldport);					SetPort(CQuicktime->m_windows);						//DoActivate((WindowPtr) event->message, (event->modifiers & activeFlag) != 0);					SetPort(oldport);					result=1;				}					    	 				break;					case updateEvt:				if ((WindowPtr) event->message == CQuicktime->m_windows){					RGBColor color,color1;								GetPort(&oldport);					SetPort(CQuicktime->m_windows);					BeginUpdate(CQuicktime->m_windows); 					color1.red=-1; color1.blue=-1; color1.green=-1;  					color.red=0; color.blue=0; color.green=0;  					RGBForeColor(&color1);				 					 					RGBBackColor(&color);				 					 					EraseRect(&CQuicktime->m_windows->theWindow.port.portRect); 					if( CQuicktime->m_theMovie) 								MCDoAction(QT_GetMCFromWindow(CQuicktime->m_windows), mcActionDraw,CQuicktime->m_windows); 												 //UpdateMovie(CQuicktime->m_theMovie);					EndUpdate(CQuicktime->m_windows);					SetPort(oldport);					result=1;				}							break;	}		return result;}// Ajustage du menu quicktime	void QT_AdjustMenu(void){MenuHandle	menu;		menu=GetMenuHandle(137);			if (!menu) 				return ;				EnableItem(menu,1);	if (CQuicktime){		//EnableItem(menu,2);		//EnableItem(menu,3);		EnableItem(menu,4);		//EnableItem(menu,5);		//EnableItem(menu,6);		EnableItem(menu,8);		//EnableItem(menu,9);		EnableItem(menu,10);	} else {		DisableItem(menu,2);		DisableItem(menu,3);		DisableItem(menu,4);		DisableItem(menu,5);		DisableItem(menu,6);		DisableItem(menu,8);		DisableItem(menu,9);		DisableItem(menu,10);	}}shortQT_MouseDown(EventRecord  *event){WindowRef	myWindow;short		myWindowPart;Rect		myScreenRect;short 		msgtreated=0;CQuicktimeClassPtr 	m_WindowQTObject = NULL;MovieController 	myMC = NULL;Movie				myMovie = NULL;Rect 				myRect;				// on gère le click dans la fenêtre		myWindowPart = FindWindow(event->where, &myWindow);	m_WindowQTObject = QT_GetWindowObjectFromWindow(myWindow);	QT_AdjustMenu();	/* enable/disable/check menu items properly */	switch (myWindowPart) {		case inMenuBar:			// a mouse click in the menu bar 			// le menu est géré de manière unique par la routine principale		break;					case inDrag: 								// on vérifie que cette fenêtre est la notre						if (QT_IsWindowObjectOurs(m_WindowQTObject)) {				myMC = m_WindowQTObject->m_theMC;						msgtreated=1;								if (myMC != NULL) {					myMovie = m_WindowQTObject->m_theMovie;									// on déplace la fenêtre 					// note cela n'est pas possible en plein écran										if (myMovie != NULL /*&& ! m_WindowQTObject->m_fullscreen*/) {						GetMovieBox(myMovie, &myRect);						myScreenRect = (**GetGrayRgn()).rgnBBox;						DragAlignedWindow(myWindow, event->where, &myScreenRect, &myRect, NULL);					}								}			} 						break;														case inContent:			//on ne gère l'event que si c'est la fenêtre quicktime			if (QT_IsWindowObjectOurs(m_WindowQTObject)){				msgtreated=1;				// QT_HandleContentClick(myWindow, event);			}			break;				case inGoAway: // fermeture du movie ?			if (QT_IsWindowObjectOurs(m_WindowQTObject)){				QT_Destrutor();				msgtreated=1;				}			break;	} // end switch(myWindowPart)		return msgtreated;}// Gestion du menu quicktime	void QT_MenuCommand(long  myMenuItem){short 		result=0;Str255		myDAName;OSErr		myErr=0;		//MacSetCursor(&qd.arrow);	switch (myMenuItem) {								case 1:					if (!CQuicktime)							 QT_Constructor();					QT_DoCreateMovieWindow(CQuicktime,NULL, NULL);  					QTText_SetTextTrack (CQuicktime); // on transfert la liste de sous-titrage					break;																			case 2: //save as ...					// fair vérification si clône ?					// attention crash !					if (CQuicktime)						if (CQuicktime->m_windows)							QT_DoSaveAsMovieFile(CQuicktime->m_windows);					break;								case 3: // save					if (CQuicktime){						myErr=QT_DoUpdateMovieFile(CQuicktime->m_windows); // on sauvegarde l'offset											if (myErr)							if (Alert( 3116,0) ==1)									if (CQuicktime->m_windows)											QT_DoSaveAsMovieFile(CQuicktime->m_windows);							}					break;														case 4:					if (CQuicktime)						QT_Destrutor();					break;								case 6:				 					 					 	if (CQuicktime){					MovieController		myMC;					OSErr				myErr = noErr;										myMC = QT_GetMCFromWindow(CQuicktime->m_windows);					if (myMC != NULL) {						myErr = QTUtils_PrintMoviePICT(MCGetMovie(myMC), kDefaultX, kDefaultY, kPrintFrame); 						if (myErr != noErr) {							QT_ShowWarning("\pCould not print!", myErr);							SysBeep(kDefaultSysBeep);						}					} else						SysBeep(kDefaultSysBeep);					break;														case 8:					if (CQuicktime){																if (CQuicktime->m_theMovie)							if (QTTC_GetTimeCodeOptions()){								QTTC_DeleteTimeCodeTracks (CQuicktime->m_theMovie); // on detruit la piste précédente								QTTC_AddTimeCodeToMovie (CQuicktime->m_theMovie, 0);								//myErr=QT_DoUpdateMovieFile(CQuicktime->m_windows); // on sauvegarde l'offset							}													// on actualise le frame count						// et on recrée la liste de sous-titre								QT_GetTimeCodeTrackOffset2FrameCount();				 		QTText_SetTextTrack (CQuicktime);						myErr=QT_DoUpdateMovieFile(CQuicktime->m_windows); // on sauvegarde l'offset											if (myErr)							if (Alert( 3116,0) ==1)									if (CQuicktime)										if (CQuicktime->m_windows)											QT_DoSaveAsMovieFile(CQuicktime->m_windows);										}								break;								case 10:					if (CQuicktime){						QTText_SetTextTrack (CQuicktime);						myErr=QT_DoUpdateMovieFile(CQuicktime->m_windows); // on sauvegarde l'offset											if (myErr)							if (Alert( 3116,0) ==1)									if (CQuicktime)										if (CQuicktime->m_windows)											QT_DoSaveAsMovieFile(CQuicktime->m_windows);						}				break;												}								}; //switch}voidQT_SetTC_Offset(void){if (!CQuicktime) return;	//CQuicktime->m_MovieOffset= AskOffset_Quicktime(CQuicktime->m_MovieOffset);	DoDialogOffsetQT();}/////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////////////////////// void QT_PositionneFenetre(GDHandle gdh,short fullscreen){PixMapHandle	pmh;Rect	rect,rect1;Point	pt;GrafPtr	oldport;unsigned short 	x,y,w,h;	if (!CQuicktime) return;			GetPort(&oldport);	SetPort(CQuicktime->m_windows);// on récupère les infos de l'écran 	rect.top=(**gdh).gdRect.top;//dimension de l'ecran 	rect.right=(**gdh).gdRect.right; 	rect.left=(**gdh).gdRect.left; 	rect.bottom=(**gdh).gdRect.bottom; 	rect.top=(**gdh).gdRect.top;				//LocalToGlobal((Point*)&rect);					if (fullscreen) {			 	y=rect.top;		x=rect.left;		w=rect.right-rect.left; // cif MPEG 1		h=rect.bottom-rect.top; // cif MPEG 1		} else {		y=rect.top+50;		x=rect.left+50;		w=352; // cif MPEG 1		w+=16; // + taille du controleur		h=264;		}	  	ShowHide(CQuicktime->m_windows,true);	 	MoveWindow(CQuicktime->m_windows,x,y,false);  	SizeWindow(CQuicktime->m_windows,w,h,false);	CQuicktime->m_ObjectType=kMovieControllerNoObject; // pout indiquer qu'il n'y a pas de mc	SetPort(oldport);}////////////// StandardModalDialogEventFilter// A standard modal dialog event filter. ////////////pascal Boolean QT_StandardModalDialogEventFilter (DialogPtr theDialog, EventRecord *theEvent, short *theItemHit){	Boolean				myEventHandled = false;	short				myItemKind;			// for GetDialogItem	Handle				myItemHandle;		// for GetDialogItem	Rect				myItemRect;			// for GetDialogItem	unsigned long		myTicks;			// for Delay	char				myKey;			WindowReference		myWindow = NULL;	ModalFilterUPP		myStdModalProc;		// the OS's standard filter procedure	short				myPart;		OSErr				myErr = noErr;			switch (theEvent->what) {		case updateEvt:			// update the specified window, if it's behind the modal dialog			myWindow = (WindowReference)theEvent->message;			if ((myWindow != NULL) && (myWindow != theDialog)) {				DoUpdate(myWindow);				myEventHandled = false;		// so sayeth IM			}			break;					case keyDown:		case autoKey:			// if new Dialog Manager calls are NOT available, handle certain key presses			if (!gHasNewDialogCalls) {				// first, map Command-period to Escape key...				myKey = theEvent->message & charCodeMask;				if (theEvent->modifiers & cmdKey)					if (myKey == kPeriod)						myKey = kEscapeKey;										// ...then, handle the standard keyboard equivalents of OK and Cancel buttons				switch (myKey) {					case kReturnKey:					case kEnterKey:						*theItemHit = kStdOkItemIndex;						GetDialogItem(theDialog, kStdOkItemIndex, &myItemKind, &myItemHandle, &myItemRect);						HiliteControl((ControlHandle)myItemHandle, kControlButtonPart);						Delay(kMyButtonDelay, &myTicks);						HiliteControl((ControlHandle)myItemHandle, false);						myEventHandled = true;						break;					case kEscapeKey:						*theItemHit = kStdCancelItemIndex;						GetDialogItem(theDialog, kStdCancelItemIndex, &myItemKind, &myItemHandle, &myItemRect);						HiliteControl((ControlHandle)myItemHandle, kControlButtonPart);						Delay(kMyButtonDelay, &myTicks);						HiliteControl((ControlHandle)myItemHandle, false);						myEventHandled = true;						break;					default:						break;				}			}			break;					case mouseDown:			myPart = FindWindow(theEvent->where, &myWindow);			if (myPart == inDrag) {				Rect		myScreenRect;								myScreenRect = (**GetGrayRgn()).rgnBBox;				DragWindow(myWindow, theEvent->where, &myScreenRect);				myEventHandled = true;			}			break;					default:			myEventHandled = false;			break;	}			// let the OS's standard filter proc handle the event, if it hasn't already been handled	if (gHasNewDialogCalls && (myEventHandled == false)) {		myErr = GetStdFilterProc(&myStdModalProc);		if (myErr == noErr)			myEventHandled = CallModalFilterProc(myStdModalProc, theDialog, theEvent, theItemHit);	}		return(myEventHandled);}void QT_PPCDispatch_init(void){	OSErr 		err;	long		response;	short		myBit;	Boolean		gHasCFM;		gAcceleratedResourceLoaded=false; // par defaut	ISpCRH=nil;	gHasCFM=0;	// sommes nous sur une machine 68K ou PPC ?	Gestalt('cput',&response);		if ((response&0xFFF) >= 0x101) { // ppc ?		err = Gestalt(gestaltCFMAttr, &response);		myBit = gestaltCFMPresent;		gHasCFM = BitTst (&response, 31-myBit);	}		if (gHasCFM){  // si machine PPC		ISpCRH = Get1Resource('MWCW', 132 );		if (ISpCRH) 	HLock(ISpCRH);				if (ISpCRH)			gAcceleratedResourceLoaded=true;				}// si machine PPC} //PPCDispatch_initunsigned long PPCDispatch_ISpCR(unsigned long code, unsigned long param,Input_GameState* igs){ISpCR_UPP	ISpCRProc;long			ret=-1;				if (ISpCRH){ // dispacht si resource pas loader		ISpCRProc = (ISpCR_UPP)*ISpCRH;		ret= ISpCR_Proc(ISpCRProc,code,param,igs);	} 	return ret;	} //