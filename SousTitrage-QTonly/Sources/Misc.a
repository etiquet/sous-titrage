	PRINT	PUSH,OFF				INCLUDE	'NewVista.a'	; pour la nu vista+	INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	INCLUDE	'PrintTrapsEqu.a'	; pour utiliser le printing manager	INCLUDE	'VXEqu.a'	INCLUDE	'VXHWEqu.a'	INCLUDE	'SlotEqu.a'		; pour le slot manager	PRINT	POP				IMPORT	qd:MyQDGlobals	IMPORT	G:AppGlobals		* ================================================* FUNCTION TrapAvailable(tNumber: INTEGER): BOOLEAN;* ================================================* Check to see if a given trap is implemented. This is only used by the* Initialize routine in this program, so we put it in the Initialize segment.* The recommended approach to see if a trap is implemented is to see if* the address of the trap routine is the same as the address of the* Unimplemented trap. Needs to be called after call to _SysEnvirons so that it can* check if a ToolTrap is out of range of a pre-Mac II ROM.  This routine* assumes we're running on 128k ROMs. It also requires the entire trap* word so that it knows if it is a ToolTrap or an OSTrap.TrapAvailable	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointtNumber		DS.W	1			; the trap number passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTrapAddress	DS.L	1			; local copy of trap addressLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; initialize function's result		MOVE.W	tNumber(A6),D0		; get trap word into D0		BTST	#ToolTrapBit,D0		; test if number is Tool trap		BEQ.S	GetOSTrap		; off means a new OS trap number				MOVE.W	G.Mac.machineType,D1	; get the machine type we're running		CMPI.W	#envMachUnknown,D1	; are we on a future machine?		BEQ.S	GetToolTrap		; yes, go ahead and test for a new Tool trap				CMPI.W	#envMacII,D1		; are we on a Mac II or better?		BGE.S	GetToolTrap		; yes, go ahead and test for a new Tool trap* ------------- TEST FOR EXCEEDING TRAP TABLE -------------* At this point we know we're on a Mac 512E, Plus, or SE and need to* test the trap number for being in the range of < $0200		AND.W	#$03FF,D0		; mask off the ToolTrap bits		CMPI.W	#$01FF,D0		; is this trap in our trap table?		BLE.S	GetToolTrap		; yes, go ahead and test for a new Tool trap		BRA.S	Exit			; no, then this trap cannot be present		* ------------- TEST FOR NEW TOOL TRAP -------------GetToolTrap	_GetTrapAddress ,NewTool	; NewTool trap macro, trap is in D0		MOVE.L	A0,TrapAddress(A6)	; save a copy of the trap address		BRA.S	TestUnimp		; test against Unimplemented trap		* ------------- TEST FOR NEW OS TRAP -------------GetOSTrap	_GetTrapAddress ,NewOS		; NewOS trap macro, trap is in D0		MOVE.L	A0,TrapAddress(A6)	; save a copy of the trap addressTestUnimp	MOVE.W	#Unimplemented,D0	; get address of Unimplemented trap		_GetTrapAddress		CMPA.L	TrapAddress(A6),A0	; see if trap is implemented		BEQ.S	Exit			; nope, they're the same		MOVE.W	#True,Result(A6)	; yes, we've got the trapExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	TrapAval		; this name will appear in the debugger		ENDF* ================================================* FUNCTION IsDAWindow(window: WindowPtr): BOOLEAN;* ================================================* Check if a window belongs to a desk accessory.  DA window has a negitive kind.IsDAWindow	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointTheWindow	DS.L	1			; a window's pointer passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; first, initialize the result		CMPI.L	#NIL,TheWindow(A6)	; valid pointer?		BEQ.S	Exit			; it was NIL, look out!		MOVEA.L	TheWindow(A6),A0	; get the window pointer		MOVE.W	WindowKind(A0),D0	; what kind of window was it?		BPL.S	Exit			; DA windows are negitive		MOVE.W	#True,Result(A6)	; return true to the callerExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	IsDAWind		; this name will appear in the debugger		ENDF* ================================================* FUNCTION IsAppWindow(window: WindowPtr): BOOLEAN;* ================================================* Check to see if a window belongs to the application. If the window pointer* passed was NIL, then it could not be an application window. WindowKinds* that are negative belong to the system and windowKinds less than userKind* are reserved by Apple except for windowKinds equal to dialogKind, which* means it is a dialog.* In order to reduce the chance of accidentally treating some window* as an AppWindow that shouldn't be, we'll only return true if the windowkind* is userKind. If you add different kinds of windows to Sample you'll need* to change how this all works.IsAppWindow	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointTheWindow	DS.L	1			; a window's pointer passed by callerParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#False,Result(A6)	; first, initialize the result		CMPI.L	#NIL,TheWindow(A6)	; valid pointer?		BEQ.S	Exit			; it was NIL, look out!		MOVEA.L	TheWindow(A6),A0	; get the window pointer		MOVE.W	WindowKind(A0),D0	; what kind of window was it?		CMPI.W	#UserKind,D0		; was it an application window?		BNE.S	Exit			; no, result is going to be false		MOVE.W	#True,Result(A6)	; return true to the callerExit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	IsAppWin		; this name will appear in the debugger		ENDF* ================================================* FUNCTION DoCloseWindow(window: WindowPtr) : BOOLEAN;* ================================================* At this point, if there was a document associated with a window, you could* do any document saving processing if it is 'dirty'.  DoCloseWindow would* return TRUE if the window actually closes, i.e., the user does not cancel* from a save dialog. This result is handy when the user quits an application,* but then cancels a save of a document associated with a window. We also added* code to close the application window since otherwise, the termination routines* would never stop looping, waiting for FrontWindow to return NIL.DoCloseWindow	FUNC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		DS.W	1			; function's result returned to callerParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1			; passed window pointer parameterParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#True,Result(A6);	; initialize the function's result		CLR.W	-(SP)			; space for result of IsDAWindow		MOVE.L	WindowPtr(A6),-(SP)	; pass the window pointer		jsr	IsDAWindow		MOVE.W	(SP)+,D0		; result of IsDAWindow		CMPI.W	#True,D0		BNE.S	@1			; this wasn't a DA window		MOVEA.L	WindowPtr(A6),A0	; get window pointer		MOVE.W	WindowKind(A0),-(SP)	; pass the refNum of DA		_CloseDeskAcc		BRA.S	Exit			; all done@1		CLR.W	-(SP)			; space for result of IsAppWindow		MOVE.L	WindowPtr(A6),-(SP)	; pass a the window pointer		jsr	IsAppWindow		MOVE.W	(SP)+,D0		; result of IsAppWindow		CMPI.W	#True,D0		BNE.S	Exit			; it wasn't our application's window		MOVE.L	WindowPtr(A6),-(SP)	; close window, it shouldn't be a dialog		_CloseWindow			; close the application windowExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ClosWind		; this name will appear in the debugger		ENDF* ================================================* PROCEDURE GetGlobalMouse(VAR mouse: Point);* ================================================* Get the global coordinates of the mouse. When you call OSEventAvail* it will return either a pending event or a null event. In either case,* the where field of the event record will contain the current position* of the mouse in global coordinates and the modifiers field will reflect* the current state of the modifiers. Another way to get the global* coordinates is to call GetMouse and LocalToGlobal, but that requires* being sure that thePort is set to a valid port.}GetGlobalMouse	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointMouse		DS.L	1			; passed reference to mouse positionParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTheEvent 	DS	EventRecord 		; local copy of the event recordLocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		MOVE.W	#NoEvents,D0		; we aren't interested in any events		LEA	TheEvent(A6),A0		; point to event record		_OSEventAvail			; just the mouse position		MOVE.L	Mouse(A6),A0		; deref address of mouse		MOVE.L	TheEvent.Where(A6),(A0)	; stuff new value		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	GetGlobalMouse		; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE AdjustCursor(mouse: Point; region: RgnHandle);* ================================================* Change the cursor's shape, depending on its position. This also calculates the* region where the current cursor resides (for WaitNextEvent). If the mouse is* ever outside of that region, an event would be generated, causing this routine* to be called, allowing us to change the region to the region the mouse is* currently in. If there is more to the event than just the mouse moved, we* get called before the event is processed to make sure the cursor is the right* one. In any (ahem) event, this is called again before we fall back into WNE.* 1.02 - Removed the mouse position parameter and instead use the current position* of the mouse by calling GetMouse and LocalToGlobal.AdjustCursor PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWhere		DS.L	1			; the mouse location passed to usMouseRegion	DS.L	1			; passed pointer to current regionParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkFrontMost	DS.L	1			; local pointer to the front windowDesktopRgn	DS.L	1			; local handle to the arrow cursor regionCursorRgn	DS.L	1			; local handle to the plus cursor regionrectangle	ds		rectLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	IsDAWindow,IsAppWindow		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		 		CMPI.W	#True,G.InBackground	;on regarde si l'application est active 		BEQ 	Exit					; NON, donc on ne fait rien		CLR.L	-(SP)					; space for result of FrontWindow		import	FrontNonFloatingWindow		jsr		FrontNonFloatingWindow		MOVE.L	(SP)+,FrontMost(A6)		; copy pointer and keep it on stack; on créé une region; CursorRgn		CLR.L	-(SP)		_NewRgn				; create an empty plus region		MOVE.L	(SP)+,CursorRgn(A6)		; on regarde si la fenètre est une fenètre à nous				lea.l	G.ListingWindow,a0		cmp.l	FrontMost(A6),a0		beq		Listing				lea.l	G.DialogSaisie,a0		cmp.l	FrontMost(A6),a0		beq		Saisie			lea.l	G.DialogSaisie,a0		cmp.l	FrontMost(A6),a0		beq		TimeCodeWindow								lea.l	G.TELECOMMANDEWindow,a0		cmp.l	FrontMost(A6),a0		beq		telecommande	DisposeLaRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra		Exit;------------------------------------; pour l'instant on ne distingue pas les deux fenètres suivantes; on place juste le curseur couleur si on se trouve au dessus de l'une d'elletelecommande	TimeCodeWindow; on définie la zone "anti-mouse moved" comme le port rect		move.l	FrontMost(A6),a0		move.l	CursorRgn(a6),-(sp)		pea		portRect(a0)		_rectRgn		bra		curseurFlecheCouleur; -------; pour l'instant, on ne s'occupe pas des autres fenètresSaisie				tst.l	G.SaisieTe		beq		PASDETE_Saisie; on definie la region du TE => curseur RGN				pea.l	G.DialogSaisie		_setPort; on recopie le rectangle du texte edit		move.l	G.SaisieTE,a0		move.l	(a0),a0			; handle		move.l	TeViewRect(a0),rectangle(a6)		move.l	4+TeViewRect(a0),4+rectangle(a6); conversion => global		pea		rectangle(a6)		_LocalToGlobal		pea		4+rectangle(a6)		_LocalToGlobal; on définie la region		move.l	CursorRgn(a6),-(sp)		pea		Rectangle(a6)		_rectRgn; on regarde si le point est dedans					clr.w	-(sp)		move.l	Where(a6),-(sp)		move.l	CursorRgn(a6),-(sp)		_PtinRgn		move.w	(sp)+,d0		bne		CurseurTexte		; oui donc curseur texte; non pas dans le texte edit		; -------;PASDETE_Saisie		pea.l	G.DialogSaisie		_setPort; on définie la zone anti-mouse moved comme le port rect		lea.l	G.DialogSaisie,a0		move.l	CursorRgn(a6),-(sp)		pea		portRect(a0)		_rectRgn		bra		curseurFleche		; ------------------------------------------------------Listing				tst.l	G.ListingTe		beq		PASDETE_Listing; on definie la region du TE => curseur RGN				pea.l	G.ListingWindow		_setPort; on recopie le rectangle du texte edit		move.l	G.ListingTE,a0		move.l	(a0),a0			; handle		move.l	TeViewRect(a0),rectangle(a6)		move.l	4+TeViewRect(a0),4+rectangle(a6); conversion => global		pea		rectangle(a6)		_LocalToGlobal		pea		4+rectangle(a6)		_LocalToGlobal; on définie la region (en global)		move.l	CursorRgn(a6),-(sp)		pea		Rectangle(a6)		_rectRgn; on regarde si le point est dedans					clr.w	-(sp)		move.l	Where(a6),-(sp)		move.l	CursorRgn(a6),-(sp)		_PtinRgn		move.w	(sp)+,d0		bne		CurseurTexte		; oui donc curseur texte; non pas dans le texte edit		; -------;PASDETE_Listing		pea.l	G.ListingWindow		_setPort; on définie la zone anti-mouse moved comme le port rect		lea.l	G.ListingWindow,a0		move.l	CursorRgn(a6),-(sp)		pea		portRect(a0)		_rectRgn		bra		curseurFleche; ----------------------------------------------------------------------------------curseurFlecheCouleur		tst.b	G.Mac.HasCOloRQD		beq		curseurFleche		; il n'y a pas de color quickdraw donc curseur N&B		move.l	G.CurseurDessineST,-(sp)		_setCCursor			move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra	ExitcurseurFleche				pea	qd.Arrow		_SetCursor		_ShowCursor				move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra	Exit; ---curseurFlecheCreuse		clr.l	-(sp)		move.w	#287,-(sp)		_GetCursor		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	curseurFlecheCreuse1		move.l	(a0),a0		; handle		move.L	a0,-(sp)		_SetCursor		_ShowCursorcurseurFlecheCreuse1				move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra	Exit; ---curseurTexte		clr.l	-(sp)		move.w	#139,-(sp)		_GetCursor		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	curseurTexte1		move.l	(a0),a0		; handle		move.L	a0,-(sp)		_SetCursor		_ShowCursorcurseurTexte1		move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		bra		Exit; ---curseurLoupe		clr.l	-(sp)		move.w	#141,-(sp)		_GetCursor		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	curseurLoupe1		move.l	(a0),a0		; handle		move.L	a0,-(sp)		_SetCursor		_ShowCursorcurseurLoupe1		move.l	cursorRgn(a6),-(sp)		move.l	MouseRegion(a6),-(sp)		_CopyRgn			move.l	cursorRgn(a6),-(sp)		_DisposRgn		Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	AdjustCursor		; this name will appear in the debugger		align 4			ENDP* ***************************************************************** *                                                              ** * FONCTIONS SPECIALES POUR LES ROUTINES SYSTEME TRACK CONTROL  ** *                                                              ** ***************************************************************** =====================================================================* PROCEDURE SpecialThumbControlActionProc();* =====================================================================* Cette routine est appelée uniquement par pour actionproc in thumb* routine spéciale pour afficher le n° qui va ètre séléctionnné* lorsque l'on drag un thumb event*SpecialThumbControlActionProc	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkRectfenetre	DS		rect			; de la fenètreMouseLoc	ds.l	1			; point de la sourisFIT_text1	ds.b	8LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT DrawListingWindow,DrawWindow		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; sauvegarde des registres qui vont ètre détruits par cette routine		movem.l	d0-d7/a0-a4,-(sp); pour l'instant on fait rien		bra		Exit@FaireInThumb:						lea.l	G.ListingWindow,a0		; transfert de rect dans buffer temporaire		move.l	portRect(a0),Rectfenetre(a6)			move.l	portRect+4(a0),Rectfenetre+4(a6)		pea		G.ListingWindow		_SetPort				pea	MouseLoc(a6)		_GetMouse; initialisation de quick-draw de la police et tout et tout		MOVE.W		#SrcCopy,-(SP)					; source mode		_TextMode		MOVE.W		#Monaco,-(SP)					; Monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace	   			_PenNormal		move.w	Left+Rectfenetre(a6),d6		move.w	Top+Rectfenetre(a6),d7		add.w	#430,d6		add.w	#20,d7		move.w	d6,-(sp)		move.w	d7,-(sp)		_MoveTo				string pascal		moveq	#0,d0		move.w	MouseLoc(a6),d0		lea.l	FIT_text1(a6),a0		CLR.W		-(SP)							; selector for NumToString		_Pack7			pea 	#'('		_DrawString		pea		FIT_text1(a6)		_DrawString		pea		#' , '		_DrawString		moveq	#0,d0		move.w	MouseLoc+2(a6),d0			lea.l	FIT_text1(a6),a0		CLR.W		-(SP)							; selector for NumToString		_Pack7		pea		FIT_text1(a6)		_DrawString		pea		#')    '		_DrawStringExit	MOVEM.L	(SP)+,D0-D7/A0-A4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	SThumbCtrlAProc	; this name will appear in the debugger		align 4			ENDP; -------------------------------------------------------------------------; librarie pour la vidéo explorer ; -------------------------------------------------------------------------; 		end			; ############### !!!!!!!!!!!!!!!!!!!VESetCaptureState		proc	Export			LINK       A6,#-26                               ; 4E56 FFE6			MOVEM.L    D4-D7/A4,-(A7)                          ; 48E7 0F08			MOVE.W     $0012(A6),D4                            ; 382E 0012			MOVE.W     $000E(A6),D5                            ; 3A2E 000E			MOVE.W     $0016(A6),D6                            ; 3C2E 0016			MOVE.L     $0018(A6),D7                            ; 2E2E 0018			LEA        -$001A(A6),A4                           ; 49EE FFE6			TST.W      D5                                      ; 4A45			BEQ.S      @26     ; 00993BBC   ; 6706			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S      Exit     ; 00993C1A   ; 605E@26		EXT.L      D4                                      ; 48C4			MOVE.W     D4,D0                                   ; 3004			AND.W      #$FFF0,D0                               ; C07C FFF0			BEQ.S      @36     ; 00993BCC   ; 6706			MOVE.W     #$010A,D0                               ; 303C 010A			BRA.S      Exit     ; 00993C1A   ; 604E@36			TST.W      D6                                      ; 4A46			BLT.S      @40     ; 00993BD6   ; 6D06			CMPI.W     #$0003,D6                               ; 0C46 0003			BLE.S      @46     ; 00993BDC   ; 6F06@40			MOVE.W     #$0108,D0                               ; 303C 0108 			BRA.S      Exit     ; 00993C1A   ; 603E@46 		MOVEQ      #-1,D0                                 ; 70FF			CMP.L      D7,D0                                   ; B087			BEQ.S      @5E     ; 00993BF4   ; 6712			MOVEQ      #$01,D0                                 ; 7001			CMP.L      D7,D0                                   ; B087			BEQ.S      @5E     ; 00993BF4   ; 670C			MOVEQ      #$02,D0                                 ; 7002			CMP.L      D7,D0                                   ; B087			BEQ.S      @5E     ; 00993BF4   ; 6706			MOVE.W     #$0109,D0                               ; 303C 0109			BRA.S      Exit     ; 00993C1A   ; 6026@5E			MOVE.W     D5,(A4)                                 ; 3885			MOVE.W     D4,$0002(A4)                            ; 3944 0002			MOVE.W     D6,$0012(A4)                            ; 3946 0012			MOVE.L     D7,$0014(A4)                            ; 2947 0014			MOVE.B     $001F(A6),$0018(A4)                     ; 196E 001F 0018			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F4                                   ; 4878 03F4			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import     VDDoPBControl              ; 009930F4   ; 4EBA F4DC			JSR        VDDoPBControl              ; 009930F4   ; 4EBA F4DCExit		MOVEM.L    -$002E(A6),D4-D7/A4                     ; 4CEE 10F0 FFD2			UNLK       A6                                      ; 4E5E			RTS 			dbginfo.new	VESetCaptureState         			endp	VESetCaptureFormat		proc	Export			link		A6,#-26 								;$4E56,$FFE6			MOVEM.L    D6/D7/A4,-(A7)                          ; 48E7 0308			MOVE.W     $000E(A6),D6                            ; 3C2E 000E			LEA        -$001A(A6),A4                           ; 49EE FFE6			MOVE.W     $0012(A6),D7                            ; 3E2E 0012			TST.W      D6                                      ; 4A46			BEQ.S      @1E    ; 00993B4E   ; 6706			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S      Exit    ; 00993B76   ; 6028@1E			TST.W      D7                                      ; 4A47			BLT.S      @28    ; 00993B58   ; 6D06			CMPI.W     #$0007,D7                               ; 0C47 0007			BLE.S      @2E    ; 00993B5E   ; 6F06@28			MOVE.W     #$0107,D0                               ; 303C 0107			BRA.S      Exit    ; 00993B76   ; 6018@2E			MOVE.W     D6,(A4)                                 ; 3886			MOVE.W     D7,$0010(A4)                            ; 3947 0010			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F7                                   ; 4878 03F7			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import       VDDoPBControl              ; 009930F4   ; 4EBA F580			JSR        VDDoPBControl              ; 009930F4   ; 4EBA F580Exit		 MOVEM.L    -$0026(A6),D6/D7/A4                     ; 4CEE 10C0 FFDA			UNLK       A6                                      ; 4E5E			RTS         			dbginfo.new	VESetCaptureFormat			endp			VESetCaptureWindow	proc Export			LINK       A6,#-26                               ; 4E56 FFE6			MOVEM.L    D7/A4,-(A7)                             ; 48E7 0108			MOVE.W     $000E(A6),D7                            ; 3E2E 000E			LEA        -$001A(A6),A4                           ; 49EE FFE6			TST.W      D7                                      ; 4A47			BEQ.S      @1A    ; 009939CE   ; 6706			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S      exit    ; 009939EE   ; 6020@1A			MOVE.W     D7,(A4)                                 ; 3887			MOVEA.L    A4,A0                                   ; 204C			ADDQ.L     #$6,A0                                  ; 5C88			LEA        $0010(A6),A1                            ; 43EE 0010 			MOVE.L     (A1)+,(A0)+                             ; 20D9			MOVE.L     (A1)+,(A0)+                             ; 20D9			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F5                                   ; 4878 03F5			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import     VDDoPBControl              ; 009930F4   ; 4EBA F708			JSR        VDDoPBControl              ; 009930F4   ; 4EBA F708Exit		MOVEM.L    -$0022(A6),D7/A4                        ; 4CEE 1080 FFDE			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75						dbginfo.new	VESetCaptureWindow			endp			VEGetChannel		proc	Export			LINK       A6,#-6           			MOVEM.L    D7/A4,-(A7)                         			LEA        -$0006(A6),A4                          			MOVE.W     $000E(A6),D7                         			BLT.S      @18          ; 009936EE   | 6D06			CMPI.W     #$0016,D7                              			BLE.S      @1E          ; 009936F4   | 6F06@18			MOVE.W     #$00F1,D0                              			BRA.S      exit          @1E			MOVE.W     D7,(A4)                                			MOVE.L     A4,-(A7)                               			PEA        $03F1                                   			MOVE.W     $000A(A6),D0                            			EXT.L      D0                                     			MOVE.L     D0,-(A7)                               			import     VDDoPBStatus              			JSR        VDDoPBStatus         			MOVE.W     D0,D7                                   			MOVEA.L    $0010(A6),A0                          			MOVE.W     $0004(A4),(A0)                          			MOVE.W     D7,D0                                  exit		MOVEM.L    -$000E(A6),D7/A4                     			UNLK       A6                                    			RTS                                   			dbginfo.new	VEGetChannel			endp			VESetChannel		proc	Export			LINK       A6,#-6                               ; 4E56 FFFA			MOVEM.L    D6/D7/A4,-(A7)                          ; 48E7 0308			LEA        -$0006(A6),A4                           ; 49EE FFFA			MOVE.W     $0012(A6),D6                            ; 3C2E 0012			MOVE.W     $000E(A6),D7                            ; 3E2E 000E			BLT.S      @1C          ; 0099374A   ; 6D06			CMPI.W     #$0016,D7                               ; 0C47 0016			BLE.S      @22          ; 00993750   ; 6F06@1C			MOVE.W     #$00F1,D0                               ; 303C 00F1			BRA.S      exit          ; 00993786   ; 6036@22			CMPI.W     #$0014,D7                               ; 0C47 0014			BNE.S      @2E          ; 0099375C   ; 6606			MOVE.W     #$00F1,D0                               ; 303C 00F1			BRA.S      exit          ; 00993786   ; 602A@2E			CMPI.W     #$0001,D6                               ; 0C46 0001			BLT.S      @3A          ; 00993768   ; 6D06			CMPI.W     #$000C,D6                               ; 0C46 000C			BLE.S      @40          ; 0099376E   ; 6F06@3A			MOVE.W     #$00F3,D0                               ; 303C 00F3			BRA.S      exit          ; 00993786   ; 6018@40			MOVE.W     D7,(A4)                                 ; 3887			MOVE.W     D6,$0004(A4)                            ; 3946 0004			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F0                                   ; 4878 03F0			MOVE.W     $000A(A6),D0                            ; 302E 000A			 EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import        VDDoPBControl              ; 009930F4   ; 4EBA F970			JSR        VDDoPBControl              ; 009930F4   ; 4EBA F970exit		MOVEM.L    -$0012(A6),D6/D7/A4                     ; 4CEE 10C0 FFEE			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75 			dbginfo.new	VESetChannel			endp			 VESetCaptureColor	proc export			LINK       A6,#-4                              ; 4E56 FFFC			MOVE.L     A4,-(A7)                                ; 2F0C			LEA        -$0004(A6),A4                           ; 49EE FFFC			MOVE.L     $000C(A6),(A4)                          ; 28AE 000C			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F8                                   ; 4878 03F8			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import        VDDoPBControl              ; 009930F4   ; 4EBA F7BC			JSR        VDDoPBControl              ; 009930F4   ; 4EBA F7BC			MOVEA.L    -$0008(A6),A4                           ; 286E FFF8			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75			dbgInfo.new	VESetCaptureColor			endp			VEGetCaptureWindow		proc	Export			LINK       A6,#-26                                ; 4E56 FFE6			MOVEM.L    D7/A4,-(A7)                             ; 48E7 0108			MOVE.W     $000E(A6),D7                            ; 3E2E 000E			LEA        -$001A(A6),A4                           ; 49EE FFE6			TST.W      D7                                      ; 4A47			BEQ.S      @1A    ; 00993970   ; 6706			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S      exit    ; 00993994   ; 6024@1A			MOVE.W     D7,(A4)                                 ; 3887			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F6                                   ; 4878 03F6			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import      VDDoPBStatus               ; 009930A8   ; 4EBA F726			JSR        VDDoPBStatus               ; 009930A8   ; 4EBA F726			MOVE.W     D0,D7                                   ; 3E00			MOVEA.L    $0010(A6),A0                            ; 206E 0010			MOVEA.L    A4,A1                                   ; 224C			ADDQ.L     #$6,A1                                  ; 5C89			MOVE.L     (A1)+,(A0)+                             ; 20D9			MOVE.L     (A1)+,(A0)+                             ; 20D9			MOVE.W     D7,D0                                   ; 3007exit		MOVEM.L    -$0022(A6),D7/A4                        ; 4CEE 1080 FFDE			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75			dbginfo.new	VEGetCaptureWindow			endpVEGetCaptureChannel		proc	Export			LINK       A6,#-26                               ; 4E56 FFE6			MOVEM.L    D7/A4,-(A7)                             ; 48E7 0108			MOVE.W     $000E(A6),D7                            ; 3E2E 000E			LEA        -$001A(A6),A4                           ; 49EE FFE6			TST.W      D7                                      ; 4A47			BEQ.S      @1A   ; 00993A28   ; 6706			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S      exit   ; 00993A48   ; 6020@1a			MOVE.W     D7,(A4)                                 ; 3887			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F7                                   ; 4878 03F7			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import       VDDoPBStatus               ; 009930A8   ; 4EBA F66E			JSR        VDDoPBStatus               ; 009930A8   ; 4EBA F66E  			MOVE.W     D0,D7                                   ; 3E00			MOVEA.L    $0010(A6),A0                            ; 206E 0010			MOVE.W     $000E(A4),(A0)                          ; 30AC 000E			MOVE.W     D7,D0                                   ; 3007exit		MOVEM.L    -$0022(A6),D7/A4                        ; 4CEE 1080 FFDE			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75			dbginfo.new	VEGetCaptureChannel			endp			VESetCaptureChannel		proc	Export			LINK       A6,#-26                               ; 4E56 FFE6			MOVEM.L    D6/D7/A4,-(A7)                          ; 48E7 0308			MOVE.W     $0012(A6),D6                            ; 3C2E 0012			MOVE.W     $000E(A6),D7                            ; 3E2E 000E			LEA        -$001A(A6),A4                           ; 49EE FFE6			TST.W      D7                                      ; 4A47			BEQ.S     @1e   ; 6706			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S    	exit  ; 00993AB6   ; 6030@1e			EXT.L      D6                                      ; 48C6			MOVE.L     D6,-(A7)                                ; 2F06			import     capChannelTblErr           ; 00993284   ; 4EBA F7F8			JSR        capChannelTblErr           ; 00993284   ; 4EBA F7F8			TST.B      D0                                      ; 4A00			ADDQ.W     #$4,A7                                  ; 584F			BEQ.S      @32   				MOVE.W     #$0106,D0                               ; 303C 0106			BRA.S      Exit 			@32			MOVE.W     D7,(A4)                                 ; 3887			MOVE.W     D6,$000E(A4)                            ; 3946 000E			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F6                                   ; 4878 03F6			MOVE.W     $000A(A6),D0                            ; 302E 000A 	 		EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import        VDDoPBControl              ; 009930F4   ; 4EBA F644			JSR        VDDoPBControl              ; 009930F4   ; 4EBA F644			LEA        $000C(A7),A7                            ; 4FEF 000CExit		MOVEM.L    -$0026(A6),D6/D7/A4                     ; 4CEE 10C0 FFDA			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75			dbgInfo.new	VESetCaptureChannel			endp			VEGetCaptureFormat		proc	Export			LINK       A6,#-26                                ; 4E56 FFE6			MOVEM.L    D7/A4,-(A7)                             ; 48E7 0108			MOVE.W     $000E(A6),D7                            ; 3E2E 000E			LEA        -$001A(A6),A4                           ; 49EE FFE6			TST.W      D7                                      ; 4A47			BEQ.S      @1    			MOVE.W     #$0105,D0                               ; 303C 0105			BRA.S    	Exit   @1			MOVE.W     D7,(A4)                                 ; 3887			MOVE.L     A4,-(A7)                                ; 2F0C			PEA        $03F8                                   ; 4878 03F8			MOVE.W     $000A(A6),D0                            ; 302E 000A			EXT.L      D0                                      ; 48C0			MOVE.L     D0,-(A7)                                ; 2F00			import     VDDoPBStatus               ; 009930A8   ; 4EBA F5A6			JSR        VDDoPBStatus               ; 009930A8   ; 4EBA F5A6			MOVE.W     D0,D7                                   ; 3E00			MOVEA.L    $0010(A6),A0                            ; 206E 0010			MOVE.W     $0010(A4),(A0)                          ; 30AC 0010			MOVE.W     D7,D0                                   ; 3007Exit		MOVEM.L    -$0022(A6),D7/A4                        ; 4CEE 1080 FFDE			UNLK       A6                                      ; 4E5E			RTS                                                ; 4E75			dbginfo.new		VEGetCaptureFormat			endp		VDDoPBStatus	proc export			LINK       A6,#-80    			MOVE.L     D7,-(A7)  			MOVEQ      #$00,D0 			MOVE.L     D0,-$0044(A6) 			MOVE.W     $000A(A6),-$0038(A6) 			MOVE.L     $0010(A6),-$0034(A6) 			MOVE.W     $000E(A6),-$0036(A6)			SUBQ.L     #$2,A7              			PEA        -$0050(A6)    			MOVEQ      #$00,D1   			MOVE.B     D1,-(A7)   			JSR        CallStatus			MOVE.W     (A7)+,D0            			EXT.L      D0        			MOVE.L     D0,D7                    			MOVE.W     D7,D0                                			MOVE.L     -$0054(A6),D7            			UNLK       A6                       			RTS                       CallStatus	 			MOVEA.L    (A7)+,A1             			MOVE.B     (A7)+,D0                           			MOVEA.L    (A7)+,A0                             			_Status                  			MOVE.W     D0,(A7)                              			JMP        (A1)   			dbginfo.new		  VDDoPBStatus                            	 		endP												VDDoPBControl proc export  			LINK       A6,#-80                     			MOVE.L     D7,-(A7)                         			MOVEQ      #$00,D0       			MOVE.L     D0,-$0044(A6)     			MOVE.W     $000A(A6),-$0038(A6)  			MOVE.L     $0010(A6),-$0034(A6)  			MOVE.W     $000E(A6),-$0036(A6)  			SUBQ.L     #$2,A7                                   			PEA        -$0050(A6)                             			MOVEQ      #$00,D1                                  			MOVE.B     D1,-(A7)                                			JSR        DoControl  			MOVE.W     (A7)+,D0                                 			EXT.L      D0                                      			MOVE.L     D0,D7                               			MOVE.W     D7,D0                                  			MOVE.L     -$0054(A6),D7                       			UNLK       A6                                       			RTS                                               DoControl	MOVEA.L    (A7)+,A1                                			MOVE.B     (A7)+,D0                                			MOVEA.L    (A7)+,A0                             			_Control   			MOVE.W     D0,(A7)                              			JMP        (A1)                                    			dbginfo.new		VDDoPBControl			endPcapChannelTblErr		proc export			LINK       A6,#$0000                      			MOVE.W     $000A(A6),D0  			SUBQ.W     #$2,D0			BMI.S      exit_err			CMPI.W     #$000F,D0  			BGT.S      exit_err			ADD.W      D0,D0       			                         			MOVE.W     TableJump(pc,D0.W),D0 			JMP       TableJump-2(pc,D0.w)TableJump	dc.w	 $0022,$0026			dc.w	 $0022,$0026			dc.w	 $0026,$0026			dc.w	 $0026,$0026			dc.w	 $0026,$0026			dc.w	 $0026,$0022			dc.w	 $0022,$0022			dc.w	 $0022,$0022			MOVEQ      #$00,D0       			BRA.S      exitexit_err  		MOVEQ      #$01,D0 exit  		UNLK       A6  			RTS   			dbginfo.new		capChannelTblErr			endp* =====================================================================* PROCEDURE FindFirstPlus();* =====================================================================** Cette routine recherche la première nu vista+ présente dans les slots d'extensions*FindFirstPlus	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		ds.l	1		; resultatParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 link 			DS.L	1			; emplacement pour stocker la taille et positionArea		ds		spBlockHandle		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame,SpBlock		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		; sauvegarde des registres qui vont ètre détruits par cette routine		movem.l	d0-d7/a0-a4,-(sp)		clr.l	Result(a6)		clr.l	-(sp)		_GetDeviceList		move.l	(sp)+,Handle(a6)		beq		exit	; no device listLoop	clr.w	-(sp)		move.l	Handle(a6),-(sp)		import	GDHandle2slot		jsr		GDHandle2slot		move.w	(sp)+,d0				lea		Area(a6),a0		move.b	d0,spSlot(a0)		move.b	#128,spId(a0)		move.b	#0,spExtDev(a0)		_SRsrcInfo		lea		Area(a6),a0		move.w	spDrvrHW(a0),d0		cmp.w	#kDrHwNuVistaPlusPAL,d0	; nuvista+		beq.s	FoundNuvista		cmp.w	#kNuVistaBoardID,d0		; nu vista classic		beq.s	FoundNuvista		cmp.w	#kDrHwNuVista4Meg,d0		; nu vista classic 4meg		beq.s	FoundNuvista				cmp.w	#kDrHwNuVistaPlusNTSC,d0		; nu vista+ NTSC 		beq.s	FoundNuvista				clr.l	-(sp)				move.l	Handle(a6),-(sp)				_GetNextDevice		move.l	(sp)+,d0		beq			Exit	; fin de la liste		move.l	d0,Handle(a6)		bra		Loop; ----------FoundNuvista		move.l	Handle(a6),result(a6)Exit	MOVEM.L	(SP)+,d0-d7/a0-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.New	findfirstplus	; this name will appear in the debugger		align 4			ENDP* ========================================*   UpdateWindowBehind* ========================================; EventAvail(short eventMask,EventRecord *theEvent); Cette routine Regarde dans la queue s'il y a un update event,; et appelle doUpdate pour redessiner les feêtres dans ce cas.UpdateWindowBehind proc exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		ds.l	1		; resultatParamBegin	EQU	*			; start parameters after this pointTicks		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 link 			DS.L	1			; emplacement pour stocker la taille et positionTheEvent 			DS	EventRecord 		; local copy of the event recordHandle		ds.l	1saveport	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR				WITH	StackFrame,SpBlock,TheEvent		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				movem.l	d0-d7/A1-A4,-(sp)		pea		saveport(a6)		_GetPortloop	clr.w	-(sp)		move.w	#64,-(sp)		pea		TheEvent(a6)		_eventAvail		move.w	(sP)+,d0		beq		Exit		MOVE.W	What(A6),D0		; get the event number		cmp.w	#6,d0		bne.s	Loop		MOVE.L	Message(A6),-(SP)	; pass the window pointer		import	DoUpdate		; do the update		jsr		DoUpdate		; do the update				bra		LoopExit	move.l	saveport(a6),-(sp)		_setPort		movem.l	(sp)+,d0-d7/A1-A4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.New	UpdateWindowBehind	; this name will appear in the debugger		align 4			ENDP 		END    ; fin de ce listing