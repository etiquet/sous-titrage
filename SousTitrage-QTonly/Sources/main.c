#include "BB.Globals_C.h"#include "CQuicktime.h"#include <SegLoad.h>typedef struct verifGlobals{	Ptr	QDdkgray;	Ptr	GspareForFutur;}verifGlobals, *verifGlobalsPtr;/* quelques protos */void 			MainLoop(void);pascal void 	StartXtimeTask(void);pascal void 	EventLoop(void);pascal void		main(void);pascal Boolean 	UpdateAV(void);pascal void 	DrawBlockNoteValue(void);pascal void 	UpdateErrorWindow(void);pascal void 	DrawServiceWindow(void);void 			GiveMeMoreMaster(void);pascal void 	TestAdresseGlobales(verifGlobalsPtr BBglobals);pascal void 	TestAdresseGlobales_conv(verifGlobalsPtr BBglobals,Ptr p2);pascal void 	TestAdresseGlobales_rend(verifGlobalsPtr BBglobals,Ptr p2);void 			UpdateInfoWindow(void);void 			DrawInfowWindValue(void);void 			DrawInfowWindValuePartiel(void);extern pascal void SauvegardeAutomatique(void);void			SauvegardeAutomatique_Idle(short type);void 			UpdateProchainSousTitre(Boolean partiel);void 			DoFollowTCForDisplay(void);extern			long 	gtcasked;void gereEventLoop(EventRecord* event,short GotEvent);void DoIdle();Boolean		gDone,gRefreshInfoW,doTrackingInListing,doTrackingOutListing,doTrackingInSaisie,doTrackingOutSaisie;DialogPtr  	gLogo,gPaletteKaraoke;extern long	DoAbortIO;extern DialogPtr gDialogProchainSousTitre;short	gCurResNum,gWatchdog;void DoSaisieIdle(void);MyQDGlobals QD;AppGlobals G;pascal void main(void){verifGlobals Glob;Ptr	p2[9];		MaxApplZone();	gCurResNum=CurResFile();	SetDialogFont(kFontIDGeneva);/*	p[0]=(Ptr)&G.performanceTask;	p[1]=(Ptr)&G.AskTcTask;	p[2]=(Ptr)&G.Rechercher_STR;	p[3]=(Ptr)&G.EveHandle;	p[4]=(Ptr)&G.versionLogiciel;	p[5]=(Ptr)&G.Justification;	p[6]=(Ptr)&G.SoftProtect;	p[7]=(Ptr)&G.CurrentFileName;*//*	TestAdresseGlobales_rend(&Glob,(Ptr)&p2);	if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(Main - routine rendering .a)");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(Main - routine rendering .a)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;*/	TestAdresseGlobales_conv(&Glob,(Ptr)&p2);		if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(Main -routine conversion )");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(Main -routine conversion)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;	// on vérifie l'identitée des variables globales	TestAdresseGlobales(&Glob);	if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(Main)");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(Main)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;	Initialise_BonBougre();	// get things the program set up	MainLoop();	C_QuitApplication();	// on dispose tous le bastring}/* Boucle Principale du programme */void MainLoop(void){EventRecord	event;Boolean		GotEvent,pbClef=true;	if (!G.FindFirstKey_error) pbClef=false;	else  if (G.SoftProtect==1) pbClef=false;		G.WatchDogSave=TickCount();	gDone=false;	G.InBackground=false;	#ifndef __NoProtect__	if (pbClef) NoteAlert(281,nil);#endif	// on regarde s'il y a un offset sur le TC	if (G.OffsetLectureTCPlay || G.OffsetLectureTCStop ) 													NoteAlert(288,nil);														SetEventMask (-1); // pour être certain de recevoir le key up event !			// la boucle pricipale du programme ...do{		GotEvent=WaitNextEvent(everyEvent,&event,0,nil);		gereEventLoop(&event,GotEvent);	}while(!gDone);		}// event loopvoid gereEventLoop(EventRecord* event,short GotEvent){long flag=0;			SauvegardeAutomatique_Idle(0); // Gestion Sauvergarde Automatique // type normal						  if (QT_EventMessage(event) )		  				 return;	  		  if (GotEvent)				DoEvent(event);//gère event record				DoIdle();} // gereEventLoop	void DoIdle(){// on update le compteur pour mesurer la performance de la boucle pricipale// Gestion des events// le système quicktime// capture en premier les évènements // si le résutat est false// laisse le reste du logiciel faire le dispatch		G.EventLoop_Counteur++;		//si mode quicktime, on demande le time code				if (G.LecteurTimeCode_Type){			G.General_TCCourant=QT_GetCurTimeCode(G.LecteurTimeCode_Type);			gWatchdog=70;		}		// on precalcule le time code courant			C_ConversionTCstASCII(G.General_TCCourant,&G.bufferTimecodeCourant);		G.bufferTimecodeCourant[0]=12;		G.bufferTimecodeCourant[12]=' ';// les routines idles des fenêtres listing, saisie,  chenille et infos		if (((WindowPeek)&G.ListingWindow)->visible) 	DoListingIdle();		if (((WindowPeek)G.ChenilleWindow)->visible) 	DoChenilleIdle();		if (((WindowPeek)&G.DialogSaisie)->visible)  	DoSaisieIdle();				DoFollowTCForDisplay(); // si ni simu ni-broadcast on fait juste le tc courant et listing		/* pour la fenêtre info, on ne rafraichi seulement le nécesaire */		if ( ((WindowPeek)G.ServiceWindow)->visible ){			if(gRefreshInfoW){				DrawInfowWindValue();			 	gRefreshInfoW=0;			 } else 			 	DrawInfowWindValuePartiel();		}		// idles pour les Les TE						if (G.saisieTE) 	TEIdle(G.saisieTE);		if (G.ListingTE) 	TEIdle(G.ListingTE);		if (G.BlockNoteTE)	TEIdle(G.BlockNoteTE);				QT_Idle(); // pour quicktime}/* routine qui gère le rafraichissement	des fenêtres générale du logiciel */pascal void DoUpdate(WindowPtr window){Rect			rect;PixPatHandle	pixpat;GrafPtr			oldport;short 			done=0;					if (window){				GetPort(&oldport);		SetPort((GrafPtr)window);		if (window==(WindowPtr)&G.ListingWindow){						//G.SerialError=1; // on force l'update du voyant						update_listingGworld();						BeginUpdate(window);						DrawListingWindow();						/* on regarde s'il y a un te en cour*/						if (G.ListingTE) {							rect=(**G.ListingTE).viewRect;							InsetRect(&rect,-1,-1);							EraseRect(&rect);							TEUpdate(&(**G.ListingTE).viewRect,G.ListingTE);							FrameRect(&rect);							}// if listing TE						EndUpdate(window);						done=true;						}			if (window==(WindowPtr)gDialogProchainSousTitre){ 				BeginUpdate(window);				UpdateProchainSousTitre(false);				EndUpdate(window);				done=true;				}															if (window==(WindowPtr)G.TELECOMMANDEWindow){ 				BeginUpdate(window);				DoUpdatePaletteTelecommande();				EndUpdate(window);				done=true;				}						if (window==(WindowPtr)G.ChenilleWindow){				 BeginUpdate(window);				 DoUpdatePaletteChenille();				 EndUpdate(window);    				done=true;				 }				 		if (window==(WindowPtr)&G.DialogSaisie){			BeginUpdate(window);			UpdateSaisie();			EndUpdate(window);			done=true;		 }					if (window==(WindowPtr)G.BlockNoteWindow){			 BeginUpdate(window);			 DrawBlockNoteValue();			 EndUpdate(window);			done=true;		 }				if (window==(WindowPtr)G.LogoWindow){			 	BeginUpdate(window);				DrawDialog(window);				EndUpdate(window);				done=true;		}				if (window==(WindowPtr)G.ServiceWindow){			 	BeginUpdate(window);				UpdateInfoWindow();				EndUpdate(window);				done=true;		}					 		if (window==(WindowPtr)G.ErrorsWindow){			 UpdateErrorWindow();						done=true;		} 	 		if (window==(WindowPtr)&G.BackDropWindow) {			BeginUpdate(window);			pixpat=GetPixPat(G.BackDrop_PatNum);			if (pixpat){				FillCRect(&window->portRect,pixpat);				DisposePixPat(pixpat);				EndUpdate(window);			} else {				PenMode(patCopy);				ForeColor(blackColor);				BackColor(whiteColor);				PenSize(1,1); 				PenPat(&QD.dkGray); 				PaintRect(&window->portRect); 				PenNormal();				EndUpdate(window);		}			done=true;	   }//backdropwindow		// si la fenêtre n'a pas été identifié	// on fait un simple erase	if (!done) {			BeginUpdate(window); 			EraseRect(&window->portRect);			EndUpdate(window);			done=true;		}			SetPort(oldport);	}// if window} // DoUpdate/* Cette routine controle la sauvegarde automatique*/void SauvegardeAutomatique_Idle(short type){long	actualDiff;		if ( !G.Preference_AutoCheck) 			return; // sauvegarde automatique pas demandée		if ( !G.ChangeSinceLastSave&0x7fff ) 	return; // pas besoin de faire sauvegarde automatique		actualDiff=(TickCount()-G.WatchDogSave)/3660;// on regarde on en est // on regarde ce que l'on nous demande// type==0 mode normal// type ==1 mode on aimerais faire la sauvegarde le plus rapidement possible						if (type==0){ // mode normal				if (actualDiff<G.Preference_NombreSauv) 	return; // on ne fait rien ,il n'y a pas besoin				// on devrais sauvegarder maintenant, mais on regarde si cela dérange								// s'il y a un TE d'ouvert on attend 50% en plus du temps prévus 				if( G.saisieTE || G.ListingTE) 					if ( (actualDiff/2) < G.Preference_NombreSauv ) return;								// on va faire la sauvegarde				// on regarde si nous sommes en affichage dans un sous-titre				// on essaye d'optimiser le bigniou, (seulement si version affichage)												// on fait la sauvegarde				C_SaveData(true);				G.ChangeSinceLastSave=0;				G.WatchDogSave=TickCount();							} 						if (type==1){ // mode on force un peu sur la sauvegarde au 3/4 du temps prévus				if (actualDiff< ((G.Preference_NombreSauv*3)/4) ) 	return; // on ne fait rien ,il n'y a pas besoin				// on fait la sauvegarde				C_SaveData(true);				G.ChangeSinceLastSave=0;				G.WatchDogSave=TickCount();			} 			}// sauvegarde automatique