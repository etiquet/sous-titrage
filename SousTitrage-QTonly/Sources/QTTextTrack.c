#include "QTTextTrack.h"#include "TimeCodeUtilities.h"long GetTcOutForThis(SousTitreRecordPtr ST_Ptr);long GetTcInForThis(SousTitreRecordPtr ST_Ptr);// les globalsextern MyQDGlobals QD;extern AppGlobals G;short QTText_SetTextTrack (CQuicktimeClass* QTC){	Track				myTypeTrack = NULL;	Track				myTextTrack = NULL;	Media				myMedia;	MediaHandler			myHandler = NULL;	TimeScale				myTimeScale;	MatrixRecord			myMatrix;	Fixed				myWidth;	Fixed				myHeight;	OSErr				myErr = noErr;	TimeRecord			my_troriginal;	TimeValue				mySampleTime;		long					currentTime;	long 					duration=GetMovieDuration (QTC->m_theMovie);	long 					ttrackheigthline=20,l;	Rect 					bounds;	GrafPtr	oldport;			// find the target track	myTextTrack = QTText_GetFirstTrackOfType(QTC->m_theMovie,TextMediaType);		if (myTextTrack) // on enlËve les anciennes tracks			QTText_RemoveIndTextTrack(QTC->m_theMovie,kAllTextTracks);				// get the (first) track of the specified type; this track determines the width of the new text track	// and (if isChapterTrack is true) is the target of the new chapter track	myTypeTrack = GetMovieIndTrackType(QTC->m_theMovie, 1, VideoMediaType, movieTrackMediaType);	if (!myTypeTrack)		myTypeTrack = GetMovieIndTrackType(QTC->m_theMovie, 1, MPEGMediaType, movieTrackMediaType);	if (!myTypeTrack) return 1; // pas de piste dans ce movie			// backyup current position	currentTime=GetMovieTime (QTC->m_theMovie,&my_troriginal); // backup	// get the dimensions of the target track	GetTrackDimensions(myTypeTrack, &myWidth, &myHeight);	myTimeScale = GetMediaTimeScale(GetTrackMedia(myTypeTrack));	// Get the text track; remember to check that it's not nil.	myTextTrack = QTText_GetFirstTrackOfType(QTC->m_theMovie,TextMediaType);	if (!myTextTrack){ // n'existe pas, on cree		// on détermine la taille de la piste texte		// en fonction de la taille de la police de base		QTC->m_TextTrack =myTextTrack= NewMovieTrack(QTC->m_theMovie, myWidth, /*myHeight+*/FixRatio(43,1), 0/*kNoVolume*/);		myMedia = NewTrackMedia(myTextTrack, TextMediaType,600/*myTimeScale*/, NULL, 0);	}		/* else {		theErr = DeleteTrackSegment(myTextTrack,0,duration);		myMedia = GetTrackMedia (myTextTrack);		QTText_RemoveIndTextTrack(QTC->m_theMovie,0); // pb est ce necessaire ou y a t-il un bug?	}*/	// get the media handler	myHandler = GetMediaHandler(myMedia);		//	On positionne la piste texte	GetTrackMatrix(myTextTrack, &myMatrix);	l=myHeight+FixRatio(1, 1)/*-FixRatio(60, 1)*/;  //dans le movie//en dessous du movie 	TranslateMatrix(&myMatrix,0,l); 	SetTrackMatrix(myTextTrack,&myMatrix);		SetTrackEnabled(myTextTrack, true);		//on deplace le controleur de la taille de la piste en dessous du movie	MCGetControllerBoundsRect(QTC->m_theMC, &bounds);/*	//bounds.top=Fix2Long(l)+1; //?	bounds.bottom+=Fix2Long(l)+1; //bounds.top+QTUtils_GetControllerBarHeight(QTC->m_theMC); //?	MCSetControllerBoundsRect(QTC->m_theMC, &bounds);*/	//edition de la piste texte 	//mediaCurrentTime = TrackTimeToMediaTime(currentTime, myTextTrack); // time de la piste	// il faut faire un bout de code pour effacer que le segment nécessaire		GetPort(&oldport);	SetPort(QTC->m_windows);			myErr = BeginMediaEdits(myMedia);	if (myErr == noErr) 		QTText_TransfertListe2QTCaption (QTC,myTypeTrack,myMedia,myHandler,1, 65536,myWidth,myHeight,&mySampleTime); // on insert les sous-titres	EndMediaEdits(myMedia);	// insert the text media into the text track	myErr = InsertMediaIntoTrack(myTextTrack, 0, 0, GetMediaDuration(myMedia),fixed1);		// on ajuste la taille de l'écran	// et on force un rafraichissement	MCDoAction(QTC->m_theMC, mcActionMovieEdited, NULL);	MCMovieChanged(QTC->m_theMC,QTC->m_theMovie);	InvalRect(&((GrafPtr)QTC->m_windows)->portRect);	SetPort(oldport);	SetMovieTime( QTC->m_theMovie,&my_troriginal); // restore le time position	return 0;}short QT_UpdateOneCaption(CQuicktimeClass* QTC,long AbsStNum){TimeRecord		starttime,endtime,my_troriginal; SousTitreRecordPtr	ST_Ptr,ST_Ptr1;	long 				tcin,tcout,moviesegstart;Track			myTextTrack = NULL;Media			myMedia=nil;MediaHandler		myHandler = nil;Fixed			myWidth,myHeight;OSErr			myErr = noErr;GrafPtr			oldport;TimeValue			myMediaSampleDuration,myMovieTime,myMediaSampleStartTime;TimeValue			myMediaCurrentTime,myInterestingTime,myInterestingTime0,myDuration,mySampleTime;long				myMediaSampleIndex;	Rect myBounds;	char* 			texte="zzzzzz";	if (!QTC)			return -1;				// find the target track	myTextTrack = QTText_GetFirstTrackOfType(QTC->m_theMovie,TextMediaType);	myMedia=GetTrackMedia (myTextTrack);	myHandler=GetMediaHandler(myMedia);	if (!myTextTrack) { // pas de piste sous-titrage		//on créer le st tracks		QTText_SetTextTrack (QTC);		return 0;		}	// STEP 1 on enlève le segment qui nous intéresse, correspondant au st demandé	// le segment pars depuis le tcout du précédent, jusqu'au in du suivant.	// calcul des time des segment.	GetMovieTime( QTC->m_theMovie,&my_troriginal); // restore le time position	GetMovieTime(QTC->m_theMovie,&starttime);  // init des times	GetMovieTime(QTC->m_theMovie,&endtime); 	starttime.value.hi = 0;	starttime.value.lo = 0;	endtime.value.hi = 0;	endtime.value.lo = GetMovieDuration (QTC->m_theMovie);					// on calcule le in point	//	ST_Ptr=C_ConversionNumeroSTPointeur((long)AbsStNum); 	if (AbsStNum>1) {// start != premier st sinon start ==0		ST_Ptr1=ST_Ptr->st_PreviousST;				if(ST_Ptr1->st_TimeCodeOut !=-1) {			starttime.value.lo=TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(ST_Ptr1->st_TimeCodeOut,QTC->m_MovieOffset));		} else {			tcin=GetTcInForThis(ST_Ptr1);			if (tcin !=-1)				starttime.value.lo =TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tcin,QTC->m_MovieOffset));		}	}			// on calcule le out point		ST_Ptr1=ST_Ptr->st_NextST;	if (ST_Ptr1){			if(ST_Ptr1->st_TimeCodeIn !=-1) {				endtime.value.lo=TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(ST_Ptr1->st_TimeCodeIn,QTC->m_MovieOffset));			} else {				tcout=GetTcOutForThis(ST_Ptr1);				if (tcout !=-1)					endtime.value.lo =TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tcout,QTC->m_MovieOffset));			}	}	 	moviesegstart=starttime.value.lo;	//on convertie en time scale du text track		SetMovieTime( QTC->m_theMovie,&starttime); // restore le time position			ConvertTimeScale(&starttime, GetMediaTimeScale(myMedia));	ConvertTimeScale(&endtime, GetMediaTimeScale(myMedia));					// delete the existing text			/*		testing  testing testing testing testing testing testing testing testing testing testing 		*/	myMovieTime = GetMovieTime(QTC->m_theMovie, NULL);	myMediaCurrentTime = TrackTimeToMediaTime(myMovieTime, myTextTrack);		MediaTimeToSampleNum(	myMedia, 	myMediaCurrentTime, 								&myMediaSampleIndex, 								&myMediaSampleStartTime,								&myMediaSampleDuration);	// see where this text starts	GetTrackNextInterestingTime(myTextTrack, nextTimeEdgeOK | nextTimeMediaSample, myMovieTime, -fixed1, &myInterestingTime, NULL);			myMovieTime = myInterestingTime;						GetTrackNextInterestingTime(myTextTrack, nextTimeEdgeOK | nextTimeMediaSample, myInterestingTime, fixed1, &myInterestingTime, &myDuration);			/*		testing  testing testing testing testing testing testing testing testing testing testing 		*/				GetPort(&oldport);	SetPort(QTC->m_windows);	GetTrackDimensions(myTextTrack, &myWidth, &myHeight);		myErr = BeginMediaEdits(myMedia);	myErr = DeleteTrackSegment(myTextTrack, starttime.value.lo, endtime.value.lo-starttime.value.lo); 	if (myErr == noErr) 		 QTText_TransfertListe2QTCaption (QTC,myTextTrack,myMedia,myHandler,AbsStNum, AbsStNum,myWidth,myHeight,&mySampleTime); // on insert les sous-titres// write out the new data to the media		/*myBounds.top = 0;		myBounds.left = 0;		myBounds.right = Fix2Long(myWidth);		myBounds.bottom = Fix2Long(myHeight);			myErr = TextMediaAddTextSample(	myHandler, texte,6,										0,0,	0,NULL,NULL, 										teCenter,&myBounds,dfClipToTextBox, 										0, 0,	0, NULL, 										endtime.value.lo-starttime.value.lo, 										&mySampleTime);*/	// insert the text media into the text track	// myErr = InsertMediaIntoTrack(myTextTrack,starttime.value.lo, starttime.value.lo,endtime.value.lo-starttime.value.lo,fixed1);	myErr = InsertMediaIntoTrack(myTextTrack, myInterestingTime, mySampleTime, endtime.value.lo-starttime.value.lo, fixed1);	EndMediaEdits(myMedia);	// on ajuste la taille de l'écran	// et on force un rafraichissement	MCDoAction(QTC->m_theMC, mcActionMovieEdited, NULL);	MCMovieChanged(QTC->m_theMC,QTC->m_theMovie);	InvalRect(&((GrafPtr)QTC->m_windows)->portRect);	SetPort(oldport);	SetMovieTime( QTC->m_theMovie,&my_troriginal); // restore le time position}short QTText_TransfertListe2QTCaption (CQuicktimeClass* QTC,Track myTypeTrack,Media myMedia,MediaHandler  myHandler, long start, long end,long myWidth,long myHeight,TimeValue* sampleinsert){SousTitreRecordPtr	ST_Ptr,ST_Ptr1;	TEHandle			te;Rect				rect;TimeRecord		starttime,endtime; RGBColor			white={-1,-1,-1};		// le blancRGBColor			black={0,0,0};			// le fond noirRGBColor			simucolor={-1,-1,0};	// couleur du textePoint           		dropOffset;Handle			progression=nil;Str255			st0,st1;TextStyle			newStyle;long 				curtime=0;short           		trans = 255,err;short 			i=1,flag=0;short			num,done;		long 				max=1;long 				tcin,tcout,duration;long 				moviedur=0;char*			blanktext=" ";	//check input contre le 		if (!myHandler) return 0;	if (!QTC) return 0;		// on récupère le pointeur des sous-titres	ST_Ptr=C_ConversionNumeroSTPointeur((long)start);	ST_Ptr1=C_ConversionNumeroSTPointeur((long)end);		if (! ST_Ptr) return 0;	if (! ST_Ptr1) return 0;		//on regarde s'il faut mettre une reglette de progression	max=(ST_Ptr1->st_AbsNUMST-ST_Ptr->st_AbsNUMST)+1;				done=0;	if ( (end-start)>12){		GetIndString(&st0,129,36);			GetIndString(&st1,129,63);			progression=RPInitReglette((unsigned char*)&st0,(unsigned char*)&st1,0,max,true);		}		//intialisation de l'edit texte structure	// on ne gère pas pour l'instant le texte par dessus le film	// on défini le cadre de dessin du texte		//SetRect(&rect,0,Fix2Long(myHeight)+2,Fix2Long(myWidth),40+Fix2Long(myHeight)+2); 	SetRect(&rect,0,2,Fix2Long(myWidth),40+2); 	te=TEStyleNew(&rect,&rect); //attention probleme de SetPort	if (!te) return 0; // oups !!!					// attribut du texte pour Quicktime	dropOffset.h = dropOffset.v = 1;	TextMediaSetTextSampleData(myHandler,(void *)&dropOffset,dropShadowOffsetType);	TextMediaSetTextSampleData(myHandler,(void *)&trans,dropShadowTranslucencyType);				// on initialise les time rec  init the in et out variable	GetMovieTime(QTC->m_theMovie,&starttime); 	GetMovieTime(QTC->m_theMovie,&endtime); 	starttime.value.hi = 0;	starttime.value.lo = 0;		endtime.value.hi = 0;	endtime.value.lo = GetMovieDuration (QTC->m_theMovie);			// STEP 1 on place un st vide depuis le tcout précédent ou bien depuis le start time du movie				// on calcule le in point	//		if (start>1) {// start != premier st sinon start ==0		ST_Ptr1=ST_Ptr->st_PreviousST;				if(ST_Ptr1->st_TimeCodeOut !=-1) {			starttime.value.lo=TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(ST_Ptr1->st_TimeCodeOut,QTC->m_MovieOffset));		} else {			tcin=GetTcInForThis(ST_Ptr1);			if (tcin !=-1)				starttime.value.lo =TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tcin,QTC->m_MovieOffset));		}	}			// on calcule le out point		if(ST_Ptr->st_TimeCodeIn !=-1) {		endtime.value.lo=TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(ST_Ptr->st_TimeCodeIn,QTC->m_MovieOffset));	} else {		tcout=GetTcOutForThis(ST_Ptr);		if (tcout !=-1)				endtime.value.lo =TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tcout,QTC->m_MovieOffset));	}		//on insert le blank	ConvertTimeScale(&starttime, GetMediaTimeScale(myMedia));	ConvertTimeScale(&endtime, GetMediaTimeScale(myMedia));	duration=endtime.value.lo-starttime.value.lo;	if(duration>0)				err=TextMediaAddTextSample(myHandler,blanktext,1,										kFontIDHelvetica,12,0,&white,&black,										teCenter,&rect,dfAntiAlias|dfClipToTextBox,0,0,0,NULL,duration,sampleinsert);  		// STEP 2 on fait une boucle pour insérer le soustitre ou bien la liste de sous-titre	  	done=0; 	num=start; 		do{		// on se positionne sur le start ST					ST_Ptr=C_ConversionNumeroSTPointeur(num);		if (ST_Ptr){					// STEP 2-1 		// on ecrit le st sous-titre			// on initialise les time values			GetMovieTime(QTC->m_theMovie,&starttime); 			GetMovieTime(QTC->m_theMovie,&endtime); 					// on position le st au tc in, on tient compte de l'offset en cours			if(ST_Ptr->st_TimeCodeIn !=-1) {				tcin=C_SoustractionTimeCode(ST_Ptr->st_TimeCodeIn,QTC->m_MovieOffset);				starttime.value.lo=TimeCode_Converted_TimeCode_2_FrameCount(tcin);				ConvertTimeScale(&starttime, GetMediaTimeScale(myMedia));				}						// le tc out			endtime.value.lo=GetMovieDuration (QTC->m_theMovie); // par defaut (la fin du film						tcout=GetTcOutForThis(ST_Ptr);			if (tcout !=-1)				endtime.value.lo =TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tcout,QTC->m_MovieOffset));						// on caltcule la pt de sortie			ConvertTimeScale(&endtime, GetMediaTimeScale(myMedia)); // offset si  média base différente							duration=endtime.value.lo-starttime.value.lo;								// on fabrique le te 			// !!!!!!!!  prb de port de dessin			// cette fonction n'est peux être pas optimum ?						TRANSFERTTEXTE_MEMOIRE_STYLETE(te,ST_Ptr,&rect,-1);						TESetSelect(0,32767,te);			newStyle.tsColor=white;			newStyle.tsFont=kFontIDHelvetica;			newStyle.tsSize=14;			TESetStyle(doColor|doFont|doSize,&newStyle,false,te);						// on insert le texte			if(duration>0)				err=TextMediaAddTESample(myHandler,te, &black,	                               C_get_STJustification(ST_Ptr),&rect,dfAntiAlias|dfClipToTextBox/*dfKeyedText |dfKeyedText|dfClipToTextBox|dfAntiAlias|dfDropShadow|dfShrinkTextBoxToFit/|dfClipToTextBox*/,	                               0,0, 0,&black,duration,&starttime);					// STEP 2-2 		// on ajoute le spacer jusqu'au prochain time-code		//			flag=0;			// le in du prochain est le out actuel			starttime.value.lo=endtime.value.lo;			// on calcule le tc in suivant pour insérer un blank text			GetMovieTime(QTC->m_theMovie,&endtime);  //in initialise le timevalue			endtime.value.lo=GetMovieDuration (QTC->m_theMovie);				// on recherche le prochain point de sortie pour le blank			ST_Ptr1=ST_Ptr->st_NextST;						if (ST_Ptr1){				if(ST_Ptr1->st_TimeCodeIn !=-1) {					endtime.value.lo=TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(ST_Ptr1->st_TimeCodeIn,QTC->m_MovieOffset));				} else {					tcout=GetTcOutForThis(ST_Ptr1);					if (tcout !=-1)						endtime.value.lo =TimeCode_Converted_TimeCode_2_FrameCount(C_SoustractionTimeCode(tcout,QTC->m_MovieOffset));				}			} 						//on insert le blank			ConvertTimeScale(&endtime, GetMediaTimeScale(myMedia)); // conversion d'échelle						duration=endtime.value.lo-starttime.value.lo;						if(duration>0)				err=TextMediaAddTextSample(myHandler,blanktext,1,										kFontIDHelvetica,12,0,&white,&black,										teCenter,&rect,dfAntiAlias|dfClipToTextBox,0,0,0,NULL,duration,&starttime);				} // ST_PTR != 0				// fin de boucle		num++;				// reglette de progression		// on regarde s'il faut arrêter la boucle		if (progression){			if ( RPIsFrontProcess(progression) ) C_SpinCursor(32);			done=done|RPIdle(progression,num,&DoUpdate,true);			}					} while( num<= max &&!done);	// fin de routine	//  on dispose 		if (te)  TEDispose(te);	if (progression)				RPDispose(progression);	progression=0;	SetCursor(&QD.arrow);		return 0;	}	void QTText_UpdateMovieAndController (Movie theMovie, MovieController theMC){	Rect		myRect;	// we must make sure that we are still top-left aligned	GetMovieBox(theMovie, &myRect);	MacOffsetRect(&myRect, -myRect.left, -myRect.top);	SetMovieBox(theMovie, &myRect);	MCDoAction(theMC, mcActionMovieEdited, NULL);	MCMovieChanged(theMC, theMovie);}// permet de déterminer le 'interesting time' suivant dans le cas d'un sous-titrelong GetTcOutForThis(SousTitreRecordPtr ST_Ptr){long retval=-1;SousTitreRecordPtr 	 ST_Ptr1;short done;									//on determine le tc out du st			//cas normal on a un tc out			if (ST_Ptr->st_TimeCodeOut !=-1){				retval=ST_Ptr->st_TimeCodeOut;				return retval;			}								// ce n'est pas le cas il faut iterer dans la liste pour trouver un timecode			done=0;			ST_Ptr1=ST_Ptr; // ptr tmp							do{ // boucle pour trouver le prochain tc valide pour faire office de tc out				ST_Ptr1=ST_Ptr1->st_NextST;				if (ST_Ptr1){					if (ST_Ptr1->st_TimeCodeIn !=-1){						retval=ST_Ptr1->st_TimeCodeIn;						done=1;					} else if (ST_Ptr1->st_TimeCodeOut !=-1){						retval=ST_Ptr1->st_TimeCodeOut;						done=1;					} 				}				} while ( ST_Ptr1 && !done) ;				// pas trouvé que fait-on ?			// on pourrait prendre le tc end film ?									return retval;}// permet de déterminer le 'interesting time' précédent dans le cas d'un sous-titrelong GetTcInForThis(SousTitreRecordPtr ST_Ptr){long retval=-1;SousTitreRecordPtr 	 ST_Ptr1;short done;			//on determine le tc in du st			//cas normal on a un tc in						if (ST_Ptr->st_TimeCodeIn !=-1){				retval=ST_Ptr->st_TimeCodeIn;				return retval;			}								// ce n'est pas le cas il faut iterer dans la liste pour trouver un timecode			done=0;			ST_Ptr1=ST_Ptr; // ptr tmp							do{ // boucle pour trouver le prochain tc valide pour faire office de tc out				ST_Ptr1=ST_Ptr1->st_PreviousST;				if (ST_Ptr1){					if (ST_Ptr1->st_TimeCodeOut !=-1){						retval=ST_Ptr1->st_TimeCodeOut;						done=1;					} else if (ST_Ptr1->st_TimeCodeIn !=-1){						retval=ST_Ptr1->st_TimeCodeIn;						done=1;					} 				}				} while ( ST_Ptr1 && !done) ;						// pas trouvé que fait-on ?			// on pourrait prendre le tc start film ?						return retval;}short QTText_RemoveIndTextTrack (Movie theMovie, short theIndex){	Track				myTrack = NULL;	OSErr				myErr = noErr;		if (theIndex == kAllTextTracks) {		// remove ALL text tracks from the movie		myTrack = GetMovieIndTrackType(theMovie, 1, TextMediaType, movieTrackMediaType);		if (myTrack == NULL)			myErr = badTrackIndex;				while (myTrack != NULL) {			QTUtils_DeleteAllReferencesToTrack(myTrack);			DisposeMovieTrack(myTrack);			myTrack = GetMovieIndTrackType(theMovie, 1, TextMediaType, movieTrackMediaType);		}	} else {		// remove ONE text track from the movie		myTrack = GetMovieIndTrackType(theMovie, theIndex, TextMediaType, movieTrackMediaType);		if (myTrack == NULL) {			myErr = badTrackIndex;		} else {			QTUtils_DeleteAllReferencesToTrack(myTrack);			DisposeMovieTrack(myTrack);		}	}	return(myErr);}TrackQTText_GetFirstTrackOfType (Movie theMovie, OSType trackType){Track theTrack = nil;OSType mediaType;short trackCount, index;		trackCount = GetMovieTrackCount(theMovie);	for (index=1; index <= trackCount; index++) {		Track t = GetMovieIndTrack(theMovie, index);		GetMediaHandlerDescription(GetTrackMedia(t),&mediaType, nil, nil);		if (mediaType == trackType) {			theTrack = t;			break;			}	}	return theTrack;}