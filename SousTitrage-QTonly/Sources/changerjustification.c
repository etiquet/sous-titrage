#include "BB.Globals_C.h"#include <Devices.h>#include <StdArg.h>#include <stdio.h>#include  "PrivateDialogLibraries.h"// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;#define thisDialogID 229/* Symbolic Dialog Item Numbers */static enum {	BUT1_OK = 1,	BUT2_Cancel,	EDIT3,	EDIT4,	ICON5,	ICON6,	ICON7,	USER8,	USER9,	STXT10_Du,	STXT11_au,	USER12,	STXT13_Choisissez,	LASTITEM	} DialogItemNumber;#define OK_ITEM 	BUT1_OK#define CANCEL_ITEM 	BUT2_Cancel/* Useful constants */#ifndef ENTERkey#define ENTERkey	0x3#endif#ifndef DELETEkey#define DELETEkey	0x8#endif#ifndef NIL#define NIL ((void *)0)#endif#ifndef TRUE#define TRUE 1#endif#ifndef FALSE#define FALSE 0#endif#ifndef FRONT_WINDOW#define FRONT_WINDOW  ((WindowPtr) (-1L))#endif/* Prototypes */int       ChangeJustifListDlog(void);static DialogPtr OpenThisDialog(void);static void      CloseThisDialog(DialogPtr dlog);static void      DoDialogUpdate(DialogPtr dlog);static void      DoDialogActivate(DialogPtr dlog, int activ);static void      DoDialogContent(DialogPtr dlog, EventRecord *evt);static int       DoDialogItem(DialogPtr dlog, short itemHit);static pascal  Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit);static Boolean CheckUserItems(Point where, short *itemHit);static int     AnyBadValues(DialogPtr dlog);static pascal void _JustifButton(DialogPtr dlog);//external functionpascal void C_Hilite_icon_button(DialogPtr Dialog,short itemNumber);pascal void C_Unhilite_icon_button(DialogPtr Dialog,short itemNumber);pascal void DoUpdate(WindowPtr window);pascal void Draw_Icon_Text_Ditl(DialogPtr dialog);void DochangeJustifSurZone( long DebutZone,long FinZone,short justif);void MyUpdateDialog(DialogPtr dialog);static Point where;static int modifiers;static short  gJustification;/* *	Display this modal dialog.  Return TRUE if OK, FALSE if CANCEL or error. *	If the dialog displays values from outside this module, you should either *	import them from globals, or change the argument list of this routine to *	bring them in and pass them to OpenThisDialog(), DoDialogItem(), etc. */int ChangeJustifListDlog(){short itemHit,okay=FALSE,keepGoing=TRUE;DialogPtr dlog=NIL; GrafPtr oldPort;ModalFilterUPP MyFilterUPP;unsigned char str[256];long 	debut,fin;		GetPort(&oldPort);		/* On PowerPC, need a RoutineDescriptor from heap; on 68K, no allocation */				MyFilterUPP = NewModalFilterProc(MyFilter);		if (MyFilterUPP == NIL) goto cleanUp;		/* Build dialog window and install its item values */				dlog = OpenThisDialog();		if (dlog == NIL) goto cleanUp;		/* Entertain filtered user events until dialog is dismissed */				while (keepGoing) {			ModalDialog(MyFilterUPP,&itemHit);			keepGoing = DoDialogItem(dlog,itemHit);			}				/*		 *	Do final processing of item values, such as exporting them to caller.		 *	DoDialogItem() has already called AnyBadValues().		 */				okay = (itemHit == OK_ITEM);		if (okay) {		/* Or whatever is equivalent */// on récupère les infos			pdl_GetDlgString(dlog,EDIT3,&str);			debut=C_CHERCHESTPARnumero(&str);			pdl_GetDlgString(dlog,EDIT4,&str);			fin=C_CHERCHESTPARnumero(&str);				if (dlog) CloseThisDialog(dlog);			if (MyFilterUPP) DisposeRoutineDescriptor(MyFilterUPP);			SetPort(oldPort);			SetDialogFont(0);			 DochangeJustifSurZone(debut,fin,gJustification);			}else {cleanUp:					if (dlog) CloseThisDialog(dlog);			if (MyFilterUPP) DisposeRoutineDescriptor(MyFilterUPP);			SetPort(oldPort);			SetDialogFont(0);			}		/* That's all, folks! */		return(okay);	}/* *	We have to have a filter function, at the very least so that we can outline *	any default button, entertain keyboard editing commands, cmd-period canceling, etc. *	Note that you do not need to have a special user item covering the default button *	in your dialog item list. */static pascal Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit)	{		Boolean ans=FALSE,doHilite=FALSE; WindowPtr w;		short type,ch,part; Handle hndl; Rect box;		static long then; static Point clickPt;		WindowPtr	window;				w = (WindowPtr)(evt->message);		switch(evt->what) {			case updateEvt:				if (w == dlog) {					/* Update our dialog contents */					DoDialogUpdate(dlog);					ans = TRUE; *itemHit = 0;					}				 else {					DoUpdate(w);					/*					 *	Call your main event loop DoUpdate(w) routine here if you					 *	don't want unsightly holes in background windows caused					 *	by nested alerts, balloon help, or screen savers (see					 *	Tech Note #304).					 */					}				break;			case activateEvt:				if (w == dlog) {					DoDialogActivate(dlog,(evt->modifiers & activeFlag)!=0);					*itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoActivate(w) routine here if					 *	you want to deactivate the former frontmost window, in order					 *	to unhighlight any selection, scroll bars, etc.					 */					}				break;			case mouseDown:				where = evt->where;		/* Make info available to DoDialog() */				part = FindWindow(evt->where, &window);				if ( part==inDrag)               /* pass screenBits.bounds to get all gDevices */						if	(window==(WindowPtr)BB_FrontNonFloatingWindow()) {							 DragWindow(window, evt->where,&QD.screenBits.bounds);							*itemHit = 0;						 } 									case mouseUp:				where = evt->where;		/* Make info available to DoDialog() */				GlobalToLocal(&where);				modifiers = evt->modifiers;				ans = CheckUserItems(where,itemHit);				break;			case keyDown:				if ((ch=(unsigned char)evt->message)=='\r' || ch==ENTERkey) {					*itemHit = OK_ITEM /* Default Item Number here */;					doHilite = ans = TRUE;					}				 else if (evt->modifiers & cmdKey) {					ch = (unsigned char)evt->message;					switch(ch) {						case 'x':						case 'X':							if (pdl_TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DialogCut(dlog); TEToScrap(); }							 else {								/* Cut from anything else cuttable, like a list */								}							break;						case 'c':						case 'C':							if (pdl_TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DialogCopy(dlog); TEToScrap(); }							 else {								/* Copy from anything else copyable, like a list */								}							break;						case 'v':						case 'V':							if (pdl_CanPaste(1,'TEXT'))								{ TEFromScrap(); DialogPaste(dlog); }							 else {							 	/* Deal with any other pasteable scraps here */								}							break;						case 'a':						case 'A':							if (((DialogPeek)dlog)->editField >= 0) {								/* Dialog has text edit item: select all */								SelectDialogItemText(dlog,((DialogPeek)dlog)->editField+1,0,32767);								}							 else {								}							*itemHit = 0;							break;						case '.':							*itemHit = CANCEL_ITEM;							doHilite = TRUE;							break;						}					ans = TRUE;		/* Other cmd-chars ignored */					}				break;			}		if (doHilite) {			GetDialogItem(dlog,*itemHit,&type,&hndl,&box);			/* Reality check */			if (type == (btnCtrl+ctrlItem)) {				long soon = TickCount() + 7;		/* Or whatever feels right */				HiliteControl((ControlHandle)hndl,1);				while (TickCount() < soon) ;		/* Leave hilited for a bit */				}			}		return(ans);	}/* * Mouse down event: * Check if it's in some user item, and convert to itemHit if appropriate. */static Boolean CheckUserItems(Point where, short *itemHit)	{		return(FALSE);	}/* * Redraw the contents of this dialog due to update event. * If you have not installed UserItem draw routines, you should redraw * them explicitly here; otherwise, UpdateDialog() will call your routines. */static void DoDialogUpdate(DialogPtr dlog){GrafPtr oldPort;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;short type; Handle hndl; Rect box,rect;		GetPort(&oldPort); SetPort(dlog);		BeginUpdate(dlog);		//UpdateDialog(dlog,dlog->visRgn);		MyUpdateDialog(dlog);		_JustifButton(dlog);// on entoure la fenêtre d'une ppat		pixpat=GetPixPat(129);						if (pixpat!=nil){			rgn=NewRgn();			rgn1=NewRgn();			RectRgn(rgn,&dlog->portRect);			GetDialogItem(dlog,9,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDialogItem(dlog,1,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDialogItem(dlog,2,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			FillCRgn(rgn,pixpat);			DisposePixPat(pixpat);			DisposeRgn(rgn);			DisposeRgn(rgn1);		}		GetDialogItem(dlog,9,&type,&hndl,&box);		MakeReliefRectangle1(&box);		GetDialogItem(dlog,8,&type,&hndl,&box);		PenPat(&QD.gray);		FrameRect(&box);		GetDialogItem(dlog,12,&type,&hndl,&box);		FrameRect(&box);				PenNormal();				 pdl_FrameDefault( dlog,1, 1);		EndUpdate(dlog);		SetPort(oldPort);	}/* * Activate event: Activate or deactivate this dialog and any items in it */static void DoDialogActivate(DialogPtr dlog, int activ)	{		SetPort(dlog);	}/* * Build this dialog's window on desktop, and install initial item values. * Return the dlog opened, or NIL if error (no resource, no memory). */static DialogPtr OpenThisDialog()	{		GrafPtr oldPort;		DialogPtr dlog; unsigned char str[256];		GetPort(&oldPort);		dlog = GetNewDialog(thisDialogID,NIL,FRONT_WINDOW);		if (dlog == NIL) { SysBeep(1); return(NIL); }	/* Poor man's error message */		SetPort(dlog);		gJustification=0;		_JustifButton(dlog);		/* Fill in dialog's values here */		C_ConvertiNumST_String(G.General_SousTitreEncour,&str);		pdl_PutDlgString(dlog,EDIT3,(char *)&str,FALSE);		C_ConvertiNumST_String(G.General_DernierSTPtr->st_NumeroST,&str);		pdl_PutDlgString(dlog,EDIT4,(char *)&str,FALSE);		ShowWindow(dlog);		return(dlog);	}/* * Clean up any allocated stuff, and return dialog to primordial mists */static void CloseThisDialog(DialogPtr dlog)	{		if (dlog) {			DisposeDialog(dlog);	/* Call CloseDialog if you provide storage to GetNewDialog */		}	}/* * Deal with user clicking on an item in this dialog, either modal or non-modal. * The local point is in where; modifiers in modifiers. * Returns whether or not the dialog should be closed (keepGoing). */static int DoDialogItem(DialogPtr dlog, short itemHit)	{		short type,okay=FALSE,keepGoing=TRUE,val;		Handle hndl; Rect box; Point pt;		unsigned char *p,str[256];		if (itemHit<1 || itemHit>=LASTITEM)			return(keepGoing);				/* Only legal items, please */		GetDialogItem(dlog,itemHit,&type,&hndl,&box);		switch(type) {			case ctrlItem+btnCtrl:				switch(itemHit) {					case BUT1_OK:						keepGoing = FALSE; okay = TRUE;						break;					case BUT2_Cancel:						keepGoing = FALSE;						break;					}				break;			case ctrlItem+chkCtrl:				break;			case ctrlItem+radCtrl:				break;			case ctrlItem+resCtrl:				break;			case statText:				switch(itemHit) {					case STXT10_Du:		/* NOT Enabled */						break;					case STXT11_au:		/* NOT Enabled */						break;					case STXT13_Choisissez:		/* NOT Enabled */						break;					}				break;			case editText:				switch(itemHit) {					case EDIT3:						break;					case EDIT4:						break;					}				break;			case iconItem:				switch(itemHit) {					case ICON5:					case ICON6:					case ICON7:					//on gère l'effect des boutons						//C_Unhilite_icon_button(dlog,ICON10);						//C_Unhilite_icon_button(dlog,ICON11);						//C_Unhilite_icon_button(dlog,ICON12);												C_Hilite_icon_button(dlog,itemHit);						switch(itemHit){								case ICON5:									gJustification=1;								break;								case ICON6:									gJustification=0;								break;								case ICON7:									gJustification=2;								break;						}												while (Button() ){};						C_Unhilite_icon_button(dlog,itemHit);						_JustifButton(dlog);						break;					}				break;			case picItem:				break;			case userItem:				switch(itemHit) {					case USER8:		/* NOT Enabled */						break;					case USER9:						break;					case USER12:						break;					}				break;			}		if (okay) keepGoing = AnyBadValues(dlog);		return(keepGoing);	}/* * Pull values out of dialog items and deliver TRUE if any of them are * illegal or inconsistent; otherwise deliver FALSE.  If any values are bad, * you should inform your user about the problem here before delivering TRUE. * If any items are missing values, this is the place to assign any defaults. */static int AnyBadValues(DialogPtr dlog)	{		unsigned char str[256]; short val,len;		if (pdl_GetDlgString(dlog,EDIT3,str)) {			/* Got a string (can also call pdl_GetDlgWord(), etc. here) */			}		else {			/* Field was empty */			}		if (pdl_GetDlgString(dlog,EDIT4,str)) {			}		else {			}		return(FALSE);	}static pascal void _JustifButton(DialogPtr dlog){short ciconid,itemtype;CIconHandle	icon;DialogPtr	w=dlog;Rect	rect;Handle	item;SousTitreRecordPtr	ST_Ptr;GrafPtr oldPort;		GetPort(&oldPort);		SetPort(w);	if (gJustification==1){		ciconid=244+2;	} else {		ciconid=244;	}		icon=GetCIcon(ciconid);		GetDialogItem(w,ICON5,&itemtype,&item,&rect);		if (icon) PlotCIcon(&rect,icon);		/* justification centrée */	if (gJustification==0){		ciconid=248+2;	} else {		ciconid=248;	}		icon=GetCIcon(ciconid);		GetDialogItem(w,ICON6,&itemtype,&item,&rect);		if (icon) PlotCIcon(&rect,icon);/* just right */		if (gJustification==2){		ciconid=252+2;	} else {		ciconid=252;	}		icon=GetCIcon(ciconid);		GetDialogItem(w,ICON7,&itemtype,&item,&rect);		if (icon) PlotCIcon(&rect,icon);			SetPort(oldPort);} //_JustifButton						