#include "BB.Globals_C.h"#include <Devices.h>#include "GiveFontInfo.h"// les globalsextern MyQDGlobals QD;extern AppGlobals G;pascal short 	GiveDisplayFont_CharInfoWidth(FontRenderRecordPtr theFontrecord:__A0,short car:__D0,short style:__D1):__D0;extern pascal Ptr	 GIVEDISPLAYFONT_CHARINFO(FontRenderRecordPtr theFontrecord:__A0,short car:__D0,short style:__D1):__A0;pascal void 	ImportationFichierAscii(ParmBlkPtr pb,short errLecture,Ptr BufferTransfert,long SIZEBufferTransfert,					long charlu,FSSpec* fss,long longueurfichier);pascal void 	ReadBonBougreFormat(ParmBlkPtr pb,char* name,long longueurfichier);pascal void 	C_ReadBonBougreFormat(short refNum,Str31 Filename,Boolean Concatene);void 			ConcatenerFichier(void);void 			FermeLEsTE(void);pascal void 	C_WriteBonBougreFormat(short refNum,Str31 Filename,Boolean saveauto);short 			QT_UpdateQTList(void);void C_SaveData(short saveautoflag){FSSpec			FilePtBack;Boolean			wasChanged,asknewname=true,RevertCreated=false;Str255			prompt;StandardFileReply  reply;OSErr			err;short			MainFRefNum,BackFRefNum,theVolume;ParamBlockRec	pb;		/* 	On commence par fermer les TE ouverts	(Comme cela on est sûr de tout sauvegarder)*/				FermeLEsTE();		DoUpdate((WindowPtr)&G.ListingWindow);			// on regarde s'il y a déja un nom et des parramètres pour stocker le fichier	// si oui on sauvegarde directement/*on teste le file type  	si NIL ou ≠ 'Bbof' => on demande un nom pour le saveData en Bbof	si = 'Bbof' => sauvegarde avec les parramètres en mémoire	 on recopie les paramètres en mémoire dans le paramBlock   on effectue une recherche par le alias manager du fichier en cour*/					if( (G.CurrentFileType=='Bbof') && (G.aliashandle)  ){		if (ResolveAlias(nil,G.aliashandle,&reply.sfFile,&wasChanged)) {				/* il ya une erreur pour l'alias				on demande le chemin pour le fichier*/ 				 AlertUser(10);			 saveautoflag=1;		} else asknewname=false;	}else asknewname=true; //(G.CurrentFileType=='Bbof')// on regarde si c'est une sauvegarde automatique// si non on demande à l'utilisateur son choix pour "sauvegarder" le nom du fichier	if (saveautoflag==true)		if(!G.aliashandle){				 Alert(155,(ModalFilterProcPtr)nil);				 saveautoflag=1;				}			if (asknewname){		if (saveautoflag==2)  GetIndString(&prompt,129,35); //on demande save as..		else				  GetIndString(&prompt,129,34);		StandardPutFile(&prompt,&G.Preference_TitreOriginal,&reply);		if(!reply.sfGood ) return;// cancel		if(!reply.sfReplacing ){	// création nouveau fichier			if (reply.sfFile.name[0]>31){	// longueur du nom					reply.sfFile.name[0]=31;					}				err=FSpCreate(&reply.sfFile,'Bbou','Bbof',reply.sfScript);				if (err) { 					AlertUser(23);					G.CurrentFileType=0;					return;					}				else G.CurrentFileType='Bbof';			}		}/* maintenant le fichier éxiste 		  on recopie les variables en mémoire	*/		G.CurrentFileType='Bbof';		// on dit que c'est un fichier bon bougre		BlockMove((Ptr)&reply.sfFile.name,(Ptr)&G.CurrentFileName,31);		// on regarde s'il faut disposer l'alias		if(G.aliashandle) {			DisposeHandle((Handle)G.aliashandle);			G.aliashandle=nil;		}// on créer un alias manager pour le fichier en cour		err=NewAlias(nil,&reply.sfFile,&G.aliashandle);		if (err) AlertUser(9);//  on ouvre le fichier		err=FSpOpenDF(&reply.sfFile,fsRdWrPerm,&MainFRefNum);	/* 	OK FICHIER OUVERT , nous pouvons écrire dans le fichier	 	routine d'écriture du fichier bon bougre		on teste s'il y a un te ouvert*/		RevertCreated=false;/* on regarde s'il y un fichier .bak  	on recopie les paramètres du fichier principal*/		BlockMove(&reply.sfFile,&FilePtBack,sizeof(FSSpec));// on ajoute le nom .back au fichier		if(FilePtBack.name[0]>27) FilePtBack.name[0]=27;//	on place le .bak			FilePtBack.name[ (FilePtBack.name[0]) +1]='.';		FilePtBack.name[ (FilePtBack.name[0]) +2]='b';		FilePtBack.name[ (FilePtBack.name[0]) +3]='a';		FilePtBack.name[ (FilePtBack.name[0]) +4]='k';		FilePtBack.name[0]+=4;		// on regarde si le fichier existe		//  on essaye d'ouvrir le fichier .bak		err=FSpOpenDF(&FilePtBack,fsRdWrPerm,&BackFRefNum);			if (err) {		// le fichier.bak n'existe pas on le créer sur le disque dur			err=FSpCreate(&FilePtBack,'Bbou','Bbof',-1);			if (err) AlertUser(25); else {				err=FSpOpenDF(&FilePtBack,fsRdWrPerm,&BackFRefNum);					RevertCreated=true;				}		}		/* on sauvegarde le film dans le fichier .bak	on créer un param block */		GetVRefNum(BackFRefNum,&pb.ioParam.ioVRefNum);		theVolume=pb.ioParam.ioVRefNum;		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioResult=0;		pb.ioParam.ioRefNum=BackFRefNum;		pb.ioParam.ioBuffer=0;		pb.ioParam.ioReqCount=0;		pb.ioParam.ioActCount=0;		pb.ioParam.ioPosMode=fsFromStart;		pb.ioParam.ioPosOffset=0;		//WriteBonBougreFormat((ParmBlkPtr)&pb,(char*)&reply.sfFile.name,saveautoflag);		C_WriteBonBougreFormat(BackFRefNum,(char*)&reply.sfFile.name,saveautoflag);		G.ChangeSinceLastSave=0;		// on raz le flag pour dire saveData		PBFlushFile((ParmBlkPtr)&pb,false);		FSClose(BackFRefNum);/* on regarde s'il faut sauvegarder dans le fichier .bak première sauvegarde du fichier ou revert absent) */		if (RevertCreated) {			GetVRefNum(MainFRefNum,&pb.ioParam.ioVRefNum);			pb.ioParam.ioCompletion=(IOCompletionUPP)nil;			pb.ioParam.ioResult=0;			pb.ioParam.ioRefNum=MainFRefNum;			pb.ioParam.ioBuffer=0;			pb.ioParam.ioReqCount=0;			pb.ioParam.ioActCount=0;			pb.ioParam.ioPosMode=fsFromStart;			pb.ioParam.ioPosOffset=0;			//WriteBonBougreFormat((ParmBlkPtr)&pb,(char*)&FilePtBack.name,saveautoflag);			C_WriteBonBougreFormat(MainFRefNum,(char*)&reply.sfFile.name,saveautoflag);			PBFlushFile((ParmBlkPtr)&pb,false);			FSClose(MainFRefNum);	} else FSClose(MainFRefNum);		// on raz le chien de garde pour sauvegarde automatique		G.WatchDogSave=TickCount();				// on échange les fichiers  nom et nom.revert		FSpExchangeFiles(&reply.sfFile,&FilePtBack);		// on flush le volume		pb.ioParam.ioVRefNum=theVolume;		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioNamePtr=(StringPtr)nil;		pb.ioParam.ioResult=0;		PBFlushVol((ParmBlkPtr)&pb,false);						//  on invalide le port rect de la fenètre listing		UpdateSaisie();				DrawListingWindow();		SetCursor(&QD.arrow);// si carte affichage on indique qu'il faut attendre la sauvegarde					CompactMem(4194304);	// on réorganise la mémoire// on met à jour QT				QT_UpdateQTList();}/* routine de lecture de fichier */pascal void C_DoFileOpen(FSSpecPtr fss){StandardFileReply  reply;unsigned long		TypeList[5];short				MainFRefNum;long				eof;OSErr				err;ParamBlockRec		pb;FInfo				fndrInfo;//  on regarde si on nous demande d'ouvrir un fichier en particulier	if (!fss) {		/* on demande so avis à l'utilisateur */		TypeList[0]='TEXT';		TypeList[1]='Bbdf';		TypeList[2]='Bbof';		StandardGetFile(nil,3,(long*)&TypeList[0],&reply);		if (!reply.sfGood) return;	// on ne fait rien (cancel)	}	else  {			BlockMove((Ptr)fss,(Ptr)&reply.sfFile,sizeof(FSSpec)); /* on recopie le fss*/			FSpGetFInfo(fss,&fndrInfo);			reply.sfType=fndrInfo.fdType;			}						/* on regarde si l'on ouvre un Bbdf (format des polices d'affichages ) 	si oui on ne n'update pas la globale type film 	sinon bug on redemmande un nom pour sauvegarde*/				if (reply.sfType != 'Bbdf') G.CurrentFileType=reply.sfType;		err=FSpOpenDF(&reply.sfFile,fsRdWrPerm,&MainFRefNum);			if (err) {				AlertUser(26);				return;		}		// on effectue un aiguillage en fct de type de fichier	switch (reply.sfType){		case 'Bbdf':		/* récupération d'une police d'affichage*/		//!!!!! faire alerte pas ouverture fichier bbdf		break;	/* fichier de type texte */			case 'TEXT':			G.ChangeSinceLastSave=true; 		// on set le flag pour dire faire saveData						//   on passe les paramètres  du fichier dans un ParamBlock	 		GetEOF(MainFRefNum,&eof);			GetVRefNum(MainFRefNum,&pb.ioParam.ioVRefNum);			pb.ioParam.ioCompletion=(IOCompletionUPP)nil;			pb.ioParam.ioResult=0;			pb.ioParam.ioRefNum=MainFRefNum;			pb.ioParam.ioBuffer=G.BufferTransfert;			pb.ioParam.ioReqCount=G.SIZEBufferTransfert;			pb.ioParam.ioActCount=0;			pb.ioParam.ioPosMode=fsFromStart;			pb.ioParam.ioPosOffset=0;			err=PBRead(&pb,false);	// on utilise pbread car on a beasoin de ioactcount							ImportationFichierAscii(&pb,err,G.BufferTransfert,G.SIZEBufferTransfert,						pb.ioParam.ioActCount,&reply.sfFile,eof);				/*pascal void ImportationFichierAscii((ParmBlkPtr)  pb,short errLecture,Ptr BufferTransfert,long SIZEBufferTransfert,						short charlu,char* name,long longueurfichier);*/				/* s'il y a un alias on le dispose pour ne pas écraser le dernier film */				if (G.aliashandle) DisposeHandle((Handle) G.aliashandle);			G.aliashandle=nil;			G.CurrentFileType=nil;		//plus de fichier pour sauvegarde auto			G.General_SousTitreEncour=1;			FSClose(MainFRefNum);		break;						/* lecture du fichier 'Bbof'  format maison*/		case 'Bbof':				C_ReadBonBougreFormat(MainFRefNum,&reply.sfFile.name,false);						if (G.aliashandle) DisposeHandle((Handle) G.aliashandle);			G.aliashandle=nil;			G.General_SousTitreEncour=1;			G.CurrentFileType='Bbof'; 		// le fichier est du type bon bougre // on créer un alias pour le fichier en cour			if (NewAlias(nil,&reply.sfFile,&G.aliashandle))	AlertUser(9);// on place les coordonées du film ouvert			MakeCurentFileAliasInPref(G.aliashandle);// on raz le chien de garde pour sauvegarde automatique			G.WatchDogSave=TickCount();			G.ChangeSinceLastSave=0;			// on regarde s'il faut vérifier le fichier (valeur par défault)			if (G.AutoOpenCheckList) VerifListWithDefaultValue();// on regarde s'il y a un texte dans le block note ou une police d'affichage			if (G.BlockNote_texte[0] && G.AutoOpenBlockNote){					ShowReferencedWindow((WindowReference)G.BlockNoteWindow);					SelectReferencedWindow((WindowReference)G.BlockNoteWindow);			}						FSClose(MainFRefNum);			break;					}// switch				//on actualise le premier et le dernier Ptr		UpdateGeneralValue();		// on raz les caches d'affichages		G.Sous_titre_dessined=nil;		G.General_DernierNumConvertiPtr=nil;		G.Sous_titreInOffscreen=nil;			//  on redessine les fenêtres		UpdateSaisie();				DrawListingWindow();		SetCursor(&QD.arrow);	}/* Cette routine permet de concaténer un autre fichier au format Bbof*/void ConcatenerFichier(void){StandardFileReply  reply;unsigned long		TypeList[5];short				MainFRefNum;long				eof,L,a;Handle				H;Ptr					P;PlaneInfoPtr		Pip;OSErr				err;ParamBlockRec		pb;FInfo				fndrInfo;//  on regarde si on nous demande d'ouvrir un fichier en particulier	TypeList[0]='Bbof';	StandardGetFile(nil,1,(long*)&TypeList[0],&reply);	if (!reply.sfGood) return;	// on ne fait rien (cancel)			err=FSpOpenDF(&reply.sfFile,fsRdWrPerm,&MainFRefNum);			if (err) {				AlertUser(26);				return;		}				/* on lit le fichier, en le plaçant à la suite du fichier en cours */				C_ReadBonBougreFormat(MainFRefNum,&reply.sfFile.name,true);// on positionne le chien de garde pour sauvegarde automatique		G.ChangeSinceLastSave=true;// on regarde s'il faut vérifier le fichier (valeur par défault)		if (G.AutoOpenCheckList) VerifListWithDefaultValue();		FSClose(MainFRefNum);//on actualise le premier et le dernier Ptr		UpdateGeneralValue();		// on raz les caches  		G.Sous_titre_dessined=nil;		G.General_DernierNumConvertiPtr=nil;		G.Sous_titreInOffscreen=nil;			//  on redessine les fenêtres		UpdateSaisie();				DrawListingWindow();		SetCursor(&QD.arrow);	}