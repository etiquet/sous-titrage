* ************************************************* *                                              ** * 		    Bon BOUGRE     					 ** *          Listing principal					 ** *												 ** ************************************************; ????	DebugStr "Turn Discipline ON; DSCA ON; G"* =========================================* -------------- INCLUDES  ----------------* =========================================	PRINT	PUSH,OFF			 	INCLUDE	'NewVista.a'	; pour la nu vista+	INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	include	'PickerEqu.a'	INCLUDE	'PrEqu.a'	INCLUDE	'PrintTrapsEqu.a'	; pour utiliser le printing manager	INCLUDE	'TimeEqu.a'		; pour utiliser le time manager	INCLUDE	'VXEqu.a'	INCLUDE	'VXHWEqu.a'	INCLUDE	'SlotEqu.a'		; pour le slot manager	PRINT	POP			* ================================================* ---------  DATA STORAGE IMPORTATION ------------* ================================================		IMPORT	G:AppGlobals		IMPORT	QD:MYQDGLOBALS;		SEG	'Main'			; case sensitive; cette routine permet de tester la validitée des import de reférence entre routine MPW_asm et Metrowerk_CTestAdresseGlobales 	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointstructure		ds.l	1					; adresse du rectangle pour retourParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR								WITH	StackFrame,Rect		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				move.l	structure(a6),a0				lea		QD.dkGray,a1				move.l	a1,(a0)				lea		G.spareForFutur,a1				move.l	a1,4(a0)						UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)				DbgInfo.new	TestAdresseGlobales			; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE DoActivate(window: WindowPtr; becomingActive: BOOLEAN);* ================================================* In this sample there is no other processing necessary other than what* the Window Manager has already done for us.  This would be the place to* perform an activate on TextEdit records, controls, lists, update GrowIcon, etc.DOACTIVATE	PROC EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointWindowPtr	DS.L	1			; passed parameter of the window pointerActive		DS.W	1			; modifiers from the event recordParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkitemRect	ds		RectLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow 		IMPORT	UpdateControlsDansLaFenetre		WITH	StackFrame		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		IMPORT	qd:MYQDGLOBALS; erreur window		move.l	G.ErrorsWindow,a0		cmpa.l	WindowPtr(a6),a0		bne		paserrorwindow				move.l	G.ErrorsWindow,-(sp)		move.w	Active(A6),-(sp)		import	ActivateErrorWindow		jsr		ActivateErrorWindow		bra		exitpaserrorwindow		move.w	Active(A6),d0	; was it an Activate?		Beq		DeActivate		; no, perform a Deactivate		* do the activate event processing here, then "BRA.S   exit"			lea		G.ListingWindow,a0		cmpa.l	WindowPtr(a6),a0		beq		doListingactivate				 		lea		G.DialogSaisie,a0 		cmpa.l	WindowPtr(a6),a0 		beq		DialogSaisieActivate		bra	exit; ----		DialogSaisieActivate		pea		G.DialogSaisie		_SetPort		move.l	G.saisieTE,a0		cmp.l	#0,a0		beq		exit	; pas de te ouvert		move.l	G.saisieTE,a0		move.l	(a0),a0		lea		teViewRect(a0),a0				move.l	(a0),itemRect(a6)		move.l	4(a0),4+itemRect(a6)						add.w	#1,bottom+itemRect(a6)		add.w	#1,right+itemRect(a6)		sub.w	#1,top+itemRect(a6)		sub.w	#1,left+itemRect(a6)					lea.l	G.DialogSaisie,a0		MOVE.L	clipRgn(a0),-(SP)		pea 	itemRect(a6)				; rectangle	on masque le reste		_RectRgn				pea 	itemRect(a6)		_EraseRect				sub.w	#1,bottom+itemRect(a6)		sub.w	#1,right+itemRect(a6)		add.w	#1,top+itemRect(a6)		add.w	#1,left+itemRect(a6)					move.l	G.saisieTE,-(sp)		_TEActivate				move.l	G.saisieTE,a0		move.l	(a0),a0		pea		teViewRect(a0)		move.l	G.saisieTE,-(sp)		_TEUpdate				add.w	#1,bottom+itemRect(a6)		add.w	#1,right+itemRect(a6)		sub.w	#1,top+itemRect(a6)		sub.w	#1,left+itemRect(a6)					_PenNormal				pea 	itemRect(a6)		_FrameRect				bra	exit; -----doListingactivate		move.w	#$0101,-(sp)		import	DoActivateListingWindow		jsr		DoActivateListingWindow		bra 	exit		; ---------------------		DeActivate					; do the deactivate event		* do the deactivate event processing here, then fall through to exit			; on verifie s'i la fenètre contient des controls; seulement	window 2 en possède (pour l'instant)				lea		G.ListingWindow,a0		cmpa.l	WindowPtr(a6),a0		beq		ListingDesactivate				;		move.l	G.TelecommandeWindow,a0;		cmpa.l	WindowPtr(a6),a0;		beq		TelecommandeWindowDesActivate		  		lea		G.DialogSaisie,a0 		cmpa.l	WindowPtr(a6),a0 		beq		DialogSaisieDesActivate				bra	exit;------		DialogSaisieDesActivate		pea		G.DialogSaisie		_SetPort				move.l	G.saisieTE,a0		cmp.l	#0,a0		beq		exit	; pas de te ouvert		move.l	G.saisieTE,a0		move.l	(a0),a0		lea		teViewRect(a0),a0				move.l	(a0),itemRect(a6)		move.l	4(a0),4+itemRect(a6)				move.l	G.saisieTE,-(sp)		_TEDeactivate				add.w	#1,bottom+itemRect(a6)		add.w	#1,right+itemRect(a6)		sub.w	#1,top+itemRect(a6)		sub.w	#1,left+itemRect(a6)					lea.l	G.DialogSaisie,a0		MOVE.L	clipRgn(a0),-(SP)		pea 	itemRect(a6)				; rectangle	on masque le reste		_RectRgn				pea 	itemRect(a6)		_EraseRect				sub.w	#1,bottom+itemRect(a6)		sub.w	#1,right+itemRect(a6)		add.w	#1,top+itemRect(a6)		add.w	#1,left+itemRect(a6)					move.l	G.saisieTE,a0		move.l	(a0),a0		pea		teViewRect(a0)		move.l	G.saisieTE,-(sp)		_TEUpdate				add.w	#1,bottom+itemRect(a6)		add.w	#1,right+itemRect(a6)		sub.w	#1,top+itemRect(a6)		sub.w	#1,left+itemRect(a6)					Pea		qd.dkGray		_PenPat				pea 	itemRect(a6)		_FrameRect		_PenNormal		bra	exit;  ------		ListingDesactivate		move.w	#0,-(sp)		import	DoActivateListingWindow		jsr		DoActivateListingWindow				exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	Activate		; this name will appear in the debugger		align 4			ENDP			* ======================================================================*	Fonction	SpecialModalDialogFilter();* ======================================================================**SpecialModalDialogFilter		PROC	EXPORT*	*		MyFilter (theDialog:  DialogPtr; VAR theEvent:  EventRecord;*                   VAR itemHit:  INTEGER) :  BOOLEAN;StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordresult			ds.w	1ParamBegin		EQU	*						; start parameters after this pointThe_Dialog		ds.l	1The_Event		ds.l	1The_item		ds.l	1ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkItemType			ds.w	1		; stockage du type de ItemItemHandle			ds.L	1		; stockage	du handle du itemitemRect			ds		Rect	; rectanglerectangle		ds	RectThe_Where		ds.l	1pictHandle		ds.l	1WindowPtr		ds.l	1LocalSize		EQU 	*					; size of all the local variables				ENDR						IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,AdjustCursor,GetGlobalMouse		WITH	StackFrame,SOUSTITRERECORD,AppGlobals			; cover our local stack frame		IMPORT	qd:MYQDGLOBALS		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(SP)				move.w	#false,result(a6)		GotEvent			; ¢a y est nous avons un événement		; move window	?		move.l	The_Event(a6),a0		MOVE.W	evtNum(A0),D0				; get the event number		cmp.w	#1,d0					; Mouse down ?		beq 	Move_Window		cmp.w	#6,d0					; Update 		beq		Update		cmp.w	#3,d0					; key down		beq		KeyDown		cmp.w	#5,d0					; repeatkey down		beq		KeyDown		bra		exit; -------KeyDown		move.l	The_Event(a6),a0		MOVE.l	evtMessage(A0),D0				; get the event number		and.l	#$ff,d0		case#.w	(d0,if),\		(13,Enter_1),\		(3,Enter_1),\		('',ANNULER)						move.l	The_Event(a6),a0		MOVE.w	evtMeta(a0),d0		; option key down ?		btst.l	#11,d0		beq		exit				; non; oui pseudo move window 				move.l	The_Event(a6),a0		MOVE.l	evtMessage(A0),d0		and.l	#$ff,d0		case#.w	(d0,if),\		(30,up_1),\		(31,down_1),\		(28,left_1),\		(29,right_1)		bra		exit	; on reboucle; ---------------------------------------------ANNULER		move.l	The_item(a6),a0		move.w	#2,(a0)				clr.l	-(sp)				import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.w	#2,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDitem		; on regarde si le 2 ème item est un bouton si oui on peut l'activé par ESC				CMP.W	# ctrlItem+btnCtrl,ItemType(a6)		bne 	exit						move.l	ItemHandle(a6),-(sp)		move.w	#2,-(sp)		_HiliteControl				move.l	#4,-(sp)		import	WaitTicks		jsr		WaitTicks				move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl				move.w	#true,result(a6)				bra		exit	; on reboucle; -----------------------------------------		Enter_1			move.l	The_item(a6),a0		move.w	#1,(a0)				clr.l	-(sp)				import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDitem				move.l	ItemHandle(a6),-(sp)		move.w	#1,-(sp)		_HiliteControl				move.l	#4,-(sp)		import	WaitTicks		jsr		WaitTicks				move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl				move.w	#true,result(a6)				bra		exit	; on reboucle; up_1		clr.l	-(sp)				import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portRect(a4),rectangle(a6)		move.l	4+portRect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal				sub.w	#1,top+rectangle(a6)				move.l	The_Event(a6),a0		MOVE.w	evtMeta(A0),d0		btst.l	#9,d0		beq.S	up_1_1		sub.w	#20,top+rectangle(a6)up_1_1							move.l	a4,-(sp)		move.w	left+rectangle(a6),-(sp)		move.w	top+rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow				move.w	#true,result(a6)		bra		exit	; on sort; -------down_1		clr.l	-(sp)				import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portRect(a4),rectangle(a6)		move.l	4+portRect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal				add.w	#1,top+rectangle(a6)				move.l	The_Event(a6),a0		MOVE.w	evtMeta(A0),d0		btst.l	#9,d0		beq.S	down_1_1		add.w	#20,top+rectangle(a6)down_1_1				move.l	a4,-(sp)		move.w	left+rectangle(a6),-(sp)		move.w	top+rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		move.w	#true,result(a6)		bra		exit	; on sort; -------left_1		clr.l	-(sp)				import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portRect(a4),rectangle(a6)		move.l	4+portRect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal		sub.w	#1,left+rectangle(a6)				move.l	The_Event(a6),a0		move.w	evtMeta(A0),d0		btst.l	#9,d0				beq.S	left_1_1		sub.w	#20,left+rectangle(a6)left_1_1			move.l	a4,-(sp)		move.w	left+rectangle(a6),-(sp)		move.w	top+rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		move.w	#true,result(a6)		bra		exit	; on sort; -------right_1				clr.l	-(sp)				import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.l	(sp)+,a4		move.l	portRect(a4),rectangle(a6)		move.l	4+portRect(a4),4+rectangle(a6)		move.l	a4,-(sp)		_SetPort		pea		rectangle(a6)		_LocalToGlobal				add.w	#1,left+rectangle(a6)				move.l	The_Event(a6),a0		MOVE.w	evtMeta(A0),d0		btst.l	#9,d0				beq.S	right_1_1		add.w	#20,left+rectangle(a6)right_1_1		move.l	a4,-(sp)		move.w	left+rectangle(a6),-(sp)		move.w	top+rectangle(a6),-(sp)		move.w	#true,-(sp)		_MoveWindow		move.w	#true,result(a6)		bra		exit	; on sort; -------		; peut ètre un update window pour les autre fenètresUpdate				move.l	The_Dialog(A6),d0		move.l	The_Event(a6),a0		cmp.l	evtMessage(a0),d0		bne		pasfenetreencour		; 	on rafraichi le dialog (nous même); comme cela nous permet de passer le signal de refresh pour la code géra, le dialog		move.l	The_Event(a6),a0				clr.w	-(sp)		move.l	The_Event(a6),-(sp)		_IsDialogEvent		move.w	(sp)+,d0		beq		genereUpate		; bizarre, cela ne devrais pas		clr.w	-(sp)		move.l	The_Event(a6),-(sp)		pea 	The_Dialog(a6)		move.l	The_item(a6),-(sp)		_DialogSelect		move.w	(sp)+,d0	; le resultat on s'en foutgenereUpate; on met #-1 au retour pour indiquer qu'il faut updater la fenètre				move.L	The_item(a6),a0		move.w	#-1,(a0); on laisse false pour que le dialog soit redessiné					move.w	#true,result(a6)				bra		exit			; pour le dialog en courpasfenetreencour		; oui pour les autres fenètres du programme				MOVE.L	evtMessage(a0),-(SP)	; pass the window pointer		import	DoUpdate				; do the update		jsr		DoUpdate				; do the update		move.w	#true,result(a6)		bra		exit		; --------------------------------------------------------------------------------		;  mouse window ?Move_Window		CLR.W	-(SP)								move.l	The_Event(a6),a0		MOVE.l	evtMouse(A0),-(sp)		; the mouse point		PEA		WindowPtr(A6)				; a local variable		_FindWindow							; put the result in a register		MOVE.W	(SP)+,D7				cmp.w	#inDrag,d7	; in drag region ?		bne		exit		; no				move.l	WindowPtr(A6),d0		cmp.l	The_Dialog(A6),d0	; Le dialog en cour ?		bne.s	exit				; non on reboucle		MoveWindow_1; pass Window Pointer				move.l	WindowPtr(A6),-(sp)		move.l	The_Event(a6),a0		MOVE.l	evtMouse(A0),-(sp)		; Mouse coordinates and boundary		PEA		qd.ScreenBits.bounds			import	DragReferencedWindow		import	DragReferencedWindow		move.w	#true,result(a6)exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New			SpecialModalDialogFilter 		endp	; donne le qd.ScreenBits.bounds rect au routine en C 			GivescreenBits proc export		IMPORT	qd:MYQDGLOBALS		move.l	4(sp),a0		lea		qd.ScreenBits.bounds,a1		move.l	(a1)+,(a0)+		move.l	(a1)+,(a0)+		move.l	(sp)+,a0		adda.l	#4,sp		jmp	(a0)		; return to the caller		DbgInfo.New			GivescreenBits 		endp				case	off* ================================================* PROCEDURE EventLoop;* ================================================* Get the events by calling WaitNextEvent, if it's available, otherwise* by calling GetNextEvent. Also call AdjustCursor before doing the event.* After returning from handling the event, we have to make sure the cursor* is still adjusted proper ONLY because this application can "sleep" forever.* An event record is allocated on the stack.  A pointer to this event is* passed to "DoEvent".  We Loop until the user has selects "Quit" in the* file menu.  This program will exit through the DoMenuCommand routine.* 1.02 made adjustments to the event Loop logic.  There was a bug in calling* AdjustCursor at the wrong time. (it crashed under _GetNextEvent too!)* If you are using modeless dialogs that have editTems,* you will want to call IsDialogEvent to give the caret a chance* to blink, even if WNE/GNE returned false. However, check FrontWindow* for a non-NIL value before calling IsDialogEvent.EventLoop	PROC	Export		; any source file can use this routineStackFrame			RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start listing parameters hereParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkTheEvent 			DS	EventRecord 		; local copy of the event recordMouseMvdRgn			DS.L	1			; local region for MouseMoved eventsMousePos			DS.L	1			; local point for mouse positionRectfenetre			DS.b 	Rect			; de la fenètreMouseLoc			ds.l	1			; point de la sourisbuffer				ds.b	256ItemType			ds.w	1			; stockage du type de ItemItemHandle			ds.L	1			; stockage	du handle du itemitemRect			ds		Rect		; rectangleVisRect				ds	RectIconHandle			ds.l	1TEHandle			ds.l	1texteStyle			ds.b	256		; style pour texte tesaved0				ds.l	1		; sauvegarde de la valeur de d0 dans le recherche st courantChgFlag				ds.w	1rgb					ds.w	6rectangle_Soustitre		ds	Rectrectangle_Soustitre2	ds	Rectrgb2				ds.w	6rectangle			ds		RectsavedTC				ds.l	1mustbeep			ds.w	1Buff2				ds.l	8oldPseudoTC			ds.l	1oldPort				ds.l	1oldforeColor		ds.w	3oldbackcolor		ds.w	3whitec				ds.w	3blackc				ds.w	3LastTicks				ds.l	1DernierTCTraiteParAffST	ds.l	1NombreDepassage			ds.w	1LocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	AdjustCursor,GetGlobalMouse,DoEvent,TransfertMemoireSaisie,CalculDuree,\				TransfertSaisieMemoire		WITH	StackFrame,SOUSTITRERECORD,VtrStatusRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		move.w	#-1,whitec(a6)		move.w	#-1,2+whitec(a6)		move.w	#-1,4+whitec(a6)			clr.w	blackc(a6)				clr.w	2+blackc(a6)				clr.w	4+blackc(a6)				CLR.L	-(SP)		_NewRgn				; create region for AdjustCursor		MOVE.L	(SP)+,MouseMvdRgn(A6)	; save the handle to this region		clr.w		G.SendVtrTime_state	; dernière demande de TC satisfaite				clr.l		rectangle_Soustitre(a6)		move.w		#1023,right+rectangle_Soustitre(a6)		move.w		#576,bottom+rectangle_Soustitre(a6); on efface la vidéo explorer et on charge le segment 'rendering		move.l	G.Base_Adresse,d0		bne.s	PasZeroBase			;si zero on raz le GDHandle		clr.l	G.VE_GDHandle		PasZeroBase		tst.l	G.VE_GDHandle		beq.s	Pas_EffaceVx		move.l	G.Base_Adresse,-(sp)		move.l	G.Row_Bytes,-(sp)		pea		rectangle_Soustitre(a6)				import	Hand_EraseRect		jsr		Hand_EraseRect		move.l	G.OffscreenDisplayBase,-(sp)	;ram du buffer offscreen 		move.l	G.Row_Bytes,-(sp) 		pea		rectangle_Soustitre(a6)		 		import	Hand_EraseRect 		jsr		Hand_EraseRect; on raz les pointeurs des buffers		clr.l	G.Sous_titre_dessined		clr.l	G.Sous_titreInOffscreen		clr.l	G.ScreenRenderedRect 		clr.l	G.OffscreenRenderedRect		move.w		#$8000,G.DrawState		; on désactive la vramLoopWaite		move.w		G.DrawState,d0		; on désactive la vram		bmi.s		LoopWaite		Pas_EffaceVx		clr.l	G.Sous_titre_dessined		move.w		#$0000,G.DrawState		; on affecte le flag 				clr.l	-(sp)		_TickCount		move.l	(sp)+,LastTicks(a6)* ------------- GET NEXT EVENT Loop -------------NextEvent								CMPI.W	#true,G.HasWNEvent 	; see if we can call WaitNextEvent		BNE.S	@1			; nope, old time events		 		PEA	MousePos(A6)		; here's the mouse 		jsr	GetGlobalMouse		; get global coordinate 		MOVE.L	MousePos(A6),-(SP)	; here's the mouse; 		MOVE.L	MouseMvdRgn(A6),-(SP)	; the region to change 		jsr	AdjustCursor		; adjust the cursor and region		CLR.W	-(SP)			; space for result		MOVE.W	#-1,-(SP)	; the events we want		PEA	TheEvent(A6)		; pointer to the event record		MOVE.L	#0,-(SP)	; the sleeping time value		MOVE.L	MouseMvdRgn(A6),-(SP)	; the current MouseRgn		_WaitNextEvent		BRA.S	@2			; got an event to handle?							; no WaitNextEvent trap available@1		_SystemTask			; call SystemTask for drivers and DAs		CLR.W	-(SP)			; space for result		MOVE.W	#-1,-(SP)	; the events we want		PEA	TheEvent(A6)		; pass a pointer to our event		_GetNextEvent@2		MOVE.W	(SP)+,D0		; result code;		BEQ.S	NextEvent		; no event, get another one		GotEvent; gestion des sous-titres à l'écran		import	Affichage_soustitre 		jsr		Affichage_soustitre				; maintenant on regarde s'il faut demander le time code		 		cmp.w	#2,G.LecteurTimeCode_Type	; mode lecteur RS 422 ?  		bne 	DoNotSendVtrRequest			; non;###### ; on demande le time code tous les Ticks (env. 1/60 sec.)			clr.l	-(sp)			_TickCount			move.l	(sp)+,d0			sub.l	LastTicks(a6),d0			cmp.l	#1,d0 			blo		DoNotSendVtrRequest; on regarde si protection par fichier dans préférences			cmp.w	#1,G.SoftProtect			beq		DoNotSendVtrRequest; on demmande la lecture du tc pour le  protocole RS 422						move.w	G.Player_TC_src,d0		; type de tc demandé 			case#.w	(d0,if),\			(0,Auto),\			(1,ltc),\			(2,vitc),\			(3,ctl),\			(3,TTM2)			bra		ltc			Auto		moveq	#3,d0			bra.s	DoAskTc			ltc			moveq	#1,d0			bra.s	DoAskTc		vitc		moveq	#2,d0				bra.s	DoAskTc		ctl			moveq	#4,d0			bra.s	DoAskTc		TTM2		moveq	#8,d0	DoAskTc			DoNotSendVtrRequest		; gestion des rafraîchissement des différentes fenètres diverses								lea.l	G.ServiceWindow,a0		tst.b	wVisible(a0)		beq 	PasDrawServiceWindow		; transfert de rect dans buffer temporaire		move.l	portRect(a0),Rectfenetre(a6)			move.l	portRect+4(a0),Rectfenetre+4(a6)				CLR.L	-(sp)		import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		_SetPort				 		move.l	$830,MouseLoc(a6)		; the mouse		pea		MouseLoc(a6)		_GlobalToLocal				pea		G.ServiceWindow		_SetPort		; initialisation de quick-draw de la police et tout et tout		MOVE.W		#srcCopy,-(SP)					; source mode		_TextMode		MOVE.W		#monaco,-(SP)					; monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace		move.w	#1,-(sp)	   	move.w	#1,-(sp)	   	_PenSize	   	move.w	#srcOr,-(sp)	   	_PenMode				move.w	left+Rectfenetre(a6),d6		move.w	top+Rectfenetre(a6),d7		add.w	#8,d6		add.w	#20,d7		move.w	d6,-(sp)		move.w	d7,-(sp)		_MoveTo				pea	#'Fenètre active :'		_drawString				CLR.L	-(sp)		import	BB_FrontNonFloatingWindow		jsr		BB_FrontNonFloatingWindow		move.l	(sp)+,d0				clr.l	-(sp)		move.l	d0,-(sp)		_GetWRefCon		move.l	(sp)+,d0				lea.l	buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7		pea		buffer(a6)		_DrawString						move.w	left+Rectfenetre(a6),d6		move.w	top+Rectfenetre(a6),d7		add.w	#8,d6		add.w	#35,d7		move.w	d6,-(sp)		move.w	d7,-(sp)		_MoveTo				string pascal		moveq	#0,d0		move.w	MouseLoc(a6),d0		lea.l	buffer(a6),a0		CLR.W		-(SP)							; selector for NumToString		_Pack7			pea 	#'mouse in local coordinates ('		_DrawString		pea		buffer(a6)		_DrawString		pea		#' , '		_DrawString		moveq	#0,d0		move.w	MouseLoc+2(a6),d0			lea.l	buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7		pea		buffer(a6)		_DrawString		pea		#')       '		_DrawString				add.w	#0,d6		add.w	#15,d7		move.w	d6,-(sp)		move.w	d7,-(sp)		_MoveTo; on affiche l'espace dipo de la pile		_StackSpace		lea.l	buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7				move.w	#6,-(sp)		move.w	#48,-(sp)		_MoveTo		pea		#'stack: '		_DrawString		pea		buffer(a6)		_DrawString		move.w	G.TravailAFaire_Affichage,d0		ext.l	D0		lea.l	buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7				move.w	#6,-(sp)		move.w	#252,-(sp)		_MoveTo		pea		#'affmode=: '		_DrawString		pea		buffer(a6)		_DrawString						move.l	G.TcInaAttendre,d0				lea	buffer(a6),a0		import	ConversionTCstASCII		jsr	ConversionTCstASCII		move.w	#6,-(sp)		move.w	#264,-(sp)		_MoveTo		pea		#'wait tc in=: '		_DrawString		pea		buffer(a6)		_DrawString		move.l	G.TcOutaAttendre,d0		lea	buffer(a6),a0		import	ConversionTCstASCII		jsr	ConversionTCstASCII		move.w	#6,-(sp)		move.w	#276,-(sp)		_MoveTo		pea		#'wait tc Out=: '		_DrawString		pea		buffer(a6)		_DrawString							; on affiche les pointeurs				move.l	G.General_SousTitreCourantPtr,d0		lea		buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7		move.w	#6,-(sp)		move.w	#288,-(sp)		_MoveTo		pea		#'sous titre en cours: '		_DrawString		pea		buffer(a6)		_DrawString									move.l	G.Sous_titre_dessined,d0		lea	buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7		move.w	#6,-(sp)		move.w	#288+12,-(sp)		_MoveTo		pea		#'sous titre dans carte: '		_DrawString		pea		buffer(a6)		_DrawString											move.l	G.Sous_titreInOffscreen,d0		lea	buffer(a6),a0		CLR.W	-(SP)							; selector for NumToString		_Pack7		move.w	#6,-(sp)		move.w	#288+24,-(sp)		_MoveTo		pea		#'sous titre offscreen: '		_DrawString		pea		buffer(a6)		_DrawString					; on affiche les différentype de tyme code du logiciel				move.l	G.LastRecevied422TC,d0		lea		buffer(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				move.w	#6,-(sp)		move.w	#288+48,-(sp)		_MoveTo		pea		#'LTC/VITC AUTO : '		_DrawString		pea		buffer(a6)		_DrawString											lea.l	G.PlayerStruct,a1 			move.l	vtr_LTC(a1),d0		lea		buffer(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				move.w	#6,-(sp)		move.w	#288+60,-(sp)		_MoveTo		pea		#'          LTC : '		_DrawString		pea		buffer(a6)		_DrawString											lea.l	G.PlayerStruct,a1 			move.l	4+vtr_LTC(a1),d0		lea		buffer(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				move.w	#6,-(sp)		move.w	#288+72,-(sp)		_MoveTo		pea		#'         VITC : '		_DrawString		pea		buffer(a6)		_DrawString											move.l	G.General_PseudoTimeCode,d0		lea		buffer(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				move.w	#6,-(sp)		move.w	#288+84,-(sp)		_MoveTo		pea		#' Géné interne : '		_DrawString		pea		buffer(a6)		_DrawString									move.w	#6,-(sp)		move.w	#288+96,-(sp)		_MoveTo		pea		#'                -----------------'		_DrawString				PasDrawServiceWindow; les routines VTRTimedTask et serial; s'occupe de update le time code courant				move.l	G.General_TCCourant,d0		lea		G.bufferTimecodeCourant,a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII		lea		G.bufferTimecodeCourant,a0		move.b	#' ',12(a0)		move.b	#12,(a0)				lea.l	G.ServiceWindow,a0		tst.b	wVisible(a0)		beq.s	PasDrawServiceWindow_2				move.w	#4,-(sp)		move.w	#288+108,-(sp)		_MoveTo		pea		#'   TC Courant : '		_DrawString		pea		G.bufferTimecodeCourant		_DrawString						PasDrawServiceWindow_2						import	DoListingIdle		jsr		DoListingIdle				import	AVIdle		jsr		AVIdle				pea		G.ListingWindow		_Setport				lea		G.ListingWindow,a0		move.l	portRect(a0),VisRect(a6)			move.l	portRect+4(a0),VisRect+4(a6) 				MOVE.W		#srcCopy,-(SP)					; source mode		_TextMode		MOVE.W		#monaco,-(SP)					; monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; standart		_TextFace			   	_PenNormal				lea.l	G.ListingWindow,a0		move.l	portRect(a0),VisRect(a6)			move.l	portRect+4(a0),VisRect+4(a6)		sub.w	#15,bottom+VisRect(a6)				move.w	left+VisRect(a6),d0		add.w	#260,d0		move.w	d0,-(sp)		move.w	bottom+VisRect(a6),d0		add.w	#12,d0		move.w	D0,-(sp)		_MoveTo				move.l	G.General_SousTitreCourantPtr,a0		move.l	G.General_TCCourant,d0		import	TestSiDansST		jsr		TestSiDansST		tst.l	d0		bne.s	Dotcnormal				move.w	#notSrcCopy,-(sp)		_TextMode		Dotcnormal		;		pea		#'tc courant: ';		_DrawString				;		pea		G.bufferTimecodeCourant;		_DrawString						move.w	#srcCopy,-(sp)		_TextMode				; on affiche l'icône sauvegarde demander dans la coin de la fenètre				lea		G.ListingWindow,a0		move.w	bottom+portRect(a0),d0		move.w	#478-18,left+itemRect(a6)		move.w	#478-4,right+itemRect(a6)		move.w	d0,bottom+itemRect(a6)		sub.w	#13,d0		move.w	d0,top+itemRect(a6)DisplaySaveChange						;--------------- gestion de la fenètre listing etc...	; on regarge si c'est différent depuis le dernier passage		move.w	ChgFlag(a6),d0		bpl		PasTracking		clr.b	ChgFlag(a6)	; on raz le bit de poids fort				tst.b	d0		bne.s	NewStDisplay; on sort d'un sous-titre; on regarde si nous disposons d'assez de temps pour faire l'affichage; on desside qu'il faut env 4 images pour effacer  un st(simple re-dessin)		move.l	G.General_SousTitreCourantPtr,a0		move.l	st_TimeCodeIn(a0),d0		move.l	G.General_TCCourant,d1		import	SoustractionTimeCode		jsr		SoustractionTimeCode		cmp.l	#8,d1			; on prend un bonne marge de sécurité		blt		PasTracking		; on décide de ne rien faire sinon on ratera le prochain st; on redessine le sous-titre	; on utilise la routine «DrawSt_enCourDansListing_ByPointeur»; on vérifie que nous sommes dans desbornes				moveq	#0,d0		move.w	G.General_SousTitreDisplayed,d0		beq		PasTracking		ext.l	D0		cmp.l	G.General_NombreST,d0		bhi		PasTracking				clr.w	G.General_SousTitreDisplayed	; on raz l'indicateur		move.l	d0,-(sp)		import	DrawSt_enCourDansListing_ByPointeur		jsr		DrawSt_enCourDansListing_ByPointeur		bra		PasTracking		; -----------------------------------------------------------------------NewStDisplay	; on entre dans un sous-titre		move.w	G.General_SousTitrecourant,d0		move.w	d0,G.General_LastSousTitrecourant 		move.w	d0,G.General_SousTitreDisplayed				; on regarde si nous disposons d'assez de temps pour faire l'affichage		move.l	G.General_SousTitreCourantPtr,a0		move.l	st_TimeCodeOut(a0),d0		move.l	G.General_TCCourant,d1		import	SoustractionTimeCode		jsr		SoustractionTimeCode		cmp.l	#10,d1			; on desside qu'il faut 10 images pour redessiner		blt		PasTracking		; on décide de ne rien faire sinon on ratera la fin du sous-titre				Pea		G.ListingWindow		_setPort; faut-t-il faire suivre la fenètre saisie	 ?		tst.w	G.Preference_HardTracking		; mode saisie activé ?		beq 	PasTrackingSaisie				 			MOVE.W	G.General_SousTitrecourant,G.General_SousTitreEncour; On transfère le contenu de la fenètre saisie dans la mémoire				jsr		TransfertSaisieMemoire		cmp.l	#-1,d0;		beq		PasTracking	; attention il y a erreur; on transfère le st en cour dans saisie		jsr		TransfertMemoireSaisie		jsr		CalculDuree		; -----; on regarde si tracking actif pour listing		PasTrackingSaisie		tst.w	G.Preference_Tracking		beq 	PasTracking				; on affiche le sous-titre en cour d'affichage				clr.w	-(sp)		move.l	G.ListingVScroll,-(sp)		_GetMaxCtl		move.w	(sp)+,d1		move.w	G.ListingMaxDisplay,d2				cmp.w	d2,d1		bge.s	oncentre				move.l	G.ListingVScroll,-(sp)		move.w	#1,-(sp)		_SetCtlValue		bra.s	DessinFenetre		; pour l'instant on centre , mais il faudrait; plutôt travailler par paquets de sous-titre.; pour n'afficher qu'une fois sur hauteur listing la liste des sous-titresoncentre:		lsr.w	#1,d2		move.w	G.General_SousTitreDisplayed ,d0		sub.w	d2,d0				move.l	G.ListingVScroll,-(sp)		move.w	d0,-(sp)		_SetCtlValue		DessinFenetre					import	DrawListingWindow		jsr		DrawListingWindow				bra		PasTracking;------------------------------------------------------		; on ne redessine pas tous les lettres; on met un • pour indiquer le field 2	Field2		pea		G.ServiceWindow		_Setport				add.w	#139,d6		add.w	#0,d7		move.w	d6,-(sp)		move.w	d7,-(sp)		_MoveTo				move.w	#'•',-(sp)		_DrawChar	; -----------------; ### faire test si assez de temps pour fait idle chenillePasTracking	 		move.l	G.ChenilleWindow,a0 		tst.b	wVisible(a0) 		beq.s	PasDrawTc		import	DoChenilleIdle		jsr		DoChenilleIdlePasDrawTc		; on regarde	s'il y a un te dans listing		move.l	G.ListingTE,a0		cmp.l	#0,a0		beq.s	PasTEListing				move.l	a0,-(sp)		_TEIdle		PasTEListing	; on regarde	s'il y a un te dans saisie				move.l	G.saisieTE,d0		beq.s	PasTEsaisie				move.l	G.saisieTE,-(sp)		_TEIdle					PasTEsaisie; on regarde	s'il y a un te dans saisie		move.l	G.BlockNoteTE,a0		cmp.l	#0,a0		beq.s	PasTEBlockNote				move.l	a0,-(sp)		_TEIdle		PasTEBlockNote; --------------------------------------------------; Chien de garde ; on analyse les compteurs ; Gestion de la sauvegarde automatique		tst.w	G.Preference_AutoCheck		beq.s	OnNeSauvegardePas				clr.l	-(sp)		_TickCount		move.l	(sp)+,d7		move.l	d7,d0		sub.l	G.WatchDogSave,d0		divu	#61*60,d0		; minutes		and.w	#$ffff,d0		cmp.w	G.Preference_NombreSauv,d0		blo.s	OnNeSauvegardePas; ok sauvegarde automatique ; on raz le compteur sauvegarde		move.l	d7,G.WatchDogSave				move.w	G.ChangeSinceLastSave,d0		and.w	#$7fff,d0  ; fichier modifié ?			beq.s	OnNeSauvegardePas				import	 SauvegardeAutomatique	  		jsr		SauvegardeAutomatique			move.w	#0,G.ChangeSinceLastSave		OnNeSauvegardePas		 		import 	DoFonctionKey		clr.w	-(sp)				; espace pour le resultat 		PEA		TheEvent(A6) 		jsr		DoFonctionKey		move.w	(sp)+,d0		bne		NextEvent			; la routine a traitée un évenement; -------------------------------------Goto_DoTheEvent			IF DEMO=1 THEN			MOVE.L	Ticks,D0			CMP.L	G.StartTicks,d0			blo		@b 			import	Terminate 			jsr		terminate@b			ENDIF		PEA	TheEvent(A6)		; pass the pointer to our event		jsr	DoEvent			; do the event and return		BRA.S	NextEvent		; done with that event, get the nextexit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	EvntLoop		; this name will appear in the debugger		align 4			ENDP; ##################################TrapInitAlert	proc export; ##################################StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult		ds.w	1ParamBegin	EQU	*			; start parameters after this pointid			ds.w	1proc		ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAlert_res			ds.l	1Ditl_res			ds.l	1LocalSize			EQU 	*			; size of all the local variables			ENDR			bra.s		startoldTrap		dc.l	1			with	StackFramestart		LINK	A6,#LocalSize		; allocate our local stack frame					move.w	#0,result(a6)				clr.l	-(sp)			move.l	#'ALRT',-(SP)			move.w	id(a6),-(sp)					_GetResource			MOVE.L	(SP)+,d0			beq.s	exit				; pas de resource									move.l	d0,Alert_res(A6)			move.l	d0,A0			move.l	(A0),a0			move.w	8(A0),d0	; ditl N°									clr.l	-(sp)			move.l	#'DITL',-(SP)			move.w	d0,-(sp)					_GetResource			MOVE.L	(SP)+,d0			beq.s	exit				; pas de resource									move.l	d0,Ditl_res(A6)			move.l	d0,A0			move.l	(A0),a0			; ------------------------------------			;			break faire test de détermination etc...; ------------------------------------						move.l	Ditl_res(A6),-(sp)			_ReleaseResource			move.l	Alert_res(A6),-(sp)			_ReleaseResource									clr.w	-(sp)			move.w	id(a6),-(sp)			move.l	proc(a6),-(sp)			move.l	oldTrap(pc),a0			jsr		(a0)	; the old trap			move.w	(sp)+,result(a6)exit		UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.new		TrapInitAlert			endp; -------------------------------------------------------------------------;			SEG 'INIT'		; case sensitiveDoPrepareVBLJump proc export;			SEG 'INIT'		; case sensitive; ------------ on installe la VBL task -------------------------------		move.l	a5,G.VBL_A5		lea		G.VBL_StartRoutinePtr,a1	; ptr de destination		lea		VBLStartCode(pc),a0			; ptr  source		lea		VBLEndCode(pc),A2		move.l	a2,d0		sub.l	a0,d0				; taille de la routine à copier		_BlockMove		; on recopie le code		bra		VBLEndCode; ----------------------------------------------------------------		; code pour lancer la vbl task, pas utilisé directementVBLSaveA5		dc.l	1VBLStartCode		movem.l	a5,-(sp)		move.l	VBLSaveA5(pc),a5		import	VBLMainTask		jmp		VBLMainTaskVBLEndCode; --------------------------------------------------------------------------------------; on initialise la structure vbl		lea		G.VBL_Structure,A0		lea		G.VBL_StartRoutinePtr,a1			move.l	a1,vblAddr(a0)		move.w	#vType,qType(a0)		move.w	#1,vblCount(a0)		move.w	#0,vblPhase(a0); on attache le slot à la gestion des interruption		move.w	G.Ve_Slot,d0		_AttachVBL; on active la vbl		move.w	G.Ve_Slot,d0		lea		G.VBL_Structure,A0		_SlotVInstall				rts		DbgInfo.new		DoPrepareVBLJump		endp				* ================================================* --------------- MAIN ENTRY POINT ---------------* ================================================* This is the entry point of the program.  We start with data initializing* and then to get the System environment (SysEnvirons).  We unload the* initialization code segment and finally get started with the EventLoop.;;		SEG	'Main'			; case sensitive;StartUp        	MAIN				; entry point of the program;		IMPORT	_DataInit,Initialize,	\;				ForceEnvirons,EventLoop,\;				LoadTelecommandeSegment,\;				VtrTimedTask,\;				VtrTimedTask,\;				DoFileOpen;		;		with	QDGlobals;;		;		JSR	_DataInit		; initialize those constants	;		PEA	_DataInit		; get rid of that segment;		_UnloadSeg;* If you have stack requirements that differ from the default, then you could* use SetApplLimit to increase StackSpace at this point, before calling MaxApplZone.;;		clr.l	-(sp);		import	GetApplLimit;		jsr		GetApplLimit;		move.l	(sp)+,d0; 		sub.l	#12*1024,d0				; 64k de pile possible		;		and.l	#$fffffffc,d0	; alignement 4		; 		move.l	d0,A0; 		_SetApplLimit ;		_MaxApplZone			; result in D0; on demande plus de master pointeurs;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters;		_MoreMasters		; on charge le segment télécommande pour que la mise en route des taches d'interruptions; puisse s'effectué ; pour ce faire il suffit d'appeler une routine du segment ;		;		import	C_Init;		JSR	C_Init		; get things the program set up;		PEA	C_Init;		_UnloadSeg			; we're done this that segment too		; -------------------------------------------------------------------							; On installe une routine sous-interuption qui interroge le ou les VTR, pour; connaitre les Times Code Ou Status;		import	StartXtimeTask;		jsr		StartXtimeTask;#################################; trap pour les alerts;###############################		;		move	#$A985,d0	; alert;		 _GetTrapAddress ,NEWTOOL		;		 move.l	a0,G.EditList;		import		TrapInitAlert;		lea			TrapInitAlert(pc),A1;		move.l		a0,2(A1);		move	#$A985,d0	; alert;		move.l	A1,A0;		 _SetTrapAddress ,NEWTOOL							* ======================================================================*	Fonction	handle=GetGlobalRgbColorHandle();* ======================================================================*** Cette routine permet de récupérer les couleurs d'incrutation pour les caractères* pour la routine en CGetGlobalRgbColorHandle	Proc ExportStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordHandle			ds.l	1ParamBegin		EQU	*						; start parameters after this pointParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR						IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,AdjustCursor,GetGlobalMouse		WITH	StackFrame,SOUSTITRERECORD,AppGlobals			; cover our local stack frame				link	a6,#LocalSize					moveq	#8*4,d0 		_NewHandle		move.l	a0,Handle(a6)		_Hlock				lea		G.RGB_FaceColor,a0		move.l	Handle(a6),a1		move.l	(a1),a1		move.l	#8*4,d0		_BlockMove				lea		Handle(a6),a0		_HUnlockexit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New			GetGlobalRgbColorHandle		* ======================================================================*	Procedure	CopieLesFontValeursUtiles(Handle);* ======================================================================*** Cette routine permet de récupérer les couleurs d'incrutation pour les caractères* pour la routine en CCopieLesFontValeursUtiles	PROC ExportStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointHandle			ds.l	1ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR						IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,AdjustCursor,GetGlobalMouse		WITH	StackFrame,SOUSTITRERECORD,AppGlobals,FontRenderRecord			; cover our local stack frame				link	a6,#LocalSize			move.l	Handle(a6),a0		_Hlock				move.l	Handle(a6),a0		move.l	(a0),a0				lea		G.Display_Font,a1				move.w	NormalKerning(a0),NormalKerning(a1)		move.w	spaceWidth(a0),spaceWidth(a1)		move.w	interligne(a0),G.Display_interligne		move.l	Handle(a6),a0		_HUnlockexit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New			CopieLesFontValeursUtiles		* ======================================================================*	Procedure	CopieLesCouleurs(Handle);* ======================================================================*** Cette routine permet de transférer les couleurs de la resource 'colo'* à partir du fichier prèfCopieLesCouleurs	PROC ExportStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointHandle			ds.l	1ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR						IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,AdjustCursor,GetGlobalMouse		WITH	StackFrame,SOUSTITRERECORD,AppGlobals			; cover our local stack frame				link	a6,#LocalSize			move.l	Handle(a6),a0		_Hlock				move.l	Handle(a6),a0		move.l	(a0),a0				lea		G.RGB_FaceColor,a1		move.l	(a0)+,(a1)+		move.l	(a0)+,(a1)+		move.l	(a0)+,(a1)+		move.l	(a0)+,(a1)+				move.l	Handle(a6),a0		_HUnlockexit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New			CopieLesCouleurs				* ======================================* pascal	short GetShort(ptr);* =====================================	GetShort 	Func exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult		ds.w	1ParamBegin	EQU	*			; start listing parameters hereadr			ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	adr(a6),a0		move.w	(a0),result(a6)				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	GetShort			; this name will appear in the debugger		align 4			endp* ======================================* pascal	void SetShort(ptr,short);* =====================================	SetShort 	Func exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start listing parameters hereadr			ds.l	1short		ds.w	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	adr(a6),a0		move.w	short(a6),(a0);				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	SetShort			; this name will appear in the debugger		align 4			endp		* ======================================* pascal	void SetLong(ptr,long);* =====================================	SetLong 	Func exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start listing parameters hereadr			ds.l	1long		ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	adr(a6),a0		move.L	long(a6),(a0);				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	SetLong			; this name will appear in the debugger		align 4			endp				* ======================================* pascal	short GetLong(ptr);* =====================================	GetLong 	Func exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult		ds.l	1ParamBegin	EQU	*			; start listing parameters hereadr			ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	adr(a6),a0		move.l	(a0),result(a6)				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	GetShort			; this name will appear in the debugger		align 4			endp		* ===================================================================		* pascal void C_ConversionnumeroSTPointeur(Ptr startblock,Ptr endblock,long offset);* ===================================================================				C_ConversionnumeroSTPointeur 	Func exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult				ds.l	1ParamBegin			EQU	*			; start listing parameters hereAbslolutNum			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	AbslolutNum(a6),d0		import	ConversionnumeroSTPointeur		jsr		ConversionnumeroSTPointeur		move.l	a0,result(a6)		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ConversionnumeroSTPointeur			; this name will appear in the debugger		align 4			endp			* ===================================================================		* pascal void C_ConversionTimeCodePointeur(l);(Ptr startblock,Ptr endblock,long offset);* ===================================================================				C_ConversionTimeCodePointeur	Func exportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordresult				ds.l	1ParamBegin			EQU	*			; start listing parameters hereTC			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	TC(a6),d0		import	ConversionTimeCodePointeur		jsr		ConversionTimeCodePointeur		move.l	a0,result(a6)		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ConversionTimeCodePointeur(l);			; this name will appear in the debugger		align 4			endp			;/* interface pour les routines en C */		C_ConvertiNumST_String proc ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start listing parameters hereSTNum				ds.l	1StringPtr			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	STNum(a6),d0		move.l	StringPtr(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ConvertiNumST_String			; this name will appear in the debugger		endP		C_ConvertiNumST_Ptr proc ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordst_Ptr				ds.l	1	ParamBegin			EQU	*			; start listing parameters hereStringPtr			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	StringPtr(a6),-(sp)		import	CHERCHESTPARnumero		jsr		CHERCHESTPARnumero		move.l	d0,st_Ptr(a6)				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ConvertiNumST_Ptr			; this name will appear in the debugger		endP						C_ConversionTCstASCII proc ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start listing parameters hereTimeCode			ds.l	1StringPtr			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	TimeCode(a6),d0		move.l	StringPtr(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ConversionTCstASCII			; this name will appear in the debugger		endP										C_ConversionChaineASCIITc proc ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordtc					ds.l	1ParamBegin			EQU	*			; start listing parameters hereStringPtr			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	StringPtr(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		move.l	d0,tc(a6)				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ConversionChaineASCIITc			; this name will appear in the debugger		endP				C_ChercheSTParNumero proc ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordST_Ptr				ds.l	1ParamBegin			EQU	*			; start listing parameters hereStringPtr			ds.l	1ParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR							WITH	StackFrame; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				move.l	StringPtr(a6),-(sp)		import	ChercheSTParNumero		jsr		ChercheSTParNumero		move.l	d0,ST_Ptr(a6)				UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	C_ChercheSTParNumero			; this name will appear in the debugger		endP			* ================================================* PROCEDURE DoAsmDebugMenu(menuResult: LONGINT);* ================================================* This is called when an item is chosen from the menu bar (after calling* MenuSelect or MenuKey). It performs the right operation for each command.* It is good to have both the result of MenuSelect and MenuKey go to* one routine like this to keep everything organized.DoAsmDebugMenu	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointMenuItem		DS.W	1			; result from _MenuKey or _MenuSelectParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkDeskname		DS.B	256			; local storage for Desk Accs nameTempPort		DS.L	1			; local storage for the current portTheItemHitalert	ds.w	1Menu			ds.l	1			; STOCKAGE handle menuTheDialogPtr	DS.l	1		; le pointeur local du dialogItemchoisi		DS.W	1		; Item choisi par l'utilisateurItemType		ds.w	1		; stockage du type de ItemItemHandle		ds.L	1		; stockage	du handle du itemitemRect		ds 		RectDialogStorage	ds	dWindLenVisRect			ds		Rectrectangle		ds		Rectstpos			ds.w	1textbuff		ds.b	256textbuff2		ds.b	256Buffer			ds.b	256windowPtr		ds.l	1STScrp			ds.l	1TexteStyle		ds.b	12mode			ds.w	1SelStyle		ds.w	1TheHandle		ds.l	1TheOffset		ds.l	1ItemHit			ds.w	1The_Dialog		ds.l	1LocalSize		EQU 	*			; size of all the local variables				ENDR				IMPORT	DoCloseWindow,Terminate,SaveData,DoGetSaveName,DoFileOpen,\				FairePreferenceFilm,DeleteST,InsertST,\				RechercherSousTitre,FairePreference2Film,\				SelectWindow,EffaceTouslesSousTitres,ExportFichier,DrawListingWindow,\				AFFICHENUMSAISIE,ConversionnumeroSTPointeur,CentreListingWindow,\ 				RenumerotationListeSousTitre,TRANSFERTMEMOIRESAISIE,Imprimer,PageSetup,\				CalculDuree		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame* ----------- DEBUG MENU -------------DEBUG		MOVE.W	MenuItem(A6),D0 		cmp.w	#4,d0		bne		serie		MOVE.L	G.General_PremierSTPtr,a0		Move.l	G.General_PremierSTPtr,a1				pea		#'liste de sous-titre pointée par a0 Pour redemarrer Bon Bougre taper G + ENTER ou command G'		_DebugStr		BRA	exitserie				MOVE.W	MenuItem(A6),D0 		cmp.w	#5,d0		bne		ResetInternalTc			 		move.w	#4,-(sp) 		move.w	#100,-(sp) 		move.w	#0,-(sp) 		pea		TexteStyle(a6)		 		import	GetKernTable	  		jsr		GetKernTable	  		move.l	TexteStyle(a6),a0		; --------------------------------------------------ResetInternalTc		MOVE.W	MenuItem(A6),D0 		cmp.w	#6,d0		bne		DoRenderTest				clr.l	-(sp)		move.w	#161,-(sp)	; id number		pea		DialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp)+,d0				pea		DialogStorage(a6)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		DialogStorage(a6)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect						move.l	G.General_PseudoTimeCode,d0		lea		Buffer(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		Buffer(a6)		_GetItext		pea		DialogStorage(a6)		move.w	#3,-(sp)				move.w	#0,-(sp)		move.w	#32767,-(sp)		_SelIText		LoopRESETTcModalDebug			clr.l	-(sp)		pea		Itemchoisi(a6)		_ModalDialog		move.w	Itemchoisi(A6),d0		cmp.w	#2,d0		beq		closeDialog_ResetTc			cmp.w	#1,d0		bne		LoopRESETTcModalDebug		move.l	ItemHandle(a6),-(sp)		pea		Buffer(a6)		_GetItext				lea		Buffer(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		move.l	d0,G.General_PseudoTimeCode		closeDialog_ResetTc				pea		DialogStorage(a6)		_CloseDialog				bra		exit		DoRenderTest		tst.l	G.Base_Adresse			; il y a t-il une carte d'affichage 		beq		exit		; non le reste du menu n'est plus actif				lea		G.Display_Font,a0					tst.l	Render_handle(a0)		; il y a t-il un bitmap  font ? 		beq		do_clear_buffer					; non		MOVE.W	MenuItem(A6),D0 		cmp.w	#7,d0		bne		DoFontRecordTest	;		import	Rendering_Font;		jsr	Rendering_Font		bra		exit; pour tester le font renderDoFontRecordTest		MOVE.W	MenuItem(A6),D0 		cmp.w	#8,d0		bne		DoFontRecordTest2		import	Test_FontRecord		jsr		Test_FontRecord		bra		exitDoFontRecordTest2		MOVE.W	MenuItem(A6),D0 		cmp.w	#9,d0		bne		Dotest_string		import	Test_FontRecord2		jsr		Test_FontRecord2		bra		exitDotest_string				MOVE.W	MenuItem(A6),D0 		cmp.w	#10,d0		bne		Dotest_clr_VX		import	Test_draw_string		jsr		Test_draw_string				bra		exitDotest_clr_VX		MOVE.W	MenuItem(A6),D0 		cmp.w	#11,d0		bne		TestFastDraw		import	clr_VX 				jsr		clr_VX 				bra		exitTestFastDraw		MOVE.W	MenuItem(A6),D0 		cmp.w	#12,d0		bne		FastDraw_string				import	TestDrawFastChar		jsr		TestDrawFastChar		bra		exitFastDraw_string		MOVE.W	MenuItem(A6),D0 		cmp.w	#13,d0		bne		Dotest_draw_A_ST		import	Test_Fastdraw_string		jsr		Test_Fastdraw_string				bra		exit		Dotest_draw_A_ST			MOVE.W	MenuItem(A6),D0 		cmp.w	#14,d0		bne		do_clear_buffer		import	test_draw_A_ST			jsr		test_draw_A_ST			bra		exitdo_clear_buffer		MOVE.W	MenuItem(A6),D0 		cmp.w	#15,d0		bne		notdisplay				import	Clear_Buffer		jsr		Clear_Buffer		bra		exit; ---notdisplay			MOVE.W	MenuItem(A6),D0 		cmp.w	#16,d0		bne		displayBuffer		import		Not_Display_Buffer				jsr		Not_Display_Buffer				bra		exit; --displayBuffer	MOVE.W	MenuItem(A6),D0 		cmp.w	#17,d0		bne		exit		import	Display_Buffer				jsr		Display_Buffer					bra		exitexit	CLR.W	-(SP)			_HiLiteMenu			; unhilite all Menus		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	DoAsmDebugMenu		endp		************************************************	Routine pour renuméroter les numéro*   secondaire d'un sous-titre*	entrée: a0	**RenumerotationSubnumero			PROC	EXPORT			with SOUSTITRERECORD									MOVEM.l	d0-d1/a1,-(sp); sommes-nous au premier sous-titre ?			cmp.l	G.General_PremierSTPtr,a0			bne.s	Loop			moveq	#1,d0			bra.s	err						Loop		cmp.l	G.General_DernierSTPtr,a0			beq.s	exit			move.l	st_PreviousST(a0),a1			move.l	st_NumeroST(a1),d0			move.l	d0,d1			beq.S	exit						add.l	#$01000000,d1			bcc.s	paserr			bra.s	err			paserr		and.l	#$00ffffff,d0			or.l	d1,d0			err			move.l	d0,st_NumeroST(a0)			move.l	d0,st_OldNumeroST(a0)			move.l	st_NextST(a0),a0			cmp.l	#0,a0			beq		exit			move.l	st_NumeroST(a0),d0			and.l	#$FF000000,d0			bne.s	Loop				exit		movem.l	(sp)+,d0-d1/a1			rts			DbgInfo.New	RenumSubST			align 4			ENDP* routines de calcul addition,soustraction en TC* la (les) routines conservent le bit de vérouillage du tc* et les bits de trames (pour addition et soustraction seulement)* les routines fonctionnnent en mode 25 images/s** entrée: d0,d1* sortie: d0*		d1-d7/a0-a6 sont conservés************************************************************ addition de deux time code*AdditionTimeCode 		PROC	EXPORT		import	ConversionTrames_TimeCode,ConversionTimeCode_Trames		movem.l		d2-d3,-(sp); on regarde si le tc de d0= -1	; (cas où on incrémente un tc in ou tc out par les flèches dans saisie); on raz le tc dans ce cas		cmp.l	#-1,d0		bne.s	@a0		moveq	#0,d0		moveq	#0,d1		bra		exit@a0		;sauvergarde des bits spéciaux vérouillage et field select;		move.l		d0,d2		move.l		d1,d3		and.l		#$c0000000,d2		and.l		#$c0000000,d3		or.l		d2,d3		and.l		#$3fffffff,d0		and.l		#$3fffffff,d1		move.l		d0,d2		move.l		d1,d0		jsr 		ConversionTimeCode_Trames		move.l		d0,d1		move.l		d2,d0		jsr 		ConversionTimeCode_Trames		add.l		d1,d0; on teste si le resultat>24H si oui res=res-24H		cmp.l		#2160000,d0		blt			AddTC_PasSuperieurA24		sub.l		#2160000,d0AddTC_PasSuperieurA24:; on restitue les bits spéciaux		move.l		d0,d1	; nombre de trames dans d1		jsr 		ConversionTrames_TimeCode		or.l		d3,d0exit	movem.l		(sp)+,d2-d3		rts		DbgInfo.New		AdditionTimeCode		align 4			ENDP**************************************************************************** Routine de conversion du Time code (format BCD), en nombre d'image (binaire) *ConversionTimeCode_Trames 		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal 	ds.b	256	numSecondaire 	ds.b	256		LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		link	a6,#LocalSize; d2 =compteur; d3 = scratch reg		movem.l		d1-d5/a0,-(sp)		move.l		d0,d3		moveq		#0,d0		moveq		#0,d2		lea.l		CTCT_PuissanceDe25(pc),a0		CTCT_boucle:		move.l	d3,d1		and.l	#$0F,d1		beq.s	CTCT_MultiEgalZero		sub.l	#1,d1		move.l	(a0,d2),d4		CTCT_boucleMultiplication:		add.l	d4,d0		dbra	d1,CTCT_boucleMultiplicationCTCT_MultiEgalZero:				lsr.l	#4,d3		addq.l	#4,d2		cmp.l	#32,d2		blt.s	CTCT_boucle		exit	movem.l		(sp)+,d1-d5/a0		UNLK		A6			; destroy the link		MOVEA.L		(SP)+,A0		; pull off the return address		ADDA.L		#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ConvTCtrames		CTCT_PuissanceDe25:		dc.l	1		dc.l	10		dc.l	25		dc.l	250		dc.l	1500		dc.l	15000		dc.l	90000		dc.l	900000				align 4			ENDP**********************************************************	Routines de conversion valeur entière en*	time code bcd*ConversionTrames_TimeCode  		PROC	EXPORT; initialisation		movem.l	d1-d4/a0,-(sp)		move.l	d0,d2			lea	CTCT_PuissanceDe25(pc),a0		moveq	#7*4,d1		adda.l	d1,a0		moveq.l	#0,d4		moveq.l	#0,d0		move.l	#7,d1 ; d1 compteur d'itérationCTCT_Loop:		move.l	(a0),d3CTCT_Loop2:		cmp.l	d3,d2		bcs.s	CTCT_InferieurAPuiss25		sub.l	d3,d2		addq.b	#1,d4		bra.s	CTCT_Loop2CTCT_InferieurAPuiss25		rol.l	#4,d0		or.b	d4,d0				moveq.l	#0,d4		sub.l	#4,a0		dbra	d1,CTCT_Loop		movem.l	(sp)+,d1-d4/a0		rts* table des puissances de "25"CTCT_PuissanceDe25:		dc.l	1		dc.l	10		dc.l	25		dc.l	250		dc.l	1500		dc.l	15000		dc.l	90000		dc.l	900000				DbgInfo.New	ConvTramTC				align 4			ENDP*********************************************************** Soustraction de deux time code*	 d0= d0-d1 ; ** entrée: d0,d1* sortie: d0 (tc abs) , d1 trames +signe* d1 est conservéSoustractionTimeCode:			PROC	EXPORT		import	ConversionTrames_TimeCode,ConversionTimeCode_Trames								movem.l		d2-d4,-(sp); on regarde si le tc de d0= -1	; (cas où on décremente un tc in ou tc out par les flèches dans saisie); on raz le tc dans ce cas		cmp.l	#-1,d0		bne.s	@a0		moveq	#0,d0		moveq	#0,d1		bra		exit@a0		;sauvergarde des bits spéciaux vérouillage et field select     		move.l		d0,d2		move.l		d1,d3		and.l		#$c0000000,d2		and.l		#$c0000000,d3		or.l		d2,d3		and.l		#$3fffffff,d0		and.l		#$3fffffff,d1		move.l		d0,d2		move.l		d1,d0		bsr 		ConversionTimeCode_Trames		move.l		d0,d1		move.l		d2,d0		bsr 		ConversionTimeCode_Trames		; on effectue un teste si les tc ont un code horaire >23 h; ce qui permet le passage par Zéro  result=d0-d1		moveq		#0,d4		cmp.l		#23*90000,d0	; 23 heures => <0 		blo.s		@a1			; pas de problème		moveq		#1,d4@a1		cmp.l		#23*90000,d1	; 		blo.s		@a2		add.w	#2,d4@a2		case#.w		(d4,if),\		(0,DoSub),\		(1,cas1),\		(2,cas2);----cas3	; d0≥23h … d1≥23h	=> r=d1-d0;		exg.l	d0,d1		bra.s	DoSub;----cas2	; d0<23h … d1≥23h	=> r=24h+d0-d1	(passage par zéro)		add.l	#24*90000,d0		bra.s	DoSub;----cas1	; d0≥23h … d1<23h	=> r=d0-(d1+24h);		add.l	#24*90000,d1		bra.s	DoSub;----DoSub	sub.l		d1,d0			move.l		d0,d1; on teste si le resultat<0 si oui res=24H-res; ( 0Heure = 24Heures) 		bpl.s		SubTC_PasNegatif		add.l		#2160000,d0SubTC_PasNegatif:; on restitue les bits spéciaux				bsr 		ConversionTrames_TimeCode		or.l		d3,d0exit	movem.l			(sp)+,d2-d4		rts		DbgInfo.New		SoustractionTimeCode		align 4			ENDP*************************************************************************		FUNC	ConversionchaineASCIITc(STR255):tcBCDLONGINT************************************************************************ *		ROUTINE DE conversion d'une chaine de caractères, en tc bcd*      *  		cette routine fait egalement des opérations de calcul comme*		additions et soustractions.***		En entrée: a0= pointeur chaine de caractères (str 255)**		En sortie	d0= nombre convertie en bcd ( 25 images/sec)*					si d0<0 => erreur*					d1= resultat en trame signé*		nb:	Un tc n'a jamais le bits 31 à un (sauf pour fct spéciales)****ConversionchaineASCIITc 		PROC	EXPORT				StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal 	ds.b	256	numSecondaire 	ds.b	256		LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,ConversionTimeCodePointeur,\				SoustractionTimeCode,AdditionTimeCode,ConversionASCIIbcdTc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize		movem.l	d2-d7/a1-a3,-(sp)			lea.l	numPrincipal(a6),a1		lea.l	numSecondaire(a6),a2		clr.w	(a2) ; si jamais il n'y en a pas		moveq.l	#1,d0		moveq.l	#0,d7 ; pour num secondaire		moveq.	#0,d5		moveq.l	#0,d4		moveq.l	#1,d2		principaleLoop				move.b	(a0,d0.w),d1		cmp.b	#'-',d1		beq		numSecondaireannonce		cmp.b	#'+',d1		beq		numSecondaireannonce		CMP.B	#':',D1	; ON S'EN FOU DU DELIMITEUR		BEQ		PL1		CMP.B	#',',D1	; ON S'EN FOU DU DELIMITEUR		BEQ		PL1		CMP.B	#' ',D1	; ON S'EN FOU DU DELIMITEUR		BEQ		PL1		cmp.b	#'0',d1		blo		ErrDansBuffer		cmp.b	#'9',d1		bgt		ErrDansBuffer		move.b	d1,(a1,d2.w)		addq	#1,d4		addq	#1,d2PL1		addq.b	#1,d0		cmp.b	(a0),d0		ble.s	principaleLoop		subq.w	#1,d2		move.b	d2,(a1)		bra		ConvertieNumnumSecondaireannonce:		MOVE.B	D1,D5	; ON Sauvegarde le type d'opération		subq.w	#1,d2		bne.s	PremierChiffrePasNul; le premier chiffre est nul		move.b	#1,(a1)		move.b	#'0',1(a1)				bra.s	OnContinuPourNombreSecondairePremierChiffrePasNul				move.b	d2,(a1)OnContinuPourNombreSecondaire		move.l	#1,d7		moveq	#0,d2secondaireLoop:		SL1			addq.w	#1,d0		cmp.b	(a0),d0		bgt.s	finrecopie		move.b	(a0,d0.w),d1; on teste si signe moin encore si oui on incrémente/décrémente le numéro secondaire				cmp.b	#'-',d1		bne.s	passignemoin		cmp.b	#'-',d5		bne.s	moinmoin		addq.l	#1,d7		bra.s	SL1moinmoin			subq.l	#1,d7		bne.s	SL1		moveq	#1,d7		bra.s	SL1; on teste si signe plus encore si oui on incrémente/décrémente le numéro secondaire		passignemoin			cmp.b	#'+',d1		bne.s	passigneplus		cmp.b	#'+',d5		bne.s	plusplus		addq.l	#1,d7		bra.s	SL1plusplus		subq.l	#1,d7		bne.s	SL1		moveq	#1,d7		bra.s	SL1		passigneplus				cmp.b	#'0',d1		blo		SL1	; pas un chiffre mais on s'en fou		cmp.b	#'9',d1		bgt		SL1	; pas un chiffre mais on s'en fou		move.b	d1,1(a2,d2.w)		addq	#1,d2				bra.s	secondaireLoop; on a fini de recopier le texte secondaire	finrecopie		move.b	d2,(a2)				cmp.l	#1,d7		bgt.s	pasnumsecondaire ; une suite de signe		ConvertieNum		tst.b	(a2)		beq.s	pasnumsecondaire		lea.l	numSecondaire(a6),a0		bsr 	ConversionASCIIbcdTc		move.l	d0,d7		lea.l	numSecondaire(a6),a0		tst.b	(a0)		bne		pasnumsecondairepasnumsecondaire				lea.l	numPrincipal(a6),a0		bsr 	ConversionASCIIbcdTc		move.l	d0,d3		import 	ConversionTimeCode_trames		bsr		ConversionTimeCode_Trames		move.l	d0,d1		move.l	d3,d0		tst.l	d5		beq		exit					move.l	d7,d1				cmp.b	#'-',d5		bne		Addition		bsr		SoustractionTimeCode		bra.s		exitAddition:			bsr		AdditionTimeCode		bra.s		exitErrDansBuffer:		move.l	#-1,d0		exit	movem.l	(sp)+,d2-d7/a1-a3		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller			DbgInfo.New		ConvChAScTC		align 4			ENDP					* ================================================* fonction ConversionASCIIbcdTc(str255=a0): result=d0* ================================================; cette fonction converti une str255 en tc bcd (uniquement chiffre) ConversionASCIIbcdTc			PROC	EXPORT						movem.l	d1-d3,-(sp) 			moveq	#0,d1			moveq	#0,d0			move.b	(a0)+,d1	; d1 compteur rotation			subq.w	#1,d1Loop		move.b	(a0)+,D2			cmp.b	#'*',d2		; timecode nul !			beq.s	ExitErr			cmp.b	#'0',d2			blo.s		finLoop			cmp.b	#'9',d2			bgt.s		finLoop			asl.l	#4,d0			and.l	#$0f,d2			or.b	d2,d0finLoop		dbra	d1,Loop						movem.l	(sp)+,d1-d3exit		rtsExitErr		move.l	#-1,d0			movem.l	(sp)+,d1-d3 			rts			DbgInfo.New		ConversionASCIIbcdTc			align 4					ENDP										* ================================================* fonction ConversionTCstASCII(tc (bcd)=d0,var str255=a0)* ================================================ConversionTCstASCII			PROC	EXPORT						movem.l	d0-d3,-(sp) 			cmp.l	#-1,d0			bne.s	valide			move.b	#11,(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			move.b	#' ',(A0)+			bra.s 	exit			valide						and.l	#$3fffffff,d0			MOVE.B	#11,(A0)+			MOVEQ	#7,D2CTCASCII_Loop1:			ROL.L	#4,D0			MOVE.B	D0,D1			and.b	#$f,d1			ADD.B	#$30,D1			MOVE.B	D1,(A0)+			cmp.b	#6,d2			beq.S	L2			cmp.b	#4,d2			beq.S	L2			cmp.b	#2,d2			bne.S	L1L2			MOVE.B	#':',(A0)+L1			DBRA	D2,CTCASCII_Loop1	exit		movem.l	(sp)+,d0-d3			rts			align 4				DbgInfo.New	ConvTCstAS		ENDP											* ======================================================================*	Fonction	CHERCHESTPARnumero(NUM):PTR;* ======================================================================**	Cette routine cherche le sous-titre désigner par le numéro (format interne)*   entrée: pile: chaine de caractères str255*	sortie:	d0: ptr du sous-titre*			d1:	ABSNum du sous-titre*	si 	   d1= 0 le sous-titre n'éxiste pas mais:*	cas1:  d0 contient le ptr du sous-titre le plus proche*   cas2:  d0=0 le sous titre est en dehors des limites de la listesCHERCHESTPARnumero	proC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointtextBuffPtr 	DS.L	1	 		; pointer de la chaine de caractèresParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal	ds.b	128numSecondaire	ds.b	128STPtr			ds.l	1		;	adresse du sous-titre trouvé par tcLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize						movem.l	d2-d7/a1-a4,-(sp); le texte est dans le buffer		; on checke la validitée; et on créer un nombre pour ètre rechercher		move.l	textBuffPtr(a6),a0		lea.l	numPrincipal(a6),a1		lea.l	numSecondaire(a6),a2		moveq.l	#1,d0		moveq.l	#0,d7 ; pour num secondaire		principaleLoop		move.b	(a0,d0.w),d1		cmp.b	#'-',d1		beq		numSecondaireannonce		cmp.b	#'0',d1		blo		ErrDansBuffer		cmp.b	#'9',d1		bgt		ErrDansBuffer		move.b	d1,(a1,d0.w)		addq.b	#1,d0		cmp.b	(a0),d0		ble.s	principaleLoop		subq.w	#1,d0		move.b	d0,(a1)		bra		CalculNumPrincipalnumSecondaireannonce:		moveq	#0,d2		subq.b	#1,d0		move.b	d0,(a1)		addq.b	#1,d0secondaireLoop:				addq.b	#1,d0		addq.b	#1,d2		move.b	(a0,d0.w),d1		cmp.b	#'0',d1		blo		ErrDansBuffer		cmp.b	#'9',d1		bgt		ErrDansBuffer		move.b	d1,(a2,d2.w)		cmp.b	(a0),d0		blt.s	secondaireLoop; on a fini de recopier le texte secondaire			move.b	d2,(a2); on calcule le numéro secondaire		lea		numSecondaire(a6),a0		move.w	#1,-(sp)	; selecteur pour string to num		_Pack7		move.l	d0,d7		cmp.l	#1,d0		blo		CenumeroNexistepasCalculNumPrincipal:		lea		numPrincipal(a6),a0		move.w	#1,-(sp)	; selecteur pour string to num		_Pack7		cmp.l	G.General_NombreST,d0		bgt		auDesusdelaliste						cmp.l	G.General_StartNumberForST,d0		blo		CenumeroNexistepas		move.l	d0,d6		;on fait la recherche à la dure dans la listeLoopRecherche		move.l	G.General_PremierSTPtr,a0LoopRecherche2				move.l	st_NumeroST(a0),d0		move.l	d0,d1		and.l	#$00ffffff,d0		cmp.l	d0,d6		beq		OnaTrouveNumPrincipal		move.l	(a0),a0		cmp.l	#0,a0		bne		LoopRecherche2			bra		CenumeroNexistepas		OnaTrouveNumPrincipal:		tst.l	d7		beq		ONYEST		; il n'y a pas de num secondaire donc on a trouvé;		cmp.l	#255,d7;		bgt 	ONYESTPresque	; on n'est pas chiant (mais tout de même) (>255)		rol.l	#8,d1		and.l	#$ff,d1		cmp.l	d1,d7		beq		ONYESTLoopNumSec:				move.l	(a0),a0		cmp.l	#0,a0		beq		ONYESTPresque	; pas trouver mais fin de liste		move.l	st_NumeroST(a0),d0		rol.l	#8,d0		and.l	#$ff,d0		beq.s	ONYESTPresque		cmp.l	d0,d7		beq		ONYEST			bra		LoopNumSec				auDesusdelaliste:		move.l	G.General_NombreST,d0				MOVE.L	G.General_DernierSTPtr,a0		bra.s	exitErrDansBuffer		CenumeroNexistepas		sub.l	a0,a0		ONYESTPresque		moveq	#0,d1					bra		exit		ONYEST	move.l	st_AbsNUMST(a0),d1exit	move.l	a0,d0		movem.l	(sp)+,d2-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ChercheSTParNumero		endp										****************************************************************** 	Routine de conversion time code => pointeur**	Cette Routine recherche le sous-titre qui correspond au time code**	Entrée: d0= time code (format BCD)*	sortie: a0= pointeur sur le sous-titre conserné*			si le tc ne correspond à aucun sous titre*			d0=0 sinon d0=a0*			(donc il faut d'abord tester d0 )*	dans le cas où le TC ne correspond à aucun sous-titre*   a0 pointe le st-inférieur, attention !!! donc pour la routine affichage, *   il faudra ajouter 1 si sens de défilement <.* 	Cette routine est le point le plus important de la routine d'affichage*ConversionTimeCodePointeur		PROC	EXPORT								WITH	SOUSTITRERECORD								import	TestSiDansST,ConversionnumeroSTPointeur; initialisation							movem.l	d3-d7/a1-a4,-(sp)						; on teste si la valeur est comprise dans la fenètre			cmp.l	G.General_PremierTC,d0			bhs.s	CTCP_AuDessusDuMin			move.l	G.General_PremierTCPtr,a0			moveq	#0,d0			movem.l	(sp)+,d3-d7/a1-a4			rts			CTCP_AuDessusDuMin:						cmp.l	G.General_DernierTC,d0			ble.s	CTCP_DansLaListe			moveq	#0,d0			move.l	G.General_DernierTCPtr,a0			movem.l	(sp)+,d3-d7/a1-a4			rts; ok nous sommes dans les limites de la fenètreCTCP_DansLaListe:			; on sauvegarde le tc dans d7			move.l	d0,d7; on regarde si nous sommes au dernier sous-titres			move.l	G.General_DernierTCPtr,a0			jsr		TestSiDansST; est ce supérieur ou égal ?, si oui on a trouvé (c'était le dernier sous-titre)			tst.w	d0						bge.s	CTCP_OnATrouve; on regarde si nous sommes au premier sous-titres			move.l	G.General_PremierTCPtr,a0			move.l	d7,d0			jsr		TestSiDansST; est ce inférieur ou égal ?, si oui on a trouvé (c'était le premier sous-titre)			tst.w	d0			beq		CTCP_OnATrouve	;initialisation 					move.l	G.General_DernierTCPtr,a0			move.l	st_AbsNUMST(a0),d6			move.l	G.General_PremierTCPtr,a0			move.l	st_AbsNUMST(a0),d5;			moveq	#0,d5;			move.l	G.General_NombreST,d6; note:  on utilise d5 = VALmin;		 on utilise d6 = VALmax	; boucle principale		CTCP_MainLoop:		; on calcule la demi-valeur						move.l	d6,d0			sub.l	d5,d0			asr.l	#1,d0	; /2			add.l	d5,d0	; d0= (d6-d5)/2 +d5			move.l	d0,d4	; secu de la valeur dans d4			jsr		ConversionnumeroSTPointeur			; on teste le tc par rapport au sous-titre			move.l	d7,d0			jsr		TestSiDansST			; #### note: problème si on nous revoie -1, qu'est ce que l'on fait	?		; est ce égal ?, si oui on a trouvé			tst.w	d0			beq.s		CTCP_OnATrouve; est ce plus petit ? si oui traitement plus petit que			cmp.w	#-100,d0			beq.S	CTCP_TestEnDessous; -- en fait c'est plus grand !CTCP_TestAuDessus:				move.l	d4,d5			bra.s	CTCP_TestSiEntreDeuxST			CTCP_TestEnDessous:			move.l	d4,d6			CTCP_TestSiEntreDeuxST:			move.l	d6,d3			sub.l	d5,d3			cmp.l	#1,d3			bhi.s	CTCP_MainLoop			; la différence entre les deux pointeurs est égale à 1 donc en principe,; le tc est compris entre ces deux valeurs.; on regarde si le tc est au dessus du sous-titre trouvé; si oui on donne le pointeur du prochain sous-titre			cmp.l	#100,d0				; au dessus ?			bne.s	PasDonnerlesuivant	; en dessous ou égal			; oui au dessus donc on donne le st suivant si c'est possible						move.l	a0,a4				; on sauvegarde le pointeur			move.l	st_NextST(a4),d0			beq.s	PasDonnerlesuivant ; oups pas sous-titre suivant			move.l	d0,a0				; le st suivant			PasDonnerlesuivant			moveq	#0,d0			movem.l	(sp)+,d3-d7/a1-a4			rtsCTCP_OnATrouve:			move.l	a0,d0			movem.l	(sp)+,d3-d7/a1-a4			rts						DbgInfo.New			ConversionTimeCodePointeur			align 4			ENDP				* ============================================* Fonction ConvertiNumST_String();* ============================================; Cette fonction converti le numéro du sous-titre,; en chaine de caractères affichable;   entrée: d0 nombre;	        a0 bufferConvertiNumST_String PROC EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linknumero		ds.l	1string		ds.l	1textSecondaire	ds.b	256LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize				movem.l	d1/a1,-(sp); sauvegarde des valeurs de départ				move.l	a0,string(a6)			move.l	d0,numero(a6)		and.l	#$00ffffff,d0			clr.w	-(sp)	; numtostring		_Pack7		; numéro secondaire				move.l	numero(a6),d0		rol.l	#8,d0		and.l	#$ff,d0		beq.s	exit; il y un numéro secondaire		lea		textSecondaire(a6),a0		clr.w	-(sp)		_Pack7				move.l	string(a6),a0		move.b	(a0),d0		addq.b	#1,d0		move.b	d0,(a0)		move.b	#'-',(a0,d0.w)				move.l	string(a6),a1		lea		textSecondaire(a6),a0		import	AppendSTr		jsr		AppendSTr		exit	movem.l	(sp)+,d1/a1		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		align 4		DbgInfo.New	ConvertiNumST_String		; this name will appear in the debugger		ENDP*******************************************************************  Ensemble de routine de bas niveau ou bien n'appellant pas *  directement un module "RESQUESTER" pour demander *  à l'utilisateur ses choix.******************************************************************************************************************	*	AppendStr(source str; a0, dest str; a1) **AppendStr	PROC	EXPORT		movem.l	d0/a2-a3,-(sp)		move.l	A0,a2		move.l	A1,a3		move.b	(a1)+,d0		and.l	#$ff,d0		add.l	d0,a1								move.b	(a0),d0		and.l	#$ff,d0		add.l	#1,a0				_BlockMove				move.b	(a3),d0		add.b	(a2),d0		move.b	d0,(a3)		movem.l	(sp)+,d0/a2-a3		rts				DbgInfo.New		AppendStr		align 4			ENDP		************************************************	*	CopyStr(source str; a0, dest str; a1) **		CopyStr			PROC	EXPORT		movem.l	d0,-(sp)		move.b	(a0),d0		addq.b	#1,d0		and.l	#$ff,d0		_BlockMove		movem.l	(sp)+,d0		rts		DbgInfo.New		CopyStr		align 4			ENDP											******************************************************************  Test si un time-code est compris dans un sous-titre*	**	entrée: d0=timecode (format bcd)*			a0=pointeur dans la liste*	sortie:  CCR  positionné*			(= par beq, <> par bne)*			(< par blo)*			(> par bhi)*    * 		d0,a0,a1 sont conservés* 	TestSiDansST	PROC	export				WITH	SOUSTITRERECORD		movem.l	d1,-(sp); on teste si les tc sont valides		and.l	#$3f7f7f3f,d0; tc valides ?				cmp.l	#-1,st_TimeCodeIn(a0)		beq.s	PasDansST		cmp.l	#-1,st_TimeCodeOut(a0)		beq.s	PasDansST				; inférieur tc in ?				move.l	st_TimeCodeIn(a0),d1		and.l	#$3f7f7f3f,d1		cmp.l	d1,d0		blo.s	TSDST_PasDansFenetre_inf	; non en desous		beq.s	TrouveSt					; pile sur le tc in; supérieur tc out				move.l	st_TimeCodeOut(a0),d1		and.l	#$3f7f7f3f,d1		cmp.l	d1,d0		bhi.s	TSDST_PasDansFenetre_sup	; au dessus		TrouveSt		moveq.l	#0,d0 		; pour beq		movem.l	(sp)+,d1		rtsPasDansST		move.l	#-1,d0		movem.l	(sp)+,d1		rtsTSDST_PasDansFenetre_inf		move.l	#-100,d0		movem.l	(sp)+,d1		rts		TSDST_PasDansFenetre_sup		move.l	#100,d0		movem.l	(sp)+,d1		rts				DbgInfo.New	TestSiDansST		align 4			ENDP								******************************************************				* routine de renumération des abs num des sous-titre				***RenumerationAbsST   PROC	EXPORT					WITH	SOUSTITRERECORD					movem.l	d0/a0,-(sp)					moveq	#0,d0					move.l	G.General_PremierSTPtr,a0Loop				addq.l	#1,d0					move.l	d0,st_AbsNUMST(a0)					move.l	(a0),a0					cmp.l	#0,a0					bne.s	Loopexit				movem.l	(sp)+,d0/a0					RTS					DbgInfo.New		RenumabsST					align 4					endP*********************************************************** addition de deux time code*C_AdditionTimeCode 		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordResultat		ds.l	1ParamBegin		EQU	*			; start parameters after this pointTC1				ds.l	1TC2				ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal 	ds.b	256	numSecondaire 	ds.b	256		LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,ConversionTimeCodePointeur,\				SoustractionTimeCode,ConversionASCIIbcdTc,C_ConversionTramesTimeCode,\				C_ConversionTimeCodeTrames		WITH	StackFrame		; cover our local stack frame		link	a6,#LocalSize		movem.l		d2-d3,-(sp)		move.l		TC1(a6),d0		move.l		TC2(a6),d1		; on regarde si le tc de d0= -1	; (cas où on incrémente un tc in ou tc out par les flèches dans saisie); on raz le tc dans ce cas		cmp.l	#-1,d0		bne.s	@a0		moveq	#0,d0		moveq	#0,d1		bra		exit@a0		;sauvergarde des bits spéciaux vérouillage et field select;		move.l		d0,d2		move.l		d1,d3		and.l		#$c0000000,d2		and.l		#$c0000000,d3		or.l		d2,d3		and.l		#$3fffffff,d0		and.l		#$3fffffff,d1		move.l		d0,d2		move.l		d1,d0				clr.l		-(sp)		move.l		d0,-(sp)		bsr 		C_ConversionTimeCodeTrames		move.l		(sp)+,d0				move.l		d0,d1		move.l		d2,d0				clr.l		-(sp)		move.l		d0,-(sp)		bsr 		C_ConversionTimeCodeTrames		move.l		(sp)+,d0				add.l		d1,d0		; on teste si le resultat>24H si oui res=res-24H		cmp.l		#2160000,d0		blt			AddTC_PasSuperieurA24		sub.l		#2160000,d0AddTC_PasSuperieurA24:; on restitue les bits spéciaux				clr.l		-(sp)		move.l		d0,-(sp)		bsr 		C_ConversionTramesTimeCode		move.l		(sp)+,d0		or.l		d3,d0exit	movem.l		(sp)+,d2-d3		move.l		d0,Resultat(a6)		UNLK		A6			; destroy the link		MOVEA.L		(SP)+,A0		; pull off the return address		ADDA.L		#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)		DbgInfo.New		C_AdditionTimeCode		align 4			ENDP**************************************************************************** Routine de conversion du Time code (format BCD), en nombre d'image (binaire) *C_ConversionTimeCodeTrames 		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordResultat		ds.l	1ParamBegin		EQU	*			; start parameters after this pointTC1				ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal 	ds.b	256	numSecondaire 	ds.b	256		LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		link	a6,#LocalSize; d2 =compteur; d3 = scratch reg		movem.l		d1-d5/a0,-(sp)		move.l		TC1(a6),d0		move.l		d0,d3		moveq		#0,d0		moveq		#0,d2		lea.l		CTCT_PuissanceDe25(pc),a0		CTCT_boucle:		move.l	d3,d1		and.l	#$0F,d1		beq.s	CTCT_MultiEgalZero		sub.l	#1,d1		move.l	(a0,d2),d4		CTCT_boucleMultiplication:		add.l	d4,d0		dbra	d1,CTCT_boucleMultiplicationCTCT_MultiEgalZero:				lsr.l	#4,d3		addq.l	#4,d2		cmp.l	#32,d2		blt.s	CTCT_boucle		exit	movem.l		(sp)+,d1-d5/a0		move.l		d0,Resultat(a6)		UNLK		A6			; destroy the link		MOVEA.L		(SP)+,A0		; pull off the return address		ADDA.L		#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New C_ConvTCtrames		CTCT_PuissanceDe25:		dc.l	1		dc.l	10		dc.l	25		dc.l	250		dc.l	1500		dc.l	15000		dc.l	90000		dc.l	900000				align 4			ENDP**********************************************************	Routines de conversion valeur entière en*	time code bcd*C_ConversionTramesTimeCode  		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordResultat		ds.l	1ParamBegin		EQU	*			; start parameters after this pointTC1				ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal 	ds.b	256	numSecondaire 	ds.b	256		LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame		; cover our local stack frame		link	a6,#LocalSize; initialisation		movem.l	d1-d4/a0,-(sp)		move.l	TC1(a6),d0		move.l	d0,d2			lea		CTCT_PuissanceDe25(pc),a0		moveq	#7*4,d1 		adda.l	d1,a0		moveq.l	#0,d4		moveq.l	#0,d0		move.l	#7,d1 ; d1 compteur d'itérationCTCT_Loop:		move.l	(a0),d3CTCT_Loop2:		cmp.l	d3,d2		bcs.s	CTCT_InferieurAPuiss25		sub.l	d3,d2		addq.b	#1,d4		bra.s	CTCT_Loop2CTCT_InferieurAPuiss25		rol.l	#4,d0		or.b	d4,d0				moveq.l	#0,d4		sub.l	#4,a0		dbra	d1,CTCT_Loopexit	movem.l		(sp)+,d1-d4/a0		move.l		d0,Resultat(a6)		UNLK		A6			; destroy the link		MOVEA.L		(SP)+,A0		; pull off the return address		ADDA.L		#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)	; return to the caller				DbgInfo.New	C_ConvTramTC* table des puissances de "25"CTCT_PuissanceDe25:		dc.l	1		dc.l	10		dc.l	25		dc.l	250		dc.l	1500		dc.l	15000		dc.l	90000		dc.l	900000		dc.l	900000						align 4			ENDP*********************************************************** C_Soustraction de deux time code*	 d0= d0-d1 ; ** entrée: d0,d1* sortie: d0 (tc abs) , d1 trames +signe* d1 est conservéC_SoustractionTimeCode 			PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordResultat		ds.l	1ParamBegin		EQU	*			; start parameters after this pointTC1				ds.l	1TC2				ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linknumPrincipal 	ds.b	256	numSecondaire 	ds.b	256		LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionnumeroSTPointeur,ConversionTimeCodePointeur,\				AdditionTimeCode,ConversionASCIIbcdTc,C_ConversionTramesTimeCode,\				C_ConversionTimeCodeTrames		WITH	StackFrame		; cover our local stack frame		link	a6,#LocalSize								movem.l		d2-d4,-(sp)		move.l		TC1(a6),d0		move.l		TC2(a6),d1		; on regarde si le tc de d0= -1	; (cas où on décremente un tc in ou tc out par les flèches dans saisie); on raz le tc dans ce cas		cmp.l	#-1,d0		bne.s	@a0		moveq	#0,d0		moveq	#0,d1		bra		exit@a0		;sauvergarde des bits spéciaux vérouillage et field select     		move.l		d0,d2		move.l		d1,d3		and.l		#$c0000000,d2		and.l		#$c0000000,d3		or.l		d2,d3		and.l		#$3fffffff,d0		and.l		#$3fffffff,d1		move.l		d0,d2		move.l		d1,d0		clr.l		-(sp)		move.l		d0,-(sp)		bsr 		C_ConversionTimeCodeTrames		move.l		(sp)+,d0		move.l		d0,d1		move.l		d2,d0		clr.l		-(sp)		move.l		d0,-(sp)		bsr 		C_ConversionTimeCodeTrames		move.l		(sp)+,d0		; on effectue un teste si les tc ont un code horaire >23 h; ce qui permet le passage par Zéro  result=d0-d1		moveq		#0,d4		cmp.l		#23*90000,d0	; 23 heures => <0 		blo.s		@a1			; pas de problème		moveq		#1,d4@a1		cmp.l		#23*90000,d1	; 		blo.s		@a2		add.w	#2,d4@a2		case#.w		(d4,if),\		(0,DoSub),\		(1,cas1),\		(2,cas2);----cas3	; d0≥23h … d1≥23h	=> r=d1-d0;		exg.l	d0,d1		bra.s	DoSub;----cas2	; d0<23h … d1≥23h	=> r=24h+d0-d1	(passage par zéro)		add.l	#24*90000,d0		bra.s	DoSub;----cas1	; d0≥23h … d1<23h	=> r=d0-(d1+24h);		add.l	#24*90000,d1		bra.s	DoSub;----DoSub	sub.l		d1,d0			move.l		d0,d1; on teste si le resultat<0 si oui res=24H-res; ( 0Heure = 24Heures) 		bpl.s		SubTC_PasNegatif		add.l		#2160000,d0SubTC_PasNegatif:; on restitue les bits spéciaux				clr.l		-(sp)		move.l		d0,-(sp)		bsr 		C_ConversionTramesTimeCode		move.l		(sp)+,d0		or.l		d3,d0exit	movem.l		(sp)+,d2-d4		move.l		d0,Resultat(a6)		UNLK		A6			; destroy the link		MOVEA.L		(SP)+,A0		; pull off the return address		ADDA.L		#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New		C_SoustractionTimeCode		align 4			ENDP* ================================================* PROCEDURE Custom_PLOTCicon(); * ================================================*Custom_PlotCicon		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointitemRect	ds.l	1ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkIconhandle	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubnumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,TxRS422				clr.l	-(sp)		move.w	d0,-(sp)		_GetCIcon		move.l	(sp)+,Iconhandle(a6)		move.l	itemRect(a6),-(sp)		move.l	Iconhandle(a6),-(sp)		_PlotCIcon				move.l	Iconhandle(a6),-(sp)		_DisposCiconexit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.New		Custom_PlotCicon		ENDP* ====================================* PROCEDURE 	OffsetTcListe()* ====================================**   Cette procédure ouvre un dialog pour déterminer une zone d'action*  	dans laquelle on effectue un offset sur les times codes**OffsetTcListe 		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkWindowPtr	DS.L	1			; local Window pointer variableWichControl	DS.L	1			; control en cour de traitementTheDialogSel ds.l	1			; le dialog en questionTheItemHit	ds.w	1			; le item frappéTheItemHitalert	ds.w	1			; le item frappéTheDialogPtr		DS.l	1		; le pointeur local du dialogTheConfirmDialogPtr	DS.l	1		; le pointeur local du dialogItemchoisi		DS.W	1		; Item choisi par l'utilisateuritemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RecttextBuff		ds.b	256textSecondaire	ds.b	256STPtr			ds.l	1		;	adresse du sous-titre trouvé par tcStart			ds.l	1End				ds.l	1Offset			ds.l	1offsetsurblocNote	ds.w	1SaveRgb			ds.w	3backRgb			ds.w	3LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(sp)		clr.l	-(sp)		move.w	#145,-(sp)	; id number		clr.l	-(sp)			move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)  		_DrawDialog		; on trace le contour du bouton rechercher				move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	TheDialogPtr(a6),-(sp)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect				_PenNormal		; on affecte le nouveau état des bouton; toute la liste		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_TouteLaListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue		; en partie		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_PartieDeListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		clr.w	-(sp)		_SetCtlValue			; on désactive les te	from et to		move.w	#Dial_OffsetTcListe_FromTEItem,d0		bsr		HydeDItem		move.w	#Dial_OffsetTcListe_ToTEItem,d0		bsr		HydeDItem		; on affecte le numéro du premier st au début						move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_FromTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	G.General_PremierSTPtr,a0		move.l	st_NumeroST(a0),d0		lea		textBuff(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String						move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText			;; on affecte le numéro du dernier st à fin						move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_ToTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	G.General_DernierSTPtr,a0		move.l	st_NumeroST(a0),d0		lea		textBuff(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String						move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText				move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_OffsetTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		; on place dans la case le dernier offset effectué		move.l	G.offsetTC,d0		lea		textBuff(a6),a0			import	ConversionTCstASCII		jsr		ConversionTCstASCII				move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText				move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_OffsetTEItem,-(sp)		move.w	#0,-(sp)		move.w	#-1,-(sp)		_SelItext														move.l	TheDialogPtr(a6),-(sp)		move.w	#15,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue											move.l	TheDialogPtr(a6),-(sp)		move.w	#8,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_FrameRect				move.l	TheDialogPtr(a6),-(sp)		move.w	#9,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_FrameRect		; *************************************************************Rechercher_Oncontinu:				import	SpecialModalDialogFilter		pea	SpecialModalDialogFilter		pea		Itemchoisi(a6)		_ModalDialog		move.w	Itemchoisi(A6),d0					case#.w	(d0,IF), \		(Dial_OffsetTcListe_OkItem,ok),\		(Dial_OffsetTcListe_AnnulerItem	,Annuler),\		(Dial_OffsetTcListe_TouteLaListeItem,TouteLaListe ),\		(15,offsetsur_BlocNote),\		(Dial_OffsetTcListe_PartieDeListeItem,PartieDeLaListe)		bra		Rechercher_Oncontinuoffsetsur_BlocNote		move.l	TheDialogPtr(a6),-(sp)		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				bsr	ToggleControl		bra		Rechercher_OncontinuTouteLaListe				move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_TouteLaListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_PartieDeListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		clr.w	-(sp)		_SetCtlValue									move.w	#Dial_OffsetTcListe_FromTEItem,d0		bsr		HydeDItem		move.w	#Dial_OffsetTcListe_ToTEItem,d0		bsr		HydeDItem				bra		Rechercher_Oncontinu		PartieDeLaListe				move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_TouteLaListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_PartieDeListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue						move.w	#Dial_OffsetTcListe_FromTEItem,d0		bsr		ChaudDItem				move.w	#Dial_OffsetTcListe_ToTEItem,d0		bsr		ChaudDItem				move.l	TheDialogPtr(a6),-(sp)		_DrawDialog												bra		Rechercher_Oncontinu; -------------------------------------ok; on Recupère la chaine offset		move.w	#true,G.ChangeSinceLastSave		; on indique qu'il y a eu modif				move.l	TheDialogPtr(a6),-(sp)		move.w	#15,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,offsetsurblocNote(a6)						move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_OffsetTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		textbuff(a6)		_GetItext				lea		textbuff(a6),a0		jsr 	ConversionchaineASCIITc 	; on effectue la conversion ou bien la soustraction		cmp.l	#-1,d0		bne.s	@0		; traitement erreur@0				move.l	d0,offset(a6)		move.l	d0,G.offsetTC; on recupère le start item		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_FromTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		textbuff(a6)		_GetItext		pea		textbuff(a6)		import	CHERCHESTPARNUMERO		jsr		CHERCHESTPARNUMERO		tst.l	d1		bne		@1		; traitement erreur		@1		move.l	d0,start(a6); on recupère le end item		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_ToTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		textbuff(a6)		_GetItext		pea		textbuff(a6)		jsr		CHERCHESTPARNUMERO		tst.l	d1		bne		@2		; traitement erreur@2		move.l	d0,end(a6)		move.l	TheDialogPtr(a6),-(sp)		move.w	#Dial_OffsetTcListe_TouteLaListeItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0				beq.s		PasTouteLaListe				move.l	G.General_PremierStPtr,start(a6)		move.l	G.General_DernierStPtr,end(a6)		PasTouteLaListe		; --------------------------------------------; on ouvre un dialog pour confirmer la demande				clr.l	-(sp)		move.w	#146,-(sp)	; id number		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheConfirmDialogPtr(a6)   ;		_DrawDialog		move.l	TheConfirmDialogPtr(a6),-(sp)			_SetPort		; on trace le contour du bouton rechercher				move.l	TheConfirmDialogPtr(a6),-(sp)			move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect		; on affiche les paramètres		move.l	TheConfirmDialogPtr(a6),-(sp)			move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	Start(a6),a0		move.l	st_NumeroST(a0),d0		lea		textBuff(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String						move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText;; on affecte le numéro du dernier st à fin		move.l	TheConfirmDialogPtr(a6),-(sp)			move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	end(a6),a0		move.l	st_NumeroST(a0),d0		lea		textBuff(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String						move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText		; offset		move.l	offset(a6),d0		lea		textBuff(a6),a0			import	ConversionTCstASCII		jsr		ConversionTCstASCII		move.l	TheConfirmDialogPtr(a6),-(sp)		move.w	#5,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText		loop_Confirmoffset				import	SpecialModalDialogFilter		pea	SpecialModalDialogFilter		pea		Itemchoisi(a6)		_ModalDialog				move.w	Itemchoisi(A6),d0		cmp.w	#1,d0		beq.s	OnneffectueLoffset		cmp.w	#2,d0		bne.s	loop_Confirmoffset		move.l	TheConfirmDialogPtr(a6),-(sp)			_DisposDialog		import ActivateFloatersAndFirstDocumentWindow		jsr ActivateFloatersAndFirstDocumentWindow		bra		Rechercher_Oncontinu		OnneffectueLoffset		move.l	TheConfirmDialogPtr(a6),-(sp)		_DisposDialog		import ActivateFloatersAndFirstDocumentWindow		jsr ActivateFloatersAndFirstDocumentWindow; ça y est on effectue l'offset sur la liste				move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		import ActivateFloatersAndFirstDocumentWindow		jsr ActivateFloatersAndFirstDocumentWindow				move.l	start(a6),-(sp)		move.l	end(a6),-(sp)		move.l	offset(a6),-(sp)			;pascal void C_FaitOffset(SousTitreRecordPtr start, SousTitreRecordPtr end	, long offset);			import	C_FaitOffset		jsr		C_FaitOffset				finOffsetSurLaListeLoop						tst.w	offsetsurblocNote(a6)		beq.s	PasModifBlocNote			lea	 	G.BlockNote_tc,a4				; pointeur sur la zone de time-code		move.w	#15,d7		machine	MC68030		ChangeBlockNote_loop				move.l	(a4,d7.w*4),d0		move.l	offset(a6),d1		import	AdditionTimeCode		jsr		AdditionTimeCode		move.l	d0,(a4,d7.w*4)		dbra	d7,ChangeBlockNote_loop		PasModifBlocNote		import	Show_cursor		move.w	#$0505,-(sp)	; on place le bon curseur		jsr		Show_cursor				import	ForceUpdateWindow		jsr		ForceUpdateWindow		import	UpdateGeneralValue		jsr		UpdateGeneralValue		; on actualise le premier et le  dernier tc						bra.s	ExitAnnuler				move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		import ActivateFloatersAndFirstDocumentWindow		jsr ActivateFloatersAndFirstDocumentWindowExit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		align 4		ToggleControl		clr.w	-(sp)		move.l	ItemHandle(a6),-(sp)		_GetCtlValue		move.w	(sp)+,d0		beq		@1		move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue		rts@1		move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue		rts		HydeDItem		move.w	d0,d7		move.l	TheDialogPtr(a6),-(sp)		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	TheDialogPtr(a6),-(sp)		move.w	d7,-(sp)		move.w	#$88,-(sp)		move.l	ItemHandle(a6),-(sp)		pea		itemRect(a6)		_SetDItem		pea		itemRect(a6)		move.w	#-3,-(sp)		move.w	#-3,-(sp)		_Insetrect				pea		itemRect(a6)		_FrameRect				pea		SaveRgb(a6)		_GetForeColor							pea		backRgb(a6)		_GetbackColor					pea		backRgb(a6)		_RGBForeColor			pea		qd.Gray		_PenPat				move.w	#srcBic,-(sp)		_PenMode				pea		itemRect(a6)		_PaintRect		_PenNormal				pea		SaveRgb(a6)		_RGBForeColor		rts				ChaudDItem		move.w	d0,d7		move.l	TheDialogPtr(a6),-(sp)		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	TheDialogPtr(a6),-(sp)		move.w	d7,-(sp)		move.w	#$10,-(sp)		move.l	ItemHandle(a6),-(sp)		pea		itemRect(a6)		_SetDItem		rts				DbgInfo.New	OffsetTcListe		; this name will appear in the debugger		ENDP* ================================================* PROCEDURE Configuration_CacheSurZone(); * ================================================**	Cette routine demande à l'utilisateur son choix*	pour les types de caches pour une zone de sous-titresConfiguration_CacheSurZone	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkResult		ds.w	1		; le résultatStartValue	ds.w	1		; la valeur de départTheDialogPtr	DS.l	1			; le pointeur local du dialogItemchoisi		DS.W	1			; Item choisi par l'utilisateuritemType		ds.w	1			; stockage du type de ItemitemHandle		ds.L	1			; stockage	du handle du itemitemRect		ds 		RectpictHandle		ds.l	1ChangeStyleDialog_debut	ds.l	1ChangeStyleDialog_fin	ds.l	1CurrentST		ds.l	1			;textBuff		ds.b	256ItemHit		ds.w	1LocalSize		EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize				move.w	#1,StartValue(a6)		move.w	#1,result(a6)				movem.l	d1-d7/a1-a4,-(sp)		clr.l	-(sp)		move.w	#178,-(sp)	; id number		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)  		_DrawDialog		; on trace le contour du bouton rechercher			move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	TheDialogPtr(a6),-(sp)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect; rectangle		move.w	#1,-(sp)		move.w	#1,-(sp)		_PenSize; ---		move.l	TheDialogPtr(a6),-(sp)		move.w	#12,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_frameRect		; on récupère le sous-titre courant	=> sous titre début;									=> sous titre fin		move.w	G.General_SousTitreEncour,d0		ext.l	d0		import	ConversionNumeroSTPointeur		jsr		ConversionNumeroSTPointeur		move.l	st_NumeroST(a0),d0		lea.l	textBuff(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String						move.l	TheDialogPtr(a6),-(sp)		move.w	#10,-(sp)				; sous titre début			pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText		move.l	G.General_nombreST,d0		import	ConversionNumeroSTPointeur		jsr		ConversionNumeroSTPointeur		move.l	st_NumeroST(a0),d0		lea.l	textBuff(a6),a0		import	ConvertiNumST_String		jsr		ConvertiNumST_String				move.l	TheDialogPtr(a6),-(sp)		move.w	#11,-(sp)				; sous titre fin		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_SetIText		; ---------------------------------------		;		move.l	TheDialogPtr(a6),-(sp)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameREct		move.w	StartValue(a6),d0		cmp.w	#4,d0		blo		PasDeProbleme		moveq	#0,d0PasDeProbleme				bsr	configDialog; ---------------------------------------------------		WaitEvent		move.l	TheDialogPtr(a6),-(sp)		_SetPort				import	SpecialModalDialogFilter		pea	SpecialModalDialogFilter		pea	ItemHit(a6)		_ModalDialog		move.w	ItemHit(a6),d7				move.l	TheDialogPtr(a6),-(sp)		_SetPort				move.l	TheDialogPtr(a6),-(sp)		move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		case#.w	(d7,if),\		(1,ok),\		(2,cancel),\		(5,DOCache),\		(6,DOCache),\		(7,DOCache),\		(8,DOCache)		bra	WaitEvent	; on configure le dialog en fct de la valeur DOCache				move.w	d7,d0		subq.w	#5,d0		move.w	d0,result(a6)				bsr	configDialog				bra		WaitEvent; -------------------------------------------------------------------------				ok		; on récupère le sous titre de départ		move.l	TheDialogPtr(a6),-(sp)		move.w	#10,-(sp)	 		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_GetItext				lea		textBuff(a6),a0				pea		textBuff(a6)		import	CHERCHESTPARNUMERO		jsr		CHERCHESTPARNUMERO		tst.l	d1		bne		@1; traitement erreur		@1		move.l	d1,ChangeStyleDialog_debut(a6); on récupère le sous titre de fin		move.l	TheDialogPtr(a6),-(sp)		move.w	#11,-(sp)	 		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		pea		textBuff(a6)		_GetItext		lea		textBuff(a6),a0		pea		textBuff(a6)		import	CHERCHESTPARNUMERO		jsr		CHERCHESTPARNUMERO		tst.l	d1		bne		@2; traitement erreur@2		move.l	d1,ChangeStyleDialog_fin(a6)	; on ferme le dialog		move.l	TheDialogPtr(a6),-(sp)		_DisposDialog; on effectue le rafraichissement de fenètres; on effectue le changement		move.l	ChangeStyleDialog_debut(a6),CurrentST(a6)Loop_Changement				move.l	CurrentST(a6),d0		import	ConversionNumeroSTPointeur		jsr		ConversionNumeroSTPointeur		move.w	result(a6),d0		move.b	d0,st_MasKType(a0)		add.l	#1,CurrentST(a6)		move.l	CurrentST(a6),d0		cmp.l	ChangeStyleDialog_fin(a6),d0		ble		Loop_Changement		; ----------------; les changements sont finis				import	ForceUpdateWindow		jsr		ForceUpdateWindow; on donne ordre de redessiné le sous-titre à l'écran		tst.l	G.Base_Adresse			; il y a t-il une carte d'affichage 		beq.s 	Pas_deCarteAffichage_1			; non on ne fait rien				move.w	#$8000,G.DrawState	; travail effectué par la VBL task@azert_1		move.w	G.DrawState,d0	; on attend que la vbltask est terminée		bmi.s	@azert_1; on raz la carte d'affichage		import	Clear_Buffer					jsr		Clear_Buffer					clr.l	G.Sous_titre_dessined	; on indique que la carte est vide		clr.l	G.Sous_titreInOffscreen	; on invalide le sous-titre dans le offscreen buffPas_deCarteAffichage_1		bra  	Exit		Cancel					move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		move.w	d0,-(sp)		JMP	(A0); ------------- sub routine -----------------------------		configDialog		movem.w	d7,-(sp)		move.w	d0,d7		move.l	TheDialogPtr(a6),-(sp)		move.w	#5,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l	TheDialogPtr(a6),-(sp)		move.w	#6,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l	TheDialogPtr(a6),-(sp)		move.w	#7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue						move.l	TheDialogPtr(a6),-(sp)		move.w	#8,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				; on active le item sélectionné		move.w	d7,d0		addq.W	#5,d0				move.l	TheDialogPtr(a6),-(sp)		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue				; on affiche le pict		move.l	TheDialogPtr(a6),-(sp)		move.w	#9,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				add.w	#134,d7	; figure de base 		clr.l	-(sp)		move.w	d7,-(sp)		_GetPicture		move.l	(sp)+,pictHandle(a6)		; picture handle; on affiche le "picture"		move.l	pictHandle(a6),-(sp)		pea		itemRect(a6)		_drawPicture				move.l	pictHandle(a6),-(sp)		_ReleaseResource				movem.w	(sp)+,d7		rts						dbgInfo.new	Configuration_CacheSurZone		endp	* ======================================================================*	Fonction	Do_Enchaine();* ======================================================================** Cette routine effectue un enchaîné* Les enchaînés sont des sous-titres ooù l'interval est égals à l'interval minimum* on peut peut donc en appuyant sur une touche effectuer la saisie du tc out du tc en cour* insérer un sous-titre (sauf condition ou il y a un st à la suite et que le tc out est vide)* et marquer le tc in * il y a deux mode: on ajoute l'interval sur le tc in du ST suivant ou on soustrait l'interval* sur le tc out du st courant.*Do_Enchaine	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordSTPtr		ds.l	1		; le soustitretcCourant	ds.l	1		; le timecodeParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linktextbuff	ds.b	256ItemType		ds.w	1ItemHandle		ds.l	1itemRect		ds		rectLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand,\				AdjustMenus,ConversionNumeroSTPointeur,TransfertSaisieMemoire,\				insertST,CalculDuree		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame				link	a6,#LocalSize				; on sauvegarde la valeur du time-code (car cela peut changer en cours de manipulation)		move.l	G.General_TCCourant,d0		and.l	#$3fffffff,d0			; on masque le field 2		move.l	d0,tcCourant(a6)				clr.w	-(sp)		move.w	#TimecodeOut_SousTitrebcd,-(sp)		move.l	#0,-(sp)		move.l	STPtr(a6),a0		move.l	st_AbsNUMST(a0),-(sp)		move.l	st_timecodeOut(a0),-(sp)		import	DoMakeUndo		jsr		DoMakeUndo		move.w	(sp)+,d0				;DoMakeUndo(TimecodeIn_SousTitrebcd,0,		;					ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);; on ferme un te s'il y en a un ouvert 		jsr		TransfertSaisieMemoire		pea		G.DialogSaisie 		move.w	#DialSaisie_TcOutTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				; le mode addition au tc fin est actif		move.l	tcCourant(a6),d0				tst.w	G.Preference_Enchaine			bne.s	PasSubToOut; nous sommes dans le mode soustraction au point de sortie		move.w	G.Preference_Interval,d1		and.l	#$ffff,d1		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		move.l	tcCourant(a6),d0		and.l	#$3fffffff,d0			; on masque le field 2		import	SoustractionTimeCode		jsr		SoustractionTimeCode		PasSubToOut		move.l	stPtr(a6),a0		and.l	#$3f7f7f3f,d0			; on masque le field 2		move.l	d0,st_timecodeOut(a0)		lea		textbuff(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII		; on affiche le time code out					lea.l	G.DialogSaisie,a0		MOVE.L	ClipRgn(a0),-(SP)		pea 	portRect(a0)				; rectangle	on masque le reste		_RectRgn				move.w	#Monaco,-(sp)		_TextFont		move.w	#14,-(sp)		_TextSize				lea		textbuff(a6),a0		move.b	(a0)+,d0		move.l	a0,-(sp)		and.l	#$ff,d0		move.l	d0,-(sp)		pea		itemRect(a6)		move.w	#0,-(sp)		_textBox					move.w	#9,-(sp)		_TextSize		; on insère un nouveau sous-titre dans la liste; on sauvegarde la valeur en cour		jsr		CalculDuree			; on vérifie que les temps ne sont pas trop cours;		move.l	soustitrePtr,-(sp);		move.l	#parramètres,-(sp);		jsr		VerifieST;		cmp.l	#-1,d0;		beq		Exit	    ; attention il y a erreur; on regarde s'il faut inserer un sous-titre		move.w	G.General_SousTitreEncour,d0		and.l	#$FFFF,d0		jsr		ConversionNumeroSTPointeur		clr.l	d0; y a t-il un sous-titre suivant ?		tst.l	(a0)		beq.s	Insere_Soustitre	; non il faut insérer un sous-titre		move.l	(a0),a1				add.w	#1,G.General_SousTitreEncour	; on passe au sous-titre suivant; oui il y a un st derrière faut-il insérer un st quand même; on ne le fait pas si le st suivant a un tc out; le sous titre suivant a t-il un timecode de sortie ?		cmp.l	#-1,st_TimeCodeOut(a1)			beq		PasInsere_SoustitreInsere_Soustitre				jsr		insertST	PasInsere_Soustitre			; on recupère l'adresse du nouveau sous-titre en cours 		move.w	G.General_SousTitreEncour,d0		and.l	#$FFFF,d0		jsr		ConversionNumeroSTPointeur		move.l	a0,StPtr(a6)		; on est au sous-titre suivant; on affecte le time code au point d'entrée		clr.w	-(sp)		move.w	#TimecodeIn_SousTitrebcd,-(sp)		move.l	#0,-(sp)		move.l	STPtr(a6),a0		move.l	st_AbsNUMST(a0),-(sp)		move.l	st_TimeCodeIn(a0),-(sp)		import	DoMakeUndo		jsr		DoMakeUndo		move.w	(sp)+,d0				;DoMakeUndo(TimecodeIn_SousTitrebcd,0,		;					ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);		move.l	tcCourant(a6),d0		tst.w	G.Preference_Enchaine			beq		PasaddToin		; Nous Sommes dans le mode addtition au tc in suivant				move.w	G.Preference_Interval,d1		and.l	#$ffff,d1		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		move.l	tcCourant(a6),d0		import	AdditionTimeCode		jsr		AdditionTimeCodePasaddToin				move.l	stPtr(a6),a0		move.l	d0,st_timeCodeIN(a0)		lea		textbuff(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				pea		G.DialogSaisie 		move.w	#DialSaisie_TcInTEItem,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						lea.l	G.DialogSaisie,a0		MOVE.L	ClipRgn(a0),-(SP)		pea 	portRect(a0)				; rectangle	on masque le reste		_RectRgn		move.w	#Monaco,-(sp)		_TextFont		move.w	#14,-(sp)		_TextSize				lea		textbuff(a6),a0		move.b	(a0)+,d0		move.l	a0,-(sp)		and.l	#$ff,d0		move.l	d0,-(sp)		pea		itemRect(a6)		move.w	#0,-(sp)		_textBox					move.w	#9,-(sp)		_TextSize		; on rafraichie la fenètre listing				import	CentreListingWindow		jsr		CentreListingWindow; on redessine la fenètre saisie		pea		G.DialogSaisie 		_SetPort				pea		G.DialogSaisie 		import	SelectReferencedWindow		jsr		SelectReferencedWindow		lea		G.DialogSaisie,a0		pea		PortREct(a0)		_InvalRect		move.w	#True,G.ChangeSinceLastSave			; on indique qu'il y a eu du changementexit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		dbgInfo.New	Do_Enchaine* =========================================* PROCEDURE   	ForceUpdateWindow()* =========================================; Cette routine affiche le contenu du block noteForceUpdateWindow	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkSavePort	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame				link	a6,#LocalSize		pea		SavePort(a6)		_GetPort		pea		G.DialogSaisie		_SetPort				lea		G.DialogSaisie,a0		pea		PortREct(a0)		_InvalRect					pea		G.listingWindow		_SetPort						lea		G.listingWindow,a0		pea		PortREct(a0)		_InvalRect						pea		G.BlockNoteWindow		_SetPort						lea		G.BlockNoteWindow,a0		pea		PortREct(a0)		_InvalRect						move.l	SavePort(a6),-(sp)		_SetPort		Exit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.New	ForceUpdateWindow		align 4			ENDP			******************************************************************* 	fonction d'alignement des registres d0 ou d1 sur un modulo 4******************************************************************AligneD0	proc 	Export		movem.l	d1,-(sp)		movem.l	d0,-(sp)		move.l	d0,d1		and.l	#$3,d1		beq.s	@1		neg.w	d1		add.w	#4,d1@1		add.l	d1,d0	; longueur ajustée sur ds.l			movem.l	(sp)+,d1		movem.l	(sp)+,d1		rts		dbgInfo.new		AligneD0		endpAligneD1	proc 	Export		movem.l	d0,-(sp)		movem.l	d1,-(sp)		move.l	d1,d0		and.l	#$3,d0		beq.s	@1		; reste nul donc aligné		neg.w	d0		add.w	#4,d0@1		add.l	d0,d1	; longueur ajustée sur ds.l			movem.l	(sp)+,d0		movem.l	(sp)+,d0		rts		dbgInfo.new		AligneD0		endp							end						