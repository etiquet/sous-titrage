	PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	PRINT	POP				IMPORT	qd:MyQDGlobals	IMPORT	G:AppGlobals			* ================================================* PROCEDURE  VerifieTimeCodes()* ================================================***	Cette routine vérifie la conformitée des time codes =>*	tc out > tc in*	interval // tc précédent*  	interval // tc suivant*VerifieTimeCodes  		PROC	EXPORT				StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointStPTR			ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkitemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		ds		rectStrItemText		ds.b	256SelBool			ds.w	1	; sauvegarde du paramètre de retour de DialogSelectPtrSousTitre 	ds.l	1longueur 		ds.l	1tcinstr			ds.b	32tcoutstr		ds.b	32comStr			ds.b	256texte			ds.b	256oldport			ds.l	1LocalSize		EQU 	*			; size of all the local variables		ENDR			with	SOUSTITRERECORD,StackFrame			link	a6,#LocalSize			import	ConversionASCIIbcdTc,ConversionNumeroSTPointeur					movem.l	d1-d7/a0-a4,-(sp)		pea		oldport(a6);		_GetPort		pea		G.DialogSaisie 		_SetPort;-------------- on vérifie l'interval minimum // st précédent ---------; si te ouvert on ne fait pas le testkjyh		move.l	G.SaisieTE,d0		bne		Exit					move.l	stPtr(a6),a0		move.l	st_previousST(a0),d0		beq 	Tcout_precedent_NIL		; pas de st précédent		move.l	d0,a1		move.l	st_timeCodeIN(a0),d0	; tc in		move.l	st_timeCodeOUT(a1),d1	; tc out st précédent		cmp.l	#-1,d1					; tc valide ?		beq 	Tcout_precedent_NIL		; non		cmp.l	#-1,d0					; tc valide ?		beq 	Tcout_precedent_NIL		; non		; on vérifie que nous respectons l'interval minimum		import	SoustractionTimeCode		jsr		SoustractionTimeCode				cmp.w	G.Preference_Interval,d1		bge		Tcout_precedent_NIL				; on respecte l'interval minimum; non on ne respecte pas l'interval minimum		cmp.w	#3,G.Preference_UtilCheck		; pas de vérification ?		beq		Tcout_precedent_NIL				; pas de vérif...; on inverse l'item tc in	et interval		pea		G.DialogSaisie 		move.w	#23,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_inverRect				pea		G.DialogSaisie 		move.w	#20,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect						move.W	#10,-(sp)		_SysBeep				pea		G.DialogSaisie 		move.w	#23,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_inverRect				pea		G.DialogSaisie 		move.w	#20,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect; ---		cmp.w	#2,G.Preference_UtilCheck		; vérif à la dure		bne		Tcout_precedent_NIL				; non pas vérif à la dure		clr.w	-(sp)		move.w	#165,-(sp)			; erreur interval //st précedent		clr.l	-(sp)		_Alert		move.w	(sp)+,d0;-------------- on vérifie l'interval minimum // st suivant ---------Tcout_precedent_NIL					move.l	stPtr(a6),a0		move.l	st_nextST(a0),d0		beq		Tcin_suivant_NIL		; pas de st suivant		move.l	d0,a1		move.l	st_timeCodeIN(a1),d0	; tc in st suivant		move.l	st_timeCodeOUT(a0),d1	; tc out 		cmp.l	#-1,d1					; tc valide ?		beq 	Tcin_suivant_NIL		; non		cmp.l	#-1,d0					; tc valide ?		beq 	Tcin_suivant_NIL		; non		; on vérifie que nous respectons l'interval minimum		import	SoustractionTimeCode		jsr		SoustractionTimeCode				cmp.w	G.Preference_Interval,d1		bge 	Tcin_suivant_NIL				; on respecte l'interval minimum; non on ne respecte pas l'interval minimum		cmp.w	#3,G.Preference_UtilCheck		; pas de vérification ?		beq		Tcin_suivant_NIL				; pas de vérif...; on inverse l'item tc out et interval				pea		G.DialogSaisie 		move.w	#23,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_inverRect				pea		G.DialogSaisie 		move.w	#21,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect						move.W	#10,-(sp)		_SysBeep				pea		G.DialogSaisie 		move.w	#21,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect		pea		G.DialogSaisie 		move.w	#23,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_inverRect; ---		cmp.w	#2,G.Preference_UtilCheck		; vérif à la dure		bne		Tcin_suivant_NIL				; non pas vérif à la dure		clr.w	-(sp)		move.w	#166,-(sp)			; erreur interval //st suivant		clr.l	-(sp)		_Alert		move.w	(sp)+,d0; ----------------- on vérifie que tc out > tc in ------------------------Tcin_suivant_NIL			move.l	stPtr(a6),a0		move.l	st_timeCodeIN(a0),d1	; tc in 		move.l	st_timeCodeOUT(a0),d0	; tc out 		cmp.l	#-1,d1					; tc valide ?		beq 	Exit		; non		cmp.l	#-1,d0					; tc valide ?		beq 	Exit		; non		; on vérifie que nous respectons l'interval minimum		import	SoustractionTimeCode		jsr		SoustractionTimeCode				tst.l	d1		bgt 	Exit			; tc in < tc out; non on ne respecte pas l'interval minimum		cmp.w	#3,G.Preference_UtilCheck		; pas de vérification ?		beq		Exit				; pas de vérif...; on inverse l'item tc in					pea		G.DialogSaisie 		move.w	#20,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect				pea		G.DialogSaisie 		move.w	#21,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect				move.W	#10,-(sp)		_SysBeep				pea		G.DialogSaisie 		move.w	#20,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect				pea		G.DialogSaisie 		move.w	#21,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_inverRect; ---		cmp.w	#2,G.Preference_UtilCheck		; vérif à la dure		bne		Exit				; non pas vérif à la dure		clr.w	-(sp)		move.w	#167,-(sp)			; erreur tc in > tc out		clr.l	-(sp)		_Alert		move.w	(sp)+,d0	Exit		move.l	oldport(a6),-(sp)			_SetPort			movem.l	(sp)+,d1-d7/a0-a4			UNLK	A6			MOVEA.L	(SP)+,A0		; save the caller's address			ADDA.L	#ParamSize,SP		; strip the caller's parameters			JMP	(A0)						DbgInfo.New	VerifieTimeCodes			align 4				ENDP					* ================================================* PROCEDURE  TransfertMemoireSaisie()* ================================================** C'est la routine qui transfère le contenu en mémoire d'un sous-titre * dans le  dialog saisie*TransfertMemoireSaisie  		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkoldport		ds.l	1LocalSize		EQU 	*			; size of all the local variables		ENDR			with	SOUSTITRERECORD,StackFrame			link	a6,#LocalSize			import	ConversionASCIIbcdTc,\			ConversionNumeroSTPointeur,ConversionTCstASCII,\			CalculDuree									movem.l	d0-d7/a0-a4,-(sp)			pea		oldport(a6)			_GetPort						pea		G.DialogSaisie			_SetPort						lea		G.DialogSaisie,a0  			pea		portRect(a0)			_InvalRect			move.l		oldport(a6),-(sp)			_SetPort			exit		movem.l	(sp)+,d0-d7/a0-a4			UNLK	A6			MOVEA.L	(SP)+,A0		; save the caller's address			ADDA.L	#ParamSize,SP		; strip the caller's parameters			JMP	(A0)									DbgInfo.New	TransfertMemoireSaisie			align 4			ENDP* =========================================* PROCEDURE   AFFICHENUMSAISIE()* =========================================; Cette procédure transfert le numéro du sous-titre en cours dans ; les cases nombre total ST et num sous-titre;AFFICHENUMSAISIE	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkitemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	Recttextbuff	ds.b	256textbuff2	ds.b	256	LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame				link	a6,#LocalSize				pea		G.DialogSaisie 		move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem									Exit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.New	affNumSaisie		align 4			ENDP												* ================================================* PROCEDURE Configuration_Cache(); * ================================================**	Cette routine demande à l'utilisateur son choix*	pour les types de caches pour le sous-titresConfiguration_Cache	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		ds.w	1		; le résultatParamBegin	EQU	*			; start parameters after this pointStartValue	ds.w	1		; la valeur de départParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTheDialogPtr	DS.l	1			; le pointeur local du dialogItemchoisi		DS.W	1			; Item choisi par l'utilisateuritemType		ds.w	1			; stockage du type de ItemitemHandle		ds.L	1			; stockage	du handle du itemitemRect		ds 		RectpictHandle		ds.l	1ItemHit			ds.w	1LocalSize		EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(sp)		clr.l	-(sp)		move.w	#177,-(sp)	; id number		clr.l	-(sp)			move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)  		_DrawDialog		; on trace le contour du bouton rechercher			move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	TheDialogPtr(a6),-(sp)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect; rectangle		move.w	#1,-(sp)		move.w	#1,-(sp)		_PenSize		; ---------------------------------------		;		move.l	TheDialogPtr(a6),-(sp)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		itemRect(a6)		_FrameREct		move.w	StartValue(a6),d0		cmp.w	#4,d0		blo		PasDeProbleme		moveq	#0,d0PasDeProbleme				bsr	configDialog		move.w	StartValue(a6),result(a6); ---------------------------------------------------		WaitEvent		move.l	TheDialogPtr(a6),-(sp)		_SetPort				import	SpecialModalDialogFilter		pea	SpecialModalDialogFilter		pea	ItemHit(a6)		_ModalDialog		move.w	ItemHit(a6),d7				move.l	TheDialogPtr(a6),-(sp)		_SetPort				move.l	TheDialogPtr(a6),-(sp)		move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		case#.w	(d7,if),\		(1,ok),\		(2,cancel),\		(5,DOCache),\		(6,DOCache),\		(7,DOCache),\		(8,DOCache)		bra	WaitEvent	; on configure le dialog en fct de la valeur DOCache				move.w	d7,d0		subq.w	#5,d0		move.w	d0,result(a6)				bsr	configDialog				bra		WaitEvent; -------------------------------------------------------------------------				ok		; on ferme le dialog		move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		move.w	#true,G.ChangeSinceLastSave		bra  	Exit		Cancel	move.w	#-1,result(a6)	; pas de choix				move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		Exit	movem.l	(sp)+,d1-d7/a1-a4		move.w	Result(a6),d0		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		move.w	d0,-(sp)		JMP	(A0); ------------- sub routine -----------------------------		configDialog		movem.w	d7,-(sp)		move.w	d0,d7		move.l	TheDialogPtr(a6),-(sp)		move.w	#5,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l	TheDialogPtr(a6),-(sp)		move.w	#6,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l	TheDialogPtr(a6),-(sp)		move.w	#7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				move.l	TheDialogPtr(a6),-(sp)		move.w	#8,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				; on active le item sélectionné		move.w	d7,d0		addq.W	#5,d0				move.l	TheDialogPtr(a6),-(sp)		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue				; on affiche le pict		move.l	TheDialogPtr(a6),-(sp)		move.w	#9,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				add.w	#134,d7	; figure de base 		clr.l	-(sp)		move.w	d7,-(sp)		_GetPicture		move.l	(sp)+,pictHandle(a6)		; picture handle; on affiche le "picture"		move.l	pictHandle(a6),-(sp)		pea		itemRect(a6)		_drawPicture				move.l	pictHandle(a6),-(sp)		_ReleaseResource				movem.w	(sp)+,d7		rts						dbgInfo.new	Configuration_Cache		endp						* ================================================* PROCEDURE DoDialogBlockNoteEvent(Event: EventPtr);* ================================================* Cette routine gère les événements de type mouse down et key down dans la fenètre BlockNoteDoDialogBlockNoteEvent	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointEvenement 		DS.L	1	 		; pointer to current eventParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkitemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectitemType3		ds.w	1		; stockage du type de ItemitemHandle3		ds.L	1		; stockage	du handle du itemitemRect3		DS	Recttextbuff		ds.b	256	textbuff2		ds.b	256duree			ds.l	1IconHandle		ds.l	1ST_EncourPtr	ds.l	1Originalid		ds.l	1originalItem	ds.w	1where			ds.l	1TE				ds.l	1stPtr			ds.l	1Ticks			ds.l	1PopUpMenuHandle	ds.l	1PopUpPoint		ds.l	1mode			ds.w	1texteStyle		ds.b	12		; style pour texte teOriginalid2		ds.l	1IconHandle2		ds.l	1itemType2		ds.w	1		; stockage du type de ItemitemHandle2		ds.L	1		; stockage	du handle du itemitemRect2		DS	RectLastTeItem		ds.w	1the_timeCode	ds.l	1		; le time code courantLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,AFFICHENUMSAISIE,INSERTST,DELETEST, \				ConversionASCIIbcdTc,SoustractionTimeCode,AdditionTimeCode,\				ConversionTCstASCII,ConversionchaineASCIITc,ConversionTimeCode_Trames, \				ConversionTrames_TimeCode,TransfertSaisieMemoire,TransfertMemoireSaisie,\				ControlActionProc,CalculDuree,DOMENUCOMMAND,DrawSt_enCourDansListing								WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame	; on recupère le time code		move.l	G.General_TcCourant,d0		and.l	#$3fffffff,d0			; on masque le field 2		move.l	d0,the_timeCode(a6)		movem.l	d0-d4,-(sp)												move.l	G.BlockNoteWindow,-(sp)		_SetPort				; le port courant				move.w	#Monaco,-(sp)		_TextFont		move.w	#9,-(sp)		_TextSize		; on regarde quel type d'évènement 		move.l	Evenement(a6),a0		move.w	evtNum(a0),d0		beq	Exit								case#.w	(d0,if),\		(mButDwnEvt,mouseDown),\		(KeyDwnEvt,KeyDown),\		(5,KeyDown)					; auto key			bra		Exit; ---------------------------; évènement mouse downmouseDown; on récupère les coordonnées de la souris => coord. locale		move.l		Evenement(a6),a0		move.l		evtMouse(a0),d0		move.l		d0,Where(a6)		move.l		evtTicks(a0),Ticks(a6)		pea			Where(a6)		_GlobalToLocal						clr.w	-(sp)		move.l	G.BlockNoteWindow,-(sp)		move.l	Where(a6),-(sp)		_FindDitem		move.w	(sp)+,d7; l'utilisateur à t-il frapper à coté des items				cmp.w	#-1,d7		beq.s	Acote	; non		; l'utilisateur a-t'il taper dans des items inactivés		add.w	#1,d7				move.w	d7,originalItem(a6)				move.l	G.BlockNoteWindow,-(sp)		move.w	d7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.w	ItemType(a6),d0		and.w	#$80,d0		beq.s	pasAcote	; non l'item est désactivéAcote; oui  on ferme le te actif s'il y  en a un				move.l	G.BlockNoteTE,d0		beq 	Exit	; on ne fait rien		; nous fermons le te en cour		import	Close_BlockNoteTE			jsr		Close_BlockNoteTE				bra		Exit; l'utilisateur n'a pas taper à coté d'un itempasAcote; on regarde si c'est dans un TE ou dans un bouton		move.w	originalItem(a6),d0		cmp.w	#11,d0		blo 	TE_TimeCode		cmp.w	#21,d0		beq		TE_Commentaire		bhi		PasBoutton		; c'est un bouton on hitite ce boutonPasPoutTe		move.w	ItemType(a6),d0		cmp.w	#32,d0		bne		Exit	; pas utilisable pour nous; on affiche l'icône enfoncé		move.w	d7,d0		jsr		findIconResourceDitl		addq.w	#1,d0		move.l	a4,Originalid(a6)		tst.b	G.Mac.HasCOloRQD		beq.s	PasColoRQuickdraw_1				clr.l	-(sp)		move.w	d0,-(sp)		_GetCIcon		move.l	(sp)+,IconHandle(a6)		pea		itemRect(a6)		move.l	IconHandle(a6),-(sp)		_PlotCIcon		move.l	IconHandle(a6),-(sp)		_disposCIcon		bra.s	FinTextAppuye		PasColoRQuickdraw_1				clr.l	-(sp)		move.w	d0,-(sp)		_GetIcon		move.l	(sp)+,IconHandle(a6)		pea		itemRect(a6)		move.l	IconHandle(a6),-(sp)		_PlotIcon		move.l	IconHandle(a6),a0		_disposHandle		; on attend que l'utilisateur est relaché la souris		FinTextAppuye							clr.w	-(sp)		_Button		move.w	(sp)+,d0		bne.s		FinTextAppuye				; on rend à l'icône sa valeur originale				finActivateButton					move.l	G.BlockNoteWindow,-(sp)		move.w	originalItem(a6),-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem							; on reprend les parramètres originaux		tst.b	G.Mac.HasCOloRQD		beq.s	PasColoRQuickdraw_2		pea		itemRect(a6)		move.l	Originalid(a6),-(sp)		_PlotCIcon		bra.s		ferme_LeTE		PasColoRQuickdraw_2				pea		itemRect(a6)		move.l	Originalid(a6),-(sp)		_PlotIcon				clr.l	-(sp)		move.w	d0,-(sp)		_GetIcon		move.l	(sp)+,IconHandle(a6)		pea		itemRect(a6)		move.l	IconHandle(a6),-(sp)		_PlotIcon		; s'il y a un te ouvert on le ferme		ferme_LeTE				import	Close_BlockNoteTE			jsr		Close_BlockNoteTE; on affecte le timecode à la case sélectionnée				move.l	the_timeCode(a6),d0		move.w	originalItem(a6),d1		sub.w	#11,d1		mulu	#4,d1		lea		G.BlockNote_tc,a0		move.l	d0,(a0,d1.w)		; on recopie le TC début du film		move.l	(a0),d1		move.l	d1,G.TcDebutFilm		; maintenant on dessine les time-code				import	DrawBlockNoteValue		jsr		DrawBlockNoteValue				bra		Exit; -----------------------------------------------TE_TimeCodeTE_Commentaire; on regarde s'il y a un te ouvert 		move.l	G.BlockNoteTE,d0		beq		PasDeTEOuvert; il y a un TE ouvert on regarde si l'on à taper dans celui là		move.w	originalItem(a6),d0		cmp.w	G.BlockNoteTE_Item,d0		beq		CestLeMeme		; ce n'est pas le même on ferme tout d'abord celui qui est ouvert				import	Close_BlockNoteTE			jsr		Close_BlockNoteTE				bra		PasDeTEOuvert	; on en ouvre un autre; -------------------------------------------------------		; c'est le même TE; routine pour  séléctionner le contenu du te à la sourisCestLeMeme		move.l	G.BlockNoteTE,a0			move.l	(a0),a1		; un handle		clr.w	-(sp)		move.l	where(a6),-(sp)		pea		teviewRect(a1)		_PtInRect		move.w	(sp)+,d0		beq 	Exit		move.l	where(a6),-(sp)		move.w	evtMeta(a6),d0		AND.w	#512,d0		beq.s	pasExtend				move.w	#true,-(sp)		bra.s	OuiClickDansTeRect_1		pasExtend		clr.w	-(sp)		OuiClickDansTeRect_1			move.l	G.BlockNoteTE,-(sp)		_TEClick		bra		Exit; ----------------------------------; il n'y a pas de TE ouvert on en ouvre unPasDeTEOuvert		tst.l	G.BlockNoteTE		bne		Exit			; oups		move.w	#Monaco,-(sp)		_TextFont			move.w	#9,-(sp)		_TextSize		clr.l	-(sp)		pea		itemRect(a6)		pea		itemRect(a6)		_TEnew		move.l	(sp)+,G.BlockNoteTE				move.w	#tejustleft,-(sp)		move.l	G.BlockNoteTE,-(sp)		_TESetJust		move.w	originalItem(a6),d1		move.w	d1,G.BlockNoteTE_Item	; le N° d'item pour le TE		cmp.w	#21,d1		bne.s	DoTimeCode; c'est le commentaire on le place dans le te commentaire		lea.l	G.BlockNote_texte,a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	G.BlockNoteTE,-(sp)		_teSetText				bra		NoTC; on place le time codeDoTimeCode				subq.W	#1,d1		mulu	#4,d1		lea		G.BlockNote_tc,a0		move.l	(a0,d1.w),d0		cmp.l	#-1,d0		beq		NoTc		; pas de time code				lea.l	textbuff(a6),a0		import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	textbuff(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	G.BlockNoteTE,-(sp)		_teSetTextNoTc						_PenNormal						pea		itemRect(a6)		move.w	#-1,-(sp)		move.w	#-1,-(sp)		_InsetRect						pea		itemRect(a6)		_FrameRect				move.l	G.BlockNoteTE,-(sp)		_TEActivate				move.l	G.BlockNoteTE,a0		move.l	(a0),a0		pea		TeViewRect(a0)		move.l	G.BlockNoteTE,-(sp)		_TEUpdate		; on active le scrolling automatique		move.w	#true,-(sp)		move.l	G.BlockNoteTE,-(sp)		_TEAutoView	; on recupère le scrap général		import	TeFromScrap		clr.w	-(sp)		jsr		TeFromScrap		move.w	(sp)+,d0				bra		Exit; ----------------------------------; s'il ya un te ouvert on le fermePasBouttonOnfermeLeteBlockNote		import	Close_BlockNoteTE			jsr		Close_BlockNoteTE			bra		Exit; ---------------------------KeyDown			move.l	G.BlockNoteTE,d0				beq 	Exit				; le clavier ne sert à rien; on regarde si c'est un TE dans une zone de time code			move.w	G.BlockNoteTE_Item,d0			cmp.w	#11,d0			blo.s	ZoneTimeCode			cmp.w	#21,d0			beq 	Commentaire						bra		Exit; c'est dans un te timecode; on effectue un filtre pour les chiffresZoneTimeCode		move.l	Evenement(a6),a4		move.l	evtMessage(a4),D0		and.l	#$ff,d0				cmp.b	#'0',d0		blo.s	PasChiffreSaisie		cmp.b	#'9',d0		ble 	doSaisieTeKey			; c'est un chiffre => on y va; ----------------------------PasChiffreSaisie		case#.w	(d0,if),\		(1,topText),\		(3,OnfermeLeteBlockNote),\		(8,PasSupKey),\		(28,PasSupKey),\		(29,PasSupKey),\		(30,PasSupKey),\		(31,PasSupKey),\		(31,PasSupKey),\		(' ',doSaisieTeKey),\		(',',doSaisieTeKey),\		(':',doSaisieTeKey),\		('-',doSaisieTeKey),\		('+',doSaisieTeKey),\		($0d,OnfermeLeteBlockNote); le caractère n'est pas acceptable donc on couigne un peu				move.w	#2,-(sp)		_SysBeep		bra	Exit; --------------------------------------------------------Commentaire			move.l	Evenement(a6),a4			move.l	evtMessage(a4),D0			and.l	#$ff,d0			case#.w	(d0,if),\			(1,topText),\			(3,OnfermeLeteBlockNote),\			(8,PasSupKey),\			(28,PasSupKey),\			(29,PasSupKey),\			(30,PasSupKey),\			(31,PasSupKey),\			($0d,PasSupKey)			cmp.b	#' ',d0		; code ascii < $20 ?			blo		Exit		; oui on ne fait rien			; a t-on appuyé sur la touche supression	?doSaisieTeKey		cmp.w	#$7f,d0		bne.s	PasSupKey		; on regarde si nous sommes à la dernière position		move.l	G.BlockNoteTe,a0		move.l	(a0),a0						; handle		move.w	teLength(a0),d1		cmp.w	TeSelStart(a0),d1		beq.s	PasSupKey_1					; nous sommes sur le dernier caractère, on ne fait rien				MOVE.w	#$1d,-(sp)					; flèche droite		move.l	G.BlockNoteTe,-(sp)		_TEKey				MOVE.w	#08,d0					; effacementPasSupKey				MOVE.w	D0,-(sp)		move.l	G.BlockNoteTe,-(sp)		_TEKeyPasSupKey_1				move.w	#True,G.ChangeSinceLastSave			; on indique qu'il y a eu du changement		topTextexit	movem.l	(sp)+,d0-d4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		string pascalfindIconResourceDitl		move.l	G.BlockNoteWindow,a0		move.l	items(a0),a0		move.l	(a0),a0		; handle		;	on a le ditl 				add.l	#2,a0		moveq	#1,d6		move.w	d0,d7SearchLoop		move.l	(a0),a4				move.b	13(a0),d0	; longueur des data		add.l	#14,a0		cmp.w	d7,d6		beq		Zexit	; ça y est ;non on continue		and.l	#$ff,d0		move.l	d0,d1		divu	#2,d1		swap	d1		add.w	d1,d0		and.l	#$ffff,d0	; alignement sur dc.w		add.l	d0,a0		; item suivant		addq.w	#1,d6		bra.s	SearchLoop		Zexit	move.w	(a0),d0		rts; --------------flashButton		move.l	d0,d7		move.l	G.BlockNoteWindow,-(sp)		_SetPort		move.l	G.BlockNoteWindow,-(sp)		move.w	d7,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		move.w	d7,d0		jsr		findIconResourceDitl		addq.w	#1,d0		move.l	a4,Originalid2(a6)		tst.b	G.Mac.HasCOloRQD		beq.s	flashButton_PasColoRQuickdraw_1				clr.l	-(sp)		move.w	d0,-(sp)		_GetCIcon		move.l	(sp)+,IconHandle2(a6)		pea		itemRect2(a6)		move.l	IconHandle2(a6),-(sp)		_PlotCIcon		move.l	IconHandle2(a6),-(sp)		_disposCIcon		bra.s	flashButton_FindItem		flashButton_PasColoRQuickdraw_1				clr.l	-(sp)		move.w	d0,-(sp)		_GetIcon		move.l	(sp)+,IconHandle2(a6)		pea		itemRect2(a6)		move.l	IconHandle2(a6),-(sp)		_PlotIcon				move.l	IconHandle2(a6),a0		_disposHandle		; on attend 8 ticksflashButton_FindItem		move.l	#8,-(sp)		import	WaitTicks		jsr		WaitTicks		tst.b	G.Mac.HasCOloRQD		beq.s	flashButton_PasColoRQuickdraw_2bis		pea		itemRect2(a6)		move.l	Originalid2(a6),-(sp)		_PlotCIcon		bra.s		outOfHere		flashButton_PasColoRQuickdraw_2bis		pea		itemRect2(a6)		move.l	Originalid2(a6),-(sp)		_PlotIconoutOfHere				rts; ------- sub routines pour l'affichage des boutons --------RazIconItem		movem.l	d7/A1-a4,-(sp)		move.w	d0,d7				move.l	G.BlockNoteWindow,-(sp)		move.w	d7,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem				move.w	d7,d0		jsr	findIconResourceDitl		; a4= handle du cicon courant		sub.l	#000014,a0					; a0 pointe sur le debut du ditl		move.l	a0,a3				; sauv		and.l	#$fffc,d0				; on raz les bits de poids faible		move.w	d0,14(a0); on charge un nouveau icon					clr.l	-(sp)		move.w	d0,-(sp)		_GetCIcon		move.l	(sp)+,d0		move.l	d0,Originalid(a6)		move.l	d0,(a3); on affiche l'icône				pea		itemRect2(a6)		move.l	d0,-(sp)		_PlotCIcon		; on dispose l'icon précédent		move.l	a4,-(sp)		_DisposCiconPasChangeIcon_1		movem.l	(sp)+,d7/A1-a4		rts				; routine pour activer un icône		Active_Icon				movem.l	d7/A1-a4,-(sp)		move.w	d0,d7		move.l	G.BlockNoteWindow,-(sp)		move.w	d7,-(sp)		pea		ItemType2(a6)		pea		ItemHandle2(a6)		pea		itemRect2(a6)		_GetDItem		; on active le mode actif dans l'Icon		move.w	d7,d0		jsr	findIconResourceDitl		; a4= handle du cicon courant			sub.l	#0000014,a0				; a0 pointe sur l'item dans la liste		move.l	a0,a3					; sauv		OR.w	#$2,d0					; mode actif		move.w	d0,14(a0); on recupère un handle de la resource		clr.l	-(sp)		move.w	d0,-(sp)		_GetCIcon		move.l	(sp)+,d0		move.l	d0,(a3)		; dans le ditl; on l'affiche				pea		itemRect2(a6)		move.l	d0,-(sp)		_PlotCIcon; on  dispose l'ancien icone				move.l	a4,-(sp)		_DisposCIcon		movem.l	(sp)+,d7/A1-a4		rts		DbgInfo.New	DoDialogBlockNoteEvent			; this name will appear in the debugger		align	4		ENDP							* ================================================* PROCEDURE Close_BlockNoteTE();* ================================================* Cette routine ferme le TE ouvert dans la fenètre block noteClose_BlockNoteTE	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkitemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectBuff			ds.b	256		; buffer pour la conversion des time codesSavePort		ds.l	1		; rectangle		ds		RectLocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,AFFICHENUMSAISIE,INSERTST,DELETEST, \				ConversionASCIIbcdTc,SoustractionTimeCode,AdditionTimeCode,\				ConversionTCstASCII,ConversionchaineASCIITc,ConversionTimeCode_Trames, \				ConversionTrames_TimeCode,TransfertSaisieMemoire,TransfertMemoireSaisie,\				ControlActionProc,CalculDuree,DOMENUCOMMAND,DrawSt_enCourDansListing								WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d0-d4,-(sp)						; on vérifie qu'il y a un TE ouvert dans le dialog		pea		SavePort(a6)								_GetPort		move.l	G.BlockNoteWindow,-(sp)		_SetPort		move.l	G.BlockNoteTE,d0		beq 	Exit			; non il n'y en a pas												; on regarde à quel item correspond le TE						move.w	G.BlockNoteTE_Item,d0		cmp.w	#11,d0		blo		TimeCode_TE		; c'est un TE commentaire				; on récupère le texte  		cmp.w	#21,d0		bne		exit	; on ne fait rien				move.l	G.BlockNoteTE,a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		; longueur du commentaire; 		beq		Exit				; pour l'instant on ne change rien: il n'y a pas de commentaire				cmp.l	#255,d0		blo.s	PasSup255Commentaire		move.l	#255,d0				; on limite le texte à 255 caractères		PasSup255Commentaire				lea.l	G.BlockNote_texte,a1		move.b	d0,(a1)+				; a1 pointe sur le 1er caractère				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove		; on dispose le TE								bra		CloseTE		; ----------------------------------------------------------------------								TimeCode_TE								; on commence par recopier le texte du te dans un buffer		move.l	G.BlockNoteTE,a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		beq		TCinVide								lea.l	Buff(a6),a1		move.b	d0,(a1)+				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove		; on converti la chaine en time code		lea.l	Buff(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine in non valide				import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		bra.s	pasTCinVide; --TCinVide		moveq.l	#-1,d0pasTCinVide; d0 = le time code on le stocke dans la mémoire		lea	 	G.BlockNote_tc,a0				; pointeur sur la zone de time-code		move.w	G.BlockNoteTE_Item,d1		; le n° du te ouvert		subq.W	#1,d1		mulu	#4,d1	; long PTR		move.l	D0,(a0,d1.w)		; on recopie le TC début du film		move.l	(a0),d1		move.l	d1,G.TcDebutFilm; on réaffiche la valeur calculée		lea.l	Buff(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Buff(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	G.BlockNoteTE,-(sp)		_teSetText				bra		CloseTE						; ------- on redessine le TE et on le dispose -----------CloseTE		move.l	G.BlockNoteTE,a0		move.l	(a0),a0		; Handle				lea		teviewRect(a0),a0		move.l	(a0),rectangle(a6)		move.l	4(a0),4+rectangle(a6)					_PenNormal		move.l	G.BlockNoteTE,-(sp)		_TEDeactivate				pea		rectangle(a6)		move.w	#-2,-(sp)		move.w	#-2,-(sp)		_InsetRect				pea		rectangle(a6)		_EraseRect				pea		rectangle(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_InsetRect						pea		QD.gray		_penPat				pea		rectangle(a6)		_FrameRect				_PenNormal		; on place le curseur au début		clr.l	-(sp)		clr.l	-(sp)		move.l	G.BlockNoteTE,-(sp)		_TESetSelect						move.l	G.BlockNoteTE,a0		move.l	(a0),a1		pea		teviewRect(a1)		; tout le rectangle du te		move.l	a0,-(sp)				_TeUpdate				move.l	G.BlockNoteTE,-(sp)		_TeDispose		clr.l	G.BlockNoteTE						clr.w	G.BlockNoteTE_Item		exit	move.l	SavePort(a6),-(sp)		_SetPort		movem.l	(sp)+,d0-d4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	Close_BlockNoteTE			; this name will appear in the debugger		align	4		ENDP		* ================================================* PROCEDURE  DoFonctionKey(the event: eventPtr)* ================================================**	Cette routine effectue le traitement des touches de fonctions*   et appelle Les routines nécessaires genre Domenu, etc…DoFonctionKey 		FUNC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordresult			DS.W	1ParamBegin		EQU	*					; start parameters after this pointTheEvent		ds.l	1				; the eventParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1				; place holder for return addressA6Link			DS.L	1				; place holder for A6 linkSTScrp			ds.l	1				; handle du Style scraptexteStyle		ds.b	12				; st style elementtcCourant		ds.l	1				; tc courant pour enchainéItemType		ds.w	1ItemHandle		ds.l	1itemRect		ds		rectstPtr			ds.l	1oldport			ds.l	1textbuff		ds.b	256LocalSize		EQU 	*				; size of all the local variables		ENDR			import	TransfertSaisieMemoire,CALCULDUREE,TransfertMemoireSaisie,insertST,\					ConversionNumeroSTPointeur			with	SOUSTITRERECORD,StackFrame			link	a6,#LocalSize			movem.l	d0-d7/a0-a4,-(sp)		pea		oldport(a6)		_GetPort	; on regarde si l'évennement est un événement clavier		clr.w		result(a6)		MOVE.L		theEvent(a6),a0			move.W		evtNum(a0),d0		cmp.w		#KeyDwnEvt,d0		bne 		ExitEvenementClavier		move.w	G.General_SousTitreEncour,d0		and.l	#$ffff,d0		jsr		ConversionNumeroSTPointeur		move.l	a0,stPtr(a6)		; on regarde si l'utilisateur à utiliser alt+shift num => si oui on simule touches de fonctions; 1=> f1 … 0=> f10 		move.l	theEvent(a6),a4				move.w	evtMeta(a4),d0		btst 	#optionKey,d0		beq.s	PasPseudoFcnt			; pas pseudo fonction		btst 	#ShiftKey,d0		beq.s	PasPseudoFcnt			; pas pseudo fonction; on convertie le pseudo fct en fct key		move.l	evtMessage(a4),d0		and.l	#$ff,d0;				sub.w	#$12,d0		bmi 	Exit			; pas pseudo fonction on ne fait rien		cmp.w	#$1d,d0		bhi 	Exit			; pas pseudo fonction on ne fait rien		lea		converttable1(pc),a0		move.b	(a0,d0),d0		asl.l	#8,d0		and.l	#$ff00,d0		bra.s	PasPseudoFcnt			; on a converti; --------------		PasPseudoFcnt		move.l	evtMessage(a4),d0		lsr.l	#8,d0		and.l	#$ff,d0		case#.w	(d0,if),\		($7a,Fonction1),\		($78,Fonction2),\		($63,Fonction3),\		($76,Fonction4),\		($60,Fonction5),\		($61,Fonction6),\		($62,Fonction7),\		($64,Fonction8),\		($65,Fonction9),\		($6d,Fonction10),\		($67,Fonction11),\		($6f,Fonction12),\		($69,Fonction13),\		($6b,Fonction14),\		($71,Fonction15)		bra		Exit		Fonction1		move.l	#1,d0		bra.s	GetFonctionNumeroFonction2		move.l	#2,d0		bra.s	GetFonctionNumeroFonction3		move.l	#3,d0		bra.s	GetFonctionNumeroFonction4		move.l	#4,d0		bra.s	GetFonctionNumeroFonction5		move.l	#5,d0		bra.s	GetFonctionNumeroFonction6		move.l	#6,d0		bra.s	GetFonctionNumeroFonction7		move.l	#7,d0		bra.s	GetFonctionNumeroFonction8		move.l	#8,d0		bra.s	GetFonctionNumeroFonction9		move.l	#9,d0		bra.s	GetFonctionNumeroFonction10		move.l	#10,d0		bra.s	GetFonctionNumeroFonction11		move.l	#11,d0		bra.s	GetFonctionNumeroFonction12		move.l	#12,d0		bra.s	GetFonctionNumeroFonction13		move.l	#13,d0		bra.s	GetFonctionNumeroFonction14		move.l	#14,d0		bra.s	GetFonctionNumeroFonction15		move.l	#15,d0; on regarde qu'elle est la fonction dans la table GetFonctionNumero		move.w	#true,result(a6)		lea		G.TableFonctionKeys,a0		move.b	(a0,d0.w),d0			; code de la focntion à effectuer		and.l	#$ff,d0		Case#	(D0,Exit),	\	; if not an event we support, then exit			,		\	;  0 Null (not used)			Annuler,\	 			Refaire,\	 			Couper,\			Copier,\			Coller,\			MarkIn,\			MarkOut,\			Enchaine,\			ChgPlEntree,\			ChgPlSortie,\			ChgPlEntSort,\			CommVide,\			TcDebPlusUn,\			TcDebmoinUn,\			TcfinPlusUn,\			TcfinMoinUn,\			,\			Inserer,\			Supprime,\			,\			fenetreSaisie,\			fenetreListing,\			fenetreTelecomm,\			FenetreTC,\			,\			SauvegardeFichier,\			,\			ModeSaisieTC,\			ModeSaisieTexte,\			ModeAucun,\			,\			Play,\			Stop,\			Playrev,\			FFwd,\			Frew,\			GotoIn,\			GotoOut,\			Eject,\			Still			bra		Exit; ----------------------------Play		move.w	#6,d0			bra		SimulClickInTelecommandeStop		move.w	#5,d0			bra		SimulClickInTelecommandePlayrev		move.w	#4,d0			bra		SimulClickInTelecommandeFFwd		move.w	#3,d0			bra		SimulClickInTelecommandeFrew		move.w	#2,d0			bra		SimulClickInTelecommandeGotoIn		move.w	#12,d0			bra		SimulClickInTelecommandeGotoOut		move.w	#13,d0			bra		SimulClickInTelecommandeStill		move.w	#1,d0			bra		SimulClickInTelecommandeEject		move.w	#7,d0; on simule un click dans la palette télécommande		SimulClickInTelecommande		move.l	G.TELECOMMANDEWindow,-(sp)		_SetPort				move.l	G.TELECOMMANDEWindow,-(sp)		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem							move.l	G.TELECOMMANDEWindow,-(sp)		import	SelectReferencedWindow		jsr		SelectReferencedWindow		; on place les coordonnées du bouton 		move.l	TheEvent(a6),a0				move.w	Top+itemRect(a6),d0		add.w	#5,d0		move.w	d0,top+evtMouse(a0)				move.w	left+itemRect(a6),d0		add.w	#5,d0		move.w	d0,left+evtMouse(a0)				pea		evtMouse(a0)		_LocalToGlobal; on appelle la routine DoMouseDownPaletteTelecommande		move.l	TheEvent(a6),-(sp)		import	DoMouseDownPaletteTelecommande		jsr		DoMouseDownPaletteTelecommande				bra		Exit		; ---------------------------Annuler 		move.w	#1,d0		move.w	#EditMenu,d1		bra		CallMenuRefaire 		move.w	#2,d0		move.w	#EditMenu,d1		bra		CallMenuCouper 		move.w	#4,d0		move.w	#EditMenu,d1		bra		CallMenuCopier 		move.w	#5,d0		move.w	#EditMenu,d1		bra		CallMenuColler 		move.w	#6,d0		move.w	#EditMenu,d1		bra		CallMenu; ----------------------------MarkIn		move.w	#DialSaisie_MarKInItem,d0		bra.s	SimulClickInSaisie		MarkOut		move.w	#DialSaisie_MarkOutItem,d0		bra.s	SimulClickInSaisieTcDebPlusUn		move.w	#DialSaisie_TCInControlplus,d0		bra.s	SimulClickInSaisieTcDebmoinUn		move.w	#DialSaisie_TCInControlmoin,d0		bra.s	SimulClickInSaisieTcfinPlusUn			move.w	#DialSaisie_TCOutControlplus,d0		bra.s	SimulClickInSaisieTcfinMoinUn			move.w	#DialSaisie_TCOutControlmoin,d0; on simule un click dans le dialog saisie		SimulClickInSaisie		pea		G.DialogSaisie 		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem							pea		G.DialogSaisie 		_setPort				pea		G.DialogSaisie 		import	SelectReferencedWindow		jsr		SelectReferencedWindow; on place les coordonnées du bouton 		move.l	TheEvent(a6),a0				move.w	Top+itemRect(a6),d0		add.w	#5,d0		move.w	d0,top+evtMouse(a0)				move.w	left+itemRect(a6),d0		add.w	#5,d0		move.w	d0,left+evtMouse(a0)				pea		evtMouse(a0)		_LocalToGlobal; on appelle la routine MouseDownSaisie		move.l	TheEvent(a6),-(sp)		import	DoDialogSaisieEvent		jsr		DoDialogSaisieEvent				bra		Exit		; -------------------		Enchaine		move.l	stPtr(a6),-(sp)		move.l	G.General_TCCourant,-(sp)		import	Do_Enchaine		jsr		Do_Enchaine		bra		Exit		; ------------------------------------------------------ChgPlEntree		move.w	#1,d7		bra 	DoCommentaireChgPlSortie		move.w	#2,d7		bra 	DoCommentaireChgPlEntSort		move.w	#3,d7		bra 	DoCommentaire		CommVide				move.w	#5,d7DoCommentaire		move.l	G.listingTE,d0		beq.s	NOnPas_TECommentaire_listing		pea		G.listingWindow		_SetPort		move.l	G.listingTE,-(sp)		move.l	G.ListingTEstNum,-(sp)		move.w	G.ListingTEstItem,-(sp)		import	TransfertTE_Memoire		jsr		TransfertTE_Memoire				move.l	G.listingTE,-(sp)		_TeDispose		clr.l	G.listingTENOnPas_TECommentaire_listing		move.l	G.SaisieTE,d0		beq.s	NOnPas_TECommentaire		; il y a un te ouvert; on le ferme		jsr		TransfertSaisieMemoire		cmp.l	#-1,d0			beq		Exit	; il y a erreurNOnPas_TECommentaire					import	GetIndString		pea		TextBuff(a6)		move.w	#128,-(sp)		; "string affichage" resource		move.w	d7,-(sp)		; id du menu		jsr		GetIndString	; on calcule maintenant l'espace nécessaire dans le sous-titre pour stocker la chaîne de commentaire					move.l	stPtr(a6),a0			move.l	st_TexteLenth(a0),d0			import	AligneD0			jsr		AligneD0	; longueur texte aligné dc.l; 								move.l	st_StyleLenth(a0),d1			import	AligneD1			jsr		AligneD1	; longueur styles dc.l			add.l	d1,d0			 			move.l	d0,d4			move.l	a0,a1					; on sauvegarde ce calcul			add.l	#st_SizeOf,d4			adda.l	d4,a1			move.l	a1,a4			move.l	a1,st_CommentairePtr(a0)	; pointeur de la chaine de commentaire			move.b	TextBuff(a6),d1			and.l	#$ff,d1			move.l	d1,st_CommentaireLenth(a0)			add.l	d1,d0					; longueur total st; on calibre la longueur du sous-titre 		; a0 ptr st, d0 longueur demandée (sera alignée ds.l par ecarteSoustitre)					import	EcarteSousTitre			jsr		EcarteSousTitre	;			lea		TextBuff(a6),a0		; chaine de caractères sauvegardé			moveq	#0,d0			move.b	(a0)+,d0			move.l	stPtr(a6),a1			move.l	a4,st_CommentairePtr(a1)	; pointeur de la chaine de commentaire			move.l	d0,st_Commentairelenth(a1)	; pointeur de la chaine de commentaire			move.l	a4,a1			_blockMove; 								jsr		TransfertMemoireSaisie;  on regarde si le st en cour est dans saisie		pea		G.ListingWindow		_SetPort				lea		G.ListingWindow,a0		move.l	clipRgn(a0),-(sp)		pea		PortRect(a0)		_RectRgn				; initialisation de quick-draw de la police et tout et tout		MOVE.W		#SrcCopy,-(SP)					; source mode		_TextMode		MOVE.W		#Monaco,-(SP)					; Monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace		move.w	#1,-(sp)	   	move.w	#1,-(sp)	   	_PenSize	   	move.w	#SrcCopy,-(sp)	   	_PenMode				clr.w	-(sp)		move.l	G.ListingVScroll,-(sp)		_GetCtlValue		move.w	(sp)+,d1		move.w	G.General_SoustitreEnCour,d0		cmp.w	d1,d0		blo		PasSaisieActif		; pas dans la fenètre		add.w	G.ListingMaxDisplay,d1		cmp.w	d1,d0		bhi.s	PasSaisieActif		; pas dans la fenètre; le sous-titre est bien dans la fenètre listing				clr.w	-(sp)		move.l	G.ListingVScroll,-(sp)		_GetCtlValue		move.w	G.General_SoustitreEnCour,d0		sub.w	(sp)+,d0			move.l	stPtr(a6),-(sp)		mulu	#ListingHauteurCarreST,d0			clr.w	-(sp)		move.w	d0,-(sp)						lea		G.ListingWindow,a0		move.l	4+PortRect(a0),-(sp)		move.l	PortRect(a0),-(sp)				import	DrawOneSousTitre			;(le sous-titre: ptr; h,v :point; windowRect: rect)			jsr		DrawOneSousTitrePasSaisieActif			pea		G.DialogSaisie		_SetPort		move.w	#True,G.ChangeSinceLastSave			; on indique qu'il y a eu du changement		bra		Exit; -------------------Inserer			move.w	#InsererSTItem,d0		move.w	#EditMenu,d1		bra		CallMenuSupprime		move.w	#OterSTItem,d0		move.w	#EditMenu,d1		bra		CallMenufenetreSaisie		move.w	#3,d0		move.w	#132,d1		bra		CallMenufenetreListing		move.w	#4,d0		move.w	#132,d1		bra		CallMenufenetreTelecomm		move.w	#7,d0		move.w	#132,d1		bra		CallMenuFenetreTC			move.w	#8,d0		move.w	#132,d1		bra		CallMenu		SauvegardeFichier			move.w	#SaveItem,d0		move.w	#FileMenu,d1		bra		CallMenuModeSaisieTC		move.w	#SaisieMode_TimecodeItem,d0		move.w	#ModeTravailMenu,d1		bra		CallMenuModeSaisieTexte		move.w	#SaisieMode_TexteItem,d0		move.w	#ModeTravailMenu,d1		bra		CallMenuModeAucun					move.w	#SaisieMode_AucunItem,d0		move.w	#ModeTravailMenu,d1		bra		CallMenu		; on simule une commande par les menuCallMenu		move.w	d0,-(sp)		;MenuItem			move.w	d1,-(sp)		;MenuID			import	DoMenuCommand		jsr		DoMenuCommand		exit	move.l	oldport(a6),-(sp)		_SetPort		movem.l	(sp)+,d0-d7/a0-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)converttable1:		dc.b	$7a,$78,$63,$76,$61,$60,$6f,$65,$62,$67,$64,$6d										DbgInfo.New	DoFonctionKey		align 4			ENDP					END