#include "BB.Globals_C.h"#include <Devices.h>#include  "PrivateDialogLibraries.h"// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;/* *	Dialog Module, created by Resorcerer		light Modified by Eric Tiquet  */#include <StdArg.h>#include <stdio.h>#define thisDialogID 273/* Symbolic Dialog Item Numbers */extern short gAppResFileNumber;static enum {	CTRL1 = 1,	CTRL2,	CTRL3,	CTRL4,	CTRL5,	CTRL6,	CTRL7,	CTRL8,	CTRL9,	CTRL10,	CTRL11,	CTRL12,	CTRL13,	CTRL14,	CTRL15,	STXT16_F1,	STXT17_F2,	STXT18_F3,	STXT19_F4,	STXT20_F5,	STXT21_F6,	STXT22_F7,	STXT23_F8,	STXT24_F9,	STXT25_F10,	STXT26_F11,	STXT27_F12,	STXT28_F13,	STXT29_F14,	STXT30_F15,	BUT31_OK,	BUT32_Par,	BUT33_Annuler,	USER34,	LASTITEM	};#define OK_ITEM 	BUT31_OK#define CANCEL_ITEM 	33 /* Define this to be item that cancels dialog *//* Useful constants */#ifndef ENTERkey#define ENTERkey	0x3#endif#ifndef DELETEkey#define DELETEkey	0x8#endif#ifndef NIL#define NIL ((void *)0)#endif#ifndef TRUE#define TRUE 1#endif#ifndef FALSE#define FALSE 0#endif#ifndef FRONT_WINDOW#define FRONT_WINDOW  ((WindowPtr) (-1L))#endif/* Prototypes */int		C_ConfigureToucheFonctions(void);static DialogPtr OpenThisDialog(void);static void			CloseThisDialog(DialogPtr dlog);static void			DoDialogUpdate(DialogPtr dlog);static void			DoDialogActivate(DialogPtr dlog, int activ);static void			DoDialogContent(DialogPtr dlog, EventRecord *evt);static int			DoDialogItem(DialogPtr dlog, short itemHit);static pascal  Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit);static Boolean CheckUserItems(Point where, short *itemHit);static int     AnyBadValues(DialogPtr dlog);static Point where;static int modifiers;/* *	Display this modal dialog.  Return TRUE if OK, FALSE if CANCEL or error. *	If the dialog displays values from outside this module, you should either *	import them from globals, or change the argument list of this routine to *	bring them in and pass them to OpenThisDialog(), DoDialogItem(), etc. */int C_ConfigureToucheFonctions(void)	{		short itemHit,i,okay,keepGoing=TRUE;		register DialogPtr dlog; GrafPtr oldPort;		Handle hndl; short type; Rect box;		/* Build dialog window and install its item values */				GetPort(&oldPort);		dlog = OpenThisDialog();		if (dlog == NIL) return(FALSE);		/* Entertain filtered user events until dialog is dismissed */				while (keepGoing) {			ModalDialog(MyFilter,&itemHit);			keepGoing = DoDialogItem(dlog,itemHit);			}				/*		 *	Do final processing of item values, such as exporting them to caller.		 *	DoDialogItem() has already called AnyBadValues().		 */				if (okay = (itemHit==OK_ITEM)) {		/* Or whatever is equivalent */						for (i=1;i<16;i++) {				GetDialogItem(dlog,i,&type,&hndl,&box);				G.TableFonctionKeys[i]=GetControlValue((ControlHandle)hndl);			}									}		/* That's all, folks! */				CloseThisDialog(dlog);		SetPort(oldPort);		SetDialogFont(0); 		return(okay);	}/* *	We have to have a filter function, at the very least so that we can outline *	any default button, entertain keyboard editing commands, cmd-period canceling, etc. *	Note that you do not need to have a special user item covering the default button *	in your dialog item list. */static pascal Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit)	{		Boolean ans=FALSE,doHilite=FALSE; WindowPtr w,window;		short type,ch,part; Handle hndl; Rect box;		static long then; static Point clickPt;				w = (WindowPtr)(evt->message);		switch(evt->what) {			case updateEvt:				if (w == dlog) {					/* Update our dialog contents */					DoDialogUpdate(dlog);					ans = TRUE; *itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoUpdate(w) routine here if you					 *	don't want unsightly holes in background windows caused					 *	by nested alerts, balloon help, or screen savers (see					 *	Tech Note #304).					 */					DoUpdate(w);					}				break;			case activateEvt:				if (w == dlog) {					DoDialogActivate(dlog,(evt->modifiers & activeFlag)!=0);					*itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoActivate(w) routine here if					 *	you want to deactivate the former frontmost window, in order					 *	to unhighlight any selection, scroll bars, etc.					 */					}				break;			case mouseDown:					where = evt->where;		/* Make info available to DoDialog() */					part = FindWindow(evt->where, &window);				if ( part==inDrag)               /* pass screenBits.bounds to get all gDevices */						if	(window==(WindowPtr)BB_FrontNonFloatingWindow()) {							 DragWindow(window, evt->where,&QD.screenBits.bounds); //&QD.screenbit bounds); //							 ans=true;							*itemHit = 0;						 } 			case mouseUp:				where = evt->where;		/* Make info available to DoDialog() */				GlobalToLocal(&where);				modifiers = evt->modifiers;				ans = CheckUserItems(where,itemHit);				break;			case keyDown:				if ((ch=(unsigned char)evt->message)=='\r' || ch==ENTERkey) {					*itemHit = OK_ITEM /* Default Item Number here */;					doHilite = ans = TRUE;				}				if ((ch=(unsigned char)evt->message)==27 ) {					*itemHit = 2 /* Default Item Number here */;					doHilite = ans = TRUE;				  }				if (evt->modifiers & cmdKey) {					ch = (unsigned char)evt->message;					switch(ch) {						case 'x':						case 'X':							if (pdl_TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DialogCut(dlog); TEToScrap(); }							 else {								/* Cut from anything else cuttable, like a list */								}							break;						case 'c':						case 'C':							if (pdl_TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DialogCopy(dlog); TEToScrap(); }							 else {								/* Copy from anything else copyable, like a list */								}							break;						case 'v':						case 'V':							if (pdl_CanPaste(1,'TEXT'))								{ TEFromScrap(); DialogPaste(dlog); }							 else {							 	/* Deal with any other pasteable scraps here */								}							break;						case 'a':						case 'A':							if (((DialogPeek)dlog)->editField >= 0) {								/* Dialog has text edit item: select all */								SelectDialogItemText(dlog,((DialogPeek)dlog)->editField+1,0,32767);								}							 else {								}							*itemHit = 0;							break;						case '.':							*itemHit = CANCEL_ITEM;							doHilite = TRUE;							break;						}					ans = TRUE;		/* Other cmd-chars ignored */					}				break;			}		if (doHilite) {			GetDialogItem(dlog,*itemHit,&type,&hndl,&box);			/* Reality check */			if (type == (btnCtrl+ctrlItem)) {				long soon = TickCount() + 7;		/* Or whatever feels right */				HiliteControl((ControlHandle)hndl,1);				while (TickCount() < soon) ;		/* Leave hilited for a bit */				}			}		return(ans);	}/* * Mouse down event: * Check if it's in some user item, and convert to itemHit if appropriate. */static Boolean CheckUserItems(Point where, short *itemHit)	{		return(FALSE);	}/* * Redraw the contents of this dialog due to update event. * If you have not installed UserItem draw routines, you should redraw * them explicitly here; otherwise, UpdateDialog() will call your routines. */static void DoDialogUpdate(DialogPtr dlog){short type,IconId,i; Handle hndl; Rect box;Str255 str; PixPatHandle	the_pixpat;RgnHandle		r1=NewRgn(),r2=NewRgn();Handle						LaListeH;DitlelementPtr			LaListe;Ditl_MasterlistPtr	LaListe1;				SetPort(dlog);		TextMode(srcOr);		BeginUpdate(dlog);		if (!EmptyRgn(dlog->visRgn)){			 RectRgn(r1,&dlog->portRect);			 			 GetDialogItem(dlog,34,&type,&hndl,&box);			 RectRgn(r2,&box);			 DiffRgn(r1,r2,r1);			 					 the_pixpat=GetPixPat(129);			  			  if (the_pixpat!=nil){			 	 FillCRgn(r1,the_pixpat);			 	 DisposePixPat(the_pixpat);			  }			  			  TextMode(srcOr);			  			 		LaListeH=((DialogPeek)dlog)->items;		HLock(LaListeH);		LaListe=(DitlelementPtr)*LaListeH;		LaListe1=(Ditl_MasterlistPtr)*LaListeH;					 for (i=1;i<=(LaListe1->dml_NumberOfItem+1);i++) {				 GetDialogItem(dlog,i,&type,&hndl,&box);				 if ((type&0x7f) == iconItem ) {					 IconId=C_findIconResourceDitl(dlog,i);					 hndl=(Handle)GetCIcon(IconId);					 PlotCIcon(&box,(CIconHandle) hndl);					 }				 				if ( ((type&0x7f) == statText )  && i!=3) {					 GetDialogItemText(hndl,&str);					 MoveTo(box.left,box.bottom);					 DrawString(&str);				 }				 			 }			  			 			 		} // vis region empty ?					GetDialogItem(dlog,34,&type,&hndl,&box);		FrameRectOneLine(&box,true);					DrawControls(dlog);		pdl_FrameDefault(dlog,OK_ITEM,true);					EndUpdate(dlog);		DisposeRgn(r1);		DisposeRgn(r2);}/* * Activate event: Activate or deactivate this dialog and any items in it */static void DoDialogActivate(DialogPtr dlog, int activ)	{		SetPort(dlog);	}/* * Build this dialog's window on desktop, and install initial item values. * Return the dlog opened, or NIL if error (no resource, no memory). */static DialogPtr OpenThisDialog()	{		short type,i; Handle hndl; Rect box; GrafPtr oldPort;		DialogPtr dlog;		GetPort(&oldPort);		SetDialogFont(kFontIDGeneva); 		dlog = GetNewDialog(thisDialogID,NIL,FRONT_WINDOW);		if (dlog == NIL) { SysBeep(1); return(NIL); }	/* Poor man's error message */		SetPort(dlog);				TextFont(kFontIDGeneva); 		TextSize(9);				/* Fill in dialog's values here */		for (i=1;i<16;i++) {			GetDialogItem(dlog,i,&type,&hndl,&box);			SetControlValue((ControlHandle)hndl,(short)G.TableFonctionKeys[i]);			}		ShowWindow(dlog);		return(dlog);	}/* * Clean up any allocated stuff, and return dialog to primordial mists */static void CloseThisDialog(DialogPtr dlog)	{		DisposeDialog(dlog);	/* Call CloseDialog if you provide storage to GetNewDialog */	}/* * Deal with user clicking on an item in this dialog, either modal or non-modal. * The local point is in where; modifiers in modifiers. * Returns whether or not the dialog should be closed (keepGoing). */static int DoDialogItem(DialogPtr dlog, short itemHit)	{		short type,i,okay=FALSE,saveResFileNumber,keepGoing=TRUE,val;		Handle hndl,pref; Rect box; Point pt;		unsigned char *p,str[256];		unsigned char table[32];		if (itemHit<1 || itemHit>=LASTITEM)			return(keepGoing);				/* Only legal items, please */		GetDialogItem(dlog,itemHit,&type,&hndl,&box);		switch(type) {			case ctrlItem+btnCtrl:				switch(itemHit) {					case BUT31_OK:						keepGoing = FALSE; okay = TRUE;						break;											case BUT32_Par: // valeur par défauts					// on regarde la préférence dans le logiciel					// on modifile la table							table[0]=0;							table[14]=0;							table[15]=0;							table[1]=10;							table[2]=11;							table[3]=12;							table[4]=8;							table[5]=7;							table[6]=8;							table[7]=34;							table[8]=35;							table[9]=36;							table[10]=30;							table[11]=27;							table[12]=26;							table[13]=25;															for (i=1;i<16;i++) {								GetDialogItem(dlog,i,&type,&hndl,&box);								SetControlValue((ControlHandle)hndl,table[i]);							}												break;											case BUT33_Annuler:							keepGoing = FALSE; okay = false;						break;					}				break;			case ctrlItem+chkCtrl:				break;			case ctrlItem+radCtrl:				break;			case ctrlItem+resCtrl:				switch(itemHit) {					case CTRL1:						break;					case CTRL2:						break;					case CTRL3:						break;					case CTRL4:						break;					case CTRL5:						break;					case CTRL6:						break;					case CTRL7:						break;					case CTRL8:						break;					case CTRL9:						break;					case CTRL10:						break;					case CTRL11:						break;					case CTRL12:						break;					case CTRL13:						break;					case CTRL14:						break;					case CTRL15:						break;					}				break;			case statText:				switch(itemHit) {					case STXT16_F1:		/* NOT Enabled */						break;					case STXT17_F2:		/* NOT Enabled */						break;					case STXT18_F3:		/* NOT Enabled */						break;					case STXT19_F4:		/* NOT Enabled */						break;					case STXT20_F5:		/* NOT Enabled */						break;					case STXT21_F6:		/* NOT Enabled */						break;					case STXT22_F7:						break;					case STXT23_F8:		/* NOT Enabled */						break;					case STXT24_F9:		/* NOT Enabled */						break;					case STXT25_F10:		/* NOT Enabled */						break;					case STXT26_F11:		/* NOT Enabled */						break;					case STXT27_F12:		/* NOT Enabled */						break;					case STXT28_F13:		/* NOT Enabled */						break;					case STXT29_F14:		/* NOT Enabled */						break;					case STXT30_F15:		/* NOT Enabled */						break;					}				break;			case editText:				break;			case iconItem:				break;			case picItem:				break;			case userItem:				switch(itemHit) {					case USER34:						break;					}				break;			}		if (okay) keepGoing = AnyBadValues(dlog);		return(keepGoing);	}/* * Pull values out of dialog items and deliver TRUE if any of them are * illegal or inconsistent; otherwise deliver FALSE.  If any values are bad, * you should inform your user about the problem here before delivering TRUE. * If any items are missing values, this is the place to assign any defaults. */static int AnyBadValues(DialogPtr dlog)	{		char str[256]; short val,len;		return(FALSE);	}/*						//saveResFileNumber=CurResFile();						UseResFile(gAppResFileNumber);						pref=Get1Resource('FreP',129);						if (pref){ // si elle existe on la lit et on la place dans les pop-ups							HLock(pref);							BlockMove(*pref,&table,18);							HUnlock(pref);							ReleaseResource(pref);																					// initialisation des fonction keys 							// on modifie quelque peu le 0-0									table[0]=0;							table[14]=0;							table[15]=0;							table[1]=10;							table[2]=11;							table[3]=12;							table[4]=8;							table[5]=7;							table[6]=8;							table[7]=34;							table[8]=35;							table[9]=36;							table[10]=30;							table[11]=27;							table[12]=26;							table[13]=25;															for (i=1;i<16;i++) {								GetDialogItem(dlog,i,&type,&hndl,&box);								SetControlValue((ControlHandle)hndl,table[i]);							}						}						UseResFile(saveResFileNumber);																	*/