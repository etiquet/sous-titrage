#include "BB.Globals_C.h"#include "E3DEMO.H"#include "appleEventHandlers.h"#include <QuickTimeComponents.h>#include <ImageCompression.h>#include "hdwr.vx.h"#include <Palettes.h>#include "PPCDispatch.h"#include "CQuicktime.h"//#define __Debug__ 1pascal short 	FIRSTVE (void);pascal void		DoPrepareVBLJump	(void);pascal void 	LitPreferenceGenerale(void);DialogPtr 		OpenErrorWindow(WindowPtr behind);static void 	InitialisationCarteGraphique(void) ;pascal OSErr	launchMoniteurVideo(void);pascal void		QuitMoniteurVideo(void);pascal OSErr	launchSFG(void);pascal void 	InitUndoRedo(void);static void 	InitSomeGlobals_1(void);static void		SetUpAppleEvents(void);static void 	DrawInitDialog (void);void 			GiveMeMoreMaster(void);void 			InitTheMac(void);void 			DoInitSomeValue2(void);void 			InitialiseLalistedesSousTitres(void);pascal void 	TestAdresseGlobales(void);static pascal void InitialisationMenus(void);pascal void		GetMainScreenRes(Rect *rect);DialogPtr 		OpenPreferenceAffichageDlog(void);pascal void 	PutPrefAffInGeneralPref(void);asm void 		jumpExitToshell( void );void 			Patch_ExitToshell(void);void 			essais(TMXTaskPtr Xtask:__A1);void 			MesureCpuVitesse(TMXTaskPtr myTask:__A1);void 			CalcVtr_Speed(TMXTaskPtr myTask:__A1);void 			GenerateurInterne(TMXTaskPtr myTask:__A1);void 			Termine_BonBougre(void);pascal void 	CloseErrorWindow(DialogPtr dlog);void 			FadeInDialog(void);static void 	ShowMyWindows(void);static void 	GetMyWindows(void);pascal void 	EcritPreferenceTravail(void);pascal void 	InitUndoRedo(void);int	  			GetLicenseInfo(void);void 	  		Install_XTask(void);void     		Dispose_XTask(void);long  			getserialnumber(void);// les globalsextern AppGlobals G;extern MyQDGlobals QD;// globales pour le mode AVstatic long	 			total,contig;static short 			MinDepth;static DialogPtr 		StartUpDialog;static Str255 			st0,st1,st2,st3;extern DialogPtr		gPaletteKaraoke;short					gAppResFileNumber;Boolean					gModeKaraoke,gTaskInstalled,gUtiliseXTask;short 					gDecalText;extern short 			gCurResNum;DialogPtr 				gDialogProchainSousTitre,gtestDecodageWindow;static 					UniversalProcPtr gOldExitToShellTrap; // la vieille adresse de ExiToshellshort					gNombreCarteGraphique,gVBLInstalled;CarteGraphElement 		gListeCarteGraph[6];Boolean 				IsQuickTimeInstalled (void) ;TMXTask 				gMesureVtrSpeed;static short			gPreviousNuVistaDepth; // la profondeur de la carte nu vista à l'initialisation// nouveau mode saisie des tcshort					gModeSaisieTC;void C_QuitApplication(void){DialogPtr	wait_dlog;	SetDialogFont(kFontIDGeneva); 			wait_dlog= GetNewDialog(140,nil,(WindowPtr)-1);	SetPort(wait_dlog);		TextFont(kFontIDGeneva); 	TextSize(9); 	DrawDialog(wait_dlog);		Dispose_XTask();// on update le fichier préférence	EcritPreferenceTravail(); 	PutFonctionKeyinPref(); 	PutPrefAffInGeneralPref();// on ferme les fenêtre flotante// on dispode les gworlds	if (G.OffscreenSaisie) 											DisposeGWorld(G.OffscreenSaisie);	if (G.OffscreenChenille) 						DisposeGWorld(G.OffscreenChenille);	if (G.OffscreenRendering)						DisposeGWorld(G.OffscreenRendering);	if (G.OffscreenListing)						DisposeGWorld(G.OffscreenListing);	if (G.DuplicateOffscreenBuffer)			 			DisposePtr(G.DuplicateOffscreenBuffer);		QT_Destrutor(); // destruction netscape	QuitSansFauteGrammaire();	DisposeDialog(wait_dlog);	SetDialogFont(0); }//------------------------------void Initialise_BonBougre(void){	short 			itemtype;	Handle			item;	WindowPtr		w;	Rect 				rect;/* on alloue des Masters Pointeurs pour des handles */			 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();	/* on initialise les Manager etc..*/			InitTheMac();// on configure le logiciel		InitSomeGlobals_1();// 		SetUpAppleEvents();								/* on initialise Quelques globales */		gAppResFileNumber=CurResFile();		gTaskInstalled=false;		gUtiliseXTask=true;/* on ouvre la fenètre back drop (fond de l'écran)*/		w=GetNewCWindow(130,(WindowPtr)&G.BackDropWindow,(WindowPtr)-1);		HideWindow(w);		SetWRefCon(w,1000);		rect=(**GetMainDevice()).gdRect;		MoveWindow(w,rect.left,rect.top+20,true);		SizeWindow(w,rect.right-rect.left,rect.bottom-rect.top,true);		DoUpdate(w);				rect=(**GetMainDevice()).gdRect;/* 	On commence par dire à l'utilisateur ce que l'on fait.		On ouvre un dialog	on récupère les informations de licence (sauf le N° de série)*/// on regarde si les information de license existe#ifndef	__NoProtect__ 		h=Get1Resource('STR#',136);		if (h)  ReleaseResource(h);		if (!h) {			// on demande les information de license			if (!GetLicenseInfo())  ExitToShell();			UpdateResFile(gCurResNum);			w=(WindowPtr)&G.BackDropWindow;			SetPort((GrafPtr)w);			InvalRect(&w->portRect);			DoUpdate((WindowPtr)w);			SetPort(StartUpDialog);				} #endif// on affiche le dialog d'initialisation		GetIndString(&st0,136,2); // nom prenom		GetIndString(&st1,136,5); // société						GetIndString(&st2,136,1); // modèle		//GetIndString(&st3,136,7); // n° de série		NumToString(getserialnumber(),&st3);		ParamText(&st0,&st1,&st2,&st3);				StartUpDialog=GetNewDialog(191,(Ptr)nil,(WindowPtr)-1);		SetPort(StartUpDialog);		/* on fait l'anim d'entrée*/  		FadeInDialog();  		/* on dessine vraiment le bazar*/		DrawInitDialog ();				MinDepth=GiveMinDepth(&StartUpDialog->portRect);		if (MinDepth==1) AlertUser(16);		DrawInitDialog ();		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,18);		SetDialogItemText(item,&st3);  // on indique ce que l'on fait/* on regarde s'il faut créer le dossier préf etc.*/		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,19);		SetDialogItemText(item,&st3);  // on indique ce que l'on fait		/* on récupère les préférences */		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,20);		SetDialogItemText(item,&st3); 		 	// on indique ce que l'on fait		G.Preference_PourTravail=nil;		// on raz le pointeur	 		 	LitPreferenceGenerale();// on vérifie les paramêtre de PPatpour les fonds de fenêtres (erreurs dans les préférences entre v1.4 et V1.5)		if (G.BackDrop_PatNum<128 || G.BackDrop_PatNum>200) 	G.BackDrop_PatNum=134;		if (G.Listing_PatNum<128 || G.Listing_PatNum>200)G.Listing_PatNum=140	;		if (G.Saisie_PatNum<128 || G.Saisie_PatNum>200)G.Saisie_PatNum=129;/*on démarre le programme*//* on regarde s'il faut fermer la fenêtre backdrop (en fct des préférences)*/		if (G.Preference_MultiFinder) HideWindow(w); 		SetPort(StartUpDialog); 		/*Demande de mémoire pour le logiciel*/		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,22);		SetDialogItemText(item,&st3);  // on indique ce que l'on fait init mémoire/* Gestion de la Clef de  protection du logiciel */#ifndef	__NoProtect__		DoInitSomeValue2();#endif 		ParamText(&st0,&st1,&st2,&st3);/* maintenant, on demande de la mémoire*/		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,24);		SetDialogItemText(item,&st3);  // on indique ce que l'on fait init mémoire -3-				G.General_PremierSTPtr=(SousTitreRecordPtr)NewPtrClear(1048576); //1Mo		if (MemError()) { 			AlertUser(2);			ExitToShell();   			}   					G.BufferTransfert=NewPtrClear(204800); //200Ko				if (MemError()) { 			AlertUser(2);			ExitToShell();   			}   					GetDialogItem(StartUpDialog,11,&itemtype,&item,&rect);		SetDialogItemText(item,"\pInitialisation de la mémoire.....");  // on l'indique		G.SIZEBufferTransfert=204800;		G.General_HIMEMST=1048576;		G.General_HIMEMST=G.General_HIMEMST+(long)G.General_PremierSTPtr;/*  on rafraichi les fenêtres */		DrawInitDialog ();		w=(WindowPtr)&G.BackDropWindow;		SetPort((GrafPtr)w);		InvalRect(&w->portRect);		DoUpdate((WindowPtr)w);		SetPort(StartUpDialog);		/*	 	On initialise la routine Timer 		Elle permet de générer un time code interne*/		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,31);		SetDialogItemText(item,&st3);  // on indique ce que l'on fait loadage timer					Install_XTask();		SetPort(StartUpDialog);		GetIndString(&st0,136,1);		GetIndString(&st1,136,2);		GetIndString(&st2,136,3);	 	ParamText(&st0,&st1,&st2,nil);		/*  on place les menus */		InitialisationMenus();		/* On initialise les carte graphiques */				GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,29);		SetDialogItemText(item,&st3);		 		 		 /* on rafraichi les fenêtres */				DrawInitDialog ();		DoUpdate((WindowPtr)&G.BackDropWindow);		SetPort(StartUpDialog);/* on ouvre les fenêtre */	GetMyWindows();	QT_Constructor(); // initialisation Quicktime/* On initialise la liste de sous-titres */	InitialiseLalistedesSousTitres();	DrawInitDialog ();	/* on ferme le dialog d'acceuil */			DisposeDialog(StartUpDialog);			ShowMyWindows();	SelectReferencedWindow((WindowReference) &G.DialogSaisie); 	ActivateFloatersAndFirstDocumentWindow();/* on dispose le fichier préférence de travail */ 	if (G.Preference_PourTravail) DisposeHandle( (Handle)G.Preference_PourTravail);// on ouvre la dernière police d'affichage utilisée// et le dernier fichier s'il existe. 	Adjust_BB_Menu(); }void InitTheMac(void){short count;EventRecord event;	InitGraf((Ptr) &QD.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	/*initialisation du module de simulmation */		C_InitMyCursor();	for (count = 1; count <= 3; count++)		EventAvail(everyEvent, &event);	 	SysEnvirons(kSysEnvironsVersion, &G.Mac);	if (G.Mac.machineType < 0) AlertUser(1);		if ((long) GetApplLimit() - (long) ApplicationZone() < kMinHeap) AlertUser(2);		/* ZeroScrap(); *//* on regarde s'il y a assez de mémoire */	PurgeSpace(&total,&contig);	if (contig<=2000*1000) {		AlertUser(1);		ExitToShell();		}		if (contig<=2600*1000) AlertUser(15);}//InitTheMac/* routine de dessin du dialog d'initialisation */static void DrawInitDialog (void){		SetPort(StartUpDialog);		TextMode(srcOr);		TextFont(kFontIDGeneva);		TextSize(9);		BeginUpdate(StartUpDialog);		DrawDialog(StartUpDialog);		EndUpdate(StartUpDialog);}		//Draw init dialogpascal short DoAlertNotKeyPresent(void){short result=0;		result=Alert(169,(ModalFilterProcPtr)nil);		return result-1;}pascal Boolean AlertFilterProc(theDialog ,event,itemhit)	DialogPtr	theDialog;	EventRecord	*event;	short		*itemhit;{	short		itemtype, value;	Point		The_point;	unsigned char		key;	GrafPtr		oldport;	Boolean		result=false,extend=false;	Handle	item;	Rect		rect;				GetPort(&oldport);		SetPort((GrafPtr)theDialog);		switch (event->what ) {				case 0:			break;				case mouseDown:					The_point=event->where;					GlobalToLocal(&The_point);										value=FindDialogItem(theDialog,The_point);					if (value!=-1) {						value++;						GetDialogItem(theDialog,value,&itemtype,&item,&rect);						if ((itemtype&0x6f)== iconItem || (itemtype&0x6f)== picItem) {							*itemhit=value;							result=TrackCurseur(theDialog,value);						}					} 			break;					case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;						switch(key) {					case 3: // ok bouton					case 13: // ok bouton						*itemhit=1;						result=true;						C_Hilite_icon_button(theDialog,1);						WaitTicks(8);						C_Unhilite_icon_button(theDialog,1);						break;											case 27:	// esc						*itemhit=2;						result=true;						C_Hilite_icon_button(theDialog,2);						WaitTicks(8);						C_Unhilite_icon_button(theDialog,2);						break;				}			break;		case activateEvt:			break;				case updateEvt:			break;				}//	switch		SetPort(oldport);		return (result);}		pascal void AlertUser(short error){	short		itemHit;	Str255		message,st1;	short		dlgFont;	dlgFont=LMGetDlgFont();	LMSetDlgFont(kFontIDGeneva);	SetCursor(&QD.arrow);	GetIndString(&message,137, error);	GetIndString(&st1,137, 7);	ParamText(&st1,&message,"","");	itemHit =  CautionAlert(129,(ModalFilterProcPtr)nil);	LMSetDlgFont(dlgFont);} /* AlertUser *//* *=====================================================================**Diverses routines utilisées pour la gestion des boutons dans un dialog **=====================================================================**/pascal void AlertCarteDaffichage(){	AlertUser(30);}pascal void EffaceTouslesSousTitres(Str255 name){Str255	st0,st1;Ptr		P;short	i;SousTitreRecordPtr	st;/* on configure le control v de listing 	/!\ note on ne fait pas l'initialisation si pas fenêtre listing et saisie*/		 if (G.ListingVScroll){ 			SetControlMinimum(G.ListingVScroll,1); 			SetControlValue(G.ListingVScroll,1); 			SetControlMaximum(G.ListingVScroll,1); 		/* ______________   on configure les nom des fenètre par défauts ________________ 			; fenètre saisie							; si pas de nom			; on place celui par défaut 		*/	 		if (name)	 			BlockMove((Ptr)name,&st1,256);	 		else	GetIndString(&st1,129,5);		//texte par défaut !(film sans titre)			 		GetIndString(&st0,129,3); 				//saisie name	 		BlockMove(&st1[1],&st0[st0[0]+1],(long)st1[0]);	 		st0[0]+=st1[0];							 		SetWTitle((WindowPtr)&G.DialogSaisie,&st0);				 		GetIndString(&st0,129,4); 				//listing name	 		BlockMove(&st1[1],&st0[st0[0]+1],(long)st1[0]);			st0[0]+=st1[0];	 		SetWTitle((WindowPtr)&G.ListingWindow,&st0);		}//  if (G.ListingVScroll)		/* le nom de la préférence titre original */// 		BlockMove(&st1,&G.Preference_TitreOriginal,256);			G.Preference_TitreEpisodeOriginal[0]=0;			G.Preference_TitreFrancais[0]=0;			G.Preference_TitreEpisodeTraduit[0]=0; 			G.Preference_NomAdaptateur[0]=0;			G.Preference_CoordonneesAdaptateur[0]=0;			G.Preference_commentaire[0]=0;			G.CodeDeReference[0]=0;			//	 on place bon bougre par défaut// 	et le nom de la société et son adresse  	 			GetIndString(&G.EditeurListe,136,4)	; 			GetIndString(&G.NomDuMonteur,136,5);	 			GetIndString(&G.CoordonneeMonteur,136,6);	// divers valeur pour le N19 			G.PaysOrigine=12;			G.CodeLangue=16;			G.CodeCaractere=1;			G.TcDebutFilm=-1; 			GetDateTime(&G.DateDeCreation); 			//date du jour 			GetDateTime(&G.ModifieLe); 				//date du jour			G.Revision=1;			G.Preference_commentaire[0]=0;			G.Preference_Interval=4;				//interval minimum					G.Preference_LisiValue=12;			// lisibilité			G.General_StartNumberForST=1;			G.General_IncrementPourST=1;			//G.Preference_Enchaine=0;  			// on prépositionne soustraction tc out			G.General_Preference_flag_1=true ;  	 // pour le dialog recherche ST			G.Preference_UtilCheck=1;						//------------- préférence pour exportation de fichier ----------- 			G.Preference_TypeExport=1;			G.Preference_ConvertMsDos=true;			G.Preference_InclureCommentaire=false;			G.Preference_InclureSousNumero=false;			G.Preference_N19_TypeTeletexte=true;			G.Preference_DoubleHauteur=true;			G.Preference_DoubleLargeur=false;			G.Preference_Couleur=3;		// -------------- on créé un premier sous-titre bidon -----------			G.General_NombreST=0;			G.General_PremierTC=-1;			G.General_DernierTC=-1;			G.General_DernierSTPtr=G.General_PremierSTPtr;			G.General_DernierNumConvertiPtr=G.General_PremierSTPtr;			st=G.General_PremierSTPtr;			(st)->st_PreviousST=nil;			(st)->st_NextST=nil;			 			(st)->st_TimeCodeIn=-1; 			(st)->st_TimeCodeOut=-1; 						(st)->st_NumeroST=1;			(st)->st_OldNumeroST=1;			(st)->st_AbsNUMST=1;			(st)->st_TexteLenth=nil;			(st)->st_CommentaireLenth=nil;			(st)->st_LenthST=32;					(st)->st_CommentairePtr=nil;			(st)->st_PosOffsetTable=nil;			(st)->st_StylePtr=nil;			(st)->st_StyleLenth=nil;			(st)->st_Nlines=1;			(st)->st_XOffset=0;			(st)->st_YOffset=0;			(st)->st_Error=0;			(st)->st_Justification=0;			(st)->st_MasKType=0;			G.General_NombreST=1;			G.General_PremierTC=-1;			G.General_DernierTC=-1;			G.General_SousTitreEncour=1;			G.General_FontNumber=kFontIDGeneva;				// police par défaut// on raz le block note 			P=(Ptr)&G.BlockNote_tc;			for (i=0;i<32;i++){				*P=-1;				P++;				}			G.BlockNote_texte[0]=0;//-------------    On raz l'offset 			G.offsetTC=0;// ______________  initialisation des modes de fonctionnement  _________________			G.SaisieModePreferenciel=3;// ______________  Prépositionnement du dialog change style et font _____________			G.ChangeStyleDialog_Mode=0;		// style uniquement			G.ChangeStyleDialog_style=2;		// italique			G.ChangeStyleDialog_font=kFontIDGeneva	;		// font courante			//ChangeStyleDialog_debut			ds.l	1//ChangeStyleDialog_fin			ds.l	1			InitUndoRedo();} // Efface_Tous_Les soustitres/* Cette routine initialise les valeurs par défaut du logiciel pour le fonctionnement*/static void InitSomeGlobals_1(void){			G.InBackground = false;	// in the front			G.HasWNEvent = 0x0101;  // on force WaitNextEvent Pour Do Event			G.AutoOpenLastFile=true;			gModeKaraoke=nil;			gDecalText=0;						gModeSaisieTC=0;					// on prépositionne pas de passage automatique			G.Preference_Enchaine=0;  			// on prépositionne soustraction tc out/*Initialisation des variables par défaut*/			G.HauteurST=ListingHauteurCarreST; 	// pour le moment on force la hauteur de listing (54)			G.ListeError=nil;					// pas de fichier liste d'erreur			G.Preference_NombreSauv=10; 		//valeur d'attente pour wait value( en minutes)			G.Preference_AutoCheck=true	;		// sauvegarde auto par défaut			G.Preference_KernCheck=1	;		// auto kern			G.SaisieModePreferenciel=3;			//SaisieMode_Aucun			G.Preference_MultiFinder=0x0000 ; 	//fenêtre de fond de l'écran présente			G.General_Preference_flag_1=true ; 	//pour le dialog recherche ST			G.General_Preference_DessinGris=nil ; 	//desactivé			G.Preference_TypeExport=1;			//exportion Fichier_TypeTexte			G.Preference_ConvertMsDos=nil;		// conversion caractères MSDos			G.Preference_InclureCommentaire=nil;	//on ne met pas les commentaires			G.Preference_InclureSousNumero=nil;	//Pas les sous-numéros			G.Preference_DisplayTimeCode=-1;		//on valide tout			G.Echelle_Bandeau=2;				//pour la chenille 2 images par pixels			G.PopUp_FontNumberList=nil;			G.N19_VPStart=21;/*On raz différents pointeurs de mémoire*/			G.FindFirstKey_error=-1;							G.RenderingFont_handle=nil;			G.DuplicateOffscreenBuffer_handle=nil;			G.OffscreenDisplayBase=nil;			G.RenderingFont_handle=nil;			gVBLInstalled=0;/*Init timer pour version limitée du logiciel*/			G.StartTicks=TickCount()+60*60*15; 	// le temps max de fonctionnement 15 minutes			G.democount=50; 					//50 sous-titre affiché/*valeur par défaut lecteur TC (tc interne) */			G.LecteurTimeCode_Type=3/*0*/; 	//	lecteur vitc			G.Player_TC_src=0; 		//	auto ltc/vitc			G.Mode_Commutateur=0; 		//	momentané			G.ModemOutRefNum=0;			G.ModemInRefNum=0;			/* initialisation des parramètres d'affichage*/			G.RGB_FaceColor=0xffffffff;			G.RGB_BorderColor=0xff000000;			G.RGB_ShadowColor=0x60000000;			G.RGB_OutlineBoxColor=0x90000000;			G.X_Offset=0;								G.Y_Offset=518;				// 518= 576*90% 				G.safearea=80;				//le kerning automatique par defaut				G.Outline_Box=nil;				G.Overriding_All_Attribute=false;				G.ListingVScroll=nil;/* upstream ou downstreamkeyer */			G.VE_Mode=1 ;			// on preset la valeur DowstreamKeyer/* cut fon du ,vitesse */			G.EffectMode=0;		//effect Cut			G.FadeTime=8;/* initialisation des fonction keys */					// on modifie quelque peu le 0-0						G.TableFonctionKeys[0]=0;			G.TableFonctionKeys[14]=0;			G.TableFonctionKeys[15]=0;						G.TableFonctionKeys[1]=10;			G.TableFonctionKeys[2]=11;			G.TableFonctionKeys[3]=12;			G.TableFonctionKeys[4]=8;			G.TableFonctionKeys[5]=7;			G.TableFonctionKeys[6]=8;			G.TableFonctionKeys[7]=34;			G.TableFonctionKeys[8]=35;			G.TableFonctionKeys[9]=36;			G.TableFonctionKeys[10]=30;			G.TableFonctionKeys[11]=27;			G.TableFonctionKeys[12]=26;			G.TableFonctionKeys[13]=25;				/* Pattern de fenêtres par défaut */						G.BackDrop_PatNum=134;			G.Listing_PatNum=140	;			G.Saisie_PatNum=129;		/* font pour saisie*/			G.General_FontNumber=kFontIDGeneva;					G.General_TextSize=14;// on ouvre la resource DATA 128	=> CONVERSION de caractères// ouverture de la resource DATA 129 conversion majuscule <=> minuscule// ouverture de la resource DATA 130 conversion Accentué => majuscule non accentué	// ouverture de la resource 1000 pour la conversion N19 <=> mac				G.ResourceDATA128=GetResource('DATA',128);		HLock(G.ResourceDATA128);		G.ResourceDATA129=GetResource('DATA',129);		HLock(G.ResourceDATA129);		G.ResourceDATA130=GetResource('DATA',130);		HLock(G.ResourceDATA130);		G.ResourceDATA1000=GetResource('DATA',1000);		HLock(G.ResourceDATA1000);		// ouverture de quelques color icon courament utilisé		G.IconHandle1=GetCIcon(144);		HLock((Handle)G.IconHandle1);		G.IconHandle2=GetCIcon(143);		HLock((Handle)G.IconHandle2);		G.IconSauvegardeOn=GetCIcon(130);		HLock((Handle)G.IconSauvegardeOn);		G.IconSauvegardeOff=GetCIcon(131);		HLock((Handle)G.IconSauvegardeOff);		// chargement de quelques curseurs couleurs		G.CurseurDessineST=GetCCursor(132);		HLock((Handle)G.CurseurDessineST);		G.CurseurClearBuffer=GetCCursor(133);		HLock((Handle)G.CurseurClearBuffer);		G.CurseurTransfert=GetCCursor(134);		HLock((Handle)G.CurseurTransfert);// on demande un handle pour la clef eve3		G.EveHandle=nil;		G.EveHandle=RBEHANDLE();		/* on regarde s'il y a une fichier nommé preférence pour clef de protection logiciel pour audiophase */ 		G.SoftProtect=0xaefc;		 /* on initialise les liste undo/redo		*/ 		InitUndoRedo();}//initsomeglobalsvoid InitialiseLalistedesSousTitres(void){Ptr P;short i;long	a5;// -------------- on créer un premier sous-titre bidon -----------			G.General_SousTitreCourantPtr=G.General_PremierSTPtr;			G.General_LastSousTitrecourant =1;			G.General_SousTitretrouve=nil;			G.General_SousTitrecourant=1;			G.Rechercher_STR[0]=0;			G.Remplacer_STR[0]=0;			// ---------------------------// on place la valeur de a5 en tête de chaque buffer série			a5=SetCurrentA5();			G.General_A5register_1=a5;			G.General_A5register_2=a5;			G.General_A5register_3=a5;			G.General_A5register_4=a5;			G.General_A5register_5=a5;			G.General_A5register_6=a5;			// --------------  on initialise le font record -----------------// on raz le Display_Font			P=(Ptr)&G.Display_Font;				for (i=0;i<sizeof(FontRenderRecord)/2;i++) {				*((short*)P)=0;				P=P+2;				}// on initialise quelques valeurs			G.Display_Font.First_Char=0x21;			G.Display_Font.last_Char=0x33;				G.Display_Font.FontSize=28;				G.Display_Font.FontNumber=1;				G.Display_Font.FontStyle=3; //normal + bold + italic				G.Display_Font.FontRatio=0x403; //4:3 ration			G.Display_Font.BorderBlur=1;			G.Display_Font.BorderThickness=2; 			// on demande de la mémoire pour les paramBlocks			G.Main_Rx_PB_Buffer=NewPtrClear(128);			G.Sony_Rx_Buffer=NewPtrClear(128);			G.Vitc_Rx_PB_Buffer=NewPtrClear(128);			G.Tx1_PB_Buffer=NewPtrClear(64);			G.Spare_PB_Buffer=NewPtrClear(64);			G.Spare1_PB_Buffer=NewPtrClear(64);					// on initialise la liste des sous-titres				  			EffaceTouslesSousTitres(nil);	}/* ----------------------------*/static void GetMyWindows(void){WindowPtr	w,w1;Rect			rect;short 		x,i,j;/* ----------- ouverture des fenètres ------------------; à partir des resources ; on affecte un numéro unique pour chaque fenètre 1 à 1000; dans la case REFCON de la fenètre; pour permettre la gestion update click inside etc...; ces fenètres sont sont stockée dans les variables globales; mais il serait sage de demander un pointeur pour chaque fenètre; plutôt que de prendre cette espace dans les variables globales*/			C_GETMAINSCREENRES(&rect);			// fenêtre Block note						G.BlockNoteWindow=GetNewDialog(261,(WindowPtr)nil,(WindowPtr)StartUpDialog);		// ouverture fenètre listing (fenètre 2) et saisie (un dialog)			w=GetNewCWindow(129,(WindowPtr)&G.ListingWindow,(WindowPtr)StartUpDialog);			SetWRefCon(w,2);		//  on récupère le control vertical				G.ListingVScroll=GetNewControl(128,(WindowPtr)&G.ListingWindow);			SetControlValue(G.ListingVScroll,1);			SetControlMinimum(G.ListingVScroll,1);			SetControlMaximum(G.ListingVScroll,1);			// on ouvre le dialog saisie			w=GetNewDialog(148,(WindowPtr)&G.DialogSaisie,(WindowPtr)StartUpDialog);			SetWRefCon(w,1);			/*	on place les fenètres dans l'écran en fct des dimensions de celui ci	 on place les fenètres au milieu de l'écran */			rect=(**GetMainDevice()).gdRect;			w1=(WindowPtr)&G.DialogSaisie;			i=(w1->portRect.right)-(w1->portRect.left);			j=(w1->portRect.bottom)-(w1->portRect.top);			x=(rect.right-rect.left)-i;			x=x/2+rect.left;			MoveWindow((WindowPtr)&G.ListingWindow,x,40+rect.top,false);			SizeWindow((WindowPtr)&G.ListingWindow,i,rect.bottom-3-j-60-14,false);			MoveWindow((WindowPtr)w1,x,rect.bottom-j-8,false); 			Adjust_ListingScrollBar(); 			/* 				Si nous disposons d'assez de mémoire on ouvre un buffer offscreen 				pour les dessins des fenêtres listing et saisie*/			G.OffscreenListing=nil;		if (contig>=2400*1000)	{				w=(WindowPtr)&G.ListingWindow;				rect.top=0;				rect.left=0;				rect.bottom=w->portRect.bottom-w->portRect.top;				rect.right=w->portRect.right-w->portRect.left;					if (MinDepth==1) NewGWorld(&G.OffscreenListing,8,&rect,nil,nil,0);					else NewGWorld(&G.OffscreenListing,0,&rect,nil,nil,0);			}						G.OffscreenSaisie=nil;			if (contig>=2400*1000)	{				w=(WindowPtr)&G.DialogSaisie;				rect.top=0;				rect.left=0;				rect.bottom=w->portRect.bottom-w->portRect.top;				rect.right=w->portRect.right-w->portRect.left;									if (MinDepth==1)  NewGWorld(&G.OffscreenSaisie,8,&rect,nil,nil,0);				else	NewGWorld(&G.OffscreenSaisie,0,&rect,nil,nil,0);			}						// ouverture fenètre  diverses/*						w=GetNewCWindow(133,(WindowPtr)&G.RenderingWindow,(WindowPtr)StartUpDialog);			SetWRefCon(w,128);*//* on ouvre les palettes flotantes */			G.TELECOMMANDEWindow=nil;			G.ErrorsWindow=nil;			G.ChenilleWindow=nil;			G.ServiceWindow=nil;			G.LogoWindow=nil;			gPaletteKaraoke=nil;			gDialogProchainSousTitre=nil;			gtestDecodageWindow=nil;					 	G.ErrorsWindow=OpenErrorWindow((WindowPtr)-1);	// palette erreurs 			GetNewWindowReference((DialogPtr*)&G.TELECOMMANDEWindow,2002,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette télécommande 			GetNewWindowReference((DialogPtr*)&G.ChenilleWindow,2003,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette chenille 			GetNewWindowReference((DialogPtr*)&G.ServiceWindow,262,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info 			GetNewWindowReference((DialogPtr*)&G.LogoWindow,263,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info 			GetNewWindowReference((DialogPtr*)&gDialogProchainSousTitre,171,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info						// un peu de protection de logiciel,  sauf si mode __NoProtect__ (sans protection )		#ifndef	__NoProtect__	#ifndef	__Demo__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}				if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}				#endif#endif/* s'il y a assez de mémoire on ouvre un offscreen pour la pallette chenille*/			G.OffscreenChenille=nil;			if (contig>=2400*1000)	{				w=(WindowPtr)G.ChenilleWindow;				rect.top=0;				rect.left=0;				rect.bottom=w->portRect.bottom-w->portRect.top;				rect.right=w->portRect.right-w->portRect.left;					if (MinDepth==1) NewGWorld(&G.OffscreenChenille,8,&rect,nil,nil,0);					else	NewGWorld(&G.OffscreenChenille,0,&rect,nil,nil,0);			} // (contig>=2400*1000)			}// GetMyWindows/* ----------------------------*/static void ShowMyWindows(void){WindowPtr	w,w1;Point			point;Rect			rect;short 		count,Everesult;/* 	on active et update	 les fenêtres saisie et listing */		ShowHide((WindowRef)&G.DialogSaisie,true);		DoUpdate((WindowPtr)&G.DialogSaisie);			ShowHide((WindowRef)&G.ListingWindow,true);		DoUpdate((WindowPtr)&G.ListingWindow);			/* maintenant on place la fenêtre télécommande en fonction du fichiers préférence*/		C_GETMAINSCREENRES(&rect);		if (G.Preference_PourTravail){  // si le fichier préférence existe					/* on place la fenêtre listing en fonction du fichiers préférence*/			w1=(WindowPtr)&G.ListingWindow;			{				point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_ListingWindowRect.top;				point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_ListingWindowRect.left;				rect=(**GetMainDevice()).gdRect;				// on vérifie les cordonnées				if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){					w=(WindowPtr)&G.ListingWindow;					SetPort(w);					point.h=w->portRect.left;					LocalToGlobal(&point);				}				if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){					w=(WindowPtr)&G.ListingWindow;					SetPort(w);					point.v=w->portRect.bottom-(w1->portRect.bottom-w1->portRect.top);					LocalToGlobal(&point);				}				MoveWindow((WindowPtr)w1,point.h,point.v ,false);			}											/* maintenant on place la fenêtre télécommande en fonction du fichiers préférence*/			w1=G.TELECOMMANDEWindow;			if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteTelecommandeVis ) {										point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteTelecommandeRect.top;										point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteTelecommandeRect.left;										rect=(**GetMainDevice()).gdRect;										// on vérifie les cordonnées										if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.h=w->portRect.left;											LocalToGlobal(&point);										}										if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.v=w->portRect.bottom-(w1->portRect.bottom-w1->portRect.top);											LocalToGlobal(&point);										}										MoveWindow((WindowPtr) G.TELECOMMANDEWindow,point.h,point.v ,false);										ShowHide((WindowRef)G.TELECOMMANDEWindow,true);										DoUpdate((WindowPtr)G.TELECOMMANDEWindow);									}																					// un peu de protection de logiciel						#ifndef	__NoProtect__	#ifndef	__Demo__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}				if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}			#endif#endif											/* maintenant on place la fenêtre chenille en fonction du fichiers préférence*/			w1=G.ChenilleWindow;			if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteChenilleVis ) {										point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteChenilleRect.top;										point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteChenilleRect.left;										rect=(**GetMainDevice()).gdRect;										// on vérifie les cordonnées										if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.h=w->portRect.left;											LocalToGlobal(&point);										}																				if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.v=w->portRect.bottom-(w1->portRect.bottom-w1->portRect.top);											LocalToGlobal(&point);										}																				MoveWindow((WindowPtr) G.ChenilleWindow,point.h,point.v ,false);										ShowHide((WindowRef)G.ChenilleWindow,true);										DoUpdate((WindowPtr)G.ChenilleWindow);									}		/* maintenant on place la fenêtre block en fonction du fichiers préférence*/			w1=(WindowPtr)G.BlockNoteWindow;			ShowHide((WindowRef)w1,false);			if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_BlockNoteVis ) {							point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_BlockNoteRect.top;							point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_BlockNoteRect.left;							rect=(**GetMainDevice()).gdRect;														// on vérifie les cordonnées							if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){								w=(WindowPtr)&G.ListingWindow;								SetPort(w);								point.h=w->portRect.left+3;								LocalToGlobal(&point);							}														if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){								w=(WindowPtr)&G.ListingWindow;								SetPort(w);								point.v=LMGetMBarHeight() +3;								LocalToGlobal(&point);							}														MoveWindow((WindowPtr)w1,point.h,point.v ,false);							ShowHide((WindowRef)w1,true);							DoUpdate((WindowPtr)w1);									}		} // si pas de resource préférence														}// ShowMyWindows/*	Set up the AppleEvent dispatch table */static void SetUpAppleEvents(void){	OSErr	installAppleEventError=0;		installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, (AEEventHandlerUPP) &OAPPHandler, 0, false);	installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, (AEEventHandlerUPP) &ODOCHandler, 0, false);	installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, (AEEventHandlerUPP) &PDOCHandler, 0, false);	installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, (AEEventHandlerUPP) &QUITHandler, 0, false);	if (installAppleEventError)		AlertUser(19); // pb installation Apple Event} //SetUpAppleEventsvoid GiveMeMoreMaster(void){	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		}	static pascal void InitialisationMenus(void){Str255	st4;Ptr	P;short 	count,familyID,itemtype,total,Everesult;Handle 	menuBar,item;Rect		rect,r;RGBColor	M_color,M_color1,M_save_color,M_black;		SetPort(StartUpDialog);				GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st4,129,25);		SetDialogItemText(item,&st4);  // on indique ce que l'on fait				GetForeColor(&M_save_color);				M_black.red=0; 		M_black.green=0;		M_black.blue=0;				M_color1.red=42000;		M_color1.green=-1;		M_color1.blue=-1;				M_color.red=30000; 		M_color.green=30000;		M_color.blue=30000;				 //    on récupère la barre des menus		menuBar = GetNewMBar(128);			/* read menus into menu bar */		if ( menuBar == nil ) AlertUser(4);		SetMenuBar(menuBar);					/* install menus */		DisposeHandle(menuBar);		AppendResMenu(GetMenuHandle(128), 'DRVR');	/* add DA names to Apple menu */ 		InsertMenu(GetMenu(138),-1);	// le menu pour AV	/* on recupère les pop up menus			Et les sous menus*/		 		G.QuickOpenMenuHandle=GetMenu(136); 	// resultat dans la pile	 		InsertMenu(G.QuickOpenMenuHandle,-1);  		C_MakeTheBbdfMenu('Bbof',G.QuickOpenMenuHandle,&G.QuickOpenHandle);  		/*  ------  on recherche les polices utilisables en affichage vidéo  et on créé une table de correspondance entre le n° d'item et le n° de font*/		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st4,129,26);		SetDialogItemText(item,&st4);  // on indique ce que l'on fait 		G.SoftProtect=OpenBBPreferenceFile(false); // pour la protection par fichier caché dans le système 		G.PopUp_Font=nil; 		G.PopUp_Font=GetMenu(2006); 		if( G.PopUp_Font){	 		AppendResMenu(G.PopUp_Font,'FONT');	 		InsertMenu(G.PopUp_Font,-1);		/* on recherche les polices "true type"	  on désactive les autres	  on fabrique une table de correspondance	*/		/* on créer une réglette */			GetDialogItem(StartUpDialog,3,&itemtype,&item,&rect);			GetIndString(&st4,129,33); 	// progression			SetDialogItemText(item,&st4);  		// on indique ce que l'on fait						GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);			r=rect;				RGBForeColor(&M_black);			FrameRect(&rect);						RGBForeColor(&M_color1);				do{	// on fait une animation pour effacer le rectangle				InsetRect(&r,1,1);				FrameRect(&r);			}while(r.bottom-r.top);				RGBForeColor(&M_color);		/* maintenant on check les polices */			r=rect;			InsetRect(&r,1,1);			total=CountMItems(G.PopUp_Font);	 		G.PopUp_FontNumberList=NewHandle(2048);	//on reserve un espace de 1000 polices (un max !?)	   		MoveHHi(G.PopUp_FontNumberList);	 		HLock(G.PopUp_FontNumberList);			count=1;	 		P=(Ptr)*G.PopUp_FontNumberList+2;	 			 		do{				GetMenuItemText(G.PopUp_Font,count,&st4);	 			GetFNum(&st4,&familyID);					// on place le n° dans la table corespondance				*((short*)P)=familyID;				P=P+2;								// on regarde si la police est "true type"				if (st4[0] )					if (!RealFont(familyID,80)  ) DisableItem(G.PopUp_Font,count);					r.right=r.left+(count*(rect.right-rect.left-2))/total;					if (r.right>=rect.right) r.right= rect.right;					PaintRect(&r);	 				C_SpinCursor(16);	//spin the ball						count++;			} while (st4[0] !=nil);		}					RGBForeColor(&M_save_color);		SetCursor(&QD.arrow);		// on place le nombre d'item 		P=(Ptr)*G.PopUp_FontNumberList; 		*((short*)P)=count;// on rafraichie le dialog 		 		GetDialogItem(StartUpDialog,4,&itemtype,&item,&rect);		InvalRect(&rect); 		GetDialogItem(StartUpDialog,3,&itemtype,&item,&rect);		GetIndString(&st4,129,32);		SetDialogItemText(item,&st4);  // on indique ce que l'on fait				// un peu de protection de logiciel		#ifndef	__Demo__	#ifndef	__NoProtect__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}						if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}				#endif#endif		 		DrawInitDialog (); }// initialisation menus/*	/!\	/!\ Protection de logiciel contre le piratage	/!\ on regarde si l'on a une clef présente	/!\	/!\	/!\	/!\*/void DoInitSomeValue2(void){ DateTimeRec			d;short	count,Everesult;		G.FindFirstKey_error=E3ERR_NOTFOUND;	d.month=8;	d.day=1;	d.hour=0;	d.year=1996;	d.minute=0;	d.second=0;	d.dayOfWeek=1;// pour la version de demo on ne met pas le code de protection , on ne sait jamais#ifndef	__Demo__	#ifndef	__NoProtect__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}			if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}					#endif#endif#ifdef	__Demo__// on récupère la date de CRÉATION du programme		GetDateTime(&(pb1.fileParam.ioFlCrDat));		a=LMGetCurApRefNum();				fcb.ioCompletion=(IOCompletionUPP)nil;		fcb.ioNamePtr=(Ptr)&st0;		fcb.ioFCBIndx=0;		fcb.ioVRefNum=0;		fcb.ioRefNum=a;			err = PBGetFCBInfo(&fcb, false);		if (!err ){			pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;			pb1.ioParam.ioNamePtr=(Ptr)&st0;			pb1.ioParam.ioVRefNum=fcb.ioFCBVRefNum;			pb1.fileParam.ioDirID=fcb.ioFCBParID;			pb1.fileParam.ioFDirIndex=0;			err=PBHGetFInfo((HParmBlkPtr)&pb1,false);		}				// pas de protection mais, on limite le logiciel jusqu'au 31 janvier 1996	 	// et on vérifie que nous ne sommes pas en dessous de la dernière date d'utilisation	// et puis on place la date courante dans une resource en mémoire			G.FindFirstKey_error=E3ERR_NOTFOUND;		DateToSeconds(&d, &limite);		oldresfile=CurResFile();		UseResFile(gCurResNum);				GetDateTime(&lo);		h=Get1Resource('FreP',130); // la resource où l'on planque la valeur						//si  la date courante est inférieur à la dernière date d'utilisation		if (h){			oldlo= *((unsigned long*)*h);			if (lo<oldlo) {		// on tente de forcer la protection, mais on ne se laisse pas faire				ReleaseResource(h);				G.FindFirstKey_error=E3ERR_NOTFOUND;				return;			} 		} 								if (!h){ // pas de resource on place la date de modification du logiciel comme date initiale				// si la date du jours est plus avancée, on prend la date du jour												if  (lo>pb1.fileParam.ioFlCrDat)  pb1.fileParam.ioFlCrDat=lo;								h=NewHandle(256);				*((unsigned long*)*h)=pb1.fileParam.ioFlCrDat;				AddResource(h, 'FreP', 130, "\pPréférences locales");						ReleaseResource(h);				UpdateResFile(gCurResNum);				h=nil;				if ((lo <limite)) G.FindFirstKey_error=0;				UseResFile(oldresfile);  // on update le fichier				return;		} 					// on efface la resource, du fichier		// et on efface la resource de la mémoire				if (lo<limite){ // on est en dessous de la valeur limite			G.FindFirstKey_error=0;									if (h){				RemoveResource(h);				ReleaseResource(h);				h=nil;			}			// maintenant on crée la resource, avec la date du jour			h=NewHandle(256);			*((LPtr)*h)=lo;			AddResource(h, 'FreP', 130, "\pQuelques Préférences Initiales");					UpdateResFile(gCurResNum);			} 		UseResFile(oldresfile);  // on update le fichier#endif#ifdef	__NoProtect__		G.FindFirstKey_error=0;#endif}//DoInitSomeValue2void FadeInDialog(void){GWorldPtr		drawWorldP;PixMapHandle 	thePixMapH;PicHandle		pic1;GDHandle		gdh;CGrafPtr		oldport;RGBColor		noir,blanc,color;long		i;short		mode=srcCopy;			noir.red=0;			noir.green=0;			noir.blue=0;						blanc.red=-1;			blanc.green=-1;			blanc.blue=-1;						GetGWorld(&oldport,&gdh);			NewGWorld(&drawWorldP,0,&StartUpDialog->portRect,nil,nil,0);		// on commence par un écran noir (on efface l'écran)			RGBForeColor(&noir);			PaintRect(&StartUpDialog->portRect);			// on y va pour le dissolve			SetGWorld(drawWorldP, nil);			thePixMapH = GetGWorldPixMap(drawWorldP);			LockPixels(thePixMapH);			pic1=GetPicture(131);			DrawPicture(pic1,&StartUpDialog->portRect);			ReleaseResource((Handle)pic1);						// on fait le fondu						for (i=0;i<=65535;i+=0x1000) {				if (i>65535) i=65535;				// on copie le  drawWorldP1->drawWorldP2				//SetGWorld(drawWorldP2, nil);				SetGWorld((CGrafPtr)StartUpDialog,gdh);				RGBForeColor(&noir);				RGBBackColor(&blanc);				PenNormal();				//PenMode(mode);				color.red=i;				color.green=i;				color.blue=i;				RGBBackColor(&color);				CopyBits((BitMapPtr)(*thePixMapH),(BitMapPtr)&((GrafPtr)StartUpDialog)->portBits,		//*thePixMapH2						&StartUpDialog->portRect, &StartUpDialog->portRect, mode, nil);				WaitTicks(1);					}			WaitTicks(8);					UnlockPixels(thePixMapH);			DisposeGWorld(drawWorldP);			SetGWorld(oldport,gdh);}Boolean IsQuickTimeInstalled (void) {	short		error;	long		result;		error = Gestalt (gestaltQuickTime, &result);	return (error == noErr);	//return (false);}void Install_XTask(void){	gTaskInstalled=false;	if (gUtiliseXTask) {				// on installe le générateur interne		G.General_PseudoTimeCode=0x01000000;		G.GenerateurTask.tmRefCon=SetCurrentA5();	// Le pointeur A5		G.GenerateurTask.tmAddr=(ProcPtr)&GenerateurInterne;		G.GenerateurTask.tmWakeUp=0;		G.GenerateurTask.tmReserved=0; 		InsXTime((QElemPtr)&G.GenerateurTask); 		PrimeTime((QElemPtr)&G.GenerateurTask,300);				// on installe le système pour mesurer les performances		G.performanceTask.tmRefCon=SetCurrentA5();	// Le pointeur A5		G.performanceTask.tmAddr=(ProcPtr)&MesureCpuVitesse;		G.performanceTask.tmWakeUp=0;		G.performanceTask.tmReserved=0; 		InsXTime((QElemPtr)&G.performanceTask); 		PrimeTime((QElemPtr)&G.performanceTask,300); 		gTaskInstalled=true;				// système qui calcule la vitesse du VTR		gMesureVtrSpeed.tmRefCon=SetCurrentA5();	// Le pointeur A5		gMesureVtrSpeed.tmAddr=(ProcPtr)&CalcVtr_Speed;		gMesureVtrSpeed.tmWakeUp=0;		gMesureVtrSpeed.tmReserved=0; 		InsXTime((QElemPtr)&gMesureVtrSpeed); 		PrimeTime((QElemPtr)&gMesureVtrSpeed,300);  				gTaskInstalled=true;				//On patch ExitToshell(); pour ètre sûr de d'arrêter les x task sinon crash assuré		gOldExitToShellTrap=NGetTrapAddress(0xA9F4,ToolTrap);		NSetTrapAddress((UniversalProcPtr)&Patch_ExitToshell,0xA9F4,ToolTrap);				}	WaitTicks(67);// on attend un peu}void Dispose_XTask(void){   	if (!gTaskInstalled) return;	// on enlève les timer task présentent 	RmvTime((QElemPtr)&G.GenerateurTask); 	RmvTime((QElemPtr)&G.performanceTask); 	RmvTime((QElemPtr)&gMesureVtrSpeed);	WaitTicks(12);	// on rend le véritable exit to shell	NSetTrapAddress(gOldExitToShellTrap,0xA9F4,ToolTrap);}// si on est ici , cc'est que exit to shell demandé// on dispose les xtasks// et on saute au vrai exittoshell void Patch_ExitToshell(void){	// on enlève les timer task présentent 	RmvTime((QElemPtr)&G.GenerateurTask); 	RmvTime((QElemPtr)&G.performanceTask); 	RmvTime((QElemPtr)&gMesureVtrSpeed); 		/* on enlève la vbl si elle existe */		if(gVBLInstalled)  SlotVRemove((QElem*)&G.VBL_Structure,G.Ve_Slot);	NSetTrapAddress(gOldExitToShellTrap,0xA9F4,ToolTrap);		jumpExitToshell();	}	asm void jumpExitToshell( void ){		move.l	gOldExitToShellTrap,a0		jmp  		(a0) }void GetMyMenuPrefFile(void );void GetMyMenuPrefFile(void ){short count, Everesult;#ifndef	__Demo__	#ifndef	__NoProtect__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}						if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}				#endif#endif}/* 	Cette routine retourne les dimensions h & v de l'écran principal, 	ainsi que ses coordonnées*/void C_GETMAINSCREENRES (Rect *rect){short	err;		if (!G.FindFirstKey_error) {/* on effectue la lecture de la clef eve3 pour les options du logiciel*/			G.Options_dansLaClef=0;			err=RBEREAD(2,&G.Options_dansLaClef,0x3232,G.EveHandle);			err=RBEREAD(4,&G.Gfr4_inkey,0x5454,G.EveHandle);		}			*rect=(**GetMainDevice()).gdRect;}long  getserialnumber (void){short	err,count,FindFirstKey_error,Everesult;Handle	EveHandle=RBEHANDLE();unsigned long		Eve_SerialNumber;// un peu de protection de logiciel					count=6;		//7 essais			do{				Everesult=RBEFINDFIRST(0xB581,&Eve_SerialNumber,EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&Eve_SerialNumber,EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);						if (	Everesult == E3_SUCCESS) {				DisposeHandle(EveHandle);				return Eve_SerialNumber;			}					count=6;		//7 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&Eve_SerialNumber,EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&Eve_SerialNumber,EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);				DisposeHandle(EveHandle);		if (	Everesult == E3_SUCCESS) return Eve_SerialNumber;		else return -1;} //giveserial