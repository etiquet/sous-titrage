#include "BB.Globals_C.h"#include <QuickTimeComponents.h>#include <ImageCompression.h>#include <Palettes.h>extern MyQDGlobals QD;extern AppGlobals 	G;// Monitor menu itemsenum{	kVideoSettingsItem = 1, kSoundSettingsItem, kQuarterSizeItem = 4, kHalfSizeItem, kFullSizeItem};// GLOBALSComponentInstance 	gComponentInstance;SeqGrabComponent 	gSeqGrabber;SGChannel 			gVideoChannel;SGChannel 			gSoundChannel;DialogPtr 			gMonitor,gDialogReglageSimu;Rect 				gActiveVideoRect;PicHandle 			gMonitorPICT;GDHandle 			gAVDevice,gmyGDH;MenuRef				gMonitorMenu,gPositionFenetreMenu;ICMAlignmentProcRecordPtr 		gSeqGrabberAlignProc;RGBColor			minRGBKeyColor;RGBColor			maxRGBKeyColor;long				IndexKeyColor,myBlackForAV;CTabHandle			clut;GWorldPtr			gMonitorOffscreen,gMonitorOffscreenFinal;// des variables de travailBoolean 			gQuitFlag;extern Boolean		gModeKaraoke;Boolean 			gFullSize;Boolean 			gHalfSize;Boolean 			gQuarterSize;Boolean				gMaskingVitc;Boolean				gMaskingSousTitre;Boolean				gForcerPolice;Boolean				gForcerBold;Boolean				gCanReadVitc;RGBColor			gSimuColor,gKaraokeColor,gKeyColor;short				gTextSize,gSimuFont,gSimuFontItem,gAntiAlias;Ptr					gBufferEmissionBlancking;	// buffer pour inscripition dans blackingBoolean 			IsQuickTimeInstalled (void) ;// FUNCTION PROTOTYPESpascal void UpdateAV(void);pascal void AVIdle(void);pascal void DoInitAV(void);pascal void HandleEventAV(void);void 	DragAVWindow(Point   StartPt);pascal void HandleMenuAV(short menuItem);void DoDisposeAV(void);pascal void AdjustMenuAV(void);Boolean IsAvWindow(WindowPtr w);void ReglageSimuUpdate(void);void initialiseFloatAVDialog(void);void DecaleLAFenetreAV(short decalage);static void Enable(Handle menu,				   short item,				   Boolean ok);static OSErr XorRectToRgn(Rect* srcRectA,						  Rect* srcRectB,						  RgnHandle* destRgn);pascal Boolean SeqGrabberModalFilterProc(DialogPtr theDialog,										 EventRecord* theEvent,										 short* itemHit,										 long refCon);pascal void ValidateWindowList(void);void DoMyAVIdle(void);void Pre_InitAV(void);void DoRectTransparent(Rect *rect);int ReglageCarteAV(void);void CentreLAFenetreAV(Boolean always);void Pre_InitAV(void){	gDialogReglageSimu =nil;	gMonitor=nil;	gAVDevice=nil;	gMonitorMenu=nil;	gSeqGrabber=nil;/* on ne pas encore lire du VITC par la carte AV*/		gCanReadVitc=false;/* on prépositionne les valeurs pour les élments du mode AV */	gMaskingVitc=true;	gMaskingSousTitre=true;	gSimuColor.red=-1; gSimuColor.green=-1; gSimuColor.blue=-1;	gMonitorPICT=nil;// si quick time existe on initialise le "movie manager"	if (IsQuickTimeInstalled())  EnterMovies();}Boolean IsAvWindow(WindowPtr w){	return (w==gMonitor);}pascal void UpdateAV(void){		GrafPtr oldPort;		short type; Handle hndl; Rect box,rect;		RgnHandle	rgn;		GDHandle	curdev;		GetPort(&oldPort);		SetPort(gMonitor);				rgn=NewRgn();		RectRgn(rgn,&gMonitor->portRect);		SGUpdate(gSeqGrabber,rgn);		BeginUpdate(gMonitor); EndUpdate(gMonitor);		if (gMaskingVitc){			rect=gMonitor->portRect;			if (gQuarterSize) rect.bottom=5;			if (gHalfSize) rect.bottom=13;			if (gFullSize) rect.bottom=25;			ForeColor(blackColor);			PaintRect(&rect);		}		curdev=GetGDevice();		SetGDevice(gAVDevice);		VDGetKeyColor(gComponentInstance,&IndexKeyColor);		Index2Color(IndexKeyColor,&gKeyColor);		SetGDevice(curdev);		DisposeRgn(rgn);		SetPort(oldPort);} // updateavvoid SimuDialogEvent (EventRecord *event){DialogPtr				dialog=gDialogReglageSimu,dummyDialog;short					itemHit,part,type,Dodraw;Point					pt;long					a;GrafPtr					oldport;RGBColor				newColor;Handle 					hndl;Rect 					rect;SPtr					P;SousTitreRecordPtr		ST_Ptr;	GetPort(&oldport);	SetPort(gDialogReglageSimu);	TextFont(kFontIDGeneva);	TextSize(9);	pt=event->where;	GlobalToLocal(&pt);	Dodraw=0;	if (DialogSelect(event,&dummyDialog,&itemHit)){		GetDialogItem(gDialogReglageSimu,itemHit,&type,&hndl,&rect);		switch(itemHit) {				case 1: // forcer police						a=GetControlValue((ControlHandle)hndl);						if (a) a=0; else a=1;						gForcerPolice=a;						SetControlValue((ControlHandle)hndl,a);						Dodraw=1;				break;								case 2: // forcer gras						a=GetControlValue((ControlHandle)hndl);						if (a) a=0; else a=1;						gForcerBold=a;						SetControlValue((ControlHandle)hndl,a);						Dodraw=1;				break;				case 3: // pop-menu						a=GetControlValue((ControlHandle)hndl);						gSimuFont=GiveFontID(a);						Dodraw=1;				break;				case 4: // texte edit taille				break;				case 5: // incrément					gTextSize=C_IncDecValueSpecial(dialog,5,4,10,50,+1);					Dodraw=1;				break;				case 6: // décrément					gTextSize=C_IncDecValueSpecial(dialog,6,4,10,50,-1);					Dodraw=1;				break;				case 7: // couleur st					//if (gMaskingSousTitre){						pt.v=0; pt.h=0;						InsetRect(&rect,1,1);						InvertRect(&rect);						if ( GetColor(pt,							"\p Choisissez la couleur pour le sous-titre",							&gSimuColor,							&newColor) )  gSimuColor=newColor;						PaintRect(&rect);						FrameRectOneLine(&rect,true);						//} else AlertUser(20);					Dodraw=1;				break;				case 19: // couleur karaoké						pt.v=0; pt.h=0;						InsetRect(&rect,1,1);						InvertRect(&rect);						if ( GetColor(pt,							"\p Choisissez la couleur du volet «karaoké»",							&gKaraokeColor,							&newColor) )  gKaraokeColor=newColor;						PaintRect(&rect);						FrameRectOneLine(&rect,true);				break;				case 8: // cache						a=GetControlValue((ControlHandle)hndl);						if (a) a=0; else a=1;						gMaskingSousTitre=a;						SetControlValue((ControlHandle)hndl,a);						Dodraw=1;						//if (gMaskingSousTitre==0){//							GetDialogItem(gDialogReglageSimu,14,&type,&hndl,&rect);							SetControlValue((ControlHandle)hndl,0);							GetDialogItem(gDialogReglageSimu,15,&type,&hndl,&rect);							SetControlValue((ControlHandle)hndl,1);							GetDialogItem(gDialogReglageSimu,16,&type,&hndl,&rect);							SetControlValue((ControlHandle)hndl,0);							gAntiAlias=1;						//}				break;				case 9: // taille image				case 10: // 				case 11: // 						GetDialogItem(gDialogReglageSimu,9,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,0);						GetDialogItem(gDialogReglageSimu,10,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,0);						GetDialogItem(gDialogReglageSimu,11,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,0);						GetDialogItem(gDialogReglageSimu,itemHit,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,true);						HandleMenuAV(kQuarterSizeItem+(11-itemHit));						Dodraw=1;				break;				case 14: // antialias				case 15: // 				case 16: //  						GetDialogItem(gDialogReglageSimu,14,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,0);						GetDialogItem(gDialogReglageSimu,15,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,0);						GetDialogItem(gDialogReglageSimu,16,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,0);						GetDialogItem(gDialogReglageSimu,itemHit,&type,&hndl,&rect);						SetControlValue((ControlHandle)hndl,true);						gAntiAlias=itemHit-14;						Dodraw=1;				break;		} // switch		if (Dodraw) {			EffaceFenetreSimulation();			ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);			DessineAVST(ST_Ptr,(gAntiAlias!=0));			if (gAntiAlias!=0) transfertAVOffscreenInScreen();		}	}//dialog select			SetPort(oldport);}//SimuDialogEventvoid ReglageSimuUpdate(void){		GrafPtr oldPort;		short type; Handle hndl; Rect box,rect;		PixPatHandle the_pixpat;		RgnHandle	rgn,rgn1;		RGBColor	oldcolor;		GetPort(&oldPort); SetPort(gDialogReglageSimu);		TextFont(kFontIDGeneva);		TextSize(9);		BeginUpdate(gDialogReglageSimu);		the_pixpat=GetPixPat(129);		if (the_pixpat!=nil){			rgn=NewRgn();			rgn1=NewRgn();						RectRgn(rgn,&gDialogReglageSimu->portRect);			GetDialogItem(gDialogReglageSimu,20,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			FillCRgn(rgn,the_pixpat);						DisposePixPat(the_pixpat);			DisposeRgn(rgn);			DisposeRgn(rgn1);		}			Draw_Icon_Text_Ditl(gDialogReglageSimu);		DrawControls(gDialogReglageSimu);				GetDialogItem(gDialogReglageSimu,20,&type,&hndl,&rect);		FrameRectOneLine(&rect,true);// on dessine la couleur du sous-titre		GetForeColor(&oldcolor);		RGBForeColor(&gSimuColor);		GetDialogItem(gDialogReglageSimu,7,&type,&hndl,&rect);		PaintRect(&rect);		RGBForeColor(&oldcolor);		FrameRectOneLine(&rect,true);		InsetRect(&rect,-1,-1);		PenPat(&QD.gray);		FrameRect(&rect);// on dessine la couleur du karaoké		PenNormal();		GetForeColor(&oldcolor);		RGBForeColor(&gKaraokeColor);		GetDialogItem(gDialogReglageSimu,19,&type,&hndl,&rect);		PaintRect(&rect);		RGBForeColor(&oldcolor);		FrameRectOneLine(&rect,true);		InsetRect(&rect,-1,-1);		PenPat(&QD.gray);		FrameRect(&rect);		GetDialogItem(gDialogReglageSimu,4,&type,&hndl,&rect);		InsetRect(&rect,-1,-1);		FrameRect(&rect);		PenNormal();		EndUpdate(gDialogReglageSimu);		SetPort(oldPort);	}void initialiseFloatAVDialog(void){	short 					type;	Handle					hndl;	Rect					rect;	Str255					st0;		gSimuFontItem=GiveFontItemNumber(gSimuFont);		// on initialise la police pour la simu		GetDialogItem(gDialogReglageSimu,3,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,gSimuFontItem);		GetDialogItem(gDialogReglageSimu,1,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,1);		GetDialogItem(gDialogReglageSimu,8,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,gMaskingSousTitre);		//HiliteControl((ControlHandle)hndl,255);		GetDialogItem(gDialogReglageSimu,9,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,gAntiAlias);		GetDialogItem(gDialogReglageSimu,4,&type,&hndl,&rect);		NumToString(gTextSize,&st0);		SetDialogItemText(hndl,&st0);// on prépositionne les valeurs des boutons antialias		GetDialogItem(gDialogReglageSimu,14,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,0);		GetDialogItem(gDialogReglageSimu,15,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,0);		GetDialogItem(gDialogReglageSimu,16,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,0);		GetDialogItem(gDialogReglageSimu,14+gAntiAlias,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,true);// si problème de mémoire offscreen, on place le système en pas de anti-aliasing// et on désactive les autres controls		if (gMonitorOffscreen==nil || gMonitorOffscreenFinal==nil){		SetControlValue((ControlHandle)hndl,false);		GetDialogItem(gDialogReglageSimu,14,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,true);		GetDialogItem(gDialogReglageSimu,15,&type,&hndl,&rect);		HiliteControl((ControlHandle)hndl,255);		GetDialogItem(gDialogReglageSimu,16,&type,&hndl,&rect);		HiliteControl((ControlHandle)hndl,255);		}// on prépositionne les valeurs des boutons taille fenêtre		GetDialogItem(gDialogReglageSimu,9,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,gFullSize);		GetDialogItem(gDialogReglageSimu,10,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,gHalfSize);		GetDialogItem(gDialogReglageSimu,11,&type,&hndl,&rect);		SetControlValue((ControlHandle)hndl,gQuarterSize);// si pas mode de karaoké on n'affiche pas le deuxième réglage de couleur		if (!gModeKaraoke) HideDialogItem(gDialogReglageSimu,19);}//initialiseFloatAVDialog//-----------------------------------------------------------------------pascal void DoInitAV(void){	ComponentDescription 	theDesc;	ComponentResult 		result = noErr;	Component 				sgCompID = 0L;	GrafPtr 				savedPort;	VideoDigitizerError 	error;	short 					type;	Handle					hndl;	Rect					rect;	Str255					st0;	MenuHandle			 	Menu;	AvFlagsPrefHandle		avfh;	OSErr					err;	PixMapHandle			gPM;	Rect					Rr;	RGBColor				min,max;	// Init stuff	gSeqGrabber = 0L;	gVideoChannel = 0L;	gSoundChannel = 0L;	gMonitorPICT = nil;// on place quelques valeurs par défault	gForcerBold=0;	gForcerPolice=1;	gTextSize=30;	gSimuFont=kFontIDHelvetica;	gAntiAlias=1;	gQuarterSize = false;	gHalfSize = false;	gFullSize = true;// on récupère les preference dans le fichier	avfh=nil;	GetAvFlagsPref(&avfh);	if (avfh){		gSimuColor=(**avfh).SimuColor;		gMaskingVitc=(**avfh).MaskingVitc;		gMaskingSousTitre=(**avfh).MaskingSousTitre;		gForcerBold=(**avfh).ForcerBold;		gForcerPolice=(**avfh).ForcerPolice;		gTextSize=(**avfh).TextSize;		gSimuFont=(**avfh).SimuFont;		gAntiAlias=(**avfh).AntiAlias;		gQuarterSize=(**avfh).QuarterSize;		gHalfSize=(**avfh).HalfSize;		gFullSize=(**avfh).FullSize;		DisposeHandle((Handle)avfh);	}// on insert le menu de configuration de la carte AV	gMonitorMenu=GetMenu(138);	InsertMenu((MenuRef)gMonitorMenu,-1);	gPositionFenetreMenu=GetMenu(143);	InsertMenu((MenuRef)gMonitorMenu,-1);// Find and open a sequence grabber	theDesc.componentType = SeqGrabComponentType;	theDesc.componentSubType = 0L;	theDesc.componentManufacturer = 'appl';	theDesc.componentFlags = 0L;	theDesc.componentFlagsMask = 0L;	sgCompID = FindNextComponent(nil, &theDesc);	if (sgCompID != 0L)	{		gSeqGrabber = OpenComponent(sgCompID);	}	// If we got a sequence grabber, set it up	if (gSeqGrabber != 0L)	{		// Get the monitor		gMonitor =nil;	// GetNewDialog(260, nil, (WindowPtr) - 1L); 		GetNewWindowReference((DialogPtr*)&gMonitor,260,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette simulation		// on demande un peu de mémoire pour faire anti-aliasing pour simu		SetRect(&rect,0,0,768,576);		gMonitorOffscreenFinal=nil;		err=NewGWorld(&gMonitorOffscreenFinal,8,&rect,nil,gAVDevice,0);		if (err) AlertUser(21);		SetRect(&rect,0,0,2306,900/*1728*/);		gMonitorOffscreen=nil;		if (!err) {			err=NewGWorld(&gMonitorOffscreen,8,&rect,nil,gAVDevice,0);			if (err)  {						AlertUser(22);						if (gMonitorOffscreenFinal){ 								DisposeGWorld(gMonitorOffscreenFinal);								gMonitorOffscreenFinal=nil;							}			}		}// on vérouille les offscreen buffer		LockPixels(GetGWorldPixMap(gMonitorOffscreenFinal));		LockPixels(GetGWorldPixMap(gMonitorOffscreen));// on récupère le dialogue de réglage		gDialogReglageSimu =nil;	// GetNewDialog(266, nil, (WindowPtr) - 1L); 		GetNewWindowReference((DialogPtr*)&gDialogReglageSimu,266,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette simulation		initialiseFloatAVDialog();		if (gMonitor != nil)		{			// Initialize the sequence grabber			GetPort(&savedPort);			SetPort(gMonitor);			result = SGInitialize(gSeqGrabber);			if (result == noErr)			{				result = SGSetGWorld(gSeqGrabber, (CGrafPtr)gMonitor, nil);				// Get a video channel				result = SGNewChannel(gSeqGrabber, VideoMediaType, &gVideoChannel);				if ((gVideoChannel != nil) && (result == noErr))				{					short 			width;					short 			height;					MatrixRecord	Matrix;					PixMapHandle	PM;					RgnHandle		mask;					Rect			rec;					Ptr				base;					result = SGSetChannelUsage(gVideoChannel, seqGrabPreview);	// on configure le standart d'entrée					gComponentInstance=SGGetVideoDigitizerComponent(gVideoChannel);					error=VDSetInputStandard(gComponentInstance,palIn /*secamIn*/);					error=VDGetActiveSrcRect(gComponentInstance,palIn,&gActiveVideoRect);					error=VDSetDigitizerRect(gComponentInstance,&gActiveVideoRect);					result = SGSetVideoRect(gVideoChannel, &gActiveVideoRect);										if (gQuarterSize) {						width = (gActiveVideoRect.right - gActiveVideoRect.left)/4;						height = (gActiveVideoRect.bottom - gActiveVideoRect.top)/4;						}					if (gHalfSize) {						width = (gActiveVideoRect.right - gActiveVideoRect.left)/2;						height = (gActiveVideoRect.bottom - gActiveVideoRect.top)/2;						}					if (gFullSize) {						width = (gActiveVideoRect.right - gActiveVideoRect.left);						height = (gActiveVideoRect.bottom - gActiveVideoRect.top);						}					SizeWindow(gMonitor, width, height, false);					CentreLAFenetreAV(true);					result = SGSetChannelBounds(gVideoChannel, &(gMonitor->portRect));				}				// Get a sound channel				result = SGNewChannel(gSeqGrabber, SoundMediaType, &gSoundChannel);				if ((gSoundChannel != nil) && (result == noErr))				{					result = SGSetChannelUsage(gSoundChannel, seqGrabPreview);				}				// Get ready…				result = SGPrepare(gSeqGrabber, true, false);			}			// Go!			result = SGStartPreview(gSeqGrabber);			result = VDGetKeyColor(gComponentInstance,&IndexKeyColor);						RAZReglageAV();			result = SGPause(gSeqGrabber, false);			UpdateAV();			gCanReadVitc=true;		SetPort(savedPort);		}	}}//-----------------------------------------------------------------------pascal void AVIdle(void){Rect	rect;	ComponentResult result = noErr;	// Give some time to the sequence grabber	if (gSeqGrabber != 0L){	 		//result = SGIdle(gSeqGrabber); 		}}//-----------------------------------------------------------------------void DragAVWindow(Point StartPt){					ComponentResult result = noErr;					Rect limitRect;					RgnHandle grayRgn = GetGrayRgn();					Rect boundsRect;					PixMapHandle	Pmh;				// Find bounds					if (grayRgn != nil)					{						limitRect = (*grayRgn)->rgnBBox;					}					else					{						limitRect = QD.screenBits.bounds;					}					// Pause the sequence grabber					result = SGPause(gSeqGrabber, true);					if (gVideoChannel != nil)					{						// Get the alignment proc						result = SGGetAlignmentProc(gSeqGrabber, gSeqGrabberAlignProc);						// Drag it with the totally cool DragAlignedWindow						// Note that the sequence grabber can get real confused when you use this						// call if you've got multiple video channels - this'll get fixed in the 						// next release.  						result = SGGetChannelBounds(gVideoChannel, &boundsRect);						DragAlignedWindow(gMonitor,StartPt, &limitRect, &boundsRect, gSeqGrabberAlignProc);						//CentreLAFenetreAV(false);						SelectReferencedWindow((WindowReference)gMonitor);						//ValidateWindowList();					}					// Start up the sequence grabber					result = SGPause(gSeqGrabber, false);					UpdateAV();} // drag windowpascal void AdjustMenuAV(void){	register WindowPeek wp = nil;	short kind = 0;	Boolean DA = false;	ComponentResult result = noErr;	if (gMonitorMenu) {			// Monitor menu			Enable((Handle)gMonitorMenu, kVideoSettingsItem, (gVideoChannel != 0L ? true : false));			Enable((Handle)gMonitorMenu, kSoundSettingsItem, (gSoundChannel != 0L ? true : false));			Enable((Handle)gMonitorMenu, kQuarterSizeItem, (gVideoChannel != 0L ? true : false));			CheckItem((MenuRef)gMonitorMenu, kQuarterSizeItem, gQuarterSize);			Enable((Handle)gMonitorMenu, kHalfSizeItem, (gVideoChannel != 0L ? true : false));			CheckItem((MenuRef)gMonitorMenu, kHalfSizeItem, gHalfSize);			Enable((Handle)gMonitorMenu, kFullSizeItem, (gVideoChannel != 0L ? true : false));			CheckItem((MenuRef)gMonitorMenu, kFullSizeItem, gFullSize);			Enable((Handle)gMonitorMenu, 8, (gVideoChannel != 0L ? true : false));	}} // adjustmenuVideo//-----------------------------------------------------------------------static void Enable(Handle menu,				   short item,				   Boolean ok){	// Utility routine to enable and disable menu items	if (ok)	{		EnableItem((MenuRef)menu, item);	}	else	{		DisableItem((MenuRef)menu, item);	}}pascal void HandleMenuAV(short menuItem){OSErr	result;Rect	rect,rect1;RGBColor newColor;Point 	pt;				switch (menuItem)				{						short width;						short height;						Rect curBounds;						Rect curVideoRect;						Rect newVideoRect;						Rect newBounds;						Rect maxBoundsRect;						GrafPtr savedPort;						RgnHandle deadRgn;						Rect boundsRect;					case kVideoSettingsItem:						{							if ((gSeqGrabber != 0L) && (gVideoChannel != 0L))							{								Rect newActiveVideoRect;								Rect adjustedActiveVideoRect;								// Get our current state								result = SGGetChannelBounds(gVideoChannel, &curBounds);								result = SGGetVideoRect(gVideoChannel, &curVideoRect);								// Do the dialog thang																ReglageCarteAV();								result = SGPause(gSeqGrabber, true);								//result = SGSettingsDialog(gSeqGrabber, gVideoChannel, 0, nil, 0L,SeqGrabberModalFilterProc,(long)StripAddress((Ptr)gMonitor));								// What happened?								result = SGGetVideoRect(gVideoChannel, &newVideoRect);								result = SGGetSrcVideoBounds(gVideoChannel, &newActiveVideoRect);								// Set up our port								GetPort(&savedPort);								SetPort(gMonitor);								// Has our active rect changed?								// If so, it's because our video standard changed (e.g., NTSC to PAL),								// and we need to adjust our monitor window								if (!EqualRect(&gActiveVideoRect, &newActiveVideoRect))								{									if (gFullSize)									{										width = newActiveVideoRect.right - newActiveVideoRect.left;										height = newActiveVideoRect.bottom - newActiveVideoRect.top;										gActiveVideoRect = newActiveVideoRect;										SizeWindow(gMonitor, width, height, false);										result = SGSetChannelBounds(gVideoChannel, &(gMonitor->portRect));									}									else if (gHalfSize)									{										width = (newActiveVideoRect.right - newActiveVideoRect.left) / 2;										height = (newActiveVideoRect.bottom - newActiveVideoRect.top) / 2;										gActiveVideoRect = newActiveVideoRect;										SizeWindow(gMonitor, width, height, false);										result = SGSetChannelBounds(gVideoChannel, &(gMonitor->portRect));									}									else if (gQuarterSize)									{										width = (newActiveVideoRect.right - newActiveVideoRect.left) / 4;										height = (newActiveVideoRect.bottom - newActiveVideoRect.top) / 4;										gActiveVideoRect = newActiveVideoRect;										SizeWindow(gMonitor, width, height, false);										result = SGSetChannelBounds(gVideoChannel, &(gMonitor->portRect));									}								}								// Has our crop changed?								// This code shows how to be crop video panel friendly								// Two important things - 								// 1) Be aware that you might have been cropped and adjust your								//    video window appropriately								// 2) Be aware that you might have been adjusted and attempt to								//    account for this.  Adjusting refers to using the digitizer								//    rect to "adjust" the active source rect within the maximum								//    source rect.  This is useful if you're getting those nasty								//    black bands on the sides of your video display - you can use								//    the control-arrow key sequence to shift the active source 								//    rect around when you're in the crop video panel								adjustedActiveVideoRect = gActiveVideoRect;								if (!EqualRect(&curVideoRect, &newVideoRect))								{									if ((newVideoRect.left < gActiveVideoRect.left) || (newVideoRect.right > gActiveVideoRect.right) || (newVideoRect.top < gActiveVideoRect.top) || (newVideoRect.bottom > gActiveVideoRect.bottom))									{										if (newVideoRect.left < gActiveVideoRect.left)										{											adjustedActiveVideoRect.left = newVideoRect.left;											adjustedActiveVideoRect.right -= (gActiveVideoRect.left - newVideoRect.left);										}										if (newVideoRect.right > gActiveVideoRect.right)										{											adjustedActiveVideoRect.right = newVideoRect.right;											adjustedActiveVideoRect.left += (newVideoRect.right - gActiveVideoRect.right);										}										if (newVideoRect.top < gActiveVideoRect.top)										{											adjustedActiveVideoRect.top = newVideoRect.top;											adjustedActiveVideoRect.bottom -= (gActiveVideoRect.top - newVideoRect.top);										}										if (newVideoRect.bottom > gActiveVideoRect.bottom)										{											adjustedActiveVideoRect.bottom = newVideoRect.bottom;											adjustedActiveVideoRect.top += (newVideoRect.bottom - gActiveVideoRect.bottom);										}										newBounds = newVideoRect;										MapRect(&newBounds, &adjustedActiveVideoRect, &(gMonitor->portRect));									}									else		// Can't tell if we've been adjusted (digitizer rect is smaller on all sides										// than the active source rect)										{											newBounds = newVideoRect;											MapRect(&newBounds, &gActiveVideoRect, &(gMonitor->portRect));										}									width = newBounds.right - newBounds.left;									height = newBounds.bottom - newBounds.top;									result = SGSetChannelBounds(gVideoChannel, &newBounds);								}								// Clean out the part of the port that isn't being drawn in								deadRgn = NewRgn();								if (deadRgn != nil)								{									result = SGGetChannelBounds(gVideoChannel, &boundsRect);									result = XorRectToRgn(&boundsRect, &(gMonitor->portRect), &deadRgn);									EraseRgn(deadRgn);									DisposeRgn(deadRgn);								}								SetPort(savedPort);								// The pause that refreshes								result = SGPause(gSeqGrabber, false);							}							break;						}					case kSoundSettingsItem:						{							if ((gSeqGrabber != 0L) && (gSoundChannel != 0L))							{								// Do the dialog thang								result = SGSettingsDialog(gSeqGrabber, gSoundChannel, 0, nil, 0L, SeqGrabberModalFilterProc, (long)StripAddress((Ptr)gMonitor));							}							break;						}						case kQuarterSizeItem:						{							// New width and height							width = (gActiveVideoRect.right - gActiveVideoRect.left) / 4;							height = (gActiveVideoRect.bottom - gActiveVideoRect.top) / 4;							// Set flags and menus							gQuarterSize = true;							gHalfSize = false;							gFullSize = false;							AdjustMenuAV();							// Resize the monitor							GetPort(&savedPort);							SetPort(gMonitor);							result = SGPause(gSeqGrabber, true);							result = SGGetChannelBounds(gVideoChannel, &curBounds);							maxBoundsRect = gMonitor->portRect;							SizeWindow(gMonitor, width, height, false);							CentreLAFenetreAV(false);							MapRect(&curBounds, &maxBoundsRect, &(gMonitor->portRect));							result = SGSetChannelBounds(gVideoChannel, &curBounds);							// Clean out part of port we're not drawing in							deadRgn = NewRgn();							if (deadRgn != nil)							{								result = SGGetChannelBounds(gVideoChannel, &boundsRect);								result = XorRectToRgn(&boundsRect, &(gMonitor->portRect), &deadRgn);								EraseRgn(deadRgn);								DisposeRgn(deadRgn);							}							SetPort(savedPort);							result = SGPause(gSeqGrabber, false);							break;						}					case kHalfSizeItem:						{							// New width and height							width = (gActiveVideoRect.right - gActiveVideoRect.left) / 2;							height = (gActiveVideoRect.bottom - gActiveVideoRect.top) / 2;							// Set flags and menus							gQuarterSize = false;							gHalfSize = true;							gFullSize = false;							AdjustMenuAV();							// Resize the monitor							GetPort(&savedPort);							SetPort(gMonitor);							result = SGPause(gSeqGrabber, true);							result = SGGetChannelBounds(gVideoChannel, &curBounds);							maxBoundsRect = gMonitor->portRect;							SizeWindow(gMonitor, width, height, false);							CentreLAFenetreAV(false);							MapRect(&curBounds, &maxBoundsRect, &(gMonitor->portRect));							result = SGSetChannelBounds(gVideoChannel, &curBounds);							// Clean out part of port we're not drawing in							deadRgn = NewRgn();							if (deadRgn != nil)							{								result = SGGetChannelBounds(gVideoChannel, &boundsRect);								result = XorRectToRgn(&boundsRect, &(gMonitor->portRect), &deadRgn);								EraseRgn(deadRgn);								DisposeRgn(deadRgn);							}							SetPort(savedPort);							result = SGPause(gSeqGrabber, false);							break;						}					case kFullSizeItem:						{							// New width and height							width = gActiveVideoRect.right - gActiveVideoRect.left;							height = gActiveVideoRect.bottom - gActiveVideoRect.top;							// Set flags and menus							gQuarterSize = false;							gHalfSize = false;							gFullSize = true;							AdjustMenuAV();							// Resize the monitor							GetPort(&savedPort);							SetPort(gMonitor);							result = SGPause(gSeqGrabber, true);							result = SGGetChannelBounds(gVideoChannel, &curBounds);							maxBoundsRect = gMonitor->portRect;							SizeWindow(gMonitor, width, height, false);							CentreLAFenetreAV(true);							MapRect(&curBounds, &maxBoundsRect, &(gMonitor->portRect));							result = SGSetChannelBounds(gVideoChannel, &curBounds);							// Clean out part of port we're not drawing in							deadRgn = NewRgn();							if (deadRgn != nil)							{								result = SGGetChannelBounds(gVideoChannel, &boundsRect);								result = XorRectToRgn(&boundsRect, &(gMonitor->portRect), &deadRgn);								EraseRgn(deadRgn);								DisposeRgn(deadRgn);							}							SetPort(savedPort);							result = SGPause(gSeqGrabber, false);							break;						}					case	8:						SelectReferencedWindow((WindowReference)gDialogReglageSimu);						ShowReferencedWindow	((WindowReference)gDialogReglageSimu);						break;					case 10 :							DecaleLAFenetreAV(-10);					break;										case 11 :							DecaleLAFenetreAV(10);					break;			}//switch}					//-----------------------------------------------------------------------static OSErr XorRectToRgn(Rect* srcRectA,						  Rect* srcRectB,						  RgnHandle* destRgn){	RgnHandle srcRgnA = NewRgn();	RgnHandle srcRgnB = NewRgn();	OSErr result = noErr;	if ((destRgn != nil) && (*destRgn != nil))	{		if ((srcRgnA != nil) && (srcRgnB != nil))		{			RectRgn(srcRgnA, srcRectA);			RectRgn(srcRgnB, srcRectB);			XorRgn(srcRgnA, srcRgnB, *destRgn);		}		else		{			result = memFullErr;		}	}	else	{		result = nilHandleErr;	}	return (result);}//-----------------------------------------------------------------------pascal Boolean SeqGrabberModalFilterProc(DialogPtr theDialog,										 EventRecord* theEvent,										 short* itemHit,										 long refCon){	// Ordinarily, if we had multiple windows we cared about, we'd handle	// updating them in here, but since we don't, we'll just clear out	// any update events meant for us	Boolean handled = false;	if ((theEvent->what == updateEvt) && ((WindowPtr)theEvent->message == (WindowPtr)refCon))	{		BeginUpdate((WindowPtr)refCon);		EndUpdate((WindowPtr)refCon);		handled = true;	}	return (handled);}//-----------------------------------------------------------------------void DoDisposeAV(void){AvFlagsPrefHandle	avfh;	ComponentResult result = noErr;// on dispose les offscreens		if (gMonitorOffscreen) DisposeGWorld(gMonitorOffscreen);		if (gMonitorOffscreenFinal) DisposeGWorld(gMonitorOffscreenFinal);	// Clean up	if (gSeqGrabber != 0L)	{		result = CloseComponent(gSeqGrabber);		gSeqGrabber = 0L;	}	if (gMonitor != nil)	{		// on ecrit les préférence dans un fichier		avfh=(AvFlagsPrefHandle)NewHandle(sizeof(AvFlagsPref));		(**avfh).SimuColor=gSimuColor;		(**avfh).MaskingVitc=gMaskingVitc;		(**avfh).MaskingSousTitre=gMaskingSousTitre;		(**avfh).ForcerBold=gForcerBold;		(**avfh).ForcerPolice=gForcerPolice;		(**avfh).TextSize=gTextSize;		(**avfh).SimuFont=gSimuFont;		(**avfh).AntiAlias=gAntiAlias;		(**avfh).QuarterSize=gQuarterSize;		(**avfh).HalfSize=gHalfSize;		(**avfh).FullSize=gFullSize;		PutAvFlagsPref(avfh);		DisposeHandle((Handle)avfh);		//DisposeWindowReference((WindowReference)gMonitor);		//DisposeWindowReference((WindowReference)gDialogReglageSimu);	}	ExitMovies();}//-----------------------------------------------------------------------void DoMyAVIdle(void){Rect	rect;long	a;GrafPtr	oldport;	GetPort(&oldport);	SetPort(gMonitor);	rect=gMonitor->portRect;	rect.top=rect.bottom-30;	//if 		(a&1==a) EraseRect(&rect);	//else	DoRectTransparent(&rect);	EraseRect(&rect);	DoRectTransparent(&rect);	SetPort(oldport);}void DoRectTransparent(Rect *therect){GrafPtr	oldport;	GetPort(&oldport);	SetPort(gMonitor);	RGBBackColor(&gKeyColor);	EraseRect(therect);	SetPort(oldport);}//DoRectTransparentvoid CentreLAFenetreAV(Boolean always){PixMapHandle	pmh;Rect	rect,rect1;Point	pt;GrafPtr	oldport;unsigned short 	h,l,W,H;Boolean flag=always;	GetPort(&oldport);	SetPort(gMonitor);//Les infos sur la carte AV 	pmh=(**gAVDevice).gdPMap;	rect1=(**pmh).bounds;	rect=gMonitor->portRect;	LocalToGlobal((Point*)&rect);	LocalToGlobal((Point*)&rect+1);// on regarde si la fenêtre est dans l'écran si non on la centre	if (rect.left <rect1.left ) flag=true;	if (rect.top < rect1.top ) flag=true;	if (rect.right >rect1.right ) flag=true;	if (rect.bottom >rect1.bottom ) flag=true;	if (flag){		W=rect1.right-rect1.left;		H=rect1.bottom-rect1.top;		l=rect.right-rect.left;		h=rect.bottom-rect.top;		W=W-l;		W=(W/2)+rect1.left;		H=H-h;		H=(H/2)+rect1.top;		MoveWindow(gMonitor,W,H,false);	} 	SetPort(oldport);}void DecaleLAFenetreAV(short decalage){PixMapHandle	pmh;Rect	rect,rect1;Point	pt;GrafPtr	oldport;unsigned short 	h,l,W,H;OSErr	result;	GetPort(&oldport);	SetPort(gMonitor);//Les infos sur la carte AV	pmh=(**gAVDevice).gdPMap;	rect1=(**pmh).bounds;	rect=gMonitor->portRect;	LocalToGlobal((Point*)&rect);	LocalToGlobal((Point*)&rect+1);	MoveWindow(gMonitor,rect.left+decalage,rect.top,false);	result = SGGetAlignmentProc(gSeqGrabber,gSeqGrabberAlignProc);	AlignWindow(gMonitor, false, nil,gSeqGrabberAlignProc);	result = SGSetChannelBounds(gVideoChannel, &gMonitor->portRect);	SetPort(oldport);}