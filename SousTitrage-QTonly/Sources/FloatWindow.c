/*	File:		WindowExtensions.c		Contains:	Routines to support floating windows		Written by:	Dean Yu		Copyright:	© 1993 Apple Computer, Inc.	*/#include <Types.h>#include <Events.h>#include <Gestalt.h>#include <Memory.h>#include <Menus.h>#include <Processes.h>#include <Resources.h>#include <LowMem.h>		// dkj replaced SysEqu.h#include <ToolUtils.h>#include <Windows.h>#include "BB.FloatWindow.h"#include "BB.Globals_C.h"// **************** structures ******************** 	extern MyQDGlobals QD;	extern AppGlobals G;			// Internal routine prototypesstatic void ActivateWindow(WindowReference theWindow);static void DeactivateWindow(WindowReference theWindow);static void HighlightAndActivateWindow(WindowReference theWindow, Boolean activate);static WindowReference GetWindowList(void);static void SetWindowList(WindowReference windowReference);//// GetNewWindowReference////	Create a window based on information in the specified resource.//pascal OSErr GetNewWindowReference(DialogPtr *windowReference, short windResourceID, WindowReference behind, ActivateHandlerUPP activateHandler){	WindowReference	newWindowReference;	WindowReference	lastFloatingWindow;	Ptr	floatingstorage;	long		gestaltResult;	OSErr		gestaltError;	OSErr		result;	short		defProcID;		result = noErr;	floatingstorage=NewPtrClear(sizeof(WindowRecordExtensions));	if (MemError() == noErr) {	// Create a window based on the specified 'WIND' resource.  If Color Quickdraw	// is around, create a color window, otherwise, make a black and white one.		gestaltError = Gestalt(gestaltQuickdrawVersion, &gestaltResult);		if ((gestaltError != noErr) || (gestaltResult == gestaltOriginalQD))			newWindowReference = (WindowReference) GetNewDialog(windResourceID,floatingstorage, (WindowPtr) behind);		else			newWindowReference = (WindowReference) GetNewDialog(windResourceID, floatingstorage, (WindowPtr) behind);		// If we got a window, create the reference, then make sure the windowKind field is	// set correctly for floating windows.			if (newWindowReference != nil) {			*windowReference =(DialogPtr) newWindowReference;			//SetActivateHandlerProc(newWindowReference, activateHandler);				// Figure out if this is a floating window, based upon the resource ID of the 'WDEF'.	// This is a really wierd way of doing it, but this allows the 'WIND' resource to	// describe the floatability of a window.	//	// A little known fact about GetResInfo is that if you specify nil for any of the	// info parameters, then it won’t return that information.  Handy, huh?				GetResInfo(GetWindowDefProc(newWindowReference), &defProcID, nil, nil);			if (defProcID == rFloatingWindowProc) {					// Return an error if it’s a floating window being created behind a non floating window.							if (((behind == nil) && (BB_FrontNonFloatingWindow() != nil)) ||					((behind != (WindowReference) -1) && (Get_WindowKind(behind) != kApplicationFloaterKind))) {					*windowReference = 0;					return kInvalidWindowOrderingError;				}				else {					SetWindowKind(newWindowReference, kApplicationFloaterKind);					HiliteWindow((WindowPtr) newWindowReference, true);				}			} 			else				// If we’re not creating a floating window, but the application wanted it in the	// front, create the window behind the last floating window.							if (behind == (WindowReference) -1) {					lastFloatingWindow = LastFloatingWindow();										if (lastFloatingWindow != nil)						SendBehind((WindowPtr) newWindowReference, (WindowPtr) lastFloatingWindow);					else						BringToFront((WindowPtr) newWindowReference);				}		}		else {			*windowReference = 0;			result = kWindowNotCreatedError;			DisposePtr(floatingstorage);		}	}	else {		*windowReference = 0;		result = kWindowNotCreatedError;	}		return result;}//// DisposeWindowReference////	Free the memory used by a window.  If it is visible, hide it first so//	that the proper activate and deactivate events are sent.//pascal void DisposeWindowReference(WindowReference windowReference){	if (GetWindowVisible(windowReference))		HideReferencedWindow(windowReference);	DisposeDialog((WindowPtr) windowReference);}//// SelectedReferencedWindow//// Select the specified window, and bring it to the front if its portion// of the window list.//pascal void SelectReferencedWindow(WindowReference windowToSelect){	WindowReference			currentFrontWindow;	WindowReference			lastFloatingWindow;	Boolean				isFloatingWindow;		ValidateWindowList();	if (Get_WindowKind(windowToSelect) == kApplicationFloaterKind) {		isFloatingWindow = true;		currentFrontWindow = (WindowReference) FrontWindow();	}	else {		isFloatingWindow = false;		currentFrontWindow = BB_FrontNonFloatingWindow();		lastFloatingWindow = LastFloatingWindow();	}	// Be fast (and lazy) and do nothing if we don’t have to.	if (currentFrontWindow != windowToSelect) {	// Selecting floating windows are easy, since they’re always active		if (isFloatingWindow){			BringToFront((WindowPtr) windowToSelect);			HiliteWindow((WindowPtr) windowToSelect,true);		} else {		// If there are no floating windows, we can call SelectWindow like the good ol’ days			if (lastFloatingWindow == nil)				SelectWindow((WindowPtr) windowToSelect);			else {	// Deactivate the window currently in front.				DeactivateWindow(currentFrontWindow);		// Bring it behind the last floating window and activate it.	// Note that Inside Mac 1 states that you need to call PaintOne() and CalcVis() on a	// window if you are using SendBehind() to bring it closer to the front.  With System 7,	// this is no longer necessary.				SendBehind((WindowPtr) windowToSelect, (WindowPtr) lastFloatingWindow);				ActivateWindow(windowToSelect);			}		}	}}//// ShowReferencedWindow////	Show the specified window.  If the window is the frontmost document window,//	unhighlight the window behind it, deactivate it, and activate this one.//pascal void ShowReferencedWindow(WindowReference windowToShow){	WindowReference			windowBehind;	WindowReference			NonFloatingWindow;	ActivateHandlerUPP	activateHandlerProc;	short				windowClass;	Boolean				windowIsInFront = false;		if (GetWindowVisible(windowToShow) != false)		return;			windowClass = Get_WindowKind(windowToShow);		// If the window behind the window to show is currently the frontmost document window,	// unhighlight it, and highlight the new front window.		if (windowClass != kApplicationFloaterKind) {		windowBehind = Get_NextWindow(windowToShow);		if (windowBehind == BB_FrontNonFloatingWindow()) {			if (windowBehind != nil)				DeactivateWindow(windowBehind);	// Set the highlight state so the window appears highlighted from the start.				SetWindowHilite(windowToShow, true);			windowIsInFront = true;		}	}	else {		// A floating window is about to be shown. Make sure the windows in the window list	// are all in the right place.			ValidateWindowList();			// Check to see if a modal window is up before trying to highlight it.			NonFloatingWindow = BB_FrontNonFloatingWindow();		if ((NonFloatingWindow != nil) &&			(NonFloatingWindow == (WindowReference) FrontWindow()) &&			(WindowIsModal(NonFloatingWindow)))			SetWindowHilite(windowToShow, false);		else {			SetWindowHilite(windowToShow, true);			windowIsInFront = true;		}	}		// Show the window		ShowHide((WindowPtr) windowToShow, true);		// If this is the new frontmost document window or a floating window, send it an activate event		if (windowIsInFront) {		activateHandlerProc = GetActivateHandlerProc(windowToShow);		/* on ne veut pas de ce code			if (activateHandlerProc != nil)			CallActivateHandlerProc(activateHandlerProc, windowToShow, kActivateWindow);		*/		}}//// HideReferencedWindow////	Hide the specified window.  If it is frontmost, move it behind the window immediately//	behind it, like HideWindow does.//pascal void HideReferencedWindow(WindowReference windowToHide){	WindowReference			frontFloater;	WindowReference			frontNonFloater;	WindowReference			lastFloater;	WindowReference			windowBehind;		// Don’t do anything if the window is already invisible.		if (GetWindowVisible(windowToHide) == false)		return;		// Get the first visible floating window, if any.		frontFloater = (WindowReference) FrontWindow();	if (Get_WindowKind(frontFloater) != kApplicationFloaterKind)		frontFloater = nil;			// Get the first visible document window, if any.		frontNonFloater = BB_FrontNonFloatingWindow();		// Hide the window.		ShowHide((WindowPtr) windowToHide, false);		// If the frontmost floating window is being hidden, move it behind the floating window	// behind it, if there is one.		if (windowToHide == frontFloater) {		windowBehind = Get_NextWindow(windowToHide);			// Only do the rearrangement if there’s another floating window.			if ((windowBehind != nil) &&			(Get_WindowKind(windowBehind) == kApplicationFloaterKind)) {			SetNextWindow(windowToHide, Get_NextWindow(windowBehind));			SetNextWindow(windowBehind, windowToHide);			SetWindowList(windowBehind);		}	}	else {		// If the frontmost document window is behind hidden, send it behind the window	// behind it.			if (windowToHide == frontNonFloater) {			windowBehind = Get_NextWindow(windowToHide);						if (windowBehind != nil) {				SetNextWindow(windowToHide, Get_NextWindow(windowBehind));				SetNextWindow(windowBehind, windowToHide);					// Set the next link of the last floating window to point to the previously second	// to front document window. If there was no floating window, change the beginning	// of the window list.					lastFloater = LastFloatingWindow();				if (lastFloater != nil)					SetNextWindow(lastFloater, windowBehind);				else					SetWindowList(windowBehind);					// The window behind it is now the front document window.  Highlight it and send it	// and activate event.								ActivateWindow(windowBehind);			}		}	}}pascal void DragReferencedWindow(WindowReference windowToDrag, Point startPoint, const Rect *draggingBounds){	Rect		dragRect;	KeyMap		keyMap;	GrafPtr		savePort;	GrafPtr		windowManagerPort;	RgnHandle	dragRegion;	RgnHandle	windowContentRegion;	long		dragResult;	short		topLimit;	short		newHorizontalWindowPosition;	short		newVerticalWindowPosition;	short		horizontalOffset;	short		verticalOffset;	Boolean		commandKeyDown = false;		if (WaitMouseUp()) {		// Adjust the top of the dragging rectangle so that it’s below the menu bar			topLimit = GetMBarHeight() + 4;		dragRect = *draggingBounds;		if (dragRect.top < topLimit)			dragRect.top = topLimit;		// Set up the Window Manager port.			GetPort(&savePort);		GetWMgrPort(&windowManagerPort);		SetPort(windowManagerPort);		SetClip(GetGrayRgn());			// Check to see if the command key is down.  If it is, don’t bring the window to the	// front after the move.  Trying to do Pascal stuff in C is so much fun.  GetKeys()	// is a total pain to try to use properly from C, so I’m going to hard code where the	// command key is in the KeyMap array.			GetKeys(keyMap);		if (keyMap[1] & 0x8000)			commandKeyDown = true;			if ((commandKeyDown == true) ||			(Get_WindowKind(windowToDrag) != kApplicationFloaterKind)) {						if (commandKeyDown == false)		// If there are floating windows, clip the dragging outline to draw behind the floaters.					ClipAbove((WindowRef) BB_FrontNonFloatingWindow());			else				// If the command key was down, clip the outline to draw behind any windows above	// the window being dragged.					ClipAbove((WindowRef) windowToDrag);		}				// Create a region to drag			dragRegion = NewRgn();		CopyRgn(GetStructureRegion(windowToDrag), dragRegion);			// Drag the window around			dragResult = DragGrayRgn(dragRegion, startPoint, &dragRect, &dragRect, noConstraint, nil);		// Restore the port for coordinate conversion.			SetPort(savePort);		if (dragResult != 0) {			horizontalOffset = dragResult & 0xFFFF;			verticalOffset = dragResult >> 16;		// Only move it if it stayed inside the dragging box.				if (verticalOffset != -32768) {				windowContentRegion = GetContentRegion(windowToDrag);				newHorizontalWindowPosition = (**windowContentRegion).rgnBBox.left + horizontalOffset;				newVerticalWindowPosition = (**windowContentRegion).rgnBBox.top + verticalOffset;								MoveWindow((WindowPtr) windowToDrag, newHorizontalWindowPosition, newVerticalWindowPosition, false);							}		}		// Bring the window forward if the command key wasn’t down			if (commandKeyDown == false)			SelectReferencedWindow(windowToDrag);		// Get rid of the dragging region			DisposeRgn(dragRegion);	}}//// BB_FrontNonFloatingWindow////	Return the first visible window that is not a floating window.//pascal WindowReference BB_FrontNonFloatingWindow(void){	WindowReference	theWindow;		// Get the first visible window in the window list.		theWindow = (WindowReference) FrontWindow();		// Keep searching until a visible window whose windowKind is not	// kApplicationFloaterKind is found, or the end of the window list is reached.		while ((theWindow != nil) && (Get_WindowKind(theWindow) == kApplicationFloaterKind)) {		do {			theWindow = Get_NextWindow(theWindow);		} while ((theWindow != nil) && (GetWindowVisible(theWindow) == false));	}	return theWindow;}//// LastFloatingWindow////	Return the last floating window, whether it is visible or not, or nil if there are//	no floating windows.//pascal WindowReference LastFloatingWindow(void){	WindowReference	theWindow;	WindowReference	lastFloatingWindow;		theWindow = GetWindowList();	lastFloatingWindow = nil;		// We have to search the entire window list because we don’t know what the windowKind	// of other windows in the list might be, and we have account for the fact that a modal	// dialog is up.		while (theWindow != nil) {		if (Get_WindowKind(theWindow) == kApplicationFloaterKind)			lastFloatingWindow = theWindow;		theWindow = Get_NextWindow(theWindow);	}		return lastFloatingWindow;}//// WindowIsModal////	Determines if a window is modal based upon the value of its windowKind and window variant.//pascal Boolean WindowIsModal(WindowReference windowReference){	short	windowVariant;		windowVariant = GetWVariant((WindowPtr) windowReference);	if ((Get_WindowKind(windowReference) == dialogKind) &&		((windowVariant == dBoxProc) ||		(windowVariant == movableDBoxProc)))		return true;	else		return false;}//// DeactivateFloatersAndFirstDocumentWindow////	Send deactivate events to all visible floating windows and the active document//	window.  This routine is called before a modal dialog is presented.//pascal void DeactivateFloatersAndFirstDocumentWindow(void){	WindowReference			firstWindow;	WindowReference			secondDocumentWindow;	WindowReference			currentWindow;		// First, make sure the window ordering hasn’t been changed behind our back	ValidateWindowList();		// Start from the frontmost window on the screen, and keep going until	// we’ve reached the second document window.		firstWindow = (WindowReference) FrontWindow();	secondDocumentWindow = BB_FrontNonFloatingWindow();	if (secondDocumentWindow != nil)		secondDocumentWindow = Get_NextWindow(secondDocumentWindow);			currentWindow = firstWindow;	while (currentWindow != secondDocumentWindow) {		if (GetWindowVisible(currentWindow))			DeactivateWindow(currentWindow);		currentWindow = Get_NextWindow(currentWindow);	}}//// ActivateFloatersAndFirstDocumentWindow////	ActivateFloatersAndFirstDocumentWindow should be called after a modal dialog//	is dismissed.  If the application is in the background when this routine is//	called (like when a moveable modal progress dialog was up and then disappears)//	this routine calls SuspendFloatingWindows to hide any visible floating windows//	instead.//pascal void ActivateFloatersAndFirstDocumentWindow(void){	ProcessSerialNumber	currentPSN;	ProcessSerialNumber	frontPSN;	WindowReference			firstWindow;	WindowReference			secondDocumentWindow;	WindowReference			currentWindow;	OSErr				getFrontProcessResult;	OSErr				getCurrentProcessResult;	OSErr				sameProcessResult;	Boolean				isSameProcess;		// See if the this process is in the background.  If it is, then the floating	// windows should be hidden instead of reactivated, so SuspendFloatingWindows()	// is called instead.		getFrontProcessResult = GetFrontProcess(&frontPSN);	getCurrentProcessResult = GetCurrentProcess(&currentPSN);		if ((getFrontProcessResult == noErr) && (getCurrentProcessResult == noErr))		sameProcessResult = SameProcess(&frontPSN, &currentPSN, &isSameProcess);			if ((sameProcessResult == noErr) && (isSameProcess == false))		SuspendFloatingWindows();	else {		firstWindow = (WindowReference) FrontWindow();		secondDocumentWindow = BB_FrontNonFloatingWindow();		if (secondDocumentWindow != nil)			secondDocumentWindow = Get_NextWindow(secondDocumentWindow);				currentWindow = firstWindow;		while (currentWindow != secondDocumentWindow) {			if (GetWindowVisible(currentWindow))				ActivateWindow(currentWindow);			currentWindow = Get_NextWindow(currentWindow);		}	}}//// SuspendFloatingWindows////	Hide any visible floating windows, and deactivate the frontmost document window.//	This routine should be called when an application recieves a suspend event.//pascal void SuspendFloatingWindows(void){	WindowReference	currentWindow;	Boolean		windowIsVisible;		currentWindow = (WindowReference) GetWindowList();	if (Get_WindowKind(currentWindow) != kApplicationFloaterKind)		return;			do {		windowIsVisible = GetWindowVisible(currentWindow);		SetWasVisible(currentWindow, windowIsVisible);		if (windowIsVisible)			ShowHide((WindowPtr) currentWindow, false);		currentWindow = Get_NextWindow(currentWindow);	} while ((currentWindow != nil) &&			 (Get_WindowKind(currentWindow) == kApplicationFloaterKind));		// The floating windows are now hidden.  Deactivate the first visible	// document window.		currentWindow = BB_FrontNonFloatingWindow();	if (currentWindow != nil)		DeactivateWindow(currentWindow);}//// ResumeFloatingWindows////	Reveal floating windows that were hidden by SuspendFloatingWindows.  An//	activate event is sent to each one as it is revealed.  The frontmost document//	is also sent an activate event.//pascal void ResumeFloatingWindows(void){	WindowReference	currentWindow;	Boolean		windowWasVisible;		currentWindow = GetWindowList();	if (Get_WindowKind(currentWindow) != kApplicationFloaterKind)		return;			do {		windowWasVisible = GetWasVisible(currentWindow);		if (windowWasVisible) {			ShowHide((WindowPtr) currentWindow, true);			ActivateWindow(currentWindow);		}		currentWindow = Get_NextWindow(currentWindow);	} while ((currentWindow != nil) &&			 (Get_WindowKind(currentWindow) == kApplicationFloaterKind));	// The floating windows have been revealed.  Activate the first document	// window as well.		currentWindow = BB_FrontNonFloatingWindow();	if (currentWindow != nil)		ActivateWindow(currentWindow);}//// ActivateWindow////	Activates the window by highlighting it, and calling its activate handler.//void ActivateWindow(WindowReference theWindow){	HighlightAndActivateWindow(theWindow, kActivateWindow);}//// DeactivateWindow////	Deactivates the window by unhighlighting it and calling its activate handler.//void DeactivateWindow(WindowReference theWindow){	HighlightAndActivateWindow(theWindow, kDeactivateWindow);	DoActivate((WindowPtr)theWindow,false);}//// HighlightAndActivateWindow////	Common code for ActivateWindow and DeactivateWindow.  Does actual highlighting//	and calling of the activate handler.//void HighlightAndActivateWindow(WindowReference theWindow, Boolean activate){	ActivateHandlerUPP	activateHandlerProc;		activateHandlerProc = GetActivateHandlerProc(theWindow);	HiliteWindow((WindowPtr) theWindow, activate);	DoActivate((WindowPtr)theWindow,true);	/*	On ne veut pas du code de dessin de la routine		if (activateHandlerProc != nil)		CallActivateHandlerProc(activateHandlerProc, theWindow, activate);	*/}//// ValidateWindowList////	Code external to the application might call SelectWindow or FrontWindow because they//	don’t know any better. If the application has floating windows that are invisible//	when some other code calls FrontWindow then SelectWindow, a document window will get//	pulled in front of the invisible floating windows. This routine makes sure everything//	is right with the world, or at least the window list. It assumes that the floating//	windows are invisible, so visually, nothing changes on the screen. This means that//	the code doesn’t call CalcVBehind or PaintBehind. If I wanted to be more general,//	those two calls would have to be made. Ideally, this routine only needs to be called//	the first time window ordering changes after a foreign window was opened in your//	applicaiton. I’m actually calling it every time ShowReferencedWindow is called on//	a floating window, and when new document windows are created or closed, just to be//	safe.//pascal void ValidateWindowList(void){	WindowReference	currentWindow = GetWindowList();	WindowReference	lastFloatingWindow = LastFloatingWindow();	WindowReference	firstFloatingWindow = nil;	WindowReference	documentWindowsToMove = nil;	WindowReference	lastDocumentWindowAdded = nil;	WindowReference	previousWindow = nil;		if (currentWindow) {		// First, gather up all the document windows in front of floating windows. We iterate	// through the window list until a floating window is encountered.			do {			if (Get_WindowKind(currentWindow) == kApplicationFloaterKind) {				firstFloatingWindow = currentWindow;				break;			}			else {				SetNextWindow(previousWindow, Get_NextWindow(currentWindow));				if (documentWindowsToMove == nil)					documentWindowsToMove = currentWindow;				else					SetNextWindow(lastDocumentWindowAdded, currentWindow);				lastDocumentWindowAdded = currentWindow;								previousWindow = currentWindow;				currentWindow = Get_NextWindow(currentWindow);			}		} while (currentWindow);			// Now put them back in their place.			if (documentWindowsToMove && firstFloatingWindow) {			SetNextWindow(lastDocumentWindowAdded, Get_NextWindow(lastFloatingWindow));			SetNextWindow(lastFloatingWindow, documentWindowsToMove);				// If the first window in the window list was a document window, and there are	// floating windows, then make the floating window the first window in the window	// list.			if (documentWindowsToMove == GetWindowList())				SetWindowList(firstFloatingWindow);		}	}}//// Getters and Setters////	GetWindowPortRect — returns the portRect from the window’s GrafPort.pascal void GetWindowPortRect(WindowReference windowReference, Rect *portRect){	*portRect = ((WindowPtr) windowReference)->portRect;}// Get/SetWindowKind — get and set the windowKind field of the windowpascal short Get_WindowKind(WindowReference windowReference){short a;	a=((WindowPeek) windowReference)->windowKind;	return a;}pascal void Set_WindowKind(WindowReference windowReference, short windowKind){	((WindowPeek) windowReference)->windowKind = windowKind;}// Get/SetWindowVisible — get and set the visible field for a windowpascal Boolean GetWindowVisible(WindowReference windowReference){	return (windowReference->theWindow.visible);}pascal void SetWindowVisible(WindowReference windowReference, Boolean windowVisible){	windowReference->theWindow.visible = windowVisible;}// Get/SetWindowHilite — get and set the hilited field of a windowpascal Boolean GetWindowHilite(WindowReference windowReference){	return (windowReference->theWindow.hilited);}pascal void SetWindowHilite(WindowReference windowReference, Boolean windowHilite){	windowReference->theWindow.hilited = windowHilite;}// Get/SetNextWindow — get and set the window after this windowpascal WindowReference Get_NextWindow(WindowReference windowReference){	return ((WindowReference) (windowReference->theWindow.nextWindow));}pascal void SetNextWindow(WindowReference windowReference, WindowReference nextWindow){	windowReference->theWindow.nextWindow = (WindowPeek) nextWindow;}// GetContentRegion — return the window’s content regionpascal RgnHandle GetContentRegion(WindowReference windowReference){	return (windowReference->theWindow.contRgn);}// GetStructureRegion — return the window’s structure regionpascal RgnHandle GetStructureRegion(WindowReference windowReference){	return (windowReference->theWindow.strucRgn);}// GetWindowDefPRoc - return a handle to the window’s definition procedurepascal Handle GetWindowDefProc(WindowReference windowReference){	return (windowReference->theWindow.windowDefProc);}// Get/SetActivateHandlerProc — get and set the activate event handler for this windowpascal ActivateHandlerUPP GetActivateHandlerProc(WindowReference windowReference){	return (windowReference->activateHandlerProc);}pascal void SetActivateHandlerProc(WindowReference windowReference, ActivateHandlerUPP activateHandlerProc){	windowReference->activateHandlerProc = activateHandlerProc;}// Get/SetWasVisible — save and restore the visible field of a windowpascal Boolean GetWasVisible(WindowReference windowReference){	return (windowReference->wasVisible);}pascal void SetWasVisible(WindowReference windowReference, Boolean wasVisible){	windowReference->wasVisible = wasVisible;}// GetWindowList — Return the first window in the application’s window list from low memory.// dkj Changed these routines to use LMGet and LMSetWindowReference GetWindowList(void){	return ((WindowReference) LMGetWindowList());}// SetWindowList — Set the first window in this process’ window list.void SetWindowList(WindowReference windowReference){	LMSetWindowList((WindowRef)windowReference);}