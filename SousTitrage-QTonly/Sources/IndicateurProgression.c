#include <Memory.h>/* Cette fentre regroupe me code pour effectuer une reglette de progression*/typedef struct Rpd{DialogPtr	dlog;Str255		WindowName;Str255		PromptString;Str255		SecondString;long		MinValue;long		MaxValue;long		value;short		state;}Rpd,*RpdPtr,**RpdHandle;pascal Handle RPInitReglette(Str255 WindowName,Str255 PromptString,long MinValue,long MaxValue,Boolean BoutonStop);void RPUpdate( RpdHandle  theRpd);pascal void RPDispose(Handle theRpd);pascal Boolean RPIdle(Handle theRpd,long value,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder);pascal Boolean RPIsFrontProcess(Handle theRpd);pascal Boolean RPIdleWText(Handle theRpd,long value,Str255 string,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder );pascal Handle RPInitReglette(Str255 WindowName,Str255 PromptString,long MinValue,long MaxValue,Boolean BoutonStop){RpdHandle	theRpd;		theRpd=(RpdHandle)NewHandleClear(sizeof(Rpd));		if (MemError()) return nil;	HLock((Handle)theRpd);	SetDialogFont(kFontIDGeneva);	ParamText(PromptString,nil,nil,nil);	BlockMove(WindowName,&(**theRpd).WindowName,256);	BlockMove(PromptString,&(**theRpd).PromptString,256);	(**theRpd).SecondString[0]=0;	(**theRpd).dlog=GetNewDialog(142,nil,(WindowPtr)-1);	if (!BoutonStop){		HideDialogItem((**theRpd).dlog,1);	}		SetWTitle((**theRpd).dlog, WindowName);	(**theRpd).MinValue=MinValue;	(**theRpd).MaxValue=MaxValue;	(**theRpd).value=MinValue;	(**theRpd).state=false;	RPUpdate(theRpd);		return (Handle)theRpd;}pascal Boolean RPIsFrontProcess(Handle theRpd){	return !(**(RpdHandle)theRpd).state;}void RPUpdate(RpdHandle theRpd){RGBColor		color,saveBackColor;GrafPtr			oldport;PixPatHandle 	pixpat;short 			type,OldTxtSize; Handle 			hndl; Rect 			box,rect;RgnHandle		r1,r2;long			a;	GetPort(&oldport);	SetPort((**(RpdHandle)theRpd).dlog);		TextSize(12);	TextFace(bold);	pixpat=GetPixPat(129);		if (pixpat!=nil){		r1=NewRgn();		r2=NewRgn();		GetDialogItem((**(RpdHandle)theRpd).dlog,1,&type,&hndl,&box);		RectRgn(r1,&((**(RpdHandle)theRpd).dlog)->portRect);				GetDialogItem((**(RpdHandle)theRpd).dlog,1,&type,&hndl,&box);		RectRgn(r2,&box);		DiffRgn(r1,r2,r1);				GetDialogItem((**(RpdHandle)theRpd).dlog,3,&type,&hndl,&box);		InsetRect(&box,-2,-2);		RectRgn(r2,&box);		DiffRgn(r1,r2,r1);				FillCRgn(r1,pixpat);		DisposePixPat(pixpat);				DisposeRgn(r1);		DisposeRgn(r2);		}	color.red=0;	color.green=0;	color.blue=30000;	RGBForeColor(&color);		// on affiche le texte	TextMode(srcOr);	GetDialogItem((**(RpdHandle)theRpd).dlog,2,&type,&hndl,&box);	MoveTo(box.left,box.bottom-3);	DrawString((unsigned char*)&(**theRpd).PromptString);// on dessine la reglette	GetDialogItem((**(RpdHandle)theRpd).dlog,3,&type,&hndl,&box);	InsetRect(&box,-2,-2);	// on dessine le contour blanc	GetForeColor(&saveBackColor);		color.red=0xffff;	color.green=0xffff;	color.blue=0xffff;	RGBForeColor(&color);	MoveTo((box).left,box.bottom-1);	LineTo((box).right-1,(box).bottom-1);	LineTo((box).right-1,(box).top);	RGBForeColor(&saveBackColor);// on dessine le contour gris	GetForeColor(&saveBackColor);		color.red=0x6000;	color.green=0x6000;	color.blue=0x6000;	RGBForeColor(&color);	MoveTo((box).left,(box).bottom-1);	LineTo((box).left,(box).top);	LineTo((box).right-1,(box).top);	RGBForeColor(&saveBackColor);								GetDialogItem((**(RpdHandle)theRpd).dlog,3,&type,&hndl,&box);		InsetRect(&box,1,1);		color.red=18000;		color.green=32000;		color.blue=18000;		RGBForeColor(&color);				rect=box;		a=(box.right-box.left);		a=a*((**(RpdHandle)theRpd).value-(**(RpdHandle)theRpd).MinValue);		a=a/(**(RpdHandle)theRpd).MaxValue;		rect.right=box.left+a;		PaintRect(&rect);		rect.left=rect.right;		rect.right=box.right;		EraseRect(&rect);		if ((**(RpdHandle)theRpd).SecondString[0]){ 			TextMode(srcCopy);			OldTxtSize=(**(RpdHandle)theRpd).dlog->txSize;			TextSize(9);			GetDialogItem((**(RpdHandle)theRpd).dlog,4,&type,&hndl,&box);			MoveTo(box.left,box.bottom-3);			DrawString((unsigned char*)&(**(RpdHandle)theRpd).SecondString);			TextSize(OldTxtSize);			TextMode(srcOr);		}	DrawControls((**(RpdHandle)theRpd).dlog);	SetPort(oldport);}pascal Boolean RPIdle(Handle theRpd,long value,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder ){EventRecord	event;Boolean	Exit=false;WindowPtr		theWindow;ControlHandle	theControl;RGBColor		color;Handle			hndl;short			type;Rect			box,rect;long 			a;GrafPtr			oldport;	Boolean			action;				GetPort(&oldport);	SetPort((**(RpdHandle)theRpd).dlog);	if (value !=(**(RpdHandle)theRpd).value) {		(**(RpdHandle)theRpd).value=value;				GetDialogItem((**(RpdHandle)theRpd).dlog,3,&type,&hndl,&box);		InsetRect(&box,1,1);		color.red=18000;		color.green=32000;		color.blue=18000;		RGBForeColor(&color);				rect=box;		a=(box.right-box.left);		a=a*((**(RpdHandle)theRpd).value-(**(RpdHandle)theRpd).MinValue);		a=a/(**(RpdHandle)theRpd).MaxValue;		rect.right=box.left+a;		PaintRect(&rect);		rect.left=rect.right;		rect.right=box.right;		EraseRect(&rect);		}	if (Multifinder) 		action=GetNextEvent(-1,&event);	else 		action=EventAvail(-1,&event);		if (action){						if (event.what==3){				if ( ( (event.message&0xff)=='.') && 						(event.modifiers&cmdKey) ) Exit=true; // cmd shift .				if ( (event.message&0xff)==27 )  Exit=true;	// escape				if ( (event.message&0xff)==' ')  Exit=true;	// espace			}										if (event.what==1){				if (FindWindow(event.where,&theWindow)==inContent){					GlobalToLocal(&event.where);					if (FindControl(event.where,theWindow,&theControl)){						Exit = TrackControl(theControl, event.where,nil);					}				}else {									if (FindWindow(event.where,&theWindow)==inDrag){						SetRect(&rect,0,0,3000,3000);						DragWindow(theWindow,event.where,&rect);					} else SysBeep(1);					}										}							if (event.what==6)				if ( event.message==(long)(**(RpdHandle)theRpd).dlog ){					BeginUpdate((**(RpdHandle)theRpd).dlog);					RPUpdate((RpdHandle)theRpd);					EndUpdate((**(RpdHandle)theRpd).dlog);								}	else 				if (UpdateFct) {					UpdateFct( (WindowPtr) event.message);				}															if (event.what==15)				switch ((event.message >> 24) & 0x0FF) {		/* high byte of message */					case 1:		/* suspend/resume is also an activate/deactivate */						(**(RpdHandle)theRpd).state= (event.message & 1) == 0;						break;				}						}	SetPort(oldport);	return	Exit;}pascal Boolean RPIdleWText(Handle theRpd,long value,Str255 string,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder ){EventRecord	event;Boolean	Exit=false;WindowPtr		theWindow;ControlHandle	theControl;RGBColor		color;Handle			hndl;short			type,OldTxtSize;Rect			box,rect;long 			a;GrafPtr			oldport;	Boolean			action;				GetPort(&oldport);	SetPort((**(RpdHandle)theRpd).dlog);		if (value !=(**(RpdHandle)theRpd).value) {		(**(RpdHandle)theRpd).value=value;				GetDialogItem((**(RpdHandle)theRpd).dlog,3,&type,&hndl,&box);		InsetRect(&box,1,1);		color.red=18000;		color.green=32000;		color.blue=18000;		RGBForeColor(&color);				rect=box;		a=(box.right-box.left);		a=a*((**(RpdHandle)theRpd).value-(**(RpdHandle)theRpd).MinValue);		a=a/(**(RpdHandle)theRpd).MaxValue;		rect.right=box.left+a;		PaintRect(&rect);		rect.left=rect.right;		rect.right=box.right;		EraseRect(&rect);		if (string[0]){ 			TextMode(srcCopy);			OldTxtSize=(**(RpdHandle)theRpd).dlog->txSize;			TextSize(9);			BlockMove(string,&(**(RpdHandle)theRpd).SecondString,256);			GetDialogItem((**(RpdHandle)theRpd).dlog,4,&type,&hndl,&box);			MoveTo(box.left,box.bottom-3);			DrawString((unsigned char*)&(**(RpdHandle)theRpd).SecondString);			TextSize(OldTxtSize);		}	}	if (Multifinder) 		action=GetNextEvent(-1,&event);	else 		action=EventAvail(mDownMask|keyDownMask|updateMask,&event);		if (action){						if (event.what==3){				if ( ( (event.message&0xff)=='.') && 						(event.modifiers&cmdKey) ) Exit=true; // cmd shift .				if ( (event.message&0xff)==27 )  Exit=true;	// escape				if ( (event.message&0xff)==' ')  Exit=true;	// espace			}										if (event.what==1){				if (FindWindow(event.where,&theWindow)==inContent){					GlobalToLocal(&event.where);					if (FindControl(event.where,theWindow,&theControl)){						Exit = TrackControl(theControl, event.where,nil);					}				}else {									if (FindWindow(event.where,&theWindow)==inDrag){						SetRect(&rect,0,0,3000,3000);						DragWindow(theWindow,event.where,&rect);					} else SysBeep(1);					}						}							if (event.what==6)				if ( event.message==(long)(**(RpdHandle)theRpd).dlog ){					BeginUpdate((**(RpdHandle)theRpd).dlog);					RPUpdate((RpdHandle)theRpd);					EndUpdate((**(RpdHandle)theRpd).dlog);								}	else 				if (UpdateFct) {					UpdateFct( (WindowPtr) event.message);				}															if (event.what==15)				switch ((event.message >> 24) & 0x0FF) {		/* high byte of message */					case 1:		/* suspend/resume is also an activate/deactivate */						(**(RpdHandle)theRpd).state= (event.message & 1) == 0;						break;				}						}	SetPort(oldport);	return	Exit;}pascal void RPDispose(Handle theRpd){	DisposeDialog((**(RpdHandle)theRpd).dlog);	DisposeHandle((Handle)theRpd);}