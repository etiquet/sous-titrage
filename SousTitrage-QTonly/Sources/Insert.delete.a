* *************    Insert.Delete.a    **************** 	Ensemble de routine qui modifie l'agencement de la liste de sous-titre*	Ce sont des routines à haut-risque de plantage, et à conséquences graves*	pour l'utilisateur*	PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	PRINT	POP				IMPORT	G:AppGlobals	IMPORT	qd:MyQDGlobals			* ================================================* PROCEDURE EcarteSousTitre(POINTEUR:A0, LONGUEUR: D0);* ================================================*	Routine pour dilater un sous-titre*	dans la liste des sous-titres**	entree: a0= pointeur du sous-titre*			d0= largeur désirée**	sortie: d0= 0 si OKEcarteSousTitre:		PROC	EXPORT		; on utilise la fonction écrite en C				move.l	a0,-(sp)		move.l	d0,-(sp)		import	C_EcarteSousTitre		jsr		C_EcarteSousTitre		rts		DbgInfo.New	ECARTESOUSTITRE			; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE InsertSt(POINTEUR:A0, LONGUEUR: D0);* ================================================*	Routine d'insertion d'un elements*	dans la liste des sous-titres**	entree: a0= pointeur du sous-titre  après lequel un sous-titre sera inséré*		d0= nombre d'octets à inserer pour le texte*		si d0=0 la routine insere 32 caracteres**	sortie: d0= 0 si OKInsertST:		PROC	EXPORT		; on utilise la fonction écrite en C		movem.l	d0-d7/a1-a4,-(sp)		move.l	a0,-(sp)		move.l	d0,-(sp)		import	C_InsertSt		jsr		C_InsertSt		movem.l	(sp)+,d0-d7/a1-a4		rts		DbgInfo.New	InsertST			; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE Insert_before(longueur d0); * ================================================*  	Cette routine créer un sous-titre avant le premier sous-titre de la liste* 	attention ! il ne faut pas plus de 255 1 er sous-titre sans renumérotation**	D0 indique la taille du sous-titre,	*	si d0=0 la routine insere 32 caracteres**	Insert_before 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkPtrSousTitre	ds.l	1		; offset absolu du sous-titrelongueur		ds.l	1previous		ds.l	1deplacement		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR;			SEG	'ListeSoustitre'			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \						RenumerotationSubNumero; intialisation				movem.l d1-d7/a1-a4,-(sp)			move.l	G.General_PremierStPtr,PtrSousTitre(a6)			move.l	#0,-(sp)			import	ManageUndoRedoListeForInsert			jsr		ManageUndoRedoListeForInsert; on détermine la longueur du déplacement en fonction ; de la longueur du premier sous-titre 		move.l	G.General_PremierSTPtr,a0		move.L	st_NextST(a0),d0		sub.l	a0,d0	; longueur totale du premier sous-titre		move.l	d0,deplacement(a6)				; ça y est c'est aligné		; on regarde s'il y a assez de place pour caser le sous-titre		move.l	G.General_DernierSTPtr,a1		add.L	st_lenthST(a1),a1		move.l	#st_sizeOf,d1	; on ajoute la taille du header		add.l	d1,a1		add.l	d7,a1		cmp.l	G.General_HIMEMST,a1			bge		before_PasSuffisemmentDeMemoire	; on ne peut pas faire le boulot			; on prépare les pointeurs pour le déplacement de la mémoire; on effectue la recopie de haut vers le bas			move.l	G.General_DernierSTPtr,a1			add.l	st_LenthST(a1),a1			move.l	#st_SizeOf,d1	; pblm l'assembleur mettrait adda.w ! sinon			adda.l	d1,a1			move.l	G.General_PremierSTPtr,a0				; on décale le reste des sous-titres, de la valeur contenue par d0; on fait le décalage du haut vers le bas, comme cela on conserve le contenu; des sous-titres; a0= pointe sur début de la zone à transférer; a1 = pointe sur la fin de la zone à transférer; d0= la longueur du déplacement; on fait une copie mot (16 bits) par motCopyLoop	move.w	(a1),(a1,d0.l)			sub.l	#2,a1			cmp.l	a0,a1			bhs.s	CopyLoop				; on place les nouveaux vecteurs de chainages des sous titres.; vecteur= addresse absolue du st; on modifie les pointeurs du sous-titre ecarter ; on actualise le dernier sous-titre			move.l	G.General_DernierSTPtr,a2			add.l	d0,a2			move.l	a2,G.General_DernierSTPtr			clr.l	st_NextST(a2)									; -------------  chaînage des sous-titres et valeurs internes au sous-titre; on place les nouveaux vecteurs de chainages des sous titres.; vecteur= addresse absolue du st; on modifie les pointeurs du sous-titre ecarter  ; --- on change le next st du sous-titre courant  			move.l	PtrSousTitre(a6),a3			move.l	a3,a0 			adda.l	d0,a0								move.l	a0,st_nextST(a3)			clr.l	st_PreviousST(a3)			;et le previous du suivant 						move.l	d0,d7			sub.l	d7,a3					; on annule l'addition au prochain passage			move.l	a3,st_PreviousST(a0)												; --- on chaîne les sous-titres			Loop_Chainage_soustitre			move.l	st_PreviousST(a0),d0			beq.s	@1						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_PreviousST(a0)@1						move.l	st_CommentairePTR(a0),d0			beq.s	@2						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_CommentairePTR(a0)@2			move.l	st_StylePTR(a0),d0			beq.s	@3						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_StylePTR(a0)@3			move.l	st_PosOffsetTable(a0),d0			beq.s	@4						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_PosOffsetTable(a0)@4			move.l	st_NextST(a0),d0			beq.S	@5 			add.l	d7,d0			move.l	d0,st_NextST(a0)			move.l	d0,a0			cmp.l	G.General_DernierSTPtr,a0		; pas au dessus de la liste			bls.s	Loop_Chainage_soustitre				; ------ on a terminé la chaînage -------------------------------------@5			; on invalide le cache du conversion num->pointeur			clr.l	G.General_DernierNumConvertiPtr			clr.l	G.Sous_titre_dessined			clr.l	G.Sous_titreInOffscreen; on actualise les valeurs intracèque au sous-titre inséré									move.l	G.General_PremierSTPtr,a0; on place  1 comme numéro de sous-titre						move.l	#1,st_NumeroST(a0)			move.l	#1,st_OldNumeroST(a0)			move.l	#1,st_AbsNumST(a0)						move.l	st_nextST(a0),a1	; a1 =suivant st			move.l	st_NumeroST(a1),d1		; on additionne 1 au numéro secondaire du 2 ème st			move.l	st_NumeroST(a1),d1			add.l	#$01000000,d1			bcc   	before_PASErreurNumerotation; nous sommes arrivé à 256 sous-valeurs donc il y a dépassement 		before_ErreurNumerotation:			clr.w	-(sp)			move.w	#134,-(sp)			clr.l	-(sp)			_Alert			move.l	PtrSousTitre(a6),a0			move.l	st_NumeroST(a0),d1			move.w	(sp)+,d0			cmp.w	#1,d0	; ok gadget			bne 	before_PASErreurNumerotation			; l'utilisateur a répondu CANCEL on n'incrémente pas le numéro de sous-titre; tant pis il y aura plusieur ST de même numéro				before_renum	move.l	d1,st_NumeroST(a1)	; on renumérote les numéro absolu			jsr		RenumerationAbsST			move.l	st_AbsNUMST(a0),d0			move.w	d0,G.General_SousTitreEncour			; on ajoute un au nombre total de sous-titre						move.l	G.General_NombreST,d0			add.l	#1,d0			move.l	d0,G.General_NombreST			; on tranfère cette valeur au control listing  				move.l	G.ListingVScroll,-(sp)			move.w	d0,-(sp)			_SetMaxCtl												; ON initialise le nouveau sous-titre			move.l	G.General_PremierSTPtr,a1			move.l	deplacement(a6),d0			sub.l	#st_sizeof,d0			move.l	d0,st_lenthST(A1)			clr.l	st_StyleLenth(a1)			clr.l	st_TexteLenth(a1)			clr.l	st_CommentairePtr(a1)			clr.l	st_CommentaireLenth(a1)			clr.l	st_StylePtr(a1)			move.l	#-1,st_TimeCodeIn(a1)			move.l	#-1,st_TimeCodeOut(a1)			clr.w	st_Error(a1)			clr.w	st_Xoffset(a1)			clr.w	st_Yoffset(a1)			clr.l	st_PosOffsetTable(a1)			clr.b	st_Justification(A1)	; justification du texte 0 centrée, 			clr.b	st_MasKType(a1)			; type de mask box, line, rectangle; = rien; on renumérote la fin de la liste			move.l	a1,-(sp)			import	C_RenumerotationListeSousTitre			jsr		C_RenumerotationListeSousTitre			bra		EXIT			; on calcule numéro absolu du sous-titre conserné; ----------------------------------------before_PASErreurNumerotation:			move.l	d1,st_NumeroST(a1)PasZeroBefore						jsr		RenumerationAbsST			move.l	st_AbsNUMST(a0),d0			move.w	d0,G.General_SousTitreEncour			; on ajoute un au nombre total de sous-titre			move.l	G.General_NombreST,d0			add.l	#1,d0			move.l	d0,G.General_NombreST; on tranfère cette valeur au control listing  				move.l	G.ListingVScroll,-(sp)			move.w	d0,-(sp)			_SetMaxCtl												; ON DÉFINIE les différentes longueur enfct de			move.l	G.General_PremierSTPtr,a1			clr.l	st_StyleLenth(a1)			clr.l	st_TexteLenth(a1)			clr.l	st_CommentairePtr(a1)			clr.l	st_CommentaireLenth(a1)			clr.l	st_StylePtr(a1)			move.l	#-1,st_TimeCodeIn(a1)			move.l	#-1,st_TimeCodeOut(a1)			clr.w	st_Error(a1)			clr.w	st_Xoffset(a1)			clr.w	st_Yoffset(a1)			clr.l	st_PosOffsetTable(a1)						move.l	G.General_PremierSTPtr,a0				; a0 pointe sur le sous-titre en cours			move.l	st_nextST(a0),a0								; le suivant			cmp.l	#0,a0			beq		Zorglub			jsr		RenumerotationSubNumero						; il faut renuméroter la liste en numéro secondaire ?	Zorglub		tst.w	 G.Preference_Renumerotation			beq		exit			move.l	PtrSousTitre(a6),-(sp)		; sp pointe sur le sous-titre en cours			import	C_RenumerotationListeSousTitre			jsr		C_RenumerotationListeSousTitre															bra		Exit ; il n'a plus assez de mémoire pour insérer un sous-titrebefore_PasSuffisemmentDeMemoire:; faire alerte			clr.w	-(sp)			move.w	#133,-(sp)			clr.l	-(sp)			_Alert			move.w	(sp)+,d0			move.l	#-1,d0		; code erreur => d0Exit	;  il faut invalider le cache du conversion num pointeur		clr.l	G.General_DernierNumConvertiPtr				clr.l	G.Sous_titre_dessined		clr.l	G.Sous_titreInOffscreen		move.w	#1,G.General_SousTitreEnCour		move.l	G.ListingVScroll,-(sp)		move.w	#1,-(sp)		_SetCtlValue		movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo	Insert_before			; this name will appear in the debugger		align 4			ENDP				* ================================================* PROCEDURE DeleteSt(pointeur: a0); * ================================================*	Routine pour effacer un sous-titre *	dans la liste.**	entree: a0= pointeur du sous-titre * 	DeleteST 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkPtrSousTitre	ds.l	1		; offset absolu du sous-titrelongueur	ds.l	1previous	ds.l	1deplacement	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \						RenumerotationSubNumero		movem.l	d1-d4/a1-a4,-(sp)		move.l	a0,-(sp)		import	C_DeleteST	;on utilise la routine ecrite en C		jsr		C_DeleteST		movem.l	(sp)+,d1-d4/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.New	DeleteSt			; this name will appear in the debugger		align 4			ENDP****************************************************************** Conversion d'un numéro de sous-titre (absolu) en pointeur dans la liste**	entrée: d0*	sortie: a0**	*	**ConversionNumeroSTPointeur 		PROC	export								WITH	SOUSTITRERECORD;initialisation; On masque les intéruptions, car la rapiditée de cette routine,; est essentielle au on fonctionnement du programme.; On détermine si nous sommes proches du début ou de la fin, par rapport au dernier ; pointeur délivré			or.w	#$0700,sr	; on masque les interruptions CPU => vitesse de calcul Maxi			movem.l	d1-d3,-(sp); nous comparons si c'est avantageux d'effectuer la recherche par rapport; au dernier ptr donné 			move.l	d0,d3		; sauvegarde de la valeur demandée						move.l	G.General_NombreST,d1			asr.l	#1,d1	; 1/2 nombre de st => d1			move.l	d0,d2			move.l	G.General_DernierNumConvertiPtr,a0			cmp.l	#0,a0			beq 	PasAvantageuxDoncRechercheStandard	; peut ètre que le cache à été invalidé			cmp.l	G.General_DernierSTPtr,a0			bhi 	PasAvantageuxDoncRechercheStandard	; cache pas valide			cmp.l	G.General_PremierSTPtr,a0			blo 	PasAvantageuxDoncRechercheStandard	; cache pas valide						sub.l	st_ABSNumST(a0),d2		; on a la différence entre les valeurs			beq.s	CestLeMeme		; c'est le même pointeur demandé donc on s'en va direct						bpl.s	sup			neg.l	D2			cmp.l	d1,d2		; on regarde si > moitiés des ST	pour gagner du temps			bhi.s	PasAvantageuxDoncRechercheStandard	; oui donc pas avantageux			;----------------------------------------			OuiAvantageurVersLeBas; on effectue la recheche du sous-titre vaers le bas de  la mémoire						subq.l	#1,d2Loop1			move.l	st_PreviousST(a0),a0			cmp.l	#0,a0			beq.s	lePremier 		; nous sommes au premier st donc on sort			dbra	d2,Loop1			CestLeMeme	; on teste si le résultat est  conforme aux extrème de la liste; s'il y a une erreur on effectue une recherche par le début de la liste			cmp.l	G.General_premierSTPtr,a0			blo.s	rechercheparlebas_1				 			cmp.l	G.General_DernierSTPtr,a0			bhi.s	rechercheparlebas_1		; le pointeur est dans la liste			move.l	a0,G.General_DernierNumConvertiPtr			movem.l	(sp)+,d1-d3			and.w	#$f8ff,sr	; on rend les interuptions			rts; ---------------------------------------; test par rapport à la dernière valeur >0; on effectue la recheche du sous-titre vers le haut de la mémoire			sup			cmp.l	d1,d2			bhi.s	PasAvantageuxDoncRechercheStandard	; ce n'est pas avantageux			OuiAvantageurVersLeHaut			subq.l	#1,d2Loop2			move.l	st_NextST(a0),a0			cmp.l	#0,a0			beq.s	leDernier		; nous sommes au dernier st donc on sort			dbra	d2,Loop2; on teste si le résultat est  conforme aux extrème de la liste; s'il y a une erreur on effectue une recherche par le début de la liste			cmp.l	G.General_premierSTPtr,a0			blo.s	rechercheparlebas_1				 			cmp.l	G.General_DernierSTPtr,a0			bhi.s	rechercheparlebas_1					move.l	a0,G.General_DernierNumConvertiPtr			movem.l	(sp)+,d1-d3			and.w	#$f8ff,sr	; on rend les interuptions			rts			;----------------------------------						leDernier				move.l	G.General_DernierSTPtr,a0			move.l	a0,G.General_DernierNumConvertiPtr			movem.l	(sp)+,d1-d3			and.w	#$f8ff,sr	; on rend les interuptions			rts;-----------------------------------					lePremier				move.l	G.General_PremierSTPtr,a0			move.l	a0,G.General_DernierNumConvertiPtr			movem.l	(sp)+,d1-d3			and.w	#$f8ff,sr	; on rend les interuptions			rts						;---------------------------------------PasAvantageuxDoncRechercheStandard;	d1 = milieu de la liste; on regarde où nous sommes dans la liste .			cmp.l	d1,d0			bhi.s	rechercheparlehaut			bra.S	rechercheparlebas; -----------------------------------------------------rechercheparlebas_1			; on est ici si erreur !			clr.l	G.Sous_titre_dessined			clr.l	G.Sous_titreInOffscreen			move.l	d3,d0			rechercheparlebas; nous sommes donc en dessous du milieu des ST						move.l	G.General_PremierSTPtr,a0			cmp.l	#1,d0		; on demande le premier sous-titre			ble.s	lePremier			move.l	d0,d2			subq.l	#2,d2Loop3			move.l	st_NextST(a0),a0			cmp.l	#0,a0		; on peut se tromper non ?			beq.s	leDernier		; nous sommes au dernier st donc on sort			dbra	d2,Loop3						alafin		move.l	a0,G.General_DernierNumConvertiPtr			movem.l	(sp)+,d1-d3			and.w	#$f8ff,sr	; on rend les interuptions			rts;---------------------------------------rechercheparlehaut; nous sommes donc au dessus de la moitié des sous-titres	; =>	recherche par le haut			move.l	G.General_DernierSTPTr,a0			cmp.l	#0,a0			beq.s	rechercheparlebas	; le pointeur de fin n'est pas valide						move.l	G.General_NombreST,d2			cmp.l	d2,d0		; demande-t-on le dernier sous-titre ?			bge.s	leDernier	; oui, c'est le cas			; on calcule la distance			sub.l	d0,d2			subq.l	#1,d2Loop4			move.l	st_PreviousST(a0),a0			cmp.l	#0,a0			beq.s	lePremier		; nous sommes au premier st donc on sort			dbra	d2,Loop4; on teste si le résultat est  conforme aux extrème de la liste; s'il y a une erreur on effectue une recherche par le début de la liste			cmp.l	G.General_premierSTPtr,a0			blo.s	rechercheparlebas_1				 			cmp.l	G.General_DernierSTPtr,a0			bhi.s	rechercheparlebas_1					move.l	a0,G.General_DernierNumConvertiPtr			movem.l	(sp)+,d1-d3			and.w	#$f8ff,sr	; on rend les interuptions			rts						DbgInfo.New	ConversionNumeroSTPointeur			align 4			ENDP* ================================================* PROCEDURE  TransfertStyleTE_Memoire(TEHandle: te,STptr: ptr)* ================================================**	Cette routine transfère les styles et le texte d'un edit record dans un sous-titre en mémoire*TransfertStyleTE_Memoire  		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*					; start parameters after this pointTEHandle		ds.l	1				; handle du te a transférerSTPtr			ds.l	1				; pointeur du sous-titreParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1				; place holder for return addressA6Link			DS.L	1				; place holder for A6 linkNbRuns			ds.w	1				; nombre de  runs dans le TENbStyle			ds.w	1				; nombre de ligne dans le TENbLine			ds.w	1				; nombre de ligne dans le TETEStyleRecPtr	ds.l	1				; pointeur du TEStyleRecTEStyleTablePtr	ds.l	1				; pointeur de TEStyleTableLHTablePtr		ds.l	1				; pointeur du TELHTableStyle_Lenth		ds.l	1				; longueur du styleTexteBuff		ds.b	255				; sauvegarde du commentaireStScrapHandle	ds.l	1				; handle du Style scrapLocalSize		EQU 	*				; size of all the local variables		ENDR			with	SOUSTITRERECORD,StackFrame,AppGlobals				link	a6,#LocalSize			import	ConversionNumeroSTPointeur,EcarteSousTitre				movem.l	d0-d7/a0-a4,-(sp)			clr.w	nbLine(a6)			clr.w	NbRuns(a6)			clr.w	NbStyle(a6)			clr.l	Style_Lenth(a6)			clr.l	TEStyleRecPtr(a6)			clr.l	TEStyleTablePtr(a6)			clr.l	LHTablePtr(a6)			clr.l	StScrapHandle(a6)						;on RAZ le style ptr et lenth			move.l	STPtr(a6),a0			clr.l	st_StylePtr(a0)			clr.l	st_StyleLenth(a0)			; on compte lenombre de ligne; on ne peut pas utiliser la variable TENLines ; dans le  te car elle enlève une ligne si cr à la fin seul sur une ligne; il faut compter à la main			move.l	TEHandle(a6),a0			_HLock						move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle			move.l	teTextH(a0),a0			_HLock									move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle			move.l	teTextH(a0),a1					move.l	(a1),a1				; handle			move.w	teLength(a0),d0			beq.s	Got_numberofline	; iln'y a pas de ligne			move.w	d0,d2			subq	#1,d2			moveq	#1,d0		Line_Count_loop			move.b	(a1)+,d1			cmp.b	#$0d,d1				; carriage return			bne.s	L_C_1			addq.l	#1,d0L_C_1		dbra	d2,Line_Count_loop			; on à le nombre deligne dans d0Got_numberofline			move.l	STPtr(a6),a1			move.w	d0,st_NLines(a1)				move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle						move.w	teSize(a0),d0			cmp.w	#-1,d0			beq		StyleEditRec			; ce n'est pas un edit record "stylé"					move.l	TeHandle(a6),a0			move.l	(a0),a4				; c'est un handle			moveq	#0,d0			move.w	teLength(a4),d0			bra		sauvegardeChaineDecommentaire			; ------------------------; ok c'est un "styled" TE StyleEditRec			move.l	teFont(a0),a0	; handle du TEstyleRec			move.l	(a0),a0			; handle						move.l	a0,TEStyleRecPtr(a6)	; pointeur du TEStyleRec			move.w	nRuns(a0),nbRuns(a6)	; nombre de runs			move.w	nStyles(a0),nbStyle(a6)	; nombre de Style; on calcule la taille de mémoire nécessaire pour stocker le style; stylelenth= 2+20scrpNStyles		; on selectionne tous le texte						move.l	#0,-(sp)			move.l	#32767,-(sp)			move.l	TEHandle(a6),-(sp)			_TeSetSelect			clr.l	-(sp)			move.l	TEHandle(a6),-(sp)					move.w	#6,-(sp)		;	_GetStylScrap			_TEDispatch			move.l	(sp)+,d0			beq		sauvegardeChaineDecommentaire	; pas de style dans le te						move.l	d0,StScrapHandle(a6)			; on récupère la taille du handle									move.l	StScrapHandle(a6),a0			_GetHandleSize			tst.l	d0			blt		sauvegardeChaineDecommentaire			move.l	d0,Style_Lenth(a6)					; on sauvegarde la chaine de commentaire	; si elle existe bien sûr …sauvegardeChaineDecommentaire			clr.w	TexteBuff(a6)						move.l	STPtr(a6),a0			tst.l	st_CommentaireLenth(a0)			beq.s	pasCommentaireAsauver						move.l	st_CommentaireLenth(a0),d0			lea.l	TexteBuff(a6),a1			move.b	d0,(a1)+			move.l	st_CommentairePtr(a0),a0			_BlockMove			pasCommentaireAsauver; on écarte maintemant le sous-titre pour que tout rentre; on calcule la longueur de la zone mémoire nécessaire						move.l	stPtr(a6),a0			move.l	TeHandle(a6),a1			move.l	(a1),a1				; c'est un handle			moveq	#0,d0			move.w	teLength(a1),d0		; taille du texte			import	AligneD0			jsr		AligneD0			move.l	Style_Lenth(a6),d1	; taille du style			import	AligneD1			jsr		AligneD1			add.l	d1,d0				; texte + style						move.b	TexteBuff(a6),d1	; taille du commentaire			and.l	#$ff,d1			add.l	d1,d0; on rajoute 16 pour prévenir un débordement sur le sous titre suivant (pour les alignements)			add.l	#16,d0				; en réserve pour l'instant 			; on calibre la longueur du sous-titre 					import	EcarteSousTitre			jsr		EcarteSousTitre				; on recopie le texte dans le sous-titre						move.l	TeHandle(a6),a0			move.l	(a0),a4				; c'est un handle						moveq	#0,d0			move.w	teLength(a4),d0			bne		RecopieTexte					;il n'y a pas de texte => donc pas de style (normal non ?)			move.l	stPtr(a6),a0			clr.l	st_texteLenth(a0)			clr.w	st_Nlines(a0)			clr.l	st_StyleLenth(a0)			clr.l	st_StylePtr(a0)			bra		RecopieCommentaire; -------RecopieTexte					move.l	tetextH(a4),a0			move.l	(a0),a0			;handle; on recopie le texte dans le st			move.l	stPtr(a6),a1			move.l	d0,st_TexteLenth(a1)						move.l	#st_SizeoF,d1			adda.l	d1,a1						_BlockMove			;--------------------------------------------------------------					; on va placer les styles mais on regarde si c'est un TE styled									tst.l	StScrapHandle(a6)			beq		RecopieCommentaire							move.l	StScrapHandle(a6),a0			_HLock			; on place le style dans le sous-titre  ; on calcule le pointeur						move.l	STPtr(a6),a0			move.l	#st_SizeOf,d0			add.l	st_TexteLenth(a0),d0			import	AligneD0			jsr		AligneD0			move.l	a0,a4			add.l	d0,a4		; a4 = pointeur du début dela zone style aligne dc.l		 			; on place le pointeur et la longueur dans le sous-titre						move.l	a4,st_StylePtr(a0)			move.l	Style_Lenth(a6),d0			move.l	d0,st_StyleLenth(a0)			; on recopie le TE Style Scrap			move.l	StScrapHandle(a6),a0			move.l	(a0),a0		; handle	=> ptr dans a0			move.l	a4,a1		; adresse de destination			add.l	d0,a4		; pointeur sur prochaine case libre après styl			move.l	Style_Lenth(a6),d0			_BlockMove; on dispose la mémoire du handle			move.l	StScrapHandle(a6),a0			_DisposHandle			; -------------------------------------			; on recopie le commentaire s'il existeRecopieCommentaire			tst.b	TexteBuff(a6)			beq.s	Exit			; il n'y en a pas donc c'est fini				; on calcule le pointeur de la chaine de commentaire						move.l	stPtr(a6),a2			move.l	a2,a1			move.l	st_TexteLenth(a2),d0			add.l	#st_SizeOF,d0			import	AligneD0			jsr		AligneD0	; longueur texte aligné dc.l 								move.l	st_StyleLenth(a2),d1			import	AligneD1			jsr		AligneD1	; longueur styles dc.l			add.l	d1,d0			 						adda.l	d0,a1			move.l	a1,st_CommentairePtr(a2)	; pointeur de la chaine de commentaire						lea		TexteBuff(a6),a0		; chaine de caractères sauvegardée			moveq	#0,d0			move.b	(a0)+,d0			move.l	d0,st_CommentaireLenth(a2)			_BlockMove									move.l	TEHandle(a6),a0			_HUnlock			move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle			move.l	teTextH(a0),a0			_HUnlock			exit		movem.l	(sp)+,d0-d7/a0-a4			UNLK	A6			MOVEA.L	(SP)+,A0		; save the caller's address			ADDA.L	#ParamSize,SP		; strip the caller's parameters			JMP	(A0)									DbgInfo.New	TransfertStyleTE_Memoire			align 4				ENDP* ================================================* PROCEDURE TransfertTE_Memoire(te: handle,num sous-titre: absNum,item : st item); * ================================================*	* Cette routine transfert le contenu du te dans la liste des sous-titres* en fonction 	TransfertTE_Memoire 	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointTEHandle		ds.l	1					; handle du teNum				ds.l	1					; abs num du sous-titreItem			ds.w	1					; item du sous-titreParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkpointeur		ds.l	1Commentaire		ds.b	256buffer			ds.b	64rectangle		ds		rectCarriageReturn	ds.w	1ThePort			ds.l	1LocalSize		EQU 	*					; size of all the local variables				ENDR							IMPORT	AdjustMenus,Terminate,DoGrowWindow,DoZoomWindow,DrawWindow, \					ControlActionProc,DrawListingWindow, \					SpecialThumbControlActionProc,AFFICHENUMSAISIE,SelectWindow,\					TransfertMemoireSaisie,TransfertSaisieMemoire,ConversionNumeroSTPointeur							WITH	StackFrame,EventRecord,soustitrerecord,AppGlobals	; cover our local stack frame			link	a6,#LocalSize						movem.l	d1-d7/a1-a4,-(sp)									move.l	num(a6),d0			jsr		ConversionNumeroSTPointeur			move.l	a0,pointeur(a6)						pea		thePort(a6)			_GetPort			; sauvegarde du port en cours						move.w	Item(a6),d0			case#.w	(d0,if),\			(Texte_SousTitre,copieTexte),\			(TimecodeIn_SousTitre,TcodeIn),\			(TimecodeOut_SousTitre,TcodeOut),\			(Duree_SousTitre,Chaine_Duration),\ 			(Commentaire_SousTitre,Chaine_Commentaire)					bra		Exit; --------------------------------------Chaine_Duration		move.l	TeHandle(a6),a0		_HLock		move.l	TeHandle(a6),a0		move.l	(a0),a0						move.l	tetextH(a0),a0		_HLock				move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0;		beq		Exit				; pour l'instant on ne change rien; on recopie la chaîne de caractères		lea.l	Commentaire(a6),a1		move.b	d0,(a1)+				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove				move.l	TeHandle(a6),a0		_HUnlock		move.l	TeHandle(a6),a0		move.l	(a0),a0						move.l	tetextH(a0),a0		_HUnlock			; on converti la chaine en time code		lea.l	Commentaire(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine durée pas valide				import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode			move.l	d0,d7				lea.l	Commentaire(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Commentaire(a6),a0		moveq	#0,d0		move.l	a0,a1		add.l	#4,a1		move.l	a1,-(sp)		move.l	#7,-(sp)		move.l	TEHandle(a6),-(sp)		_teSetText		move.l	pointeur(a6),a0		move.l	st_timeCodein(a0),d2		move.l	st_timeCodeOut(a0),d3				cmp.l	#-1,d2			bne.s	calculeTcout	; tc in valide		cmp.l	#-1,d3		beq 	Exit					; tc out valide tc in pas valide; on peut calculer tcin = tc out - durée		move.l	d3,d0		move.l	d7,d1		import	SOUSTRACTIONTIMECODE		jsr		soustractionTimeCode		move.l	pointeur(a6),a0		move.l	d0,st_timeCodein(a0)		bra		Exit		; autre cas on calcule le tc outcalculeTcout		move.l	d2,d0		move.l	d7,d1		import	AdditionTimeCode		jsr		additionTimeCode		move.l	pointeur(a6),a0		move.l	d0,st_timeCodeout(a0)		bra		Exit;--------Chaine_Commentaire		; on commence par recopier le texte du te dans un buffer		move.l	TeHandle(a6),a0		_HLock		move.l	TeHandle(a6),a0		move.l	(a0),a0						move.l	tetextH(a0),a0		_HLock						move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		; longueur du commentaire; 		beq		Exit				; pour l'instant on ne change rien: il n'y a pas de commentaire				cmp.l	#255,d0		blo.s	PasSup255Commentaire		move.l	#255,d0				move.l	tetextH(a4),a0		_HLock		PasSup255Commentaire				lea.l	Commentaire(a6),a1		move.b	d0,(a1)+				; a1 pointe sur le 1er caractère		move.l	tetextH(a4),a0		move.l	(a0),a0			;handle		_BlockMove						move.l	TeHandle(a6),a0		_HUnlock		move.l	TeHandle(a6),a0		move.l	(a0),a0						move.l	tetextH(a0),a0		_HUnlock		; ------------------		; on calcule maintenant l'espace nécessaire dans le sous-titre pour stocker la chaîne de commentaire; on n'aligne pas sur dc.l on ajoute 16 en reserve 		lea.l	Commentaire(a6),a1		move.b	(a1),d0		; longueur du commentaire		and.l	#$ff,d0		move.l	pointeur(a6),a0		add.l	st_TexteLenth(a0),d0	;longueur du texte		add.l	st_StyleLenth(a0),d0	;Longueur du style		add.l	#16,d0		; en reserve; on calibre la longueur du sous-titre 		; a0 ptr st, d0 longueur demandée				import	EcarteSousTitre		jsr		EcarteSousTitre	; on calcule le pointeur du commentaire		move.l	pointeur(a6),a2		move.l	a2,d1				add.l	#st_SizeOf,d1			; taille du header		add.l	st_TexteLenth(a2),d1	; taille du texte			import	AligneD1		jsr		AligneD1				; premier alignement		add.l	st_StyleLenth(a2),d1	; longueur du style		add.l	#4,d1					; 4 octets de séparations		import	AligneD1		jsr		AligneD1				move.l	d1,st_CommentairePtr(a2)	; pointeur du commentaire		move.l	d1,a1				lea		commentaire(a6),a0		; chaine de caractères sauvegardé		moveq	#0,d0		move.b	(a0)+,d0				; longueur du commentaire; et ptr chaine +1 (str 255 !)		move.l	d0,st_CommentaireLenth(a2)				_BlockMove						; on recopie le commentaire		bra		Exit		; -------------------------------------------------------		TcodeIn; on commence par recopier le texte du te dans un buffer		move.l	TeHandle(a6),a0		_HLock		move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		move.l	tetextH(a4),a0		_HLock				move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		beq		TCinVide								lea.l	Commentaire(a6),a1		move.b	d0,(a1)+		move.l	tetextH(a4),a0		move.l	(a0),a0			;handle		_BlockMove						move.l	TeHandle(a6),a0		_HUnlock		move.l	TeHandle(a6),a0		move.l	(a0),a0						move.l	tetextH(a0),a0		_HUnlock						; on converti la chaine en time code		lea.l	Commentaire(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine in non valide		import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		bra.s	pasTCinVide; --TCinVide		moveq.l	#-1,d0pasTCinVide		move.l	pointeur(a6),a0		move.l	d0,st_timeCodeIn(a0)		lea.l	Commentaire(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Commentaire(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	TEHandle(a6),-(sp)		_teSetText				bra		Exit; ---------------------------------------------------------------------TcodeOut; on commence par recopier le texte du te dans un buffer		move.l	TeHandle(a6),a0		_HLock		move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		move.l	tetextH(a4),a0		_HLock				move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		beq		TCOutVide								lea.l	Commentaire(a6),a1		move.b	d0,(a1)+		move.l	tetextH(a4),a0		move.l	(a0),a0			;handle		_BlockMove						move.l	TeHandle(a6),a0		_HUnlock		move.l	TeHandle(a6),a0		move.l	(a0),a0						move.l	tetextH(a0),a0		_HUnlock					; on converti la chaine en time code		lea.l	Commentaire(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine in valide				import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		bra.s	pasTCOutVideTCOutVide		moveq.l	#-1,d0pasTCOutVide				move.l	pointeur(a6),a0		move.l	d0,st_timeCodeOut(a0)		lea.l	Commentaire(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Commentaire(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	TEHandle(a6),-(sp)		_teSetText		bra		Exit; -----------------------------------------------------------copieTexte	; nous sommes ici pour recopier le texte	; on commence par recopier la chaine de commentaire dans un buffer, s'il y en a une		move.l	TEHandle(a6),-(sp)		move.l	pointeur(a6),-(sp)		import	TransfertStyleTE_Memoire		;(TEHandle: te,STptr: ptr)			jsr		TransfertStyleTE_Memoire							; -----------------------------------------------------------									Exit		; on update le sous-titres dns la fenêtre listing		move.l		Num(a6),-(sp)		import		DrawSt_enCourDansListing_ByPointeur		jsr			DrawSt_enCourDansListing_ByPointeur	; on le redessine dans listing								; on redessine le suivant si tc out		cmp.w		#TimecodeOut_SousTitre,Item(a6)		bne			SupDernier		move.l		num(a6),d0		addq.l		#1,d0		cmp.l		G.General_NombreST,d0		bhi.s		SupDernier		move.l		d0,-(sp)		import		DrawSt_enCourDansListing_ByPointeur		jsr			DrawSt_enCourDansListing_ByPointeur	; on le redessine dans listingSupDernier								; on regarde si le sous-titre était celui en cour		move.l	num(a6),d0		cmp.w	G.General_sousTitreEnCour,d0		beq.s	EnCour				add.w	#1,d0	; ou bien celui d'après		cmp.w	G.General_sousTitreEnCour,d0		bne.s	PAsEnCour				EnCour				pea		G.DialogSaisie		_SetPort				lea		G.DialogSaisie,a0		pea		PortRect(a0)		_InvalRectPAsEnCour					movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.new	TransfertTE_Memoire			; this name will appear in the debugger		align 4						ENDP		end	