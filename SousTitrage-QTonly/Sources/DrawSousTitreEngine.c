#include "DrawSousTitre.h"#include "GiveFontInfo.h"// preprocesseur directive pour le type de compilation #ifdef 	powerc#ifndef    	__procinfo__  //cette valeur est definie pendant la compilation de de PowerSubtitling//pour le cas ou l'on compile la resource du code ....ProcInfoType __procinfo = kPascalStackBased     		 | RESULT_SIZE(SIZE_CODE(sizeof(short))) 		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(FontRenderRecordPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(SousTitreRecordPtr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(DrawStParamPtr))) 		 | STACK_ROUTINE_PARAMETER(8, SIZE_CODE(sizeof(Rect*)))	 ;#endif //#ifdef 	powerc#endif// routine de dessin de sous-titrepascal short Draw_SousTitreEng(FontRenderRecordPtr FontRender,			SousTitreRecordPtr STPtr,short X,short Y,Ptr ScreenPtr,			long RowBytes,	DrawStParamPtr DP,Rect *rect){long			thecharindex,start,end,startY,currentY,currentX;short 		nbligne,lastchar,curlin,a;short		justif,mask,kernAdit,style,laststyl;scanst		scan;linebreak		Lignes;CharHeaderPtr	tmpPtr;short		c,flag;Rect			rectligne,rectST,tempmask;PlaneInfoPtr	planeinfo;unsigned long  	LL;// initialisation	rect->top=-32767;	rect->left=-1;	rect->bottom=32767;	rect->right=0;	justif=STPtr->st_Justification;	mask=STPtr->st_MasKType;	// on intialise la routine qui récupère les caractères d'un sous-titre	InitialiseScanST(&scan,STPtr);// on calcule les lines breaks du sous-titre	nbligne=CalculLineBreak(&scan,FontRender,&Lignes,DP);// on calcule le start Y	a=FontRender->interligne;	startY=Y-(DP->Display_interligne+FontRender->interligne)*nbligne;	currentX=X;	// boucle de dessin// on effectue une boucle ligne par ligne	currentY=startY;	// on s'occupe des masques en premier	for (curlin=0;curlin<=nbligne;curlin++){		//on récupère les offsets de la ligne dans le texte		start=Lignes.elmt[curlin].startindex;		end=Lignes.elmt[curlin].endindex;					// on calcule le rectangle du sous-titre			CalRectDrawST(justif,DP,&Lignes, &rectligne,curlin,&kernAdit);		// chg de coordonnees		rectligne.left+=X;		rectligne.right+=X;		rectligne.top+=currentY;		rectligne.bottom+=currentY;						// on taille en fct de l'ascent et le descent de la police		// et non pas en fct du rectangle de la ligne determinée plus haut		rectligne.top=currentY-FontRender->max_Ascent;		rectligne.bottom=currentY+FontRender->max_descent;						if((end-start)>0){ // ligne vide ?		// on calcule le rectangle global sur la ligne			if (!curlin){ //qu'une seule fois							CalcRectGlobal(justif,DP,&Lignes);						// note 										rectST=Lignes.rect;						// chmt de coordonées						rectST.top+=currentY;				rectST.bottom+=currentY;				rectST.right+=currentX;				rectST.left+=currentX;				// on agrandi le rectangle avec les boxing size				rectST.top-=DP->Boxing_SizeV+2;				rectST.bottom+=DP->Boxing_SizeV+2;				rectST.left-=DP->Boxing_SizeX+2;				rectST.right+=DP->Boxing_SizeX+2;				*rect=rectST;												// on agrandie le rectangle de sortie de qques pixels pour être sûr que				// tous le rectangle sera correctement effacé dans le cas d'une carte 				// nu-vista 				rect->top-=2;				rect->left-=2;				rect->right+=2;				rect->bottom+=2;				if (rect->left<0) rect->left=0;				if (rect->top<0) rect->top=0;				if (rect->bottom>DP->screenbound.bottom) rect->bottom=DP->screenbound.bottom;				if (rect->right>DP->screenbound.right) rect->right=DP->screenbound.right;							}						// on s'occupe du type de boxing			switch(mask){				case 1:	//boxing_mask, carré sur tout le rectangle du sous-titre					tempmask=rectligne;					tempmask.left=rectST.left;					tempmask.right=rectST.right;										// on agrandi le rectangle					tempmask.top-=DP->Boxing_SizeV+2;					tempmask.bottom+=DP->Boxing_SizeV+2;						// on modifie le rectangle global du sous-titre					if (tempmask.left < rect->left) rect->left=tempmask.left;					if (tempmask.top < rect->top) rect->top=tempmask.top;					if (tempmask.right > rect->right) rect->right=tempmask.right;					if (tempmask.bottom >rect->bottom) rect->bottom=tempmask.bottom;					 C_paintRect(&tempmask,DP->RGB_OutlineBoxColor,ScreenPtr,RowBytes);				break;								case 2: //style arte					tempmask=rectligne;										// on regarde s'il y a une ligne dessinnée au dessus de la ligne courante					a=curlin-1;					flag=true;										if (a>0) { // la ligne précedente existe t-elle?						start=Lignes.elmt[a].startindex;						end=Lignes.elmt[a].endindex;						if ((end-start)>0) flag=false;  //ligne avec caractères ...					}						if(flag) tempmask.top-=DP->Boxing_SizeV+2;	 			//premiere ligne										a=curlin+1;					flag=true;										if (a<nbligne) { // la ligne suivante existe t-elle?						start=Lignes.elmt[a].startindex;						end=Lignes.elmt[a].endindex;						if ((end-start)>0) flag=false; // ligne avec caractères ...					}										if(flag)  tempmask.bottom+=DP->Boxing_SizeV+2; 	 //derniere ligne										// en X					tempmask.left-=(DP->Boxing_SizeX+2);					tempmask.right+=DP->Boxing_SizeX+2;															// maintenant on regarde si les left et right de cette ligne ne sont pas proche					// du rectangle global du sous-titre					// si oui on remplace les valeurs courante par celles du rectangle global					// on déclare que 12 pixels est le seuil										if (justif!=1){ // quelle justif ?						// pas justif à gauche						if (_abs(tempmask.left-rectST.left )<12) {							tempmask.left=rectST.left-2;							tempmask.right=rectST.right;						}					} else { // justif à gauche 						if (_abs(tempmask.right-rectST.right )<12) {							tempmask.left=rectST.left;							tempmask.right=rectST.right;						}					}										// on modifie le rectangle global du sous-titre					if (tempmask.left < rect->left) rect->left=tempmask.left;					if (tempmask.top < rect->top) rect->top=tempmask.top;					if (tempmask.right > rect->right) rect->right=tempmask.right;					if (tempmask.bottom > rect->bottom) rect->bottom=tempmask.bottom;										 C_paintRect(&tempmask,DP->RGB_OutlineBoxColor,ScreenPtr,RowBytes);				break;								case 3: //toute la ligne					tempmask=rectligne;					// on agrandi le rectangle					tempmask.top-=DP->Boxing_SizeV+2;					tempmask.bottom+=DP->Boxing_SizeV+2;					tempmask.left=0;					tempmask.right=(DP->screenbound.right)-(DP->screenbound.left);					// on modifie le rectangle global du sous-titre					if (tempmask.left < rect->left) rect->left=tempmask.left;					if (tempmask.top < rect->top) rect->top=tempmask.top;					if (tempmask.right > rect->right) rect->right=tempmask.right;					if (tempmask.bottom > rect->bottom) rect->bottom=tempmask.bottom;					 C_paintRect(&tempmask,DP->RGB_OutlineBoxColor,ScreenPtr,RowBytes);				break;			};							}//if(end-start)				currentY+=(DP->Display_interligne+FontRender->interligne); // ligne suivant	} // for (curlin=0;curlin<=nbligne;curlin++)  //dessin des masques	// ---------------       on affiche les caractères		// boucle de dessin	currentY=startY;				// on effectue une boucle ligne par ligne	for (curlin=0;curlin<=nbligne;curlin++){			//on récupère les offsets de la ligne dans le texte		start=Lignes.elmt[curlin].startindex;		end=Lignes.elmt[curlin].endindex;			// on calcule les ccordonnes du rectangle		CalRectDrawST(justif,DP,&Lignes, &rectligne,curlin,&kernAdit);			// chg de coordonnees		rectligne.left+=X;		rectligne.right+=X;		rectligne.top+=currentY;		rectligne.bottom+=currentY;		// le pt de depart du curseur		currentX=rectligne.left;				/* on compense le x du 1er char		note pour chaque caractère, il ya plusieurs plans		tous les calculs fait précedemment, ne tiennent compte que du rectangle		global d'un caractère, tous plans confondus.		Mais, pour le dessin du premier caractère d'une ligne, on compense cette ecard		pour que cette ligne soit bien centrée.				note: il faut vérifier si le premier caractères un caractère affichage sinon caca à l'écran		*/				c=GetScanST(&scan,start);					// on récupère le 1er caractère de la ligne		tmpPtr=C_GiveDisplayFont_CharInfo(FontRender,c,(scan.stylerec.scrpFace/*&0xFFFD*/));				// si tmp ptr valide ?		if(tmpPtr){			LL=(unsigned long)tmpPtr+sizeof(CharHeader);		// on calcule l'adresse du plane info 1 du caractère			planeinfo=(PlaneInfo*)LL;			currentX-=(planeinfo->pi_Rect.left)/2;		}		// dessin de la ligne		lastchar=0; // raz (sert pour le kerning char a char...		laststyl=0;				for (thecharindex=start;thecharindex<=end;thecharindex++){				c=GetScanST(&scan,thecharindex);		// on récupère le catactère								// si caractère affichable on dessine								if( c != 0x20 && c!=0xca && c>0x20 && ( c!=0x7f ) ) {					style=scan.stylerec.scrpFace;										a=GiveKern(FontRender,lastchar,c,laststyl,style); 		// on récupère le kerning 					// on soustrait le kern global, le kern automatique et le kern global					currentX-=a;					//style=0;										//on dessine le caractère					a=C_FastDraw_A_Char(FontRender,c,style,currentX,currentY,ScreenPtr,RowBytes,32,DP);					// avancement du curseur					currentX+=a;					currentX+=DP->kerning;					currentX-=kernAdit;											// pour le kerning					lastchar=c;					laststyl=style;				}							// si espace on ne dessine pas								if (c ==0x20 || c== 0xca){					currentX+=DP->kerning;					currentX-=kernAdit;					currentX+=DP->spacewith;				}										} //(thecharindex=start;thecharindex<=end;thecharindex++)		currentY+=(DP->Display_interligne+FontRender->interligne); // ligne suivant	} // for (curlin=0;a<curlin;curlin++){	// on place les valeurs du rectangle du st actuel dans le st de sortie	//on aggrandi de quelques pixels le rectangle glogal du sous-titre	rectST.left-=2;	rectST.top-=2;	rectST.right=2;	rectST.bottom=2;		// on clip le rectangle à la largeur du sous-titre	if (rectST.left<0) rectST.left=0;	if (rectST.top<0) rectST.top=0;	a=(DP->screenbound.right)-(DP->screenbound.left);	if (rectST.right>a) rectST.right=a;	a=(DP->screenbound.bottom)-(DP->screenbound.top);	if (rectST.bottom>a) rectST.bottom=a;		return 0;} //C_Draw_SousTitre//Cette routine effectue les calculs// pour la justification des sous-titresstatic void CalRectDrawST(short justif,DrawStParamPtr DP,linebreakPtr Lignes,Rect *rectligne,short curlin,short *kernAddition){short 		nbligne,lastchar,x,y,a,end,start;short		largeurmaxligne,kernAdit,larg,largEcran,largLigne,style;CharHeaderPtr	cp;short		c;Rect			rectST,tempmask;			// si mode kerning automatique on vérifie	// que cela ne sort pas du "safe area"			kernAdit=0;//##### note: on ajoute 6 pixels à droite, mais on ne sais pas d'où viens l'erreur!!!!!!!!!			start=Lignes->elmt[curlin].startindex;			end=Lignes->elmt[curlin].endindex;					largLigne=Lignes->elmt[curlin].rect.right-Lignes->elmt[curlin].rect.left;			largEcran=(DP->screenbound.right)-(DP->screenbound.left);						//gestion du kerning automatique			kernAdit=0;			if (DP->AutomaticKerning) kernAdit=DoCalcKernAuto(largEcran,&largLigne,end-start,DP);						//on recopie le  kerning 			if (kernAddition) *kernAddition=kernAdit;				// gestion de la justification du sous-titre					largEcran=(DP->screenbound.right)-(DP->screenbound.left);						switch (justif){				case 1:	//à gauche					rectligne->left=(largEcran)/10;					if (rectligne->left<0) rectligne->left=0;					rectligne->right=rectligne->left+largLigne;					if (rectligne->right>largEcran) { 	// pb de depassement ?						rectligne->right=largEcran;						//### note: faire modification de kerning ?						}					rectligne->top=Lignes->elmt[curlin].rect.top;					rectligne->bottom=Lignes->elmt[curlin].rect.bottom;							break;										case 2:	// à droite					rectligne->right=(largEcran*9)/10;					rectligne->left=rectligne->right-largLigne;					if (rectligne->left<0) { //erreur ?						 rectligne->left=0;					}					rectligne->top=Lignes->elmt[curlin].rect.top;					rectligne->bottom=Lignes->elmt[curlin].rect.bottom;				break;									default :	//centré					rectligne->left=(largEcran-largLigne)/2;					rectligne->right=rectligne->left+largLigne;					if (rectligne->right>largEcran) rectligne->right=largEcran;					if (rectligne->left<0) rectligne->left=0;					rectligne->top=Lignes->elmt[curlin].rect.top;					rectligne->bottom=Lignes->elmt[curlin].rect.bottom;				break;									};					} ////Cette routine effectue les calculs// pour la justification du rectangle global d'un sous-titre des sous-titres static void  CalcRectGlobal (short justif,DrawStParamPtr DP,linebreakPtr Lignes){short 		nbligne,lastchar,x,y,a,end,start;short		largeurmaxligne,kernAdit,larg,largEcran,largLigne,style;CharHeaderPtr	cp;short		c;Rect			rectST,tempmask;	// gestion de la justification du sous-titre					largEcran=(DP->screenbound.right)-(DP->screenbound.left);						switch (justif){				case 1:	//à gauche					// traitement du rectangle global						Lignes->rect.left=(largEcran)/10;						if (Lignes->rect.left<0) Lignes->rect.left=0;											if (DP->AutomaticKerning) {							Lignes->rect.right=Lignes->rect.left+Lignes->AutoKernLarg;						} else {							Lignes->rect.right+=Lignes->rect.left;						}										if (Lignes->rect.right>largEcran) { 	// pb de depassement ?							Lignes->rect.right=largEcran;							//### note: faire modification de kerning ?							}								break;										case 2:	// à droite					// traitement du rectangle global						Lignes->rect.right=(largEcran*9)/10;						if (DP->AutomaticKerning) {							Lignes->rect.left=Lignes->rect.right-Lignes->AutoKernLarg;						} else {							Lignes->rect.left-=Lignes->rect.right;						}						if (Lignes->rect.left<0) Lignes->rect.left=0;																	if (Lignes->rect.right>largEcran) { 	// pb de depassement ?							Lignes->rect.right=largEcran;							//### note: faire modification de kerning ?							}				break;									default :	//centré					// traitement du rectangle global						if (DP->AutomaticKerning) {							Lignes->rect.left=(largEcran-Lignes->AutoKernLarg)/2;							Lignes->rect.right=Lignes->rect.left+Lignes->AutoKernLarg; // la largeur du kerning						} else {							Lignes->rect.left=(largEcran-Lignes->rect.right)/2;							Lignes->rect.right+=Lignes->rect.left;						}						if (Lignes->rect.left<0) Lignes->rect.left=0;						if (Lignes->rect.right>largEcran) { 	// pb de depassement ?							Lignes->rect.right=largEcran;							//### note: faire modification de kerning ?							}									break;									};} //calc rect global// ----------------------------------------------//cette routine verifie si on ne dépasse pas le "safe area" d'un ecranstatic short DoCalcKernAuto(short largEcran,short *largLigne,short nbchar,DrawStParamPtr DP){short larg,kernAdit,a;					kernAdit=0;							larg=*largLigne;		largEcran=(largEcran*DP->SafeArea)/100;		if (larg >largEcran ){			//si cela dépasse on modifie le kerning sur la ligne			// dans la proportion nécessaire pour que la ligne rentre dans le safe area			kernAdit=(larg-largEcran)/nbchar; 			// on tient compte des arrondis de calcul pour la largeur finale...			a=(*largLigne-largEcran)-kernAdit*nbchar;			*largLigne=largEcran;			*largLigne+=a;					}			return kernAdit;	} //			kernAdit=DoCalcKernAuto(short largEcran,short largLigne);//----------------------------------------------// Cette routine calcule les ligne break d'un sous-titrestatic short CalculLineBreak(scanstPtr scan,FontRenderRecordPtr FontRender,linebreakPtr Lignes,DrawStParamPtr DP){long			a;short 		nbligne,larg,lastchar,haut,bas,largLigne,largEcran;CharHeaderPtr	cp;short		c,style,laststyle;//initialisation ...	nbligne=0;	larg=0;		Lignes->rect.left=0;	Lignes->rect.top=0;	Lignes->rect.bottom=0;	Lignes->rect.right=-32767;	Lignes->AutoKernLarg=-32767;	Lignes->elmt[0].rect.left=0;	Lignes->elmt[0].rect.top=32767;	Lignes->elmt[0].rect.bottom=-32767;	Lignes->elmt[0].rect.right=0;	Lignes->elmt[0].startindex=0;	Lignes->elmt[0].endindex=(scan->ST)->st_TexteLenth-1;	lastchar=0;// on commence par calculer la largeur de chaque ligne du sous-titre	// boucle	for (a=0;a< ( (scan->ST)->st_TexteLenth);a++){			c=GetScanST(scan,a);						if (c==0x0d){ //retour chariot					Lignes->elmt[nbligne].endindex=a-1; // on place la fin de la ligne sauf le cr					if(nbligne>200) goto  CalcRectGlobal;											nbligne++;					Lignes->nbligne=nbligne;					// on initialise la nouvelle ligne					Lignes->elmt[nbligne].rect.left=0;					Lignes->elmt[nbligne].rect.top=0;					Lignes->elmt[nbligne].rect.bottom=0;					Lignes->elmt[nbligne].rect.right=0;					Lignes->elmt[nbligne].startindex=a+1;					Lignes->elmt[nbligne].endindex=(scan->ST)->st_TexteLenth-1;					lastchar=0;					laststyle=0;			} else {				// si caractères espace ou espace-insécable			// on remplace la valeur par le global largeur espace			if (c==0xca || c==0x20){				larg=DP->spacewith;				haut=0;				bas=0;								if(a){ // 1er caractère ?						// non,						// donc on pondère avec le kerning global						larg+=DP->kerning;					}								Lignes->elmt[nbligne].rect.right+=larg;					} else {				if (c>0x20&&( c!=0x7f )){	//caractère affichable ?					// note on masque l'italique comme dans la routine en ASM												// on récupère le style du char					style=scan->stylerec.scrpFace;					cp=C_GiveDisplayFont_FastCharInfo(FontRender,c,(scan->stylerec.scrpFace&0xFFFD));					if( cp) {						 // on calcule le rectangle relatif à la base line						// et on actualise le rectangle global de la ligne						larg=(cp->CH_Rect).right-(cp->CH_Rect).left;						haut=(cp->CH_Rect).top;						bas=(cp->CH_Rect).bottom;						haut+=cp->CH_Spare;	// on effectue un chmt de coordonne (base line)						bas+=cp->CH_Spare;	// on effectue un chmt de coordonne(base line)						if(a){ // 1er caractère ?							// non,							// donc on pondère avec le kerning global et le kerning lettre à lettre							larg+=DP->kerning;							larg-=GiveKern(FontRender,lastchar,c,laststyle,style);						}												// on actualise le rectangle de la ligne							Lignes->elmt[nbligne].rect.right+=larg;							if ( haut<Lignes->elmt[nbligne].rect.top) Lignes->elmt[nbligne].rect.top = haut;							if (bas>Lignes->elmt[nbligne].rect.bottom ) Lignes->elmt[nbligne].rect.bottom = bas;										} 					}// char >0x20			} // pas espace			lastchar=c;			laststyle=style;			} //else	} //for (a=0;a<STPtr->st_TexteLenth;a++)CalcRectGlobal:					//on calcule le rectangle global du sous-titre	Lignes->rect.left=0;	Lignes->rect.top=Lignes->elmt[0].rect.top;  //(..top <0 !)	Lignes->rect.bottom=-(DP->Display_interligne+FontRender->interligne); //compensation du nb de boucle	Lignes->rect.right=-32767;	Lignes->AutoKernLarg=-32767;	largEcran=(DP->screenbound.right)-(DP->screenbound.left);// on ajuste la largeur et la hauteur globale	for (a=0;a<=nbligne;a++){			if (Lignes->elmt[a].rect.right> Lignes->rect.right) Lignes->rect.right= Lignes->elmt[a].rect.right;			Lignes->rect.bottom+=(DP->Display_interligne+FontRender->interligne); 						largLigne= Lignes->elmt[a].rect.right;						// on gère le kerning automatique pour le rectangle global			if (DP->AutomaticKerning) {				DoCalcKernAuto(largEcran,&largLigne,Lignes->elmt[a].endindex-Lignes->elmt[a].startindex,DP);				if (largLigne>Lignes->AutoKernLarg)Lignes->AutoKernLarg=largLigne;			} 	}		//si pas autokern	if (!DP->AutomaticKerning) 	Lignes->AutoKernLarg=Lignes->rect.right;	// on compense avec le descent de la dernière ligne	Lignes->rect.bottom+=Lignes->elmt[nbligne].rect.bottom;	return nbligne;}// ------------------------------------------------// routine pour initialiser la recupération des caractèresstatic  short InitialiseScanST(scanstPtr scan,SousTitreRecordPtr STPtr){		scan->ST=STPtr;		scan->lastindex=-1;		scan->lastStyleindex=-1;		scan->nextstyleindex=-1;		scan->theChar=0;		scan->stylerec.scrpStartChar=0;		scan->stylerec.scrpHeight=0;		scan->stylerec.scrpAscent=0;		scan->stylerec.scrpFont=0;		scan->stylerec.scrpFace=0;		scan->stylerec.scrpSize=0;		scan->stylerec.scrpColor.red=-1;		scan->stylerec.scrpColor.green=-1;		scan->stylerec.scrpColor.blue=-1;				return 0;}// routine pour recupérer les infos sur le  caractère à un index (start=0)static unsigned short GetScanST(scanstPtr scan,long index){unsigned char*	P;long	L,stylindex,maxstyle,lastscanstyleindex,i;unsigned short c;StScrpPtr 	styl;		if (!  (scan->ST)->st_TexteLenth )  return -1; // st vide ?		if (index>(  ( (scan->ST)->st_TexteLenth) ) )return -1; // index valid ?		if (index<0) return -1; // index valid ?// on récure le char	// note: fonctionne uniquement en single byte caractères		L=(long) (scan->ST);		L+=sizeof(SousTitreRecord);		L+=index;		P=(unsigned char*)L;		c=(unsigned short) *P;		if (c>=0x80) {			c=c;			c=c&0xff;		}		scan->theChar=c;		// on récupère le style associé			styl=(StScrpPtr)(scan->ST)->st_StylePtr;				if ( styl==nil){  //si  pas de style on met des valeurs par défaut			scan->stylerec.scrpStartChar=0;			scan->stylerec.scrpHeight=0;			scan->stylerec.scrpAscent=0;			scan->stylerec.scrpFont=0;			scan->stylerec.scrpFace=0;			scan->stylerec.scrpSize=0;			scan->stylerec.scrpColor.red=-1;			scan->stylerec.scrpColor.green=-1;			scan->stylerec.scrpColor.blue=-1;			 return c; // pas de style		}				// on scanne les styles		lastscanstyleindex=0;		maxstyle=styl->scrpNStyles;				if (maxstyle>1600){	// erreur sur le nb de styles ?			scan->stylerec.scrpStartChar=0;			scan->stylerec.scrpHeight=0;			scan->stylerec.scrpAscent=0;			scan->stylerec.scrpFont=0;			scan->stylerec.scrpFace=0;			scan->stylerec.scrpSize=0;			scan->stylerec.scrpColor.red=-1;			scan->stylerec.scrpColor.green=-1;			scan->stylerec.scrpColor.blue=-1;			 return c; // pas de style		}				// on copie le 1er style		scan->stylerec=styl->scrpStyleTab[0];		for (i=0;i<maxstyle;i++){			stylindex=styl->scrpStyleTab[i].scrpStartChar;			if (stylindex>index) return c; // on a trouvé on sort			scan->stylerec=styl->scrpStyleTab[i];		}				return c;}// routine pour recupérer le prochain caractèrestatic  unsigned short GetNextScanST(scanstPtr scan){Ptr	P;long	L;char c;				scan->lastindex++;		if (scan->lastindex>((scan->ST)->st_TexteLenth)) return -1; // index valid ?	// on récure le char				return GetScanST(scan,scan->lastindex);		}static short GiveKern(FontRenderRecordPtr FontRender,short firstchar,short secondchar,							short firstcharstyl,short secondcharstyl){KerningMasterListHandle KPLH=nil;long 	nb,i;short	ekual,kern=0;	// on recupère la liste	KPLH=(KerningMasterListHandle)FontRender->KerningTable;	if(!KPLH) 	return 0;		nb=	(**KPLH).nbKernPair;			// on recherche le kern		// boucle de recherche				for (i=0;i<nb;i++){						// on regarde si cela correspond			ekual=0;									// premier caractère valide ?						if ( (**KPLH).kernElements[i].PremierChar==-1) // joker ?				ekual=true;			else 				if ((**KPLH).kernElements[i].PremierChar==firstchar) 				ekual=true;							// second caractère valide ?						if ( (**KPLH).kernElements[i].DeuxiemeChar==-1) // joker ?				ekual=ekual&true;			else 				if ( !( (**KPLH).kernElements[i].DeuxiemeChar==secondchar ) ) 		ekual=false;									// traitement du masque de style			// note dans le masque le style plain est =0x10			// il faut transformer la value si plain						if ( !firstcharstyl) 	firstcharstyl=0x10;			if ( !secondcharstyl) 	secondcharstyl=0x10;						if ( !(firstcharstyl&(**KPLH).kernElements[i].PremierCharStylMask) ) 	ekual=false;			if ( !(secondcharstyl&(**KPLH).kernElements[i].DeuxiemeCharStylMask) ) 	ekual=false;						// si equal on renvoi la valeur			//			if(ekual){				short a=(**KPLH).kernElements[i].value;				 return -a;				}		} // for (i=0;i<nb;i++)	return 0;}// cette routine remplie un rectangle par un long//attention cette routine ne fait pas de test de validitévoid C_paintRect(Rect *rect,long color,Ptr BaseAdresse,long RowBytes){long		L;long*	P;long		x,y,i,j;	x=rect->right-rect->left;	y=rect->bottom-rect->top;	L=rect->top*RowBytes+rect->left*4;	L+=(long)BaseAdresse;	for(i=0;i<y;i++){		P=(long*)L;		for(j=0;j<x;j++){			*P=color;			P++;		}		L+=RowBytes;	}}	 static  short   C_FastDraw_A_Char(FontRenderRecordPtr  FontRender,short  TheChar,short TheStyle,  short  Xpos ,short Ypos ,char* BaseAdresse,long RowBytes,short deph,DrawStParamPtr DP){short	largcarn,larg;unsigned long 		LL;long				rowbytesource,x,y;short			hautc,largc,pixss,pixds,alphd,alphs,alphsn;long 				temp,temp1,temp2;long				pixsl,pixdl;CharHeaderPtr		cp,cp2;PlaneInfoPtr		planeinfo;long*			DLP;long*			DLP1;long*			SLP;long*			SLP1;short*			DSP;short*			DSP2;short*			SSP;short*			SSP1;long				Row_Byte,destination,source;unsigned long 		a,r,g,b,a2,r2,g2,b2,a3,r3,g3,b3;short			YS,YD,YF;short			flag;		// on recupère les infos sur le char		cp=C_GiveDisplayFont_FastCharInfo(FontRender,TheChar,TheStyle);		if(!cp) return 0; // le caractère est hors de cette police		largcarn=(cp->CH_Rect).right-(cp->CH_Rect).left;		if(largcarn<=0) return 0;		// si rectangle non valid on ne dessine pas ....				// hauteur er largeur du caractère		largc=largcarn;		hautc=(cp->CH_Rect).bottom-(cp->CH_Rect).top;		//on calcule la luminance de la face				r2=DP->RGB_FaceColor&0xff0000;		g2=DP->RGB_FaceColor&0xff00;		b2=DP->RGB_FaceColor&0xff;		YF=((r2>>16)*3+(g2>>8)*6+b2)/10;				// si le style est l'italique on prend la largeur du caractère en style normal		if(TheStyle==2){			cp2=C_GiveDisplayFont_FastCharInfo(FontRender,TheChar,TheStyle&0Xfffd);			if(!cp2) return 0; // le caractère est hors de cette police			largcarn=(cp2->CH_Rect).right-(cp2->CH_Rect).left;		}		//calcul de la position en XY		// on les affectes dans char* pour le mode 16 bits		// et lo,g* pour le mode 32 bits argb		LL=(unsigned long) BaseAdresse;		LL+=Xpos*4;		LL+=(Ypos+cp->CH_Spare)*RowBytes;	// on compense avec le base line				Row_Byte=RowBytes/4;						DLP=(long*)LL;		DSP=(short*)LL;				// on calcule la position des données source dans la police		LL=(unsigned long) cp;		LL+=sizeof(CharHeader);		SLP=(long*)LL;		SSP=(short*)LL;//----------------------------------------// boucle de recopie -----------------------		if(deph==32) { // mode 32 bits			rowbytesource=(largc+1);					for (y=0;y<hautc;y++){				DLP1=DLP;				SLP1=SLP;				for (x=0;x<largc;x++){				// on ne dessine que si on est dans le buffer ecran									if (DLP1>=(long*)BaseAdresse) { 						destination=*DLP1;	// pixel present dans la carte						source=*SLP1;	// pixel de la source												//y a t-il un pixel desssiné dans la carte ?						if( destination&0xFF000000){ // oui le pixel existe														if(destination==DP->RGB_OutlineBoxColor){ // couleur de fond ?								// oui: on remplace par le pixel du char en faisant un blend																	// on effectue un blend des deux pixels									// traitement des alpha									alphd=((destination&0xff000000 )>>24);									alphs=((source&0xff000000 )>>24);									alphsn=255-alphs;	//multiplicateur inverse																		// on adittione les alphas									a=alphd+alphs;  // le nouveau alpha									if (a>255) a=255; // on clip la valeur									a=a<<24;																		// rouge									temp=(( destination&0xff0000 )>>16);									temp1=(( source&0xff0000 )>>16);									r=temp1*alphs+temp*alphsn;									r=r&0xff00;									r=r<<8;																//vert									temp=(( destination&0xff00 )>>8);									temp1=(( source&0xff00 )>>8);									g=temp1*alphs+temp*alphsn;									g=g&0xff00;									//bleu									temp=( destination&0xff);									temp1=( source&0xff);									b=temp1*alphs+temp*alphsn;									b=b&0xff00;									b=b>>8;																		*DLP1=a+r+g+b;																} else {								// non c'est donc un pixel d'un caractère								// le traitement est simple: le pixel le plus clair (en N&B) l'emporte ...								// maintenant il faut déterminer quel est celui qui est devant l'autre								// on fait un key de luminance																	flag=false;																				a2=destination&0xff000000;									r2=destination&0xff0000;									g2=destination&0xff00;									b2=destination&0xff;									//calcul de la luminance des 2 pixels apres le blend															YD=((r2>>16)*3+(g2>>8)*6+b2)/10;																	// on determine le pixel de la destination à une luminance proche de la couleur de la face									//tolerance 32 niveaux ....																	if ( L_abs(YF-YD) <33) {  															r=r2;										g=g2;										b=b2;										a=a2;																			} else {										alphd=a2>>24;										alphs=((source&0xff000000 )>>24);										alphsn=255-alphs;	//multiplicateur inverse										a=alphd+alphs;  // le nouveau alpha										if (a>255) a=255; // on clip la valeur										a=a<<24;																															r3=source&0xff0000;										g3=source&0xff00;										b3=source&0xff;																				// rouge										temp=r2>>16;										temp1=r3>>16;										r=temp1*alphs+temp*alphsn;										r=r&0xff00;										r=r<<8;									//vert										temp=g2>>8;										temp1=g3>>8;										g=temp1*alphs+temp*alphsn;										g=g&0xff00;									//bleu										temp=b2;										temp1=b3;										b=temp1*alphs+temp*alphsn;										b=b&0xff00;										b=b>>8;									}																	*DLP1=a+r+g+b;															} // pixel == couleur de fond ?											} else { 							*DLP1=source; // non on copie simplement le pixel						}						DLP1++;	//PIXEL SUIVANT						SLP1++;					}				}// for (x=0;x<hautc;x++)				// note le compilateur multiplie par 4 pour nous ...				SLP+=rowbytesource;				DLP+=Row_Byte;							}//for (y=0;y<hautc;y++)		} else { // pas mode 32 bits			if(deph==16) {	// mode 16 bits ?			//######## mode 16 bits à faire ###########					} else return 0; // non ni 32 ni 16 bits, on ne fait rien		}	return largcarn;} //static inline long L_abs(long L){	if (L<0) L=-L;	return L;}static inline short _abs(short L){	if (L<0) L=-L;	return L;}