#include "BB.Globals_C.h"#include <Devices.h>// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;/* *	Dialog Module, created by Resorcerer		light Modified by Eric Tiquet  */#include <StdArg.h>#include <stdio.h>// en attendant MPW Pro .... pour etre compatible avec la nouvelle version des includespascal void DialogCut(DialogPtr theDialog); pascal void DialogPaste(DialogPtr theDialog); pascal void DialogCopy(DialogPtr theDialog); pascal void DlgDelete(DialogPtr theDialog); //#pragma segment Dialogs_1#define thisDialogID 268/* Symbolic Dialog Item Numbers */static enum {	LIST1 = 1,	STXT2_PALETTE,	STXT3_Liste,	BUT4_Analyse,	ICON5,	ICON6,	Min_7,	Mout_8,	LASTITEM	};#define OK_ITEM 	?? /* Can't determine which item dismisses dialog affirmatively */#define CANCEL_ITEM 	?? /* Define this to be item that cancels dialog *//* Useful constants */#ifndef ENTERkey#define ENTERkey	0x3#endif#ifndef DELETEkey#define DELETEkey	0x8#endif#ifndef NIL#define NIL ((void *)0)#endif#ifndef TRUE#define TRUE 1#endif#ifndef FALSE#define FALSE 0#endif#ifndef FRONT_WINDOW#define FRONT_WINDOW  ((WindowPtr) (-1L))#endif/* Prototypes */void DoAnalyseTexte(SousTitreRecordPtr ST_Ptr,UserList *list1);void DoMarkInKaraoke(SousTitreRecordPtr ST_Ptr,UserList *list1);void DoMarkOutKaraoke(SousTitreRecordPtr ST_Ptr,UserList *list1);//void PutKaraokeIntoSt(SousTitreRecordPtr ST_Ptr,UserList *list1);//void GetKaraokeFromST(SousTitreRecordPtr ST_Ptr,UserList *list1);extern DialogPtr gPaletteKaraoke;static int		DoDialogItem(DialogPtr dlog, short itemHit);static pascal  Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit);static Boolean CheckUserItems(Point where, short *itemHit);static int     AnyBadValues(DialogPtr dlog);static long    strlen(char *);char   *strcpy(char *dst, char *src);char   *PascalToC(char *pstr);char   *CToPascal(char *cstr);void    PutDlgString(DialogPtr dlog, int item, char *str, int sel);void    PutDlgWord(DialogPtr dlog, int item, int val, int sel);void    PutDlgLong(DialogPtr dlog, int item, long val, int sel);void    PutDlgChkRadio(DialogPtr dlog, int item, int val);static int     GetDlgString(DialogPtr dlog, int item, char *str);static int     GetDlgWord(DialogPtr dlog, int item, short *val);static int     GetDlgLong(DialogPtr dlog, int item, long *val);static int     GetDlgChkRadio(DialogPtr dlog, int item);static int     TextSelected(DialogPtr dlog);OSType  CanPaste(int n, ...);void    FrameDefault(DialogPtr dlog, int item, int frame);static void    GetDlgPanel(DialogPtr dlog, int item, Rect *panel);static int     BuildList(DialogPtr dlog, int item, int csize, UserList *l);static unsigned char   *GetCellData(UserList *l, short i, short *len);static int     GetLengthList(UserList *l);static int     DoOpenCell(UserList *l, unsigned char *buf, short *len);static Point where;static int modifiers;/* Lists and/or popups */static UserList list1;/* *	For non-modal dialogs, after a mouse down event in dialog window, w, call this *	to entertain the click. */void DoPaletteKaraokeContent(DialogPtr w, EventRecord *evt)	{		short itemHit;				SetPort(w);						/* If it's not already */		modifiers = evt->modifiers;		/* Stuff our local globals */		where = evt->where;		GlobalToLocal(&where);				itemHit=1+FindDialogItem(w,where);	 	if (itemHit) DoDialogItem(w,itemHit);	}/* * Mouse down event: * Check if it's in some user item, and convert to itemHit if appropriate. */static Boolean CheckUserItems(Point where, short *itemHit)	{		return(FALSE);	}/* * Redraw the contents of this dialog due to update event. * If you have not installed UserItem draw routines, you should redraw * them explicitly here; otherwise, UpdateDialog() will call your routines. */void DoPaletteKaraokeDialogUpdate(DialogPtr dlog)	{short type,IconId,i; Handle hndl; Rect box;Str255 str; PixPatHandle	the_pixpat;RgnHandle		r1=NewRgn(),r2=NewRgn();Handle						LaListeH;DitlelementPtr			LaListe;Ditl_MasterlistPtr	LaListe1;				SetPort(dlog);		TextMode(srcOr);		BeginUpdate(dlog);						if (!EmptyRgn(dlog->visRgn)){			 RectRgn(r1,&dlog->portRect);			 			 GetDialogItem(dlog,1,&type,&hndl,&box);			 RectRgn(r2,&box);			 DiffRgn(r1,r2,r1);			 			 GetDialogItem(dlog,9,&type,&hndl,&box);			 RectRgn(r2,&box);			 DiffRgn(r1,r2,r1);			 			 			  the_pixpat=GetPixPat(129);			  			  if (the_pixpat!=nil){			 	 FillCRgn(r1,the_pixpat);			 	 DisposePixPat(the_pixpat);			  }			  			  TextMode(srcOr);			  			 		LaListeH=((DialogPeek)dlog)->items;		HLock(LaListeH);		LaListe=(DitlelementPtr)*LaListeH;		LaListe1=(Ditl_MasterlistPtr)*LaListeH;					 for (i=1;i<=(LaListe1->dml_NumberOfItem+1);i++) {				 GetDialogItem(dlog,i,&type,&hndl,&box);				 if ((type&0x7f) == iconItem ) {					 IconId=C_findIconResourceDitl(dlog,i);					 hndl=(Handle)GetCIcon(IconId);					 PlotCIcon(&box,(CIconHandle) hndl);					 }				 				if ( ((type&0x7f) == statText )  && i!=3) {					 GetDialogItemText(hndl,&str);					 MoveTo(box.left,box.bottom);					 DrawString(&str);				 }				 			 }			  			 			 			FrameRect(&list1.bounds);			LUpdate(((GrafPtr)dlog)->visRgn,list1.hndl);			} // vis region empty ?					GetDialogItem(dlog,9,&type,&hndl,&box);		FrameRectOneLine(&box,true);					EndUpdate(dlog);		DisposeRgn(r1);		DisposeRgn(r2);}/* * Activate event: Activate or deactivate this dialog and any items in it */void DoPaletteKaraokeDialogActivate(DialogPtr dlog,Boolean activ){		short type; Handle hndl; Rect box; GrafPtr oldPort;		SetPort(dlog);		if (activ) LActivate(true,list1.hndl); else LActivate(false,list1.hndl);}/* * Build this dialog's window on desktop, and install initial item values. * Return the dlog opened, or NIL if error (no resource, no memory). */pascal DialogPtr OpenPaletteKaraoke(void)	{		short type; Handle hndl; Rect box; GrafPtr oldPort;		DialogPtr dlog; unsigned char *p,str[256];		GetPort(&oldPort);		/*dlog = GetNewDialog(thisDialogID,NIL,FRONT_WINDOW);*/		GetNewWindowReference((DialogPtr*)&dlog,thisDialogID,(WindowReference)-1,(ActivateHandlerUPP)nil);		if (dlog == NIL) { SysBeep(1); return(NIL); }	/* Poor man's error message */		SetPort(dlog);				TextFont(kFontIDGeneva); 		/* Fill in dialog's values here */		if (!BuildList(dlog,LIST1,12,&list1)) goto broken;		//ShowWindow(dlog);		return(dlog);		/* Error return */broken:		ClosePaletteKaraoke(dlog);		SetPort(oldPort);		return(NIL);	}/* * Clean up any allocated stuff, and return dialog to primordial mists */void ClosePaletteKaraoke(DialogPtr dlog)	{		if (list1.hndl) { LDispose(list1.hndl); list1.hndl = NIL; }		DisposeDialog(dlog);	/* Call CloseDialog if you provide storage to GetNewDialog */	}/* * Deal with user clicking on an item in this dialog, either modal or non-modal. * The local point is in where; modifiers in modifiers. * Returns whether or not the dialog should be closed (keepGoing). */static int DoDialogItem(DialogPtr dlog, short itemHit)	{		short type,okay=FALSE,keepGoing=TRUE,val;		Handle hndl; Rect box; Point pt;		unsigned char *p,str[256];		SousTitreRecordPtr	ST_Ptr;						ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);				if (itemHit<1 || itemHit>=LASTITEM)			return(keepGoing);				/* Only legal items, please */		GetDialogItem(dlog,itemHit,&type,&hndl,&box);				switch(itemHit) {					case BUT4_Analyse:						if ( TrackCurseur(dlog,BUT4_Analyse) )							DoAnalyseTexte(ST_Ptr,&list1);						break;					case 7:	//in						if ( TrackCurseur(dlog,7) )							DoMarkInKaraoke(ST_Ptr,&list1);						break;					case 8:	//out						if ( TrackCurseur(dlog,8) )							DoMarkOutKaraoke(ST_Ptr,&list1);						break;											case LIST1:							LClick(where,modifiers,list1.hndl);							val = 256;							DoOpenCell(&list1,str,&val);						break;			}		if (okay) keepGoing = AnyBadValues(dlog);		return(keepGoing);	}/* * Pull values out of dialog items and deliver TRUE if any of them are * illegal or inconsistent; otherwise deliver FALSE.  If any values are bad, * you should inform your user about the problem here before delivering TRUE. * If any items are missing values, this is the place to assign any defaults. */static int AnyBadValues(DialogPtr dlog)	{		char str[256]; short val,len; Cell cell;		return(FALSE);	}/*••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*//* *  The following are various utility routines for general dialog management. *  Typically, you'll want to keep them in a library that is available to all *  your dialog modules; however, they are included here (and declared static) *  as a private library so that you can quickly compile this file for testing. */#define _PrivateLibraries_#ifdef  _PrivateLibraries_/* Local C string length routine */static long strlen(register char *str)	{		register char *p;		p = str;		while (*p++) ;		return((long)(--p - str));	}/* Convert in place a Pascal string to C string, and deliver its address */static char *PascalToC(char *str)	{		register char *p,*q,*end;		end = str + *(unsigned char *)str;		q = (p=str) + 1;		while (p < end) *p++ = *q++;		*p = '\0';		return(str);	}/* *	Convert in place a C string to Pascal string, and deliver its address. *	The C string should not be greater than 255 chars in length, or the *	resulting Pascal string will be truncated to 255 chars. */static char *CToPascal(char *str)	{		register char *p,*q;		register long len;		len = strlen(str);		if (len > 255) len = 255;		p = str + len;		q = p-1;		while (p != str) *p-- = *q--;		*str = len;		return(str);	}/* Dialog Item Stuffers *//* *	Install a given Pascal string, str, into the given static or edit text item *	in the dialog, dlog.  If the item is an edit text item, leave the installed *	text selected or not according to the value of sel (TRUE or FALSE). */static void PutDlgString(DialogPtr dlog, int item, char *str, int sel)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		SetDialogItemText(hndl,str);		if (type == editText)			SelectDialogItemText(dlog,item,sel?0:32767,32767);		InvalRect(&box);	}/* *	Install a given decimal long value into the static or edit text item of the *	given dialog, dlog.  If the item is an edit text item, leave the installed *	text for the number selected or not according to sel (TRUE or FALSE). */static void PutDlgLong(DialogPtr dlog, int item, long val, int sel)	{		char str[32];		NumToString(val,str);		PutDlgString(dlog,item,str,sel);	}/* *	Same as above, only for an int (word) decimal number. */static void PutDlgWord(DialogPtr dlog, int item, int val, int sel)	{		PutDlgLong(dlog,item,(long)val,sel);	}/* *	Set the given check box or radio button item of the given dialog, dlog, to *	on or off, according to val. */static void PutDlgChkRadio(DialogPtr dlog, int item, int val)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		SetControlValue((ControlHandle)hndl,val!=0);	}/* *	Deliver the value of the checkbox or radio button item of the given dialog. */static int GetDlgChkRadio(DialogPtr dlog, int item)	{		short type; Handle hndl; Rect box;				GetDialogItem(dlog,item,&type,&hndl,&box);		return(GetControlValue((ControlHandle)hndl) != 0);	}/* Dialog Item Unstuffers *//* *	Retrieve the value of an edit text item in a given dialog, placing the *	resulting Pascal string in the buffer, str, which is assumed large enough *	to hold the text (256 bytes max).  If item is the number of a static text *	item, the empty string is delivered.  Delivers TRUE or FALSE according to *	whether or not the text so delivered was empty.   */static int GetDlgString(DialogPtr dlog, int item, char *str)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		if (type == editText) GetDialogItemText(hndl,str);		 else                 *str = 0;		return(*str != 0);	}/* *	Retrieve the value of an edit text item in a given dialog, converting the *	Pascal string to a long and setting *val to it.  Delivers TRUE or FALSE *	according to whether or not the text so delivered was empty.  If FALSE, *	*val is set to 0; if TRUE, *val is set to whatever StringToNum() says the *	value is, even if the text contains non-numerical characters. */static int GetDlgLong(DialogPtr dlog, int item, long *val)	{		int ans; char str[256];		*val = 0;		if (ans = GetDlgString(dlog,item,str))			StringToNum(str,val);		return(ans);		}/* Same as above, only delivers the value of a word */static int GetDlgWord(DialogPtr dlog, int item, short *val)	{		int ans; long num;		*val = 0;		if (ans = GetDlgLong(dlog,item,&num))			*val = num;		return(ans);	}/* *	Deliver the number of the current editText item in given dialog if any text *	is selected in it, or 0 if none selected. */static int TextSelected(DialogPtr dlog)	{		register TEHandle textH; int item = 0;				textH = ((DialogPeek)dlog)->textH;		if (*textH)			if ( (*textH)->selStart != (*textH)->selEnd )				item = ((DialogPeek)dlog)->editField+1;		return(item);	}/* *  If any of the variable argument scrap types are available for pasting from *  the scrap, deliver the first one.  Otherwise, deliver 0.  For example, *	 *      if (whichType = CanPaste(3,'TEXT','PICT','STUF')) ... * *  There can be any number of types in the list, as long as the preceding count, n, *  is correct. */static OSType CanPaste(int n, ...)	{		register OSType nextType,ans = 0L;		long err,offset;		va_list nextArg;				va_start(nextArg,n);		nextType = va_arg(nextArg, OSType);				while (n-- > 0) {			err = GetScrap(NIL, nextType, &offset);			if (err >= -1) {				ans = nextType;				break;				}			nextType = va_arg(nextArg, OSType);			}				va_end(nextArg);		return(ans);	}/* *	Get rectangle, *panel, for a given item (usually a user or picture item) *	and then hide the item so that it doesn't interfere with mouse clicking. *	This lets you stop worrying about the item order any user or pict items that *	obscure other items in the item list, which can affect how the DialogMgr *	returns itemHits. */static void GetDlgPanel(DialogPtr dlog, int item, Rect *panel)	{		short type; Handle hndl;				GetDialogItem(dlog,item,&type,&hndl,panel);		HideDialogItem(dlog,item);	}/* *	GetLengthList() should compute a given list's length and prepare *	its data to be inserted into screen cells. */static int GetLengthList(UserList *l)	{		return(l->nCells = 8);    /* Or whatever (8 is size of stubstr[] below) */	}/* *	GetCellData(l,i,len) should deliver start of pure data of i'th cell's *	contents in the given list, and sets the data's length in *len.  It can *	be assumed to be called sequentially from i=0 to l->nCells-1.  The prototype code *	here should be replaced with your content-specific instructions. */static unsigned char *GetCellData(UserList *l, short i, short *len)	{		static unsigned char *stubstr[8] = {				"\pmot 1",				"\pmot 2",				"\pmot 3",				"\pmot 4",				"\pmot 5",				"\pmot 6",				"\pmot 7",				"\pmot 8"				};						/* Reality check */				if (i < 0) i = 0;		 else if (i >= l->nCells) i = l->nCells-1;		 		*len = *(unsigned char *)stubstr[i];		return(stubstr[i]+1);	}/* *	Build a new list in given user item box of dialog, dlog, *	with cell height, csize.  If success, delivers TRUE; if couldn't *	allocate ListMgr list (no more memory or whatever), delivers FALSE. */static int BuildList(DialogPtr dlog, int item, int csize, UserList *l)	{		short i,len,type; Rect box; Handle hndl; unsigned char *data;Str255	st0;		/* Content area (plus scroll bar) of list corresponds to user item box */		TextFont(kFontIDGeneva); TextSize(9);		GetDialogItem(dlog,item,&type,&hndl,&box);		l->bounds = box; InsetRect(&l->bounds,-1,-1);		SetDialogItem(dlog,item,userItem,NIL,&l->bounds);		l->scroll = box; l->scroll.left = l->scroll.right - 15;		/* Scrollbar width */		l->content = box; l->content.right = l->scroll.left;		SetRect(&l->dataBounds,0,0,1,0);		l->cSize.v = csize > 0 ? csize : 1;		l->cSize.h = (l->content.right - l->content.left)/3;		l->hndl = LNew(&l->content,&l->dataBounds,l->cSize,0,dlog,FALSE,FALSE,FALSE,TRUE);		if (l->hndl) {			/*(*l->hndl)->selFlags = lOnlyOne;		 Or whatever */			GetLengthList(l);			LAddRow(l->nCells,0,l->hndl);			LAddColumn(2,0,l->hndl); 							/*		for (i=0; i<l->nCells; i++) {				l->cell.h = 0; l->cell.v = i;				data = GetCellData(l,i,&len);				LSetCell((Ptr)data,len,l->cell,l->hndl);				}							for (i=0; i<l->nCells; i++) {				l->cell.h = 1; l->cell.v = i;				NumToString(i+1,&st0);				LSetCell((Ptr)&st0[1],st0[0],l->cell,l->hndl);				}							for (i=0; i<l->nCells; i++) {				l->cell.h = 2; l->cell.v = i;				NumToString(i+10,&st0);				LSetCell((Ptr)&st0[1],st0[0],l->cell,l->hndl);				}		*/								l->cell.v = 0;			LSetSelect(TRUE,l->cell,l->hndl);			EraseRect(&l->content);			InvalRect(&l->bounds);			LSetDrawingMode(TRUE,l->hndl);			}		return(l->hndl!=NIL);	}/* *	Do whatever when user double clicks (opens) on a list cell.  Delivers *	TRUE or FALSE according to whether any cell was selected or not. */static int DoOpenCell(UserList *l, unsigned char *buf, short *len)	{		int ans=0;		l->cell.h = l->cell.v = 0;		LGetSelect(TRUE,&l->cell,l->hndl);		//	LGetCell((Ptr)buf,len,l->cell,l->hndl);		l->cell.h=2;		LSetSelect(true,l->cell,l->hndl);		l->cell.h=1;		LSetSelect(true,l->cell,l->hndl);		l->cell.h=0;		LSetSelect(true,l->cell,l->hndl);						/* Got data for first selected cell: do whatever with it */			/* ... */				return(ans);	}#endif// cette routine permet de détecter tous les mots pour effectuer une liste// on détecte les espaces pour faire séparationvoid DoAnalyseTexte(SousTitreRecordPtr ST_Ptr,UserList *l){Ptr	P,P1;long	index,start,end,ligne,i,ELMT;unsigned char	c;KaraokeRecordHandle KRH;KaraokeRecordPtr	KRP;KaraokeElementPtr	KEP;// on efface toutes la fenètre	LDelRow(0,0,l->hndl);	if (ST_Ptr->st_PosOffsetTable){		 KRH=(KaraokeRecordHandle)ST_Ptr->st_PosOffsetTable;	} else {		ST_Ptr->st_PosOffsetTable=NewHandle(sizeof(KaraokeElement)*50+2);		KRH=(KaraokeRecordHandle)ST_Ptr->st_PosOffsetTable;		}	HLock((Handle)KRH);	KRP=*KRH;	(*KRP).total=0;// on scanne le texte	index=(unsigned long)ST_Ptr+sizeof(SousTitreRecord);	P=(Ptr)index;	index=start=end=0;	ligne=1;	i=0;		if (ST_Ptr->st_TexteLenth){		P1=P;		// on élimine les caractères parasites avant le début du texte		while ((*P1)<=' ')			{		 				start++;				end++;				 P1++;				 i++;			}				// boucle d'analyse du texte		if (i<ST_Ptr->st_TexteLenth) { // texte dans st ?			do{				c=*P1;	// si !=espace ou pas caractère de controle (retour chariot)	// ou pas fin de liste								if ( (c>' ') && (i<ST_Ptr->st_TexteLenth) ){ 					end++;					P1++;					i++;				} else {									(*KRP).total++;					ELMT=(*KRP).total;										(**KRH).KElement[ELMT-1].StartOffset=start;					(**KRH).KElement[ELMT-1].EndOffset=end;					(**KRH).KElement[ELMT-1].ligne=ligne;					(**KRH).KElement[ELMT-1].spare=0;					(**KRH).KElement[ELMT-1].TcIn=-1;					(**KRH).KElement[ELMT-1].TcOut=-1;					(**KRH).KElement[ELMT-1].duree=0;					(**KRH).KElement[ELMT-1].spare2=0;										l->cell.v=(*KRP).total-1;					l->cell.h=0;					LAddRow(1,(*KRP).total-1,l->hndl);					LSetCell((Ptr)P+start,end-start,l->cell,l->hndl);					l->cell.h=1;										// on recherche le prochain char !=espace					do{					 end++;					 P1++;					 i++;					}while ((*P1)==' ');					start=end;				}				if (c==13) ligne++;				}while (i<=ST_Ptr->st_TexteLenth); //for i		 }// si texte dans st		} // if (ST_Ptr->st_TexteLenth)	HUnlock((Handle)KRH);		// on sélectionne le premier		l->cell.h=0;l->cell.v=0;		LSetSelect(true,l->cell,l->hndl);		l->cell.h=1;l->cell.v=0;		LSetSelect(true,l->cell,l->hndl);		l->cell.h=2;l->cell.v=0;		LSetSelect(true,l->cell,l->hndl);	//LAddColumn(2,0,l->hndl);}// note attention on utilise  posoffset table peut etre prb en routine assmb// car si faire offset sur handle catastrophe // *---------void DoMarkInKaraoke(SousTitreRecordPtr ST_Ptr,UserList *l){long	TC=G.General_TCCourant;Str255	st0;KaraokeRecordHandle KRH;	KRH=(KaraokeRecordHandle)ST_Ptr->st_PosOffsetTable;	C_ConversionTCstASCII(TC,(Ptr)&st0);	if (KRH){			l->cell.h = l->cell.v = 0;		if (LGetSelect(TRUE,&l->cell,l->hndl)) {			l->cell.h=1;			LSetCell((Ptr)&st0[1],st0[0],l->cell,l->hndl);						(**KRH).KElement[l->cell.v].TcIn=TC;		}	} else SysBeep(1);}// *----------void DoMarkOutKaraoke(SousTitreRecordPtr ST_Ptr,UserList *l){long	TC=G.General_TCCourant;Str255	st0;KaraokeRecordHandle KRH;	KRH=(KaraokeRecordHandle)ST_Ptr->st_PosOffsetTable;	C_ConversionTCstASCII(TC,(Ptr)&st0);	if (KRH){		l->cell.h = l->cell.v = 0;		if (LGetSelect(TRUE,&l->cell,l->hndl)) {			l->cell.h=2;			LSetCell((Ptr)&st0[1],st0[0],l->cell,l->hndl);			(**KRH).KElement[l->cell.v].TcOut=TC;		}	} else SysBeep(1);}// cette routine transfère le karaoké dans la palettevoid GetKaraokeFromST(long st_num){short	i;KaraokeRecordHandle KRH;Str255	st0;Ptr		P;long	L,L1;SousTitreRecordPtr	ST_Ptr;UserListPtr		UL=&list1;		if (!gPaletteKaraoke) return;				ST_Ptr=C_ConversionNumeroSTPointeur(st_num);				// on efface toutes la fenètre		LDelRow(0,0,UL->hndl);						// on regarde s'il y a un handle karaoke		if (!ST_Ptr->st_PosOffsetTable) return;		KRH=(KaraokeRecordHandle)ST_Ptr->st_PosOffsetTable;		// on traite le karaoké				L=(unsigned long)ST_Ptr+sizeof(SousTitreRecord);		P=(Ptr)L;						for (i=0;i<(**KRH).total;i++){			UL->cell.v = i;			UL->cell.h = 0;						LAddRow(1,i,UL->hndl);						L=(**KRH).KElement[i].StartOffset;			L1=(**KRH).KElement[i].EndOffset;			LSetCell((Ptr)P+L,L1-L,UL->cell,UL->hndl);						UL->cell.h=1;			L=(**KRH).KElement[i].TcIn;			if (L !=-1){				C_ConversionTCstASCII(L,(Ptr)&st0);				LSetCell((Ptr)&st0[1],st0[0],UL->cell,UL->hndl);				}			UL->cell.h=2;			L=(**KRH).KElement[i].TcOut;			if (L !=-1){				C_ConversionTCstASCII(L,(Ptr)&st0);				LSetCell((Ptr)&st0[1],st0[0],UL->cell,UL->hndl);				}		}}//st_PosOffsetTable