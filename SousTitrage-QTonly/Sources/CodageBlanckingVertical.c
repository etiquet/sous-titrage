#include "BB.Globals_C.h"#include "E3DEMO.H"#include "appleEventHandlers.h"#include <Palettes.h>#include <QuickTimeComponents.h>#include <ImageCompression.h>extern WindowPtr 	gMonitor;extern GDHandle 	gAVDevice;Ptr	gBuffer;extern Ptr	gBufferEmissionBlancking;	// buffer pour inscripition dans blackingextern TEHandle		gAfficheStTE;// les globalsextern AppGlobals 	G;extern MyQDGlobals 	QD;Boolean gGenereSousTitreBlankInterval,gCodageBlanckingVerticalActif;void PlotThisOctects(short x,short y,unsigned char car);void GenereBlanckingVertical(void);PrepareLeBufferBlancking(SousTitreRecordPtr ST_Ptr);/* cette routine code dans le blancking vertical   un buffer sous la forme de petit points */void GenereBlanckingVertical(void){unsigned char c=0;short x,y;	Ptr	P,P1;long	i;	if (!gGenereSousTitreBlankInterval) return;	P1=gBufferEmissionBlancking;	c=0;	for (y=0;y<24;y++){		for (x=0;x<13;x++){			if (x<1) c=255;			if (x==1) c=0;			if (x>1) { 				c=*P1; 				P1++; 				}			PlotThisOctects(x,y,c);		}	}}void PlotThisOctects(short x,short y,unsigned char car){long	L;unsigned char c=car,d;long 				TC;SousTitreRecordPtr 	ST_Ptr;Ptr				P,base;PixMapHandle	PM;Rect			rect,bound;OSErr			result;long			rowb,i;GrafPtr 		oldPort;unsigned long   a,b;long*			P2;short type; Handle hndl;		GetPort(&oldPort); SetPort(gMonitor);	rect=gMonitor->portRect;	LocalToGlobal((Point*)&rect);	PM=(**gAVDevice).gdPMap;	base=(**PM).baseAddr;	rowb=(**PM).rowBytes&0x3fff;	bound=(**PM).bounds;	// on fait l'offset des coordonnées de la fenêtre	rect.top-=bound.top;	rect.left-=bound.left;		P=base;	a=rect.left+x*(6*9);	b=rect.top+y;	a=a+b*rowb;	P+=a;	// on affiche le pixels	L=0;	for(i=0;i<8;i++){		if (!( c&(1<<i)) ) {  			 *P=255; P++;			 *P=255; P++;			 *P=255; P++;			 *P=255; P++;			 *P=255; P++;			 *P=255; P++;			 } else {			 *P=0; P++;			 *P=0; P++;			 *P=0; P++;			 *P=0; P++;			 			 *P=0; P++;			 *P=0; P++;			 }	}		*P=255; P++;	*P=255; P++;	*P=0; 	P++;	*P=0; 	P++;	*P=255; P++;			 	*P=255; P++;		SetPort(oldPort);}PrepareLeBufferBlancking(SousTitreRecordPtr ST_Ptr){short x,y,i;long	L,L1,L2;Ptr		P,P1;	if (gGenereSousTitreBlankInterval && gBufferEmissionBlancking && gAfficheStTE){		//on place les time code du st courant		(*(VISTCPtr)gBufferEmissionBlancking).TcCourant=G.General_TCCourant;		(*(VISTCPtr)gBufferEmissionBlancking).TcIn=ST_Ptr->st_TimeCodeIn;		(*(VISTCPtr)gBufferEmissionBlancking).TcOut=ST_Ptr->st_TimeCodeOut;		(*(VISTCPtr)gBufferEmissionBlancking).NumST=ST_Ptr->st_AbsNUMST;		// on place justification+ masque		i=ST_Ptr->st_MasKType;		i=i<<2;		i=i|ST_Ptr->st_Justification;				(*(VISTCPtr)gBufferEmissionBlancking).Flags=i;				// on place le texte		P=(Ptr)ST_Ptr+sizeof(SousTitreRecord);		P1=(Ptr)gBufferEmissionBlancking+sizeof(VISTC); // adresse du premier octets de data				L=ST_Ptr->st_TexteLenth;		if (L>128) L=128; // on limite le texte à 128 octects				(*(VISTCPtr)gBufferEmissionBlancking).TexteLenth=L; // longueur du texte		BlockMove(P,P1,L);		P1+=L; // prochain octet libre				// on place les styles		L1=ST_Ptr->st_StyleLenth;		L2=214-L; // la place qui nous reste pour caser les styles		if (L1>L2) {			L1=0;			}		(*(VISTCPtr)gBufferEmissionBlancking).StyleLenth=L1; // longueur des styles										if (L1){ // seulement si style			BlockMove(ST_Ptr->st_StylePtr,P1,L1);			P1+=L1;			L+=L1;		}						// on raz le reste 		for (i=0;i<(214-L);i++){			*P1=0;			P1++;		}						// on calcule le checksum		P=(Ptr)&(*(VISTCPtr)gBufferEmissionBlancking).TcIn; // calcul du checksum à partir du tc in		L=0;				for (i=8;i<240;i++){			L+=*(P);			P++;		}				(*(VISTCPtr)gBufferEmissionBlancking).Checksum=L; //checksum	}}