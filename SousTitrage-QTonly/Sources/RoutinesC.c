# include <StandardFile.h># include "BB.Globals_C.h"#include <Gestalt.h># include <Folders.h>extern MyQDGlobals QD;extern AppGlobals G;OSErr	FindSysFolder(short *foundVRefNum, long *foundDirID);pascal 	short Get_TexT(Str255 *string,short font);void pdl_FrameDefault(DialogPtr dlog, int item, int frame);//#pragma segment C_code#define BTstQ(arg, bitnbr)		(arg & (1 << bitnbr))    /* FindSysFolder returns the (real) vRefNum, and the DirID of the current     system folder.  It uses the Folder Manager if present, otherwise it falls     back to SysEnvirons.  It returns zero on success, otherwise a standard     system error. */  OSErr	FindSysFolder(short *foundVRefNum, long *foundDirID)  {  	long			gesResponse;  	SysEnvRec		envRec;  	WDPBRec			myWDPB;  	unsigned char	volName[34];  	OSErr			err;  	  	  	*foundVRefNum = 0;  	*foundDirID = 0;  	if (!Gestalt (gestaltFindFolderAttr, &gesResponse) &&  		BTstQ (gesResponse, gestaltFindFolderPresent)) {	/* Does Folder Manager  exist? */  			err = FindFolder (kOnSystemDisk, kSystemFolderType, kDontCreateFolder,   				foundVRefNum, foundDirID);  	} else {  		/* Gestalt can't give us the answer, so we resort to SysEnvirons */  		if (!(err = SysEnvirons (curSysEnvVers, &envRec))) {  			myWDPB.ioVRefNum = envRec.sysVRefNum;  			volName[0] = '\000';					/* Zero volume name */  			myWDPB.ioNamePtr = volName;  			myWDPB.ioWDIndex = 0;  			myWDPB.ioWDProcID = 0;  			if (!(err = PBGetWDInfo (&myWDPB, 0))) {  				*foundVRefNum = myWDPB.ioWDVRefNum;  				*foundDirID = myWDPB.ioWDDirID;  			}  		}  	}  	return (err);} //FindSysFolderpascal void find_Bbof_File(MtcSearch *The_MtcSearch,long signature){	CInfoPBRec	spec1;	CInfoPBRec	spec2;	Ptr		buffer,buffer2;	long		size;		short		vRefNum;	long		DirId,date;	CSParam		MyPb;	OSErr		err;	Str255		string="\pBB.";				The_MtcSearch->TheHandle=NewHandle(128000);	if (The_MtcSearch->TheHandle != nil){	HLock(The_MtcSearch->TheHandle);	buffer=*The_MtcSearch->TheHandle;	size=GetHandleSize(The_MtcSearch->TheHandle);	buffer2=NewPtr(128000);		GetDateTime(&date);	err=HGetVol(nil,&vRefNum,&DirId);	// SetupFirstTime	MyPb.ioCompletion=(IOCompletionUPP)nil;	MyPb.ioNamePtr=(StringPtr)nil;	MyPb.ioMatchPtr=(FSSpecPtr)buffer;	MyPb.ioReqMatchCount=1872;	MyPb.ioVRefNum=vRefNum;		MyPb.ioSearchBits=fsSBFlFndrInfo; //+fsSBFlAttrib+fsSBPartialName; // on recherche par Bbof // Bbou	MyPb.ioSearchInfo1=(CInfoPBPtr)&spec1;	MyPb.ioSearchInfo2=(CInfoPBPtr)&spec2;	MyPb.ioSearchTime=0;	MyPb.ioCatPosition.initialize=0;	MyPb.ioOptBuffer=(Ptr)buffer2;	MyPb.ioOptBufSize=128000;			if (signature=='Bbof') spec1.hFileInfo.ioFlMdDat=date-60*24*20; // de date infŽrieur de 20 jours//	spec1.hFileInfo.ioNamePtr=&string; /*the type of the file*/	spec1.hFileInfo.ioNamePtr=nil; /*the type of the file*/	spec1.hFileInfo.ioFlAttrib=0;	spec1.hFileInfo.ioFlFndrInfo.fdType=signature; /*the type of the file*/	spec1.hFileInfo.ioFlFndrInfo.fdCreator='Bbou'; /*file's creator*/	spec1.hFileInfo.ioFlFndrInfo.fdFlags=0; 	spec1.hFileInfo.ioFlFndrInfo.fdFldr=0;	spec1.hFileInfo.ioFlFndrInfo.fdLocation.h=0;	spec1.hFileInfo.ioFlFndrInfo.fdLocation.v=0;		spec2.hFileInfo.ioNamePtr=(Ptr)nil; /*the type of the file*/	spec2.hFileInfo.ioFlAttrib=0x00;	//spec2.hFileInfo.ioFlFndrInfo.fdType='TEXT'; /*the type of the file*/	spec2.hFileInfo.ioFlFndrInfo.fdType=0xFFFFFFFF; /*the type of the file*/	spec2.hFileInfo.ioFlFndrInfo.fdCreator=0xFFFFFFFF;; /*file's creator*/	spec2.hFileInfo.ioFlFndrInfo.fdFlags=0; 	spec2.hFileInfo.ioFlFndrInfo.fdFldr=0;	spec2.hFileInfo.ioFlFndrInfo.fdLocation.h=0;	spec2.hFileInfo.ioFlFndrInfo.fdLocation.v=0;		err=PBCatSearchSync((CSParamPtr) &MyPb);		The_MtcSearch->FoundElement=MyPb.ioActMatchCount;// on dispose le pointeur 2 et on unlock le handle	DisposePtr(buffer2);	HUnlock(The_MtcSearch->TheHandle);	SetHandleSize(The_MtcSearch->TheHandle,(long) (MyPb.ioActMatchCount+1)*70);	}}pascal short C_MakeTheBbdfMenu(long signature,MenuHandle menu,Handle *Le_handle){	MtcSearch The_MtcSearch;	long		i,j,nbitem;	Ptr			adr;	Str255		string="\p-";	j=(long)CountMItems(menu);		for (i=j;i>=1;i--) DeleteMenuItem(menu,i); // on efface le menu		// la focntion de recherche	find_Bbof_File(&The_MtcSearch,signature);	*Le_handle=The_MtcSearch.TheHandle;	 HLock(The_MtcSearch.TheHandle);	 	 nbitem=The_MtcSearch.FoundElement;	 EnableItem (menu,0); 	 	 if (The_MtcSearch.FoundElement>0) {		if (signature=='Bbdf'){			InsertMenuItem(menu,"\pPlease Select ...",0);			DisableItem (menu,1); // non-utilisable			for (i=0;i<The_MtcSearch.FoundElement; i++) {				adr=*(The_MtcSearch.TheHandle);				adr=adr+i*70+6;				InsertMenuItem(menu,(Ptr) adr,i+1);				EnableItem (menu,i+2); 			}		} else { // pour les fichiers "Bbof"					for (i=0;i<The_MtcSearch.FoundElement; i++) {				adr=*(The_MtcSearch.TheHandle);				adr=adr+i*70+6;				InsertMenuItem(menu,(Ptr) adr,i+1);							}				}					} else {		// si pas recherche de police d'affichage		// si pas d'Žlement trouvŽ		// on place une texte indiquant qu'il n'y a pas de fichier trouvŽ		if (signature!='Bbdf'){			GetIndString(&string,129,7);			AppendMenu(menu,&string);			}	}					 HUnlock(The_MtcSearch.TheHandle);	 return The_MtcSearch.FoundElement;}				pascal short GiveUser_Choice(Str255 *string){short	itemHit;		ParamText((void*)string,nil,nil,nil);	itemHit = Alert(240,(ModalFilterProcPtr)nil);	return	itemHit;}			pascal	void C_FaireCopie_Fichier(name)		Str255		*name;{				HParamBlockRec		pb1;		StandardFileReply	TheReply;		OSErr				err;		short				The_Volume;		DialogPtr			TheDialogPtr;		Str255				string;		Str255				string2="\p.copie";		long				lenth,ptr;		unsigned long		time;					 	GetDateTime(&time);         				lenth=(long)*name[0];		BlockMove(name,&string,lenth+1);		if	(string[0]>26) string[0]=26;		lenth=(long)string2[0];		ptr=(long)&string+(long) string[0]+1;		BlockMove((&string2+1),(Ptr) ptr,lenth);		string[0]=string[0]+string2[0];		StandardPutFile("\pFaire une copie du document :",&string,&TheReply);		if	(TheReply.sfGood==true){			// on gŽnre le param block		pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb1.ioParam.ioNamePtr=(Ptr) &(TheReply.sfFile.name);		pb1.ioParam.ioVRefNum=(short)TheReply.sfFile.vRefNum;		pb1.ioParam.ioPermssn=fsRdWrShPerm;			pb1.ioParam.ioBuffer=(Ptr) nil;		pb1.fileParam.ioDirID=TheReply.sfFile.parID;				if	(TheReply.sfReplacing==false){			err=PBHCreate((HParmBlkPtr)&pb1,false);			//DebugStr("\p");			//TraitementErreurFichier(err);			pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;			pb1.ioParam.ioNamePtr=(Ptr) &(TheReply.sfFile.name);			pb1.ioParam.ioVRefNum=(short)TheReply.sfFile.vRefNum;			pb1.ioParam.ioPermssn=fsRdWrShPerm;				pb1.ioParam.ioBuffer=(Ptr) nil;			pb1.fileParam.ioDirID=TheReply.sfFile.parID;			pb1.fileParam.ioFlCrDat=(unsigned long) time;			pb1.fileParam.ioFlMdDat=(unsigned long) time;						pb1.fileParam.ioFlFndrInfo.fdType='Bbof';			pb1.fileParam.ioFlFndrInfo.fdCreator='Bbou';						err=PBHSetFInfo((HParmBlkPtr)&pb1,false);			//TraitementErreurFichier(err);			}					if	(TheReply.sfFile.name[0]>31) TheReply.sfFile.name[0]=31;		PBHOpen((HParmBlkPtr)&pb1,false);		WriteBonBougreFormat((ParmBlkPtr)&pb1,&(TheReply.sfFile.name),0);	// on place la date actuelle 		pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb1.ioParam.ioNamePtr=(Ptr) &(TheReply.sfFile.name);		pb1.ioParam.ioVRefNum=(short)TheReply.sfFile.vRefNum;		pb1.ioParam.ioPermssn=fsRdWrShPerm;			pb1.ioParam.ioBuffer=(Ptr) nil;		pb1.fileParam.ioDirID=TheReply.sfFile.parID;				pb1.fileParam.ioFlMdDat=(unsigned long) time;		pb1.fileParam.ioFlFndrInfo.fdType='Bbof';		pb1.fileParam.ioFlFndrInfo.fdCreator='Bbou';				err=PBHSetFInfo((HParmBlkPtr)&pb1,false);				//TraitementErreurFichier(err);		TheDialogPtr=GetNewDialog(140,nil,(WindowPtr)-1);		DrawDialog(TheDialogPtr);				PBFlushFile((ParmBlkPtr)&pb1,false);						err=GetVRefNum(pb1.ioParam.ioVRefNum,&The_Volume);		err=FlushVol(nil,The_Volume);				//TraitementErreurFichier(err);		WaitTicks(60);		DisposeDialog(TheDialogPtr);		PBClose((ParmBlkPtr)&pb1,false);		err=FlushVol(nil,The_Volume);} //reply=good}	pascal 	short Get_TexT(Str255 *string,short font){	DialogPtr				Dialog;	DialogPeek				dialog;		short					TheitemHit;	Rect					Rectangle;	short					the_itemType,the_font=font;	Handle					the_Handle;	TEHandle				te_h;	DialogPtr				SavePort;	// on ouvre le dialog	GetPort(&SavePort);	Dialog=GetNewDialog(190,0,(WindowPtr) -1);	dialog=(DialogPeek)Dialog;	DrawDialog(Dialog);	SetPort(Dialog);	te_h=dialog->textH;	if	(font==0x4312){	GetDialogItem(Dialog,5,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,true);		GetDialogItem(Dialog,6,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,false);		} else {		GetDialogItem(Dialog,5,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,false);		GetDialogItem(Dialog,6,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,true);		}	(**te_h).txFont=the_font;// Boucle principale	do	{	ModalDialog((ModalFilterProcPtr) &Special_C_ModalDialogFilter,&TheitemHit); 	switch (TheitemHit){	case	3:			(**te_h).txFont=the_font;		GetDialogItem(Dialog,3,&the_itemType,&the_Handle,&Rectangle);		TEUpdate( &Rectangle,(TEHandle)te_h);	break;	case	1: //ok dialog		GetDialogItem(Dialog,2,&the_itemType,&the_Handle,&Rectangle);		GetDialogItemText(the_Handle,*string);		DisposeDialog(Dialog);		SetPort(SavePort);		return	the_font;		break;			case	4:	// fin texte		DisposeDialog(Dialog);		SetPort(SavePort);		return	0x0000;		break;	case	5:	case	6:		GetDialogItem(Dialog,5,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,false);		GetDialogItem(Dialog,6,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,false);		GetDialogItem(Dialog,TheitemHit,&the_itemType,&the_Handle,&Rectangle);		SetControlValue((ControlHandle) the_Handle,true);			GetDialogItem(Dialog,5,&the_itemType,&the_Handle,&Rectangle);		if ( GetControlValue((ControlHandle) the_Handle)==true) {		the_font=0x4312;		} else {		the_font=0x7101;		}		(**te_h).txFont=the_font;		GetDialogItem(Dialog,3,&the_itemType,&the_Handle,&Rectangle);		TEUpdate( &Rectangle,(TEHandle)te_h);	break;	 } 	} while(true);}	pascal Boolean Special_C_ModalDialogFilter(theDialog ,event,itemhit)	DialogPtr	theDialog;	EventRecord	*event;	short		*itemhit;{	OSErr		result;	short		the_itemType,part,dh,dv, value;	Handle		the_Handle;	Rect		Rectangle;	WindowPtr	window;	Point		The_point;	unsigned char		key;	ControlHandle	control;		result=false;			switch (event->what ) {		case mouseDown:			part = FindWindow(event->where, &window);						switch ( part ) {			case inContent:// dans le control ?					The_point=event->where;			GlobalToLocal(&The_point);			part = FindControl(The_point, window, &control);			value = GetControlValue(control);			SystemClick	(event,window);  //let the system handle it			break;//						case inDrag:                /* pass screenBits.bounds to get all gDevices */					if	(window==(WindowPtr)BB_FrontNonFloatingWindow()) {					GivescreenBits(&Rectangle);	//QD.screenbit bounds					DragWindow(window, event->where,&Rectangle); //&QD.screenbit bounds); //					result=true;					}					break;			}							break;		case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;			if ( (event->modifiers & optionKey)&&(key<32)) {	/* option key down */				if ( (event->modifiers & (shiftKey))) {	/* shift key down */// on bouge la fentre par 20							switch	(key){					case 30:						dv=-20;						dh=0;					break;					case 31:						dv=20;						dh=0;					break;					case 28:						dv=0;						dh=-20;					break;					case 29:						dv=0;						dh=20;					break;					}				} else {// on bouge la fentre par 1								switch	(key){					case 30:						dv=-1;						dh=0;					break;					case 31:						dv=1;						dh=0;					break;					case 28:						dv=0;						dh=-1;					break;					case 29:						dv=0;						dh=1;					break;						}				}// on dŽplace la fentre				window=(WindowPtr)BB_FrontNonFloatingWindow();			SetPort(window);			The_point.v=window->portRect.top+dv;			The_point.h=window->portRect.left+dh; 			LocalToGlobal(&The_point);			MoveWindow(window,The_point.h,The_point.v,false);				result=true;				}	else {			switch(key) {			case 3:			case 13:			GetDialogItem((DialogPtr)BB_FrontNonFloatingWindow(),1,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=1;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);								}				break;							case 27:	// on vŽrifie que c'est un  bouton 				GetDialogItem((DialogPtr)BB_FrontNonFloatingWindow(),2,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=2;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);				}				break;						} //switch			} //else			break;														case activateEvt:			break;				case updateEvt:		if (event->message!=(long)theDialog)	DoUpdate((WindowPtr)event->message);				// do the Bbou update		else {					*itemhit=-1;				result=true;				}		break;					}	//	switch		return (result);}		void pdl_FrameDefault(DialogPtr dlog, int item, int frame)	{		short type; Handle hndl; Rect box;		GrafPtr oldPort; PenState oldPen;		RGBColor	black,white,oldcolor;								black.red=0;		black.green=0;		black.blue=0;		white.red=-1;		white.green=-1;		white.blue=-1;				GetPort(&oldPort); 		SetPort(dlog);		GetForeColor(&oldcolor);		GetPenState(&oldPen);				GetDialogItem(dlog,item,&type,&hndl,&box);		InsetRect(&box,-4,-4);				PenSize(3,3);		if (frame) RGBForeColor(&black);		/* Paint frame */		 else      RGBForeColor(&white);		/* Erase frame */		FrameRoundRect(&box,16,16);		SetPenState(&oldPen);		RGBForeColor(&oldcolor);		SetPort(oldPort);	}