#include "BB.Globals_C.h"#include "E3DEMO.H"#include "appleEventHandlers.h"#include <Palettes.h>#include <QuickTimeComponents.h>#include <ImageCompression.h>#include  "MyCopyBits.h"#include "PPCDispatch.h"short	gAnimColor,gAnimColorSens;void DoKaraoke(SousTitreRecordPtr ST_Ptr,long TC);static void GiveStartEndPosition (short start, short end,short line,									Rect *rect,SousTitreRecordPtr ST_Ptr);void GiveKaraokeInfo (KaraokeRecordHandle KRH,					 SousTitreRecordPtr ST_Ptr,					 long tc, long *in, long *out,					 long *start, long *end, long *ELine,  long *SLine );pascal long TestSiDansST(SousTitreRecordPtr ST_Ptr:__A0,unsigned long TC:__D0):__D0;pascal void TRANSFERTTEXTE_MEMOIRE_STYLETE_SPECIAL (TEHandle	te,SousTitreRecordPtr  ST_Ptr,Rect* rect,short newsize);void C_ClearVx (void);short ValidST(SousTitreRecordPtr ST_Ptr);		 // les globalsextern AppGlobals 	G;extern MyQDGlobals 	QD;extern WindowPtr 	gMonitor,gPaletteKaraoke,gDialogProchainSousTitre;extern Boolean 		gFullSize;extern Boolean 		gHalfSize;extern Boolean 		gQuarterSize;extern GWorldPtr 	gAvOffscreen;extern GDHandle 	gAVDevice;extern long			IndexKeyColor,myBlackForAV,gVitesseVTR;extern Boolean		gDone,gRefreshInfoW,gMaxSpeed,doTrackingInListing,doTrackingOutListing,doTrackingInSaisie,doTrackingOutSaisie;extern Boolean			gMaskingSousTitre;extern Boolean			gForcerPolice;extern Boolean			gModeKaraoke;extern Boolean			gForcerBold;extern RGBColor			gSimuColor,gKaraokeColor;extern short			gTextSize,gSimuFont,gSimuFontItem,gAntiAlias;extern GWorldPtr		gMonitorOffscreen,gMonitorOffscreenFinal;Rect 						gLastRect,gSourceRect;extern PicHandle			gMonitorPICT;extern SeqGrabComponent 	gSeqGrabber;TEHandle					gAfficheStTE;SousTitreRecordPtr			gTempSousTitre;void RedessineSTenCours_BroadCast(void);extern RGBColor			gKeyColor;long	gEtatAffichage;pascal void TransfertOffscreen_Vram(void);void IndiqueSauvegardeEnCours(Boolean flag); // débutvoid MyDrawText(Str255 string, Rect box);pascal void C_ClrEcran(void);void IndiqueEtatEnCours(short atat);void DoFollowTCForDisplay(void);void UpdateProchainSousTitre(Boolean partiel);void C_TransfertOffscreen_Vram(Rect* rect);short CC_Draw_SousTitre(SousTitreRecordPtr Str,short X,short Y,Ptr ScreenBase,long RowBytes,Rect *rect);long C_TestSiDansST_RUNTIME(SousTitreRecordPtr ST_Ptr,unsigned long TC, unsigned long TCOutOffset);pascal void C_ClrOffscreen(void);void DessineAVST_eng(SousTitreRecordPtr ST_Ptr,Boolean inOffscreen);long C_TestSiDansST_RUNTIME(SousTitreRecordPtr ST_Ptr,unsigned long TC, unsigned long TCOutOffset){SousTitreRecordPtr ST_Ptr1;unsigned long tempTC, out;// note: cette routine effectue des taches d'anticipations// ne pas l'utiliser pour un mode non runtime// elle anticipe de 1 images ou non suivant vitesse		// TCIN TC out valide ? 		if (ST_Ptr->st_TimeCodeIn==-1 && ST_Ptr->st_TimeCodeOut==-1) return -1;				// on anticipe le tc in si magnetoscope en  play		tempTC=ST_Ptr->st_TimeCodeIn;		if (gVitesseVTR>4)					tempTC=C_SoustractionTimeCode(tempTC,1);			out=C_SoustractionTimeCode(ST_Ptr->st_TimeCodeOut,TCOutOffset);		// pour le cas ou tc in vide et tc out pas vide									if (ST_Ptr->st_TimeCodeIn==-1 && ST_Ptr->st_TimeCodeOut!=-1) {			if (TC>ST_Ptr->st_TimeCodeOut) return 100;			ST_Ptr1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;			if (!ST_Ptr1) return 0;			out=C_SoustractionTimeCode(ST_Ptr1->st_TimeCodeOut,TCOutOffset);			if (TC>out) return 0;		}				// pour le cas ou tc out vide et tc in pas vide							if (ST_Ptr->st_TimeCodeIn!=-1 && ST_Ptr->st_TimeCodeOut==-1) {			if (TC<tempTC) return -100;			ST_Ptr1=(SousTitreRecordPtr)ST_Ptr->st_NextST;			if (!ST_Ptr1) return 0;			if (TC<ST_Ptr1->st_TimeCodeIn) return 0;		}		// cas normal tc et tc out pas vide (!=-1) 		out=C_SoustractionTimeCode(ST_Ptr->st_TimeCodeOut,TCOutOffset);		if (TC>=tempTC && TC<out) return 0;		if (TC<tempTC) return -100;		return 100;}void InitialiseAffichageSimulation(void){		gAfficheStTE=nil;		gKaraokeColor.red=0;		gKaraokeColor.green=-1;		gKaraokeColor.blue=0;}void Affichage_SousTitreSimulation(void){long 				TC,a;SousTitreRecordPtr 	ST_Ptr;Ptr				P,P1,P2,P3,base;PixMapHandle	PM;Rect			rect;OSErr			result;long			rowb,i,j;// a réfléchir#ifndef __Demo__	#ifndef __NoProtect__		if (G.FindFirstKey_error) return;	#endif	#endifCanDisplayST:		TC=G.General_TCCourant;		ST_Ptr=C_ConversionTimeCodePointeur(TC);		G.General_SousTitreCourantPtr=ST_Ptr;		if (ST_Ptr==nil) return;		G.General_SousTitrecourant=ST_Ptr->st_AbsNUMST;		a=TestSiDansST(ST_Ptr,TC);	//	if (a==-1) return;	// on est en dessous// on regarde si nous sommes dans le sous-titre		if( !((WindowPeek)gMonitor)->visible) return;				if (a){	// nous ne sommes pas dans un sous-titre			if(G.DrawState&0x0f){								// on efface le sous-titre en cours				EffaceFenetreSimulation();								doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingOutListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingOutSaisie=true;												G.DrawState=0;				if (gModeKaraoke)DessineAVST((SousTitreRecordPtr)ST_Ptr,true); // pour karaoke						// on vérifie le prochain sous-titre				if (gAntiAlias!=0){						 if (G.Sous_titreInOffscreen!=ST_Ptr){						 	DessineAVST((SousTitreRecordPtr)ST_Ptr,true);								G.Sous_titreInOffscreen=ST_Ptr;							// on update la fenêtre prochain sous-titre							if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);								}					 } else G.Sous_titreInOffscreen=ST_Ptr; 					 			} else {						// c'est déjà effacé			// on vérifie que nous sommes prêt pour le prochain sous-titre							if (!gModeKaraoke){					 if (gAntiAlias!=0)						 if (G.Sous_titreInOffscreen!=ST_Ptr){						 	DessineAVST((SousTitreRecordPtr)ST_Ptr,true);								G.Sous_titreInOffscreen=ST_Ptr;							// on update la fenêtre prochain sous-titre							if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);						 } 				} 				G.DrawState=0;	 				return; // rien à faire			}		}					if (!gModeKaraoke){ // pour dire mode karaoké ou non		if (!a){	// nous sommes dans un sous-titre					if(G.DrawState&0x0f){ // il a déjà été affiché				if (G.Sous_titre_dessined!=ST_Ptr){					DessineAVST((SousTitreRecordPtr)ST_Ptr,true);					transfertAVOffscreenInScreen();					G.Sous_titreInOffscreen=ST_Ptr;					G.Sous_titre_dessined=ST_Ptr;										// on update la fenêtre prochain sous-titre					if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);						}									return; // rien à faire				}							if (gAntiAlias!=0) {						if (G.Sous_titreInOffscreen==ST_Ptr) {							transfertAVOffscreenInScreen();						} else {							DessineAVST((SousTitreRecordPtr)ST_Ptr,true);							G.Sous_titreInOffscreen=ST_Ptr;							transfertAVOffscreenInScreen();						}				} else {					DessineAVST((SousTitreRecordPtr)ST_Ptr,false);					G.Sous_titre_dessined=ST_Ptr;				}												G.DrawState=1;				G.General_SousTitreDisplayed=G.General_SousTitrecourant;								doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingInListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingInSaisie=true;								if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);														if (gAntiAlias!=0) {					G.Sous_titre_dessined=ST_Ptr;						G.Sous_titreInOffscreen=(SousTitreRecordPtr)ST_Ptr->st_NextST;						if (ST_Ptr->st_NextST) {						DessineAVST((SousTitreRecordPtr)ST_Ptr->st_NextST,true);						}					}//gMaskingSousTitre 		}	} else {	 	// mode KARAOKE		if (!a){	// nous sommes dans un sous-titre			if(!G.DrawState&0x0f){					transfertAVOffscreenInScreen();				G.DrawState=1;				G.General_SousTitreDisplayed=G.General_SousTitrecourant;								doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingInListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingInSaisie=true;								G.Sous_titre_dessined=ST_Ptr;					G.Sous_titreInOffscreen=(SousTitreRecordPtr)ST_Ptr->st_NextST;				} else  DoKaraoke(ST_Ptr,TC);		}			} // karaoké}//		Affichage_soustitreSimulationvoid DoFollowTCForDisplay(void){long 				TC,a;SousTitreRecordPtr 	ST_Ptr;Ptr				P,P1,P2,P3,base;PixMapHandle	PM;Rect			rect;OSErr			result;long			rowb,i,j;CanDisplayST:		TC=G.General_TCCourant;		ST_Ptr=C_ConversionTimeCodePointeur(TC);		G.General_SousTitreCourantPtr=ST_Ptr;		if (ST_Ptr==nil) return;		G.General_SousTitrecourant=ST_Ptr->st_AbsNUMST;		a=TestSiDansST(ST_Ptr,TC);// on regarde si nous sommes dans le sous-titre				if (a){	// nous ne sommes pas dans un sous-titre			if(G.DrawState&0x0f){									doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingOutListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingOutSaisie=true;												G.DrawState=0;			} else {				G.DrawState=0;	 				return; // rien à faire			}		}						if (!a){	// nous sommes dans un sous-titre					if(G.DrawState&0x0f) return; 								doTrackingOutListing=false;				G.DrawState=1;				G.General_SousTitreDisplayed=G.General_SousTitrecourant;												doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingInListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingInSaisie=true;												if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);		}	}//	DoFollowTCForDisplayvoid IndiqueSauvegardeEnCours(Boolean flag){GrafPtr		oldport;RGBColor	color;Rect		box;Str255		st0;	/*if (flag) {		if(G.Base_Adresse){						GetPort(&oldport);				SetPort ((WindowPtr)&G.DisplayWindow);				MoveTo(12,100);								color.red=-1;				color.green=12000;				color.blue=12000;								RGBForeColor(&color);				TextSize(24);				TextFont(kFontIDGeneva);								GetIndString(&st0,129,51);				MoveTo(20,50);				SetRect(&box,10,10,768,250);				EraseRect(&box);				DrawString(&st0);												SetPort(oldport);		}		if(gMonitor){						GetPort(&oldport);				SetPort ((WindowPtr)gMonitor);								color.red=-1;				color.green=12000;				color.blue=12000;								RGBForeColor(&color);				TextSize(24);				TextFont(kFontIDGeneva);								GetIndString(&st0,129,51);				MoveTo(20,50);				SetRect(&box,10,10,768,250);				EraseRect(&box);				DrawString(&st0);									SetPort(oldport);		}	}*/	}void RedessineSTenCours_BroadCast(void){	if (G.Base_Adresse){			if (G.Sous_titre_dessined){ 	 		C_ClearVx(); // on efface le buffer d'affichage			CC_Draw_SousTitre(G.Sous_titre_dessined,G.X_Offset,G.Y_Offset, 							G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect); // on redessine le sous-titre directement dans le buffer		}// screen				if (G.Sous_titreInOffscreen){			G.OffscreenRenderedRect.left-=20;			G.OffscreenRenderedRect.right+=23;			G.OffscreenRenderedRect.top-=20;			G.OffscreenRenderedRect.bottom+=20;						C_ClrOffscreen();			 			 						CC_Draw_SousTitre(G.Sous_titreInOffscreen,G.X_Offset,G.Y_Offset,							G.OffscreenDisplayBase,G.Row_Bytes,&G.OffscreenRenderedRect);					} // offscreen	}}void IndiqueEtatEnCours(short atat){GrafPtr		oldport;RGBColor	color;Rect		box;Str255		st0;return;		if(G.Base_Adresse){						GetPort(&oldport);				SetPort ((WindowPtr)&G.DisplayWindow);				MoveTo(12,100);								color.red=-1;				color.green=-1;				color.blue=-1;								RGBForeColor(&color);				TextSize(24);				TextFont(kFontIDGeneva);								NumToString(atat,&st0);								MoveTo(20,50);				TextMode(srcCopy);				DrawString(&st0);												SetPort(oldport);		}	}void Affichage_SousTitreBroadcast(void){long 				TC,a;SousTitreRecordPtr 	ST_Ptr,ST1;Ptr				P,P1,P2,P3,base;PixMapHandle	PM;Rect			rect;OSErr			result;long			rowb,i,j,TCOutOffset;RGBColor		color;GrafPtr			oldport;Str255			st0;Rect			box;WindowPtr		w=(WindowPtr)&G.DisplayWindow;// a réfléchir/*#ifndef __Demo__	#ifndef __NoProtect__		if (G.SoftProtect==1) goto CanDisplayST;		if (G.FindFirstKey_error) return;	#endif	#endifCanDisplayST:*/			GetPort(&oldport);						SetPort(w);				TC=G.General_TCCourant;		gTempSousTitre=C_ConversionTimeCodePointeur(TC);		// protection de la routine		/*if (gTempSousTitre){			if (ValidST(gTempSousTitre)) SysBreak();		}*/		G.General_SousTitrecourant=gTempSousTitre->st_AbsNUMST;		G.General_SousTitreCourantPtr=gTempSousTitre;				if (gTempSousTitre){			TCOutOffset=G.FadeTime/2;			if (!G.EffectMode) TCOutOffset=0;			gEtatAffichage=C_TestSiDansST_RUNTIME(gTempSousTitre,TC,TCOutOffset);			//if (gEtatAffichage==100) Debugger();		}				if (gTempSousTitre==nil) {							return;		}// sortons-nous d'1 sous-titre ?				if (gEtatAffichage){	// nous ne sommes pas dans un sous-titre			if(G.DrawState&0x0f){				// on sort d'un sous-titre, on efface le sous-titre en cours				G.DrawState=0x8000;				do{}while(G.DrawState&0x8000); //si il y a un fondu				// on attend la routine en intéruption								doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingOutListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingOutSaisie=true;								C_ClearVx(); // on efface le buffer d'affichage			// on vérifie si le sous-titre présent dans le buffer offscreen est correct		if ( gEtatAffichage==100) //si on pointe sur le st courant il faut passer au suivant.				gTempSousTitre=(SousTitreRecordPtr)gTempSousTitre->st_NextST;					if (G.Sous_titreInOffscreen==gTempSousTitre){ 					//c'est correcte, on transfère simplement le offscreen dans la carte d'affichage					C_TransfertOffscreen_Vram(&G.OffscreenRenderedRect);					G.Sous_titre_dessined=G.Sous_titreInOffscreen;					G.ScreenRenderedRect=G.OffscreenRenderedRect;											if (gTempSousTitre){						G.General_SousTitrecourant=gTempSousTitre->st_AbsNUMST;						TCOutOffset=G.FadeTime/2;						if (!G.EffectMode) TCOutOffset=0;						gEtatAffichage=C_TestSiDansST_RUNTIME(gTempSousTitre,TC,TCOutOffset);					}		 					} else {					// non pas correcte, il faut le dessiner directement dans le buffer						G.Sous_titre_dessined=gTempSousTitre;						G.Sous_titreInOffscreen=nil;											 CC_Draw_SousTitre(gTempSousTitre,G.X_Offset,G.Y_Offset,									G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect);												// on update la fenêtre prochain sous-titre						if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);										if (gTempSousTitre){							G.General_SousTitrecourant=gTempSousTitre->st_AbsNUMST;							TCOutOffset=G.FadeTime/2;							if (!G.EffectMode) TCOutOffset=0;							gEtatAffichage=C_TestSiDansST_RUNTIME(gTempSousTitre,TC,TCOutOffset);							}												}			} else { /// on est dans un moment où il n'y a pas de sous-titre						// c'est déjà effacé			// on vérifie que nous sommes prêt pour le prochain sous-titre															//IndiqueEtatEnCours(3);					if (G.Sous_titre_dessined != gTempSousTitre){ // non ce n'est pas le cas, on redessine le tc dans le screen 	 					C_ClearVx(); // on efface le buffer d'affichage							 					G.Sous_titreInOffscreen=nil;						G.Sous_titre_dessined=gTempSousTitre;						CC_Draw_SousTitre(gTempSousTitre,G.X_Offset,G.Y_Offset, 							G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect); // on redessine le sous-titre directement dans le buffer						// on update la fenêtre prochain sous-titre						if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);						 } 				}		}		// entrons-nous dans un sous-titre ?	if (gEtatAffichage==0){	// nous sommes dans un sous-titre					// cas où nous avons déjà affiché le sous-titre		// on regarde seulement si le st en cours correspond à celui qui devrait être affiché			if (G.Sous_titre_dessined!=gTempSousTitre){ // non ce n'est pas le cas, on redessine le tc dans la carte							//G.DrawState=0x8000;			G.Sous_titre_dessined=gTempSousTitre;			C_ClearVx(); // on efface le buffer d'affichage			if (gTempSousTitre) CC_Draw_SousTitre(gTempSousTitre,G.X_Offset,G.Y_Offset, 						G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect); // on redessine le sous-titre directement dans le buffer			G.DrawState=0x8001;		}				if(G.DrawState&0x0f) return; // si déja affiché on ne fait pas la suite de la routine			G.DrawState=0x8001; // on active l'affichage de la vram		// on action les tracking de listing					// on gère le tracking de listing								doTrackingInListing=false;				doTrackingOutListing=false;				if(G.Preference_Tracking&1) doTrackingInListing=true;								doTrackingOutSaisie=false;				doTrackingInSaisie=false;				if(G.Preference_Tracking&2) doTrackingInSaisie=true;						G.General_SousTitreDisplayed=G.General_SousTitrecourant;				// on update la fenêtre prochain sous-titre		if(((WindowPeek)gDialogProchainSousTitre)->visible) UpdateProchainSousTitre(true);							// on calcule le prochain sous-titre dans le buffer offscreen			G.Sous_titreInOffscreen=(SousTitreRecordPtr)gTempSousTitre->st_NextST;			if (G.Sous_titreInOffscreen) {		// on agrandi de 20 pixels le rectangle 		// pour être sur de tout effacer autour					G.OffscreenRenderedRect.left-=20;			G.OffscreenRenderedRect.right+=23;			G.OffscreenRenderedRect.top-=20;			G.OffscreenRenderedRect.bottom+=20;						C_ClrOffscreen();			 			 						CC_Draw_SousTitre(G.Sous_titreInOffscreen,G.X_Offset,G.Y_Offset,							G.OffscreenDisplayBase,G.Row_Bytes,&G.OffscreenRenderedRect);						}		do{}while(G.DrawState&0x8000); //si il y a un fondu	}		GetPort(&oldport);		}//		Affichage_SousTitreBroadcastvoid EffaceFenetreSimulation(void){Rect	rect;GrafPtr	oldport;// on efface la fenêtre simulation					GetPort(&oldport);			SetPort(gMonitor);	// ON EFFACE D'ABORDS La zone du SOUS-TITRE	// pour ètre le plus précis possible temporellement				rect=gMonitor->portRect;						rect.top=gLastRect.top;			DoRectTransparent(&rect);		// et en suite on efface le reste pour éviter les sous-titres partiellement effacés			rect.bottom=rect.top;			rect.top=gMonitor->portRect.top;			if (gFullSize) rect.top+=25;			if (gHalfSize)  rect.top+=9;			if (gQuarterSize) rect.top+=5;				DoRectTransparent(&rect);						SetPort(oldport);			} //EffaceFenetreSimulationvoid DessineAVST_eng(SousTitreRecordPtr ST_Ptr,Boolean inOffscreen){ long				TC;CGrafPtr			oldport;Rect				rect,rect1;Str255				st0;short				w,LetterSize=gTextSize,YstartPos=518,whatToDo,taille=3;	GDHandle			gdh;RGBColor			color,blanc,noir,oldB;TextStyle			newStyle;short				Mystyl=0;unsigned long		a;	GDHandle			curdev;/* on filtre le stPtr */		taille=gAntiAlias+1;			// on vérifie que l'on a les buffers offscreen (sinon on ne fait pas offscreen)				if ( (gMonitorOffscreen==nil) || (gMonitorOffscreenFinal==nil) ) inOffscreen=false;/* on taille en fonction de la taille de la fenêtre d'incrustation*/		if (gFullSize){					LetterSize=LetterSize;				YstartPos=YstartPos;				}			if (gHalfSize)  	{					LetterSize=LetterSize/2;				YstartPos=YstartPos/2;				}		if (gQuarterSize)  	{					LetterSize=LetterSize/4;				YstartPos=YstartPos/4;				/*if (!inOffscreen || !gAntiAlias) Mystyl=condense;*/				}		whatToDo=0;		if (LetterSize<9) LetterSize=9;			color.red=-1; color.green=-1; color.blue=32768;		blanc.red=-1; blanc.green=-1; blanc.blue=-1;		noir.red=0; noir.green=0; noir.blue=0;		SetRect(&rect1,0,0,0,0);// on dessine le contenu du sous-titre		GetGWorld(&oldport,&gdh);		SetPort(gMonitor);		rect=gMonitor->portRect;				rect.bottom=YstartPos;						// si offscreen on place le offscreen buffer		if (inOffscreen){			if (LockPixels(GetGWorldPixMap(gMonitorOffscreen)) )				SetGWorld(gMonitorOffscreen,nil);							else 	{inOffscreen=false; }			}					RGBForeColor(&gSimuColor);		BackColor(blackColor);	// on regarde le nombre de ligne					TextMode(srcOr);				if (gAntiAlias){ 				rect1.left=0;				rect1.top=0;				a=(rect.right-rect.left)*taille;				rect1.right=a;				a=(rect.bottom-rect.top)*taille;				rect1.bottom=a;				if ( !gQuarterSize ) {					w=rect1.right-rect1.left;					rect1.left=(w*5)/100;					a=rect1.right;					a=(a*95)/100;						rect1.right=a;										w=rect.right-rect.left;					rect.left=(w*5)/100;					a=rect.right;					a=(a*95)/100;						rect.right=a;									}				newStyle.tsSize=LetterSize*taille;	// taille double			} else {				if ( gFullSize ){ // si plein écran					w=rect.right-rect.left;					rect.left=(w*5)/100;					a=rect.right;						a=(a*95)/100;						a=a;					rect.right=a;								}							rect1=rect;				newStyle.tsSize=LetterSize;			}										if (!inOffscreen ) {			rect1=rect;			OffsetRect(&rect1,4000,4000);	// pour ne pas avoir de dessin dans la fenêtre			newStyle.tsSize=LetterSize;		}		TextSize(LetterSize);		// si mode pas anti-aliasé		// on regarde s'il faut masquer le sous-titre				if (gAntiAlias==0){		 if (!gMaskingSousTitre ){			RGBBackColor(&gKeyColor);			} else BackColor(blackColor);		} else BackColor(blackColor);		// on vérifie que l'on a bien un te		if (! gAfficheStTE) gAfficheStTE=TEStyleNew(&rect1,&rect1);		// on efface l'ancien contenu du te		TESetSelect(0,32767,gAfficheStTE);		TEDelete(gAfficheStTE);		(**gAfficheStTE).crOnly=true;		(**gAfficheStTE).destRect=rect1;		(**gAfficheStTE).viewRect=rect1;		(**gAfficheStTE).txMode=srcOr/*srcCopy*/;	// on place des fausses coordonnées pour le gAfficheStTE// note on n'utilise pas la fonction TRANSFERTTEXTE_MEMOIRE_STYLETE// car on est sur du pointeur qui nous a été passé ...		TRANSFERTTEXTE_MEMOIRE_STYLETE_SPECIAL(gAfficheStTE,ST_Ptr,&rect1,-1);		a=C_get_STJustification(ST_Ptr);		TESetAlignment(a,gAfficheStTE);		// on sélectionne tous le texte et on place la taille désirée		TESetSelect(0,32767,gAfficheStTE);		newStyle.tsColor=gSimuColor;		newStyle.tsFace=Mystyl;		newStyle.tsFont=gSimuFont;		(**gAfficheStTE).txMode=srcOr/*srcCopy*/;		TextMode(srcOr);		PenMode(srcOr);		whatToDo=doSize+doColor+doFace+doToggle;				if (gForcerBold) 					newStyle.tsFace=newStyle.tsFace+bold;		if (gForcerPolice) {					whatToDo=whatToDo|doFont;					}							TESetStyle(whatToDo,&newStyle,false,gAfficheStTE);		TECalText(gAfficheStTE);		w=TEGetHeight(0,32767,gAfficheStTE); // on mesure la hauteur totale du texte 				// maintenant on update en fct du mode demandé		if (!inOffscreen) {			(**gAfficheStTE).inPort=(GrafPtr)gMonitor;			rect.top=rect.bottom-w;			(**gAfficheStTE).destRect=rect;			(**gAfficheStTE).viewRect=rect;			TEUpdate(&rect,gAfficheStTE);		} else {			(**gAfficheStTE).inPort=(GrafPtr)gMonitorOffscreen;			if (gAntiAlias) rect.top=rect.bottom-(w/taille);				else		rect.top=rect.bottom-w;			rect1.bottom=rect1.top+w;			gSourceRect=rect1;			TEUpdate(&rect1,gAfficheStTE);			}// on recopie en anti-aliasant le texte		if (inOffscreen) {			SetGWorld(gMonitorOffscreenFinal,nil);			BackColor(blackColor); /*IndexKeyColor*/			ForeColor(whiteColor);			LockPixels(GetGWorldPixMap(gMonitorOffscreenFinal));			CopyBits(&((GrafPtr)gMonitorOffscreen)->portBits,				&((GrafPtr)gMonitorOffscreenFinal)->portBits,				&rect1,&rect,srcCopy+ditherCopy,nil);			//UnlockPixels(GetGWorldPixMap(gMonitorOffscreenFinal));			//UnlockPixels(GetGWorldPixMap(gMonitorOffscreen));		}		gLastRect=rect;		SetGWorld(oldport,gdh);} // DessineAVSTvoid transfertAVOffscreenInScreen(void){Rect		rect;GrafPtr		oldport;RGBColor	color;			GetPort(&oldport);						SetPort(gMonitor);			rect=gMonitor->portRect;						if (gMaskingSousTitre){				BackColor(blackColor);			 } else {				RGBBackColor(&gKeyColor);			}						ForeColor(whiteColor);			if (LockPixels(GetGWorldPixMap(gMonitorOffscreenFinal)) ) {			CopyBits(&((GrafPtr)gMonitorOffscreenFinal)->portBits,				&((GrafPtr)gMonitor)->portBits,				&gLastRect,&gLastRect,srcCopy,nil);				}						G.Sous_titre_dessined=G.Sous_titreInOffscreen; 	//cache du st dans la ram			//UnlockPixels(GetGWorldPixMap(gMonitorOffscreenFinal));			SetPort(oldport);}// cette routine effectue le Karaokévoid DoKaraoke(SousTitreRecordPtr ST_Ptr,long TC){KaraokeRecordHandle KRH;long		in,out,tc,a,x,X,Y,vi,w,longtext,start,end,xTc,			largeur,SLine,ELine,line,Kin,Kout,Kline,Kstart,Kend,dur,curligne;RGBColor	fcolor,bcolor,color;Rect		rect,selRect,selRect1,TheRect;GrafPtr		oldport;Handle		th;Point		startP,endP;		GetPort(&oldport);		if (!gPaletteKaraoke) return;		if (!gAfficheStTE)  return;		if (ST_Ptr->st_TexteLenth==nil) return;				SetPort(gMonitor);		KRH=(KaraokeRecordHandle)ST_Ptr->st_PosOffsetTable;						/*on détermine le n° de l'élément Karaoké*/		GiveKaraokeInfo (KRH,ST_Ptr,TC,&in,&out,&start,&end,&ELine,&SLine);		if (in==-1 || out==-1) return;				/* quelques conversions */		tc=C_ConversionTimeCodeTrames(TC);		in=C_ConversionTimeCodeTrames(in);		out=C_ConversionTimeCodeTrames(out);/* on récupère le rectangle de la zone	 et on regarde si c'est à cheval sur plusieurs lignes*/	 		if (SLine==ELine){ // non sur la même			GiveStartEndPosition (start,end,SLine,&selRect,ST_Ptr);			xTc=tc-in;			largeur=selRect.right-selRect.left;			a=(largeur*xTc)/(out-in)+selRect.left;			rect=selRect;			rect.right=a;					} else { // oui a cheval			a=(gLastRect.bottom-gLastRect.top)/ST_Ptr->st_Nlines; // hauteur d'une ligne			GiveStartEndPosition (start,end,SLine,&selRect,ST_Ptr);			GiveStartEndPosition (start,end,ELine,&selRect1,ST_Ptr);						in=ST_Ptr->st_TimeCodeIn;			out=ST_Ptr->st_TimeCodeOut;						//on détérmine sur quelle ligne on est 			xTc=tc-in;			dur=out-in;			//Y=ELine-SLine;			curligne=(ST_Ptr->st_Nlines*xTc)/dur+1; // la ligne courante			/*			// on calcule les coordonnées en fonction de la ligne courante			if (curligne==SLine){	// 1er ligne ?				rect=selRect;				rect.right=gLastRect.right;				rect.bottom=rect.top+a;				} else 	{				if (curligne==ELine) { // dernière ligne ?					rect=selRect1;					rect.left=gLastRect.left;					rect.top=rect.bottom-a;					} else { // ni première ni dernière						rect=selRect1;						rect.left=gLastRect.left;		// on prend coordonnées gauche et droite								rect.right=gLastRect.right;						rect.top=gLastRect.top+a*(curligne-1);						rect.bottom=rect.top+a;				}			}	// pas première ligne			*/						rect.left=gLastRect.left;		// on prend coordonnées gauche et droite					rect.right=gLastRect.right;			rect.top=gLastRect.top+a*(curligne-1);			rect.bottom=rect.top+a;						largeur=rect.right-rect.left;			a=(largeur*xTc)/(dur)+rect.left;			rect.right=a;		}/* on prépare les couleurs*/		GetForeColor(&fcolor); GetBackColor(&bcolor);				RGBForeColor(&gKaraokeColor);				color.red=0; color.green=0; color.blue=0;		RGBBackColor(&color);					PenMode(srcXor);			MoveTo(rect.right-1,rect.bottom);		Line(1,0);		PenMode(srcCopy);				//FrameRect(&rect);// on effectue le volet			if (LockPixels(GetGWorldPixMap(gMonitorOffscreenFinal)) ) {		CopyBits(&((GrafPtr)gMonitorOffscreenFinal)->portBits,			&((GrafPtr)gMonitor)->portBits,			&rect,&rect,srcCopy,nil);		}					RGBForeColor(&fcolor);		RGBBackColor(&bcolor);			SetPort(oldport);}// Cette routine donne les infos du karaoké correspondant au tc en coursvoid GiveKaraokeInfo (KaraokeRecordHandle KRH,					 SousTitreRecordPtr ST_Ptr,					 long tc,					 long *in,					 long *out,					 long *start,					 long *end,					 long *ELine,					 long *SLine ){KaraokeElementPtr	KEP;long i,Kin,Kout,foundIndex;Boolean	found,outfound;		if (KRH){			HLock((Handle)KRH);					// on détermine la position start						/* on place les coordonnées par défaut pour le sous-titre*/			*start=0;			*end=(**gAfficheStTE).teLength;			*SLine=1;			*ELine=ST_Ptr->st_Nlines;			*in=ST_Ptr->st_TimeCodeIn;			*out=ST_Ptr->st_TimeCodeOut;						i=0;			found=false;			outfound=false;			foundIndex=0;						do{				KEP=&(**KRH).KElement[i];				Kin=KEP->TcIn;				Kout=KEP->TcOut;								if (Kin!=-1)					if (tc>=Kin) {						*in=Kin;						*start=KEP->StartOffset;						*SLine=KEP->ligne;						foundIndex=i;												if (Kout!=-1)							if (tc<=Kout) {							*out=Kout;							*end=KEP->EndOffset;							*ELine=KEP->ligne;							outfound=true;						}												} else found=true;				i++;			} while (!found && i<(**KRH).total);				/* on détermine la position end 			On prend le premier tc trouvé dans la liste,			à partir de l'index déja défini */						i=foundIndex+1;			found=false;			if ( (foundIndex<(**KRH).total) && (!outfound) )				do{					KEP=&(**KRH).KElement[i];					Kin=KEP->TcIn;					Kout=KEP->TcOut;						if (Kin!=-1){							*out=KEP->TcIn;							*end=KEP->StartOffset;							*ELine=KEP->ligne;							found=true;						}																	if ( (Kout!=-1) && (!found) ){							*out=KEP->TcOut;							*end=KEP->EndOffset;							*ELine=KEP->ligne;							found=true;						}					i++;									} while (!found && i<(**KRH).total );																		/*KEP->StartOffset=;					KEP->EndOffset=end;					KEP->ligne=ligne;					KEP->spare=0;					KEP->TcIn=-1;					KEP->TcOut=-1;					KEP->duree=0;					KEP->spare2=0;*/			HUnlock((Handle)KRH);				} /*if KRH)*/				else {					/* si pas de Karaoké Handle,			on place les coordonnées entières du sous-titres*/				*start=0;				*end=(**gAfficheStTE).teLength;				*SLine=1;				*ELine=ST_Ptr->st_Nlines;				*in=ST_Ptr->st_TimeCodeIn;				*out=ST_Ptr->st_TimeCodeOut;		}} // GiveKaraokeInfo/* cette routine détermine 	les coordonées du rectangle par rapport aux coordonées start et end 	pour effectuer le karaoké */	static void GiveStartEndPosition (short start, short end,short line,									Rect *rect,SousTitreRecordPtr ST_Ptr){Point	startP,endP,result;long	a;						if ((**gAfficheStTE).teLength){				startP=TEGetPoint(start,gAfficheStTE);				endP=TEGetPoint(end,gAfficheStTE);			}						rect->left=startP.h;			rect->top=startP.v;			rect->right=endP.h;			rect->bottom=endP.v;			a=(gLastRect.bottom-gLastRect.top)/ST_Ptr->st_Nlines;			rect->top=gLastRect.top+(line-1)*a;			rect->bottom=gLastRect.top+(line)*a;			rect->left=(rect->left)/(gAntiAlias+1);			rect->right=(rect->right)/(gAntiAlias+1)+1;	}									void C_TransfertOffscreen_Vram(Rect* rect){short flag;		SetCCursor(G.CurseurTransfert);		if (!G.Sous_titreInOffscreen)  return;		if (!G.OffscreenDisplayBase)  return;		if (!G.Base_Adresse)  return;		//test àla dure		flag=0;					if (rect->bottom<=rect->top) flag=1;		if (rect->right<=rect->left) flag=1;		if (rect->left<0) flag=1;		if (rect->top<0) flag=1;		if (rect->right>768) flag=1;		if (rect->bottom>576) flag=1;		if (flag){ // y un pb ?			SysBeep(1);		}	else  PPCDispatch_MyCopyBits (G.OffscreenDisplayBase,G.Base_Adresse,G.Row_Bytes, rect);		SetCursor(&QD.arrow);}						void C_ClearVx (void){		Clear_Buffer(); // note cette fonction est en asm							// si la carte est une nu-vista							// elle appelle la fonction ci-dessous}			pascal void C_ClrEcran(void){			short	flag=0;			if (G.ScreenRenderedRect.left<0){				 G.ScreenRenderedRect.left=0;				 flag=1;				 }			if (G.ScreenRenderedRect.right >768 ){				 G.ScreenRenderedRect.right=768; 				 flag=1;				 }			if (G.ScreenRenderedRect.top < 0 ){				 G.ScreenRenderedRect.top=0; 				 flag=1;				 }			if (G.ScreenRenderedRect.bottom>576){				 G.ScreenRenderedRect.bottom=576; 				 flag=1;				}		if (flag){			 SysBeep(1);		}			C_paintRect(&G.ScreenRenderedRect,0x0,G.Base_Adresse,G.Row_Bytes);}pascal void C_ClrOffscreen(void){			short	flag=0;			if (G.OffscreenRenderedRect.left<0){				 G.OffscreenRenderedRect.left=0;				 flag=1;				 }			if (G.OffscreenRenderedRect.right >768 ){				 G.OffscreenRenderedRect.right=768; 				 flag=1;				 }			if (G.OffscreenRenderedRect.top < 0 ){				 G.OffscreenRenderedRect.top=0; 				 flag=1;				 }			if (G.OffscreenRenderedRect.bottom>576){				 G.OffscreenRenderedRect.bottom=576; 				 flag=1;				}		if (flag){			// SysBeep(1);		}			C_paintRect(&G.OffscreenRenderedRect,0x0,G.OffscreenDisplayBase,G.Row_Bytes);}