#include "BB.Globals_C.h"#include "E3DEMO.H"#include "appleEventHandlers.h"#include <Palettes.h>#include <QuickTimeComponents.h>#include <ImageCompression.h>#include <stdlib.h>// les globalsextern AppGlobals 	G;extern MyQDGlobals 	QD;extern WindowPtr 	gMonitor;extern Boolean 		gFullSize;extern Boolean 		gHalfSize;extern Boolean 		gQuarterSize;extern GWorldPtr 	gAvOffscreen;extern GDHandle 	gAVDevice;extern long			IndexKeyColor,myBlackForAV;extern Boolean		gDone,gRefreshInfoW,doTrackingInListing,doTrackingOutListing,doTrackingInSaisie,doTrackingOutSaisie;extern Boolean				gMaskingSousTitre;extern Boolean				gForcerPolice;extern Boolean				gForcerBold;extern RGBColor			gSimuColor,gKaraokeColor;extern short				gTextSize,gSimuFont,gSimuFontItem,gAntiAlias;extern GWorldPtr			gMonitorOffscreen,gMonitorOffscreenFinal;extern PicHandle			gMonitorPICT;extern SeqGrabComponent 	gSeqGrabber;DialogPtr			gBlankingVerticalWindow;unsigned long		gVitcLuParAV;Boolean 			gMaxSpeed;short	gcomp,gcomp1,gcomp2,gdelaybit,gValeurFiltrage;Ptr WaitEndNextSyncBit(Ptr P);Ptr WaitEndNextSyncBit16bits(Ptr P);long FiltreTimeCode(long tc,long tcdefault);void LitVITCAVIdle1024(void);void LitVITCAVIdle832(void);void RecopieVerticalIntervalIdle(void){long 				TC;SousTitreRecordPtr 	ST_Ptr;Ptr				P,P1,P2,P3,base;PixMapHandle	PM;Rect			rect,bound,box;OSErr			result;long			rowb,i,j;GrafPtr 		oldPort;unsigned long   a,b;Point			mouse;Str255			st0;short type; Handle hndl;				GetPort(&oldPort); SetPort(gBlankingVerticalWindow);		rect=gBlankingVerticalWindow->portRect;		LocalToGlobal((Point*)&rect);		TextMode(srcCopy);		GetMouse(&mouse);				GetDialogItem(gBlankingVerticalWindow,7,&type,&hndl,&box);		NumToString(mouse.h,&st0);		EraseRect(&box);		MoveTo(box.left,box.top+9);		DrawString(&st0);				GetDialogItem(gBlankingVerticalWindow,8,&type,&hndl,&box);		NumToString(mouse.v,&st0);		EraseRect(&box);		MoveTo(box.left,box.top+9);		DrawString(&st0);				GetDialogItem(gBlankingVerticalWindow,5,&type,&hndl,&box);		C_ConversionTCstASCII(gVitcLuParAV,&st0);		EraseRect(&box);		MoveTo(box.left,box.top+9);		DrawString(&st0);							PM=(**gAVDevice).gdPMap;		base=(**PM).baseAddr;		rowb=(**PM).rowBytes&0x3fff;		bound=(**PM).bounds;				if (rowb==768) i=0xe0200800+768*8;		if (rowb==832) i=0xe0200800+768*8;		if (rowb==1152) i=0xe0200000+1024*4;		P=(Ptr)i;		// on fait l'offset des coordonnées de la fenêtre		rect.top-=bound.top;		rect.left-=bound.left;				P2=base;		a=rect.left;		b=rect.top;		a=a+b*rowb;		P2+=a;		switch(rowb) {			case 768:			case 832:				for (j=0;j<17;j++){					P3=P2;					P1=P;					for (i=0;i<768;i++){						*P3=255-(*P1);						P1+=2;						P3++;						}				P+=768*2;				P2+=rowb;			}			break;						case 1152:				for (j=0;j<17;j++){					P3=P2;					P1=P;					BlockMove(P1,P3,768);					P+=1024;					P2+=rowb;				}			break;		} // row byte								SetPort(oldPort);}void DoUpdateVerticalIntervalWindow(void){		GrafPtr oldPort;		short type; Handle hndl; Rect box,rect;		PixPatHandle the_pixpat;		RgnHandle	rgn,rgn1;		RGBColor	oldcolor;		GetPort(&oldPort); SetPort(gBlankingVerticalWindow);		TextFont(kFontIDGeneva);		TextSize(9);		ForeColor(whiteColor);		BackColor(blackColor);		EraseRect(&gBlankingVerticalWindow->portRect);		GetDialogItem(gBlankingVerticalWindow,6,&type,&hndl,&rect);		FrameRect(&rect);		Draw_Icon_Text_Ditl(gBlankingVerticalWindow);		DrawControls(gBlankingVerticalWindow);		PenNormal();		SetPort(oldPort);	}void LitVITCAVIdle(void){PixMapHandle	PM;long			rowb;					PM=(**gAVDevice).gdPMap;	rowb=(**PM).rowBytes&0x3fff;	if (rowb==1152) LitVITCAVIdle1024();	if (rowb==832) LitVITCAVIdle832();}void LitVITCAVIdle1024(void){unsigned long i,j,x,y,TC,a,rowb,b;Point		startVitc;Ptr			P,P1,P2,P3,base;GrafPtr 	oldPort;short 		type,itemHit;Handle		hndl;Rect 		box,bound,rect;Str255		st0;RGBColor	oldcolor;Boolean		found=false;unsigned char c;unsigned char d[32];PixMapHandle	PM;EventRecord	event;		GetPort(&oldPort);		SetPort(gBlankingVerticalWindow);// l'adresse de la zone mémoire de l'image		i=0xe0200000+1024*11;		P=(Ptr)i;		// on recherche la première ligne de VITC	y=10;	do{		x=0;		P1=P;		do{								c=*(P1);				if (c<100) { 									startVitc.v=y;									startVitc.h=x;									found=true;									P2=P1;							   }		P1++;				x++;		}while(x<30 &&(!found)); 		y++;		P+=1024;	} while (!found && (y<20));	if (!found) { SetPort(oldPort); return; }		// on a le début du vitc			GetDialogItem(gBlankingVerticalWindow,3,&type,&hndl,&box);	NumToString(startVitc.h,&st0);	EraseRect(&box);	MoveTo(box.left,box.top+9);	DrawString(&st0);		NumToString(startVitc.v,&st0);	MoveTo(box.left+40,box.top+9);	DrawString(&st0);						// si fenêtre blanking ouverte on affiche nos petit points			if ( ((WindowPeek)gBlankingVerticalWindow)->visible ){			rect=gBlankingVerticalWindow->portRect;		LocalToGlobal((Point*)&rect);		PM=(**gAVDevice).gdPMap;		base=(**PM).baseAddr;		rowb=(**PM).rowBytes&0x3fff;		bound=(**PM).bounds;				// on fait l'offset des coordonnées de la fenêtre		rect.top-=bound.top;		rect.left-=bound.left;		P=base;		a=rect.left;		b=rect.top+(startVitc.v-1);		a=a+b*rowb+4+startVitc.h;		P+=a;					for (i=0;i<80;i++){			*(P)=128;		P+=8;			if( ((i/10)*10) ==i) P+=2;		}	}		// on mesure le time code	distance en 2 synchros => 81 pixels// 10 points entre 2 synchro => 1 point=8 pixels (environ)		P2=P2+4;	//le centre du point		P2=WaitEndNextSyncBit(P2);	P2+=12;	//	les images	d[0]=*(P2);		P2+=8;	d[1]=*(P2);		P2+=8;	d[2]=*(P2);		P2+=8;	d[3]=*(P2);		P2+=8;	P2+=32;				P2=WaitEndNextSyncBit(P2);	P2+=12;			//	les dizaine images	d[4]=*(P2);		P2+=8;	d[5]=*(P2);		P2+=8;	d[6]=255;	d[7]=255;	P2+=48;					P2=WaitEndNextSyncBit(P2);	P2+=12;	//	les secondes	d[8]=*(P2);		P2+=8;	d[9]=*(P2);		P2+=8;	d[10]=*(P2);	P2+=8;	d[11]=*(P2);	P2+=8;	P2+=32;				P2=WaitEndNextSyncBit(P2);	P2+=12;		*(P2+4096)=0; *(P2+4097)=0;//	les dizaine secondes	d[12]=*(P2);	P2+=8;	d[13]=*(P2);	P2+=8;	d[14]=*(P2);	P2+=8;	d[15]=255;		P2+=40;				P2=WaitEndNextSyncBit(P2);	P2+=12;	//	les minutes	d[16]=*(P2);	P2+=8;	d[17]=*(P2);	P2+=8;	d[18]=*(P2);	P2+=8;	d[19]=*(P2);	P2+=8;	P2+=32;				P2=WaitEndNextSyncBit(P2);	P2+=12;	//	les dizaine minutes	d[20]=*(P2);	P2+=8;	d[21]=*(P2);	P2+=8;	d[22]=*(P2);	P2+=8;	d[23]=255;		P2+=40;						P2=WaitEndNextSyncBit(P2);	P2+=12;	//	les heures	d[24]=*(P2);	P2+=8;	d[25]=*(P2);	P2+=8;	d[26]=*(P2);	P2+=8;	d[27]=*(P2);	P2+=8;	P2+=32;				P2=WaitEndNextSyncBit(P2);	P2+=12;			//	les dizaine heures	d[28]=*(P2);	P2+=8;	d[29]=*(P2);	P2+=8;	d[30]=255;		d[31]=255;		TC=0;	for (i=0;i<32;i++){		TC=TC<<1;			if (d[31-i]<120 ) a=1; else a=0;		TC=TC|a;	}	gVitcLuParAV=TC;		/* simode lecture VITC par carte av */	if (G.LecteurTimeCode_Type==3){		G.General_LastTCCourant=G.General_TCCourant;		G.General_TCCourant=FiltreTimeCode(gVitcLuParAV,G.General_TCCourant);		}		// si click souris && max speed on revient à normal speed			if (gMaxSpeed)   {			if (Button()){				gMaxSpeed=0;				GetDialogItem(gBlankingVerticalWindow,9,&type,&hndl,&rect);				SetControlValue((ControlHandle)hndl,false);				do{}while(Button());			}		}	SetPort(oldPort);} // LitVITCAVIdle1024void LitVITCAVIdle832(void){unsigned long i,j,x,y,TC,a,rowb,b;Point		startVitc;Ptr			P,P1,P2,P3,base;GrafPtr 	oldPort;short 		type,itemHit;Handle		hndl;Rect 		box,bound,rect;Str255		st0;RGBColor	oldcolor;Boolean		found=false;unsigned char c;unsigned short d[32];PixMapHandle	PM;EventRecord	event;		GetPort(&oldPort);		SetPort(gBlankingVerticalWindow);		//gcomp=50,gcomp1=50,gcomp2=50;// l'adresse de la zone mémoire de l'image		i=0xe0200800+768*22;		P=(Ptr)i;		// on recherche la première ligne de VITC	y=7;	do{		x=0;		P1=P;		do{								c=*(P1)+*(P1+2);				if (c>gcomp) { 									startVitc.v=y;									startVitc.h=x;									found=true;									P2=P1;							   }		P1+=2;	// 16 bits			x++;		}while(x<30 &&(!found)); 		y++;		P+=768*2;	} while (!found && (y<20));	if (!found) { SetPort(oldPort); gVitcLuParAV=-1;  return; }	// on a le début du vitc			GetDialogItem(gBlankingVerticalWindow,3,&type,&hndl,&box);	NumToString(startVitc.h,&st0);	EraseRect(&box);	MoveTo(box.left,box.top+9);	DrawString(&st0);		NumToString(startVitc.v,&st0);	MoveTo(box.left+40,box.top+9);	DrawString(&st0);				// si fenêtre blanking ouverte on affiche nos petit points			if ( ((WindowPeek)gBlankingVerticalWindow)->visible ){		rect=gBlankingVerticalWindow->portRect;		LocalToGlobal((Point*)&rect);		PM=(**gAVDevice).gdPMap;		base=(**PM).baseAddr;		rowb=(**PM).rowBytes&0x3fff;		bound=(**PM).bounds;				// on fait l'offset des coordonnées de la fenêtre		rect.top-=bound.top;		rect.left-=bound.left;		P=base;		a=rect.left;		b=rect.top+(startVitc.v-1);		a=a+b*rowb+8+startVitc.h;		P+=a;				}				// on mesure le time code	distance en 2 synchros => 81 pixels// 10 points entre 2 synchro => 1 point=8 pixels (environ)		P2=P2+8;	//le centre du point	 	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les images	d[0]=*(P2)+*(P2+2)+*(P2+4); P2+=16;	d[1]=*(P2)+*(P2+2)+*(P2+4); P2+=16;	d[2]=*(P2)+*(P2+2)+*(P2+4); P2+=16;	d[3]=*(P2)+*(P2+2)+*(P2+4); P2+=16;	P2+=64;			*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les dizaine images	d[4]=*(P2)+*(P2+2)+*(P2+4); P2+=16;	d[5]=*(P2)+*(P2+2)+*(P2+4); P2+=16;	d[6]=0;	d[7]=0;	P2+=96;					*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;//	les secondes	d[8]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[9]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[10]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[11]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	P2+=64;				*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les dizaine secondes	d[12]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[13]=*(P2)+*(P2+2)+*(P2+4);	P2+=16;	d[14]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[15]=0;		P2+=80;				*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les minutes	d[16]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[17]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[18]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[19]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	P2+=64;				*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les dizaine minutes	d[20]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[21]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[22]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[23]=0;		P2+=80;						*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les heures	d[24]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[25]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[26]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[27]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	P2+=64;				*(P2+768*4)=129;	*(P2+768*4+2)=129;	P2=WaitEndNextSyncBit16bits(P2);	P2+=gdelaybit;		*(P2+768*4)=129;	*(P2+768*4+2)=129;	//	les dizaine heures	d[28]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[29]=*(P2)+*(P2+2)+*(P2+4);		P2+=16;	d[30]=0;		d[31]=0;		if ( ((WindowPeek)gBlankingVerticalWindow)->visible )  RecopieVerticalIntervalIdle();	TC=0;	for (i=0;i<32;i++){		TC=TC<<1;			if (d[31-i]>gcomp1 ) a=1; else a=0;		TC=TC|a;	}	gVitcLuParAV=TC;			/* simode lecture VITC par carte av */	if (G.LecteurTimeCode_Type==3){		G.General_LastTCCourant=G.General_TCCourant;		G.General_TCCourant=FiltreTimeCode(gVitcLuParAV,G.General_TCCourant);	}		// si click souris && max speed on revient à normal speed			if (gMaxSpeed)   {			if (Button()){				gMaxSpeed=0;				GetDialogItem(gBlankingVerticalWindow,9,&type,&hndl,&rect);				SetControlValue((ControlHandle)hndl,false);				do{}while(Button());			}		}	SetPort(oldPort);} // mode832Ptr WaitEndNextSyncBit16bits(Ptr P){short	Count=0;		unsigned short c;	do{		P+=2;		c=*(P)+*(P+2)+*(P+4);		*(P+768*4)=129;	}while (Count<40 && c>gcomp2);	return P;}Ptr WaitEndNextSyncBit(Ptr P){short	Count=0;		unsigned char c;		do{		P++;		c=*(P);	}while (Count<20 && c<80);	return P;}