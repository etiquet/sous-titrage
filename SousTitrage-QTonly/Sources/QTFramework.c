// application header files//#include "QTFramework.h"#include <extras.h>#include <stdio.h>#include "CQuicktime.h"#include "ISp_Sample.h"#include "IPsCR.h"extern ModalFilterUPP		gModalFilterUPP;	extern Boolean				gHasNewDialogCalls;					// are the new Dialog Manager functions available?extern Boolean				gHasNewDialogCalls;					// are the new Dialog Manager functions available?long 						m_key_joy_flag;extern Input_GameState 		igs;extern  short				initsprocket;long 						button;long 						glastdirection;extern short				gAppResFileNumber;extern long				get_flag;void SimulClickInTelecommande(short itemNum);pascal void AlertUser(short error);static  char *evnt_string[]={" nullEvent",      //             = 0,"mouseDown",    //            = 1,"mouseUp",         //           = 2,"keyDown",        //            = 3,"keyUp",           //             = 4,"autoKey",         //            = 5,"updateEvt",       //           = 6,"diskEvt",            //          = 7,"activateEvt"     //           = 8,};MovieControllerQT_SetupMovieWindowWithController (Movie theMovie, WindowReference theWindow, Boolean theMoveWindow,CQuicktimeClass* m_WindowQTObject){	MovieController			myMC;	Rect						myRect;	Rect						LimitRect = {10, 10, 576,768};	// max size for any window	GrafPtr					mySavedPort;	short					myMovieWidth;	short					myMovieHeight;	long 						l1,l2,l3;	GetPort(&mySavedPort);	MacSetPort((GrafPtr)theWindow);		// resize the movie bounding rect and offset to 0,0	GetMovieBox(theMovie, &myRect);	MacOffsetRect(&myRect, -myRect.left, -myRect.top);		// resize the movie	if (m_WindowQTObject->m_fullscreen){				l1=(QT_GetWindowWidth(theWindow)*82)/100; // 83 de la taille Žcran		//limitation au double taille movie		/*if (l1 >(myRect.right*2))					l1=(myRect.right*2);*/							l3=(l1*100)/myRect.right; // coef d'agrandissement		l1=(myRect.right*l3/100);		l2=(myRect.bottom*l3)/100;				myRect.left= (QT_GetWindowWidth(theWindow)-l1)/2;		myRect.top=5;		myRect.right=myRect.left+l1;		myRect.bottom=myRect.top+l2;			} 			SetMovieBox(theMovie, &myRect); // nouvelle coordonnŽes		//if (m_WindowQTObject->m_fullscreen)	AlignWindow((WindowPtr)theWindow, false, &myRect, NULL);	// create the movie controller	myMC = NewMovieController(theMovie, &myRect, kMCFlags);	if (myMC == NULL)		return(NULL);			QT_ShowControler(m_WindowQTObject,(m_WindowQTObject->m_fullscreen==false));		// enable the default movie controller editing	MCEnableEditing(myMC, true);			// suppress movie badge	MCDoAction(myMC, mcActionSetUseBadge, (void *)false);	//suppress key use	MCDoAction(myMC, mcActionSetKeysEnabled, (void *)(m_WindowQTObject->m_fullscreen==false));	MCGetControllerBoundsRect(myMC, &myRect);		// add grow box for the movie controller	MCDoAction(myMC, mcActionSetGrowBoxBounds, &LimitRect);		// set the initial looping state of the movie; this is a nice touch	//QTUtils_SetLoopingStateFromFile(theMovie, myMC);		// on empche le looping	MCDoAction(myMC, mcActionSetLooping, (void *)false);	MCDoAction(myMC, mcActionSetLoopIsPalindrome, (void *)false);			// install an action filter that does any application-specific mc action processing	MCSetActionFilterWithRefCon(myMC, NewMCActionFilterWithRefConProc(QT_ApplicationMCActionFilterProc), (long)m_WindowQTObject);												// see if the bounding rects are sane	myMovieWidth = myRect.right - myRect.left;	myMovieHeight = myRect.bottom - myRect.top;		if (!m_WindowQTObject->m_fullscreen) // seulement si pas full screen		SizeWindow(theWindow, myMovieWidth, myMovieHeight, true);	if (theMoveWindow)		MoveWindow(theWindow, kDefaultX, kDefaultY, false);			MacSetPort(mySavedPort);	// add any application-specific controller functionality	QT_AddControllerFunctionality(myMC);	QTUtils_EnableSoundlevel(theMovie, true);	get_flag=true;	return(myMC);}////////////// DoCreateMovieWindow// Open a movie in a new movie window; returns true if successful.//// This function is called from several places in our framework. The following combinations are possible://	* theMovie == NULL, theFSSpec == NULL: no movie, no file; elicit a movie file from user and open it//	* theMovie != NULL, theFSSpec == NULL: new movie, no file (yet)//	* theMovie == NULL, theFSSpec != NULL: no movie, but we have an FSSpec; so just open the specified movie file//	* theMovie != NULL, theFSSpec != NULL: new movie, theFSSpec contains (at least) the movie name////////////Boolean QT_DoCreateMovieWindow (CQuicktimeClass*	m_WindowQTObject, Movie theMovie, FSSpec *theFSSpec){	MovieController		myMC = NULL;	WindowReference		myWindow = NULL;	FSSpec				myFSSpec;	Movie				myMovie = NULL;	short				myRefNum = kInvalidFileRefNum;	short				myResID = movieInDataForkResID;	SFTypeList			myTypeList = {kQTFileTypeMovie, 0, 0, 0};	StandardFileReply		myReply;	GrafPtr				mySavedPort;	OSErr				myErr = noErr;	Rect					LimitRect = {10, 10, 576,768};	// max size for any window	short				readonly=0;		// get the current port; we may need to restore it if we cannot successfully create a new window	GetPort(&mySavedPort);		if (m_WindowQTObject == NULL) 	goto bail; // pas valide ? 		// if we got neither a movie nor an FSSpec passed in, prompt the user for a movie file	if ((theMovie == NULL) && (theFSSpec == NULL)) {		StandardGetFilePreview(NULL, 1, myTypeList, &myReply);		if (!myReply.sfGood) goto bail;		FSMakeFSSpec(myReply.sfFile.vRefNum, myReply.sfFile.parID, myReply.sfFile.name, &myFSSpec);		// make an FSSpec record	}	// if we got an FSSpec passed in, copy it into myFSSpec	if (theFSSpec != NULL) 		FSMakeFSSpec(theFSSpec->vRefNum, theFSSpec->parID, theFSSpec->name, &myFSSpec);	// make an FSSpec record		// if we got no movie passed in, read one from the specified file	if (theMovie == NULL) {		// ideally, we'd like read and write permission, but we'll settle for read-only permission		myErr = OpenMovieFile(&myFSSpec, &myRefNum, fsRdWrPerm);				if (myErr != noErr) { // // ce fichier est peux-tre read only,  			AlertUser(33);  //il faut avertir l'utilisateur qu'il faut crŽer un clone (dummy movie)			QT_MakeCloneOfMovieFile (&myFSSpec,&myFSSpec);			myErr = OpenMovieFile(&myFSSpec, &myRefNum, fsRdWrPerm);			if (myErr != noErr)	 goto bail; // dŽfinitivement une erreur			readonly=1;		}				// now fetch the first movie from the file		myResID = movieInDataForkResID;		myErr = NewMovieFromFile(&myMovie, myRefNum, &myResID, NULL, newMovieActive, NULL);		if (myErr != noErr)	goto bail;				// NON NON NON !!!! : we will allow the user to edit our files, so we keep the movie file open		// CloseMovieFile(myRefNum);				} else { //if (theMovie == NULL) 			myMovie = theMovie;		}	//////////	//	// at this point, myMovie is an open movie, but myFSSpec may or may not be a valid FSSpec	//	//////////		// set the default progress procedure for the movie	SetMovieProgressProc(myMovie, (MovieProgressUPP)-1, 0);	// on gre la fentre	myWindow = m_WindowQTObject->m_windows;	//SetWRefCon(myWindow, (long)m_WindowQTObject);	MacSetPort(QT_GetPortFromWindowReference(myWindow));	// set the window title	//SetWTitle(myWindow, myFSSpec.name);	// make sure the movie uses the window GWorld in all situations	SetMovieGWorld(myMovie, (CGrafPtr)QT_GetPortFromWindowReference(myWindow), GetGWorldDevice((CGrafPtr)QT_GetPortFromWindowReference(myWindow)));	// create and configure the movie controller	myMC = QT_SetupMovieWindowWithController(myMovie, myWindow,(m_WindowQTObject->m_fullscreen==false),m_WindowQTObject);			// store movie info in the window record	m_WindowQTObject->m_theMovie = myMovie;	m_WindowQTObject->m_theMC = myMC;	m_WindowQTObject->m_FileResID = myResID;	m_WindowQTObject->m_FileRefNum = myRefNum;	m_WindowQTObject->m_Dirty = false;	m_WindowQTObject->m_Instance = NULL;	m_WindowQTObject->m_FileFSSpec = myFSSpec;		// size the window to fit the movie and controller	QT_SizeWindowToMovie(m_WindowQTObject,m_WindowQTObject->m_fullscreen);		// Loop = non	MCDoAction (myMC, mcActionSetLooping,(void*)(0));  	// set the movie's play hints to allow dynamic resizing	SetMoviePlayHints(myMovie, hintsAllowDynamicResize, hintsAllowDynamicResize);	// show the window	ShowWindow(myWindow);		if (!m_WindowQTObject->m_fullscreen)			SelectReferencedWindow(myWindow);	// make it front-most, since it's just been created	InvalRect(&((GrafPtr)myWindow)->portRect);		// on force un rafraichissement de la fentre		// if the movie is a streamed movie, then start it playing immediately	/*if (QTUtils_IsStreamedMovie(myMovie))		MCDoAction(myMC, mcActionPrerollAndPlay, (void *)GetMoviePreferredRate(myMovie));	*/		// on replace l'offset du film	QT_GetTimeCodeTrackOffset2FrameCount();	return(true);// ok fini		bail: // gestion d'erreurs ?	if (myWindow != NULL)		DisposeWindow(myWindow);			if (myMC != NULL)		DisposeMovieController(myMC);			if (myMovie != NULL)		DisposeMovie(myMovie);			if (myRefNum != 0)		CloseMovieFile(myRefNum);	MacSetPort(mySavedPort);	// restore the port that was active when this function was called	return(false);}////////////// DoDestroyMovieWindow// Close the specified movie window.////////////void  QT_DoDestroyMovieWindow (WindowReference theWindow){	Movie 				myMovie = NULL;	MovieController		myMC = NULL;	CQuicktimeClass*		m_WindowQTObject = NULL;		// get the window object associated with the specified window	m_WindowQTObject = QT_GetWindowObjectFromWindow(theWindow);		if (!m_WindowQTObject) return ;		// note le code suivant propose l'option de sauvegarder les modifications du fichier en cours.	// je ne suis pas certain que ce code doit tre gardŽ tel quel.	// if the window's data is "dirty", give the user a chance to save it;	// this is modeled on Inside Macintosh: Macintosh Toolbox Essentials, pp. 4-62f.		if (m_WindowQTObject->m_Dirty) {		Str255			myString;		short			myItem;		short 			mySavedResFile;				// get the current resource file and set the application's resource file		mySavedResFile = CurResFile();		//!!!!!!! UseResFile(gAppResFile);		// get the title of the window		GetWTitle(theWindow, myString);				// insert the application's name and the window title into the dialog box text		ParamText("\p---", myString, NULL, NULL);			  		myItem = CautionAlert(kSaveDialogQTID, gModalFilterUPP);				UseResFile(mySavedResFile);					// restore the original resource file				switch (myItem) {			case kSaveChanges:				// save the data in the window				QT_DoUpdateMovieFile(theWindow);				break;							case kDontSaveChanges:				// discard any unsaved changes (that is, don't do anything)				break;						}	}		QT_DoUpdateMovieFile(theWindow); // on enregistre  la fentre actuelle		// remove our mcAction filter function	MCSetActionFilterWithRefCon(m_WindowQTObject->m_theMC, NULL, NULL);	// close the movie file	if (m_WindowQTObject->m_FileRefNum != kInvalidFileRefNum) {		CloseMovieFile(m_WindowQTObject->m_FileRefNum);		m_WindowQTObject->m_FileRefNum = kInvalidFileRefNum;	}		// order is important here; according to Inside Macintosh: QuickTime, p. 2-96:	// "Do not dispose of a movie if it has any special clients--for example,	// if it has an attached movie controller component.	// Only dispose of the movie after any clients are done with it."		if (m_WindowQTObject->m_theMC != NULL)		DisposeMovieController(m_WindowQTObject->m_theMC);		 	m_WindowQTObject->m_theMC=nil;	if ( m_WindowQTObject->m_theMovie != NULL)		DisposeMovie( m_WindowQTObject->m_theMovie);			m_WindowQTObject->m_theMovie=nil;	m_WindowQTObject->m_movieOpened=false;// les appels ci-dessous ont ŽtŽ dŽscativŽ car c'est le destrcuteur de la pseudo class qui effectue le netoyage.	// do any application-specific window clean-up	//	QT_RemoveApplicationWindowObject(m_WindowQTObject);	//	DisposeHandle((Handle)m_WindowQTObject);}////////////// DoSaveAsMovieFile// Save the movie in the specified window under a new name.//// Human interface guidelines for "Save As..." dictate that, if the user selects a new file name// for the current movie, then that new file shall become the active one. This means that we need// to close the current movie file and open the new one.////////////OSErrQT_DoSaveAsMovieFile (WindowReference theWindow){	CQuicktimeClass*		m_WindowQTObject = NULL;	Movie 				myMovie = NULL;	StandardFileReply		theFSSpec;	StandardFileReply		theFSSpecDst;	StringPtr 				myPrompt = nil;	StringPtr 				myFileName =  nil;	OSErr				myErr = paramErr;			myPrompt = QTUtils_ConvertCToPascalString(kSavePrompt);	myFileName = QTUtils_ConvertCToPascalString(kSaveMovieFileName);			// get the window object associated with the specified window	m_WindowQTObject = QT_GetWindowObjectFromWindow(theWindow);	if (m_WindowQTObject == NULL)	return (-1);	myMovie = m_WindowQTObject->m_theMovie;	if (myMovie == NULL) 			return (-1);			// on fait in FsSpec		FSMakeFSSpec(m_WindowQTObject->m_FileFSSpec.vRefNum,				 m_WindowQTObject->m_FileFSSpec.parID,				 m_WindowQTObject->m_FileFSSpec.name,				 &theFSSpec);	// make an FSSpec record		QT_DoDestroyMovieWindow(theWindow); // on ferme la fentre actuelle	QT_MakeCloneOfMovieFile (&theFSSpec,&theFSSpecDst); // on clone le movie	QT_DoCreateMovieWindow (m_WindowQTObject,nil, &theFSSpecDst); // on ouvre le nouveau movie 	QT_DoUpdateMovieFile(theWindow); // on upgrade la fentre actuelle		if(myPrompt) DisposePtr(myPrompt);	if(myFileName) DisposePtr(myFileName);	myPrompt=nil;	myFileName=nil;}// Cette Routine permet de cloner le movie en cours ou bien un movie sur le disqueOSErrQT_MakeCloneOfMovieFile (const FSSpec *theFSSpec,FSSpec *theFSSpecDst){	Movie 				myMovie = NULL;	StandardFileReply		mySFReply;	StringPtr 				myFileName = nil; 	StringPtr 				myprompt = "\pEnregistrez un clone"; 	OSErr				myErr = paramErr;	short				myRefNumSrc = kInvalidFileRefNum;	short				myRefNum = kInvalidFileRefNum;	short				myResIDSrc = movieInDataForkResID;	short				myResID = movieInDataForkResID;		Movie			myNewMovie = NULL;	MovieController	myMC = NULL;	long				myFlags;			short				a;	char				buff[256];					char*			cPtr;	char				c;	// proctection	if (theFSSpec == NULL) return -1;		// on ouvre l'ancien fichier	myErr = OpenMovieFile(theFSSpec, &myRefNumSrc, fsRdPerm);		if (myErr != noErr)	 return myErr;		myResIDSrc = 0;	myErr = NewMovieFromFile(&myMovie, myRefNumSrc, &myResIDSrc, NULL, NULL, NULL);		if (myErr != noErr)	{			CloseMovieFile(myRefNumSrc);			return myErr;	}		// P2C	memcpy(&buff, &theFSSpec->name[1], 32L);  // name file sur 32 chars	a=theFSSpec->name[0];	buff[a]=0;		cPtr=&buff;	a=0;		do {		c=*cPtr++;		a++;	} while ( c !=0 && c != '.' && a<13);		if (cPtr>&buff){		*cPtr--;		*cPtr=nil;	}	// on fabrique un nom du type :  xxxxxx-[clone].mov //theFSSpec->name		if (a) { // chaine non nulle			if (a>20){				buff[18]='~';				buff[19]=0;				}			strcat(&buff,"-(clone).mov");			myFileName = QTUtils_ConvertCToPascalString(&buff);				} else			myFileName = QTUtils_ConvertCToPascalString(kSaveMovieFileName); // pas de nom de fichier				if (myFileName[0]>31)				 myFileName[0]=31;					// on demande un nom de fichier				StandardPutFile(myprompt, myFileName, &mySFReply ); 		if (myFileName) 				DisposePtr(myFileName);		myFileName=nil;	if ( mySFReply.sfGood)  {	// enregistrer ?		// delete any existing file of that name ?		if (mySFReply.sfReplacing) {			myErr = DeleteMovieFile(&mySFReply.sfFile);						if (myErr != noErr)	{				CloseMovieFile(myRefNumSrc);				return myErr;			}		}				// on crŽer le nouveau fichier 		myFlags = createMovieFileDeleteCurFile | 				createMovieFileDontOpenFile | 				createMovieFileDontCreateMovie | 				createMovieFileDontCreateResFile;				myErr = CreateMovieFile(&mySFReply.sfFile, FOUR_CHAR_CODE('TVOD'), smSystemScript, myFlags, NULL, NULL);		if (myErr != noErr)	{			CloseMovieFile(myRefNumSrc);			return myErr;		}				// on ouvre le nouveau fichier		myErr = OpenMovieFile(&mySFReply.sfFile, &myRefNum, fsRdWrPerm);						if (myErr != noErr)	{			CloseMovieFile(myRefNumSrc);			return myErr;		}							// on ajoute les donnŽes, write existing movie's data into new movie file		myErr = AddMovieResource(myMovie, myRefNum, &myResID, mySFReply.sfFile.name);				if (myErr != noErr)	{			CloseMovieFile(myRefNumSrc);			CloseMovieFile(myRefNum);			return myErr;		}		if (theFSSpecDst){			FSMakeFSSpec(mySFReply.sfFile.vRefNum, mySFReply.sfFile.parID, mySFReply.sfFile.name, theFSSpecDst);		}		// mise ˆ jour du fichier		myErr = UpdateMovieResource(myMovie,myRefNum, myResID, NULL);				// close the existing movie file		CloseMovieFile(myRefNumSrc);		CloseMovieFile(myRefNum);		return(myErr);	}				return 0;}////////////// DoUpdateMovieFile// Update the file (if any) attached to the movie.////////////BooleanQT_DoUpdateMovieFile (WindowReference theWindow){	CQuicktimeClass*		m_WindowQTObject = NULL;	Movie 				myMovie = NULL;	OSErr				myErr = noErr;		// get the window object associated with the specified window	m_WindowQTObject = QT_GetWindowObjectFromWindow(theWindow);	if (m_WindowQTObject == NULL)						return(false);			myMovie = m_WindowQTObject->m_theMovie;	if (myMovie == NULL)	return(false);		// update the current volume setting	QTUtils_UpdateMovieVolumeSetting(myMovie);		if (m_WindowQTObject->m_FileRefNum == kInvalidFileRefNum){		// brand new movie, so no file attached to it		myErr = QT_DoSaveAsMovieFile(theWindow);	} else	{												// we have an existing file; just update the movie resource		myErr = UpdateMovieResource( myMovie, m_WindowQTObject->m_FileRefNum, m_WindowQTObject->m_FileResID, NULL);		//myErr = PutMovieIntoDataFork(myMovie,m_WindowQTObject->m_FileRefNum,0,-1);	}	if (!myErr)		m_WindowQTObject->m_Dirty = false;	return( myErr);}////////////// DoActivateWindow// Activate or deactivate the specified window.////////////voidQT_DoActivateWindow (WindowReference theWindow, Boolean isBecomingActive){	CQuicktimeClass* 		m_WindowQTObject = NULL;	MovieController		myMC = NULL;	GrafPtr				mySavedPort = NULL;		if (theWindow == NULL)		return;		GetPort(&mySavedPort);	MacSetPort((GrafPtr)theWindow);		// get the window object associated with the specified window	m_WindowQTObject = QT_GetWindowObjectFromWindow(theWindow);	if (m_WindowQTObject != NULL) {		myMC = m_WindowQTObject->m_theMC;		if (myMC != NULL)			MCActivate(myMC, theWindow, isBecomingActive);	}		MacSetPort(mySavedPort);}////////////// StandardUserItemProcedure// A standard user-item procedure to outline the OK button in a modal dialog.////////////pascal void  QT_StandardUserItemProcedure (DialogPtr theDialog, short theItem){#pragma unused(theItem)	short			myItemKind;		// for GetDialogItem	Handle			myItemHandle;	// for GetDialogItem	Rect			myItemRect;		// for GetDialogItem	if (!gHasNewDialogCalls) {		// no need to do any of this if the new Dialog Manager calls are available		GetDialogItem(theDialog, kStdOkItemIndex, &myItemKind, &myItemHandle, &myItemRect);				MacInsetRect(&myItemRect, -4, -4);		PenSize(3, 3);		FrameRoundRect(&myItemRect, 16, 16);		PenSize(1, 1);	}}////////////// CheckMovieControllers// Let all movie controllers have a chance to process the event.//// Returns true if the event was handled by some movie controller, false otherwise////////////Boolean  QT_CheckMovieControllers (EventRecord *theEvent,WindowReference theWindow){		WindowPtr				myWindow;	CQuicktimeClass*			m_WindowQTObject;	MovieController			myMC;		myWindow = (WindowPtr)theWindow;		if (!myWindow) 				return 0;					 	m_WindowQTObject = QT_GetWindowObjectFromWindow(myWindow);				if (m_WindowQTObject != NULL) {			myMC = m_WindowQTObject->m_theMC;			if (myMC != NULL)				if (MCIsPlayerEvent(myMC, theEvent))												return(true);		}		return(false);}////////////// SizeWindowToMovie// Set the window size to exactly fit the movie and controller (if visible).////////////// note cette fonction de doit pas tre appelŽe lorsque le fichier est en pleine fentrevoid QT_SizeWindowToMovie (CQuicktimeClassPtr theWindowObject,short fullscreen){	Rect					myMovieBounds;	MovieController		myMC = NULL;	Movie				myMovie = NULL;	GrafPtr	oldport;	if (theWindowObject == NULL)							return;	GetPort(&oldport);	SetPort(theWindowObject->m_windows);	myMC = theWindowObject->m_theMC;	myMovie = theWindowObject->m_theMovie;	if (!fullscreen){		if (MCGetVisible(myMC))			MCGetControllerBoundsRect(myMC, &myMovieBounds);		else			GetMovieBox(myMovie, &myMovieBounds);				// make sure that the movie has a non-zero width;		// a zero height is okay (for example, with a music movie with no controller bar)		if (myMovieBounds.right - myMovieBounds.left == 0) {			myMovieBounds.left = 0;			myMovieBounds.right = QT_GetWindowWidth(theWindowObject->m_windows);		}											SizeWindow(QT_GetPortFromWindowReference(theWindowObject->m_windows),												myMovieBounds.right - myMovieBounds.left,												myMovieBounds.bottom - myMovieBounds.top,												true);		// il 		} else {		// si mode fullscreen on dŽplace la fentre de visionnage		// on ne fait rien car il ne faut pas resizer la fentre	}		InvalRect(&((GrafPtr)theWindowObject->m_windows)->portRect);	SetPort(oldport);}////////////// ShowWarning// Display a warning box.////////////void QT_ShowWarning(Str255 theMessage, OSErr theErr){	Str255				myString;	short 				mySavedResFile;		// get the current resource file and set the application's resource file	mySavedResFile = CurResFile();	UseResFile(gAppResFileNumber);	NumToString(theErr, myString);	ParamText("\pWarning!", theMessage, theErr ? myString: NULL, NULL);	Alert(kAlertErrorID, gModalFilterUPP);		// restore the original resource file	UseResFile(mySavedResFile);}/*////////////// GetMCFromFrontWindow// Get the movie controller (if any) associated with the front window.////////////MovieControllerQT_GetMCFromFrontWindow (void){	MovieController 	myMC = NULL;	CQuicktimeClass*		m_WindowQTObject = NULL;			m_WindowQTObject = QT_GetWindowObjectFromFrontWindow();	if (m_WindowQTObject != NULL)		myMC = m_WindowQTObject->m_theMC;			return(myMC);}*/////////////// GetMCFromWindow// Get the movie controller (if any) associated with the specified window.////////////MovieControllerQT_GetMCFromWindow (WindowReference theWindow){	MovieController 	myMC = NULL;	CQuicktimeClass*		m_WindowQTObject = NULL;			m_WindowQTObject = QT_GetWindowObjectFromWindow(theWindow);	if (m_WindowQTObject != NULL)		myMC = m_WindowQTObject->m_theMC;			return(myMC);}/////////////////////////////////////////////////////////////////////////////////////////////////////////////// Miscellaneous utilities.//// Use the following functions to play beeps, manipulate menus, and do other miscellaneous things. These// functions are intended for use in cross-platform code./////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// GetPortFromWindowReference // Return the graphics port associated with a window reference.////////////GrafPtrQT_GetPortFromWindowReference (WindowReference theWindow){	return((GrafPtr)theWindow);}////////////// GetWindowReferenceFromPort// Return the window reference associated with a graphics port.////////////WindowReferenceQT_GetWindowReferenceFromPort (GrafPtr thePort){	return((WindowReference)thePort);}////////////// GetWindowWidth// Return the width of the specified window.////////////shortQT_GetWindowWidth (WindowReference theWindow){	short		myWidth = 0;		if (theWindow != NULL)		myWidth = (GetWindowPort(theWindow))->portRect.right - (GetWindowPort(theWindow))->portRect.left;	return(myWidth);}////////////// AddControllerFunctionality// Configure the movie controller.////////////voidQT_AddControllerFunctionality (MovieController theMC){	long			myControllerFlags;		// CLUT table use	MCDoAction(theMC, mcActionGetFlags, &myControllerFlags);	MCDoAction(theMC, mcActionSetFlags, (void *)(myControllerFlags | mcFlagsUseWindowPalette));	// enable keyboard event handling	MCDoAction(theMC, mcActionSetKeysEnabled, (void *)true);		// disable drag support	MCDoAction(theMC, mcActionSetDragEnabled, (void *)false);}////////////// ApplicationMCActionFilterProc // Intercept some mc actions for the movie controller.//// NOTE: The theRefCon parameter is a handle to a window object record.////////////pascal Boolean QT_ApplicationMCActionFilterProc (	MovieController theMC, short theAction, void *theParams, long theRefCon){#pragma unused(theMC, theParams)	Boolean				isHandled = false;			// false => allow controller to process the action	CQuicktimeClass*		m_WindowQTObject = NULL;		m_WindowQTObject = (CQuicktimeClass*)theRefCon;	if (m_WindowQTObject == NULL)						return(isHandled);			switch (theAction) {		// handle window resizing		case mcActionControllerSizeChanged:			QT_SizeWindowToMovie(m_WindowQTObject,m_WindowQTObject->m_fullscreen); // note cette fonction ne doit pas tre appelŽe si mode plein Žcran			break;		// handle idle events		case mcActionIdle:			//DoIdle(m_WindowQTObject->fWindow);			break;					// handle movie edits		case mcActionMovieEdited:			break;					case mcActionKey:			break;						default:			break;				}	// switch (theAction)		return(isHandled);	}////////////// QT_GetWindowObjectFromWindow// Get the window object associated with the specified window.////////////CQuicktimeClassPtrQT_GetWindowObjectFromWindow (WindowReference theWindow){CQuicktimeClass*		myWindowQTObject = NULL;	myWindowQTObject = (CQuicktimeClass*)GetWRefCon(theWindow);	if (!myWindowQTObject)					return 0;	// make sure this is a window object	if (!QT_IsWindowObjectOurs(myWindowQTObject))		return(NULL);			return(myWindowQTObject);}////////////// IsWindowObjectOurs// Does the specified window object belong to our application?////////////BooleanQT_IsWindowObjectOurs (CQuicktimeClassPtr m_WindowQTObject){	OSType		myType = NULL;	if (!m_WindowQTObject )							return(false);			myType = m_WindowQTObject->m_ObjectType;	if (myType == kMovieControllerObject || myType == kMovieControllerNoObject)		return(true);	else		return(false);}void QT_ShowControler(CQuicktimeClassPtr m_WindowQTObject,short flag){	Rect	bounds;		if (!m_WindowQTObject->m_fullscreen)		MCSetVisible (m_WindowQTObject->m_theMC,flag);	else 		MCSetVisible (m_WindowQTObject->m_theMC,false);		// 0,0 Movie coordinates	GetMovieBox(m_WindowQTObject->m_theMovie, &m_WindowQTObject->m_theMovieRect);	if (!m_WindowQTObject->m_fullscreen)		MacOffsetRect(&m_WindowQTObject->m_theMovieRect,-m_WindowQTObject->m_theMovieRect.left, -m_WindowQTObject->m_theMovieRect.top);		// Get the controller rect 	if (!m_WindowQTObject->m_fullscreen)	  if (flag){		MCGetControllerBoundsRect(m_WindowQTObject->m_theMC, &bounds);		SizeWindow(m_WindowQTObject->m_windows, bounds.right, bounds.bottom, FALSE);// Size our window		} else {		SizeWindow(m_WindowQTObject->m_windows, m_WindowQTObject->m_theMovieRect.right,m_WindowQTObject->m_theMovieRect.bottom, FALSE);		}	MCMovieChanged(m_WindowQTObject->m_theMC,m_WindowQTObject->m_theMovie);}short QT_ProcessKey(short wParam, short message, long modifier, CQuicktimeClassPtr m_QT){long 			flag,spd;OSErr			myErr=0;clock_t 		sum,ltim=clock(); TimeRecord 	my_tr;short  		c;spd=m_QT->m_keyMovSpeed;#ifndef WM_KEYUP	//correspodance mac pc#define WM_KEYUP keyUp#define WM_KEYDOWN keyDown#endif		if (m_QT->m_keytime)			sum=((ltim-m_QT->m_keytime)*10)/CLOCKS_PER_SEC; // difference depuis le dernier passage		else sum=0;				//preprocessing key				// si relache les touche <- & -> 		// en moins d'2 sec on stoppe le movie		// printf("key press  event ( wParam: %lx (\"%c\")  message : %lx  (%s)   modifier :%lx ) \n",(long) wParam,(char)wParam&0x0ff, (long)message, (char *) evnt_string[message],(long)modifier );		c=(wParam&0xff);				if (message==WM_KEYUP)		 if ( c  == arrowleftkey ||  c == arrowrightkey )		  if (sum<12)	{ //step by step					QT_MovieSpeed(m_QT,0); //stop ...					m_QT->m_AutoIncrtime=0;					m_QT->m_AutoIncrFlag=0;					m_QT->m_keytime=0;					m_QT->m_lastkeypress=0;					m_QT->m_lastkeyUp=-1;					m_QT->m_keypress=0;					m_QT->m_keyUp++; 					m_key_joy_flag = 0;					return 1;				} else {				m_QT-> m_keyUp++;				 m_QT->m_AutoIncrtime=0;				}		//switching key		if (message==WM_KEYDOWN ||			message==autoKey ){				c=(wParam&0xff00 	)>>8;				// hi byte cmd							switch(c){					case 0x73: //1er image						if (m_QT ->m_theMovie && m_QT ->m_theMC) {												GetMovieTime(m_QT ->m_theMovie,&my_tr);  // fill-in de la structure							my_tr.value.lo=0;							my_tr.value.hi=0;							MCDoAction (m_QT->m_theMC, mcActionGoToTime,(void*)(&my_tr)); 								return 1;							}						break;					case 0x77: //goto derniere image						if (m_QT ->m_theMovie && m_QT ->m_theMC) {												GetMovieTime(m_QT ->m_theMovie,&my_tr);  // fill-in de la structure							my_tr.value.lo =GetMovieDuration (m_QT->m_theMovie)-1;							MCDoAction (m_QT->m_theMC, mcActionGoToTime,(void*)(&my_tr)); 								return 1;						}					break;										case 0x74 :// goto st prŽcedent+ suivit quicktime						if (modifier & controlKey){							SimulClickInTelecommande(14);							SimulClickInTelecommande(12);							}						return 1;					break;										case 0x79  :// goto st suivant + suivit quicktime						if (modifier & controlKey){							SimulClickInTelecommande(15);							SimulClickInTelecommande(12);							}						return 1;					break;				};				// low bytes cmd				c=(wParam&0xff);				// les chiffres du shutle pro								if (	modifier & controlKey &&					( c >= 0x30 && c <= 0x39 )  ) {// 										short valspe= (c-0x30) ;															if ( !  (modifier & optionKey) ) { // mode reverse						QT_MovieSpeed(m_QT, valspe);					} else {						QT_MovieSpeed(m_QT, -valspe );					}				}				// les lettres				switch(c){									case 'C': // show/hide controler					case 'c': 						if(m_QT ) 							QT_ShowControler(m_QT,MCGetVisible(m_QT->m_theMC));						return 1;					break;										case 'P': // play					case 'p': 						if(m_QT ) 							QT_MovieSpeed(m_QT,4);						m_QT->m_keyUp=0;						m_QT->m_AutoIncrtime=0;						m_QT->m_AutoIncrFlag=0;						m_QT->m_keytime=0;						m_QT->m_lastkeypress=0;						m_QT->m_keypress=0;						m_key_joy_flag = 0;						return 1;					break;					case 'S': // stop					case 's':						if(m_QT ) 						   QT_MovieSpeed(m_QT,0);						m_QT->m_keyUp=0;						m_QT->m_AutoIncrtime=0;						m_QT->m_AutoIncrFlag=0;						m_QT->m_keytime=0;						m_QT->m_lastkeypress=0;						m_QT->m_keypress=0;						m_key_joy_flag = 0;						return 1;					break;										case ' ': // play/stop-					case 13 : 					case 10 : 					case 9 :						if(m_QT ) 							if (m_QT->m_keyMovSpeed)									QT_MovieSpeed(m_QT,0);							else 									QT_MovieSpeed(m_QT,4);						m_QT->m_keyUp=0;						m_QT->m_AutoIncrtime=0;						m_QT->m_AutoIncrFlag=0;						m_QT->m_keytime=0;						m_QT->m_lastkeypress=0;						m_QT->m_keypress=0;						m_key_joy_flag = 0;						return 1;					break;					case arrowleftkey: // Frew						m_QT->m_key_joy_flag=0; // le clavier prend la main						if (modifier & optionKey ) { // jog mode avec audio ?												// dernière touche appuyée ==							if (m_QT->m_keypress != wParam)  										m_QT->m_keytime=0;														// premiere appel de cette touche ?							if (!m_QT->m_keytime){ //oui							 	QT_MovieSpeed(m_QT,-3);							 	m_QT->m_keytime=clock();							 	m_QT->m_AutoIncrtime=0;			 					m_QT->m_keypress=wParam;								m_QT->m_AutoIncrFlag=m_QT->m_keytime;								m_QT->m_lastkeyUp=-1;							 	m_QT->m_keyUp=0;							 	m_key_joy_flag = 0;							 	return 1;							}														// Si 1er press && presse depuis - de 4 secondes => nop								if (sum<30 && m_QT->m_keyUp <1) return 1;																		if (!m_QT->m_keyUp){ //auto-incrémentation ?								// oui auto incrémentation								// on incrémente automatiquement (en fct du temps)																if(!m_QT->m_AutoIncrFlag && sum<15 ) return 1;// 1er pression & t < 4 sec => nop																			sum=((ltim-m_QT->m_AutoIncrtime)*10)/CLOCKS_PER_SEC; // difference depuis le dernier passage								if(m_QT->m_AutoIncrFlag && sum < 7 ) return 1; // n eme pression & t <1 sec => nop								m_QT->m_AutoIncrFlag =1;								m_QT->m_AutoIncrtime=ltim;															} else if (m_QT->m_keyUp==m_QT->m_lastkeyUp) return 1;							m_QT->m_lastkeyUp=m_QT->m_keyUp;							m_QT->m_lastkeypress=m_QT->m_keypress;							m_QT->m_keypress=wParam;														if (spd>0) spd=0;							spd--;							if (spd == -1) spd = -2;							m_key_joy_flag = 0;							QT_MovieSpeed(m_QT,spd);							return 1;					} else { // pas jog mode avec audio, simple step							if(m_QT)MCDoAction (m_QT->m_theMC, mcActionStep,(void*)(-1)); 					}										break;					case arrowrightkey: // Ffwd						m_QT->m_key_joy_flag=0; // le clavier prend la main						if (modifier & optionKey ) { // jog mode avec audio ?																	// dernière touche appuyée ==							if (m_QT->m_keypress != wParam)  m_QT->m_keytime=0;																	if (!m_QT->m_keytime){ //oui							 	QT_MovieSpeed(m_QT,3);							 	m_QT->m_keytime=clock();			 					m_QT->m_keypress=wParam;							 	m_QT->m_AutoIncrtime=0;								m_QT->m_AutoIncrFlag=m_QT->m_keytime;								m_QT->m_lastkeyUp=-1;							 	m_QT->m_keyUp=0;							 	m_key_joy_flag = 0;							 	return 1;							}							// Si 1er press && presse depuis - de 4 secondes => nop								if ( sum<30 && !m_QT->m_keyUp ) return 1;																		if (!m_QT->m_keyUp){ //auto-incrémentation ?								// oui auto incrémentation								// on incrémente automatiquement (en fct du temps)																if(!m_QT->m_AutoIncrFlag && sum<15 ) return 1;// 1er pression & t < 4 sec => nop																			sum=((ltim-m_QT->m_AutoIncrtime)*10)/CLOCKS_PER_SEC; // difference depuis le dernier passage								if(m_QT->m_AutoIncrFlag && sum < 7 ) return 1; // n eme pression & t <1 sec => nop								m_QT->m_AutoIncrFlag =1;								m_QT->m_AutoIncrtime=ltim;							} else if (m_QT->m_keyUp==m_QT->m_lastkeyUp) return 1;							m_QT->m_lastkeyUp=m_QT->m_keyUp;							m_QT->m_lastkeypress=m_QT->m_keypress;							m_QT->m_keypress=wParam;							if (spd<0) spd=0;							spd++;							if (spd == 1) spd = 2;							m_key_joy_flag = 0;							QT_MovieSpeed(m_QT,spd);											return 1;													} else { // pas jog mode avec audio, simple step							if(m_QT)MCDoAction (m_QT->m_theMC, mcActionStep,(void*)(1)); 						}										break;										case arrowupkey: // Play							m_QT->m_key_joy_flag=0; // le clavier prend la main						m_QT->m_keytime=clock(); 						m_QT->m_lastkeypress=m_QT->m_keypress;						m_QT->m_keypress=wParam;						m_QT->m_keyUp=0;						m_QT->m_AutoIncrtime=0;						m_QT->m_AutoIncrFlag=0;						m_QT->m_keytime=0;						m_QT->m_lastkeypress=0;						m_QT->m_keypress=0;						m_key_joy_flag = 0;						QT_MovieSpeed(m_QT,4); //play x1								return 1;					break;												case arrowdownkey: // Stop						m_QT->m_key_joy_flag=0; // le clavier prend la main						QT_MovieSpeed(m_QT,0);						m_QT->m_keyUp=0;						m_QT->m_AutoIncrtime=0;						m_QT->m_AutoIncrFlag=0;						m_QT->m_keytime=0;						m_QT->m_lastkeypress=0;						m_QT->m_keypress=0;						m_key_joy_flag = 0;						return 1;					break;					}; //switch					}				return 0;}short QT_ProcessJoystick(CQuicktimeClassPtr m_QT){long val;long pitch=0;long roll=0;long yaw=0;	// on gère le stop play	//	igs.throttleInput=igs.yawInput=igs.pitchInput=igs.rollInput=0;	if ( initsprocket) return 0;	pitch=igs.pitchInput*1000/600;	roll=igs.rollInput*1000/600;	yaw=igs.yawInput*1000/600;		if (pitch<-400){ //		m_key_joy_flag = 0;		QT_MovieSpeed( m_QT,0 ); //stop		return 1;	}		if (pitch>400){ //		QT_MovieSpeed(m_QT, 4 ); //play		m_key_joy_flag = 0;		return 1;	}		if(m_key_joy_flag != 1){ // on regarde si l'axe 1 bouge		if (roll> 300 ||  roll < -300) 					m_key_joy_flag = 1;	}	if(m_key_joy_flag != 2){ // on regarde si l'axe 2 bouge		if (yaw> 300 ||  yaw < -300) 					m_key_joy_flag = 2;	}		// si l'on a deja processe on tient compte	// de la position du slider activé	// sinon on ne fait rien		if(m_key_joy_flag==1){ //axe principale		val=roll;		if (val<-120 || val>120){  // hysteresys			if (val > 800){				 QT_MovieSpeed(m_QT,(val-800)/ 100+7 );			} else if (val < -800){				 QT_MovieSpeed(m_QT,(val+800)/ 100-7 );				} else 	QT_MovieSpeed(m_QT,(val)/ 150 );				}	else 	QT_MovieSpeed(m_QT,0);		return 1;	}		if(m_key_joy_flag==2){ //axe principale		val=yaw;		if (val<-120 || val>120){  // hysteresys			if (val > 800){				 QT_MovieSpeed(m_QT,(val-800)/ 100+7 );			} else if (val < -800){				 QT_MovieSpeed(m_QT,(val+800)/ 100-7 );				} else 	QT_MovieSpeed(m_QT,(val)/ 150 );				}	else 	QT_MovieSpeed(m_QT,0);		return 1;	}	return 0;}void QT_MovieSpeed(CQuicktimeClass* m_QT, long speed ){ //speed * 10long val;Fixed fval;short flag;		// on effectue une compensation de courbe		// 0 stop		// 1 play .2 speed		// 2 play .5 speed		// 3 play .7 speed		// 4 play 1 speed		// 5 play 1.5 speed		// 6 play 2 speed		// 7 play 3 speed		// 8 play 5 speed		// 9 play 8 speed				//bornes		if (speed>10) speed=10;		if (speed<-10) speed=-10;				m_QT->m_keyMovSpeed=speed;				switch (speed){					case 0:				val=0;			break;						case -1:				val=-2;			break;						case 1:				val=2;			break;						case -2:				val=-5;			break;						case 2:				val=5;			break;						case -3:				val=-7;			break;						case 3:				val=7;			break;						case -4:				val=-10;			break;						case 4:				val=10;			break;						case -5:				val=-15;			break;						case 5:				val=15;			break;				case -6:				val=-20;			break;						case 6:				val=20;			break;									case -7:				val=-30;			break;						case 7:				val=30;			break;							case -8:				val=-50;			break;						case 8:				val=50;			break;						case -9:				val=-80;			break;						case 9:				val=80;			break;						case -10:				val=-100;			break;						case 10:				val=100;			break;														}				fval=FixDiv(Long2Fix(val),Long2Fix(10)); //conversion en fix			// Si passage par zero on envoie un ordre "zero".				flag=0;		if (glastdirection>0 && fval<0) flag=1;		if (glastdirection<0 && fval>0) flag=1;			if ( flag){			if(m_QT)MCDoAction (m_QT->m_theMC, mcActionPlay,(void*)(0)); 			if( m_QT->m_theMovie)				MoviesTask(m_QT->m_theMovie,30);		}		if(m_QT)MCDoAction (m_QT->m_theMC, mcActionPlay,(void*)(fval)); 		glastdirection=fval;	}