* ===========================================================** 	Ensemble de routine de gestion de l'undo/Redo****	PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	PRINT	POP				IMPORT	G:AppGlobals	IMPORT	qd:QDGlobals	;;	Gestion des Undos :;	-------------------;  Quand on effectue une capture de tc ou bien une ouverture de texte; on stocke l'ancienne valeur dans une case tampon avec une indication; de temps.;;	Puis si l'utilisateur demande Undo, on prend le dernier évènement de la liste;   on rend cette valeur	à l'endroit où elle a été prise,;	et on transfère le contenu actuel dans la mémoire undo ;;;	Doit-on mettre actif le sous-titre concerné lors d'un Undo ?;; 	Ces parramètres sont-ils raz si insert ou delete un sous-titre ?;	Combien faut-il garder de undo;	Au bout de combien de temps il faut attendre pour faire un nouveau undo sur le texte ?;	;	Undo sur renumérotation ?;;;	structure de l'undoptr:;			;		NumberOfItem	ds.w	1;		UndoElement		;;UndoElement:;;		Type		ds.w	1	; type del'undo;		Ticks		ds.l	1	; heure de l'undo;		AbsST		ds.l	1	; n° absolu du Sous-titre;		Data		ds.l	1	; timecode ou Handle		;		spare		ds.l	2	;;Texte_SousTitre				equ		1;Commentaire_SousTitre			equ		2;TimecodeIn_SousTitre			equ		3;TimecodeOut_SousTitre			equ		4;Duree_SousTitre				equ		5;TimecodeIn_SousTitrebcd			equ		6;TimecodeOut_SousTitrebcd		equ		7	* ================================================* PROCEDURE DoMakeUndo(Type,ticks,Abs_num,Data);* ================================================; Cette routine créé /ajoute un élément dans la table des undo;;;	Undo sur les times code :;;	Entrée:;			N° de  l'élément Mêmechose que pour les TE;			ticks;			 N°du sous-titre Absolu ? (ou N° du sous-titre);			TimeCode  à sauvegarder / pointeur du TE;	Sortie: False/true si undo faitDoMakeUndo	FUNC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult			ds.w	1ParamBegin		EQU	*			; start parameters after this pointthe_type		ds.w	1		;the_ticks		ds.l	1Abs_Num			ds.l	1		;Data			ds.l	1		;timecode ou TEHandleParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkVisRect			ds	RectTEStyleRecPtr	ds.l	1Startselection	ds.l	1EndSelection	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow 		IMPORT	UpdateControlsDansLaFenetre		WITH	StackFrame,Undo_Structure		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		move.w	#false,Result(a6)		movem.l	d0-d7/a1-a4,-(sp)		; on regarde si l'on a un pointeur de mémoire pour la liste undo		tst.l	G.Undo_StackPtr		bne.s	PointeurOK		; oui on en a un				move.l	#(Undo_spare+8)*36,d0		_NewPtr		move.l	a0,G.Undo_StackPtr		tst.w	d0		bne		Exit	;erreur				clr.l	(a0)	;PasdeUndo dans la liste; ----PointeurOK; on vérifie que le parramètres type est ok		cmp.w	#Texte_SousTitre,the_type(a6)		blo		Exit		cmp.w	#TimecodeOut_SousTitrebcd,the_type(a6)		bhi		Exit		; on regarde s'ilfaut effectuer le Undo		move.l	the_ticks(a6),d0	; si ticks NUL on le fait		beq		Make_the_Undo		; on regarde si c'est le même type de undo que le dernier				move.l	G.Undo_StackPtr,a0		adda.l	#00000002,a0				move.w	the_type(a6),d0		cmp.w	Undo_Type(a0),d0		bne		Make_the_Undo				move.L	Abs_Num(a6),d0		cmp.l	Undo_AbsST(a0),d0		bne		Make_the_Undo				move.l	G.Undo_LastTicks,d1	; 		move.l	the_ticks(a6),d0		move.l	d0,G.Undo_LastTicks 	; 		sub.l	d1,d0	; 		cmp.l	#67*3,d0			; 3 secondes minimum		blo		Exit				; on ne fait rien				Make_the_Undo		; on décale la liste			move.l	G.Undo_StackPtr,a0		add.l	#00002,A0		move.l	G.Undo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy				move.w	(a1),(a1,d0.w)		suba.l	#0000000002,a1		cmpa.l	a0,a1		bhs		Loop_Copy		; on regarde s'il faut disposer de la mémoire du dernier élément				move.l	G.Undo_StackPtr,a0		move.w	Undo_NumberOfItem(a0),d0		cmp.w	#31,d0		blo		PasDisposeHandle				move.l	#(Undo_spare+8)*31+2 ,d0		move.L	G.Undo_StackPtr,a4				adda.l	d0,a4		cmp.w	#TimecodeIn_SousTitrebcd-1,Undo_Type(a4)		bhi.s	PasDisposeHandle	; c'est un timecode BCD on ne dispose rien		; on dispose les handles du dernier élément qui va ètre éliminé		move.l	Undo_TexteHandle(a4),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_DisposHandle@1		move.l	Undo_StyleHandle(a4),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_DisposHandle@2						PasDisposeHandle; ----; on créé un nouveau élément; on incrémente le nombre d'élément en mémoire		move.l	G.Undo_StackPtr,a0		move.w	Undo_NumberOfItem(a0),d0		addq.w	#1,d0		cmp.w	#31,d0		blo		PasSup32		Move.w	#31,d0PasSup32		move.w	D0,Undo_NumberOfItem(a0)		adda.l	#0000002,a0		; on place les éléments dans la structure						move.w	the_type(a6),Undo_Type(a0)		move.l	the_ticks(a6),Undo_Ticks(a0)		MOVE.L	Abs_Num(A6),Undo_AbsST(A0)		clr.l	Undo_TexteHandle(a0)		clr.l	Undo_StyleHandle(a0)		clr.l	Undo_spare(a0)		clr.l	4+Undo_spare(a0)		; on s'occupe de la data ; 		cmp.w	#TimecodeIn_SousTitrebcd,the_type(a6)		blo		TypeTE		cmp.w	#TimecodeOut_SousTitrebcd,the_type(a6)		bhi		Exit	; on ne connait pas ce type; ------ type	TimecodeBCD ON STOCKE LA VALEUR				move.l	Data(A6),Undo_Data(a0)		move.w	#true,Result(a6)		bra		Exit		; ------ C'est un type TE; il nous faut faire une copie du TE pour le stocker en mémoireTypeTE			move.l	G.Undo_StackPtr,a4			adda.l	#0000002,a4			move.l	Data(a6),a0			_Hlock	; on lock le handle;on sauvegarde la selection courante						move.l	Data(a6),a0			move.l	(a0),a0		;handle						move.w	teSelStart(a0),Startselection(A6)			move.w	teSelEnd(a0),EndSelection(A6)			; on selectionne tous le texte						move.l	#0,-(sp)			move.l	#32767,-(sp)			move.l	Data(a6),-(sp)			_TeSetSelect			clr.l	Undo_StyleHandle(a4)						clr.l	-(sp)			move.l	Data(a6),-(sp)			move.w	#6,-(sp)		;	_GetStylScrap			_TEDispatch			move.l	(sp)+,d7			beq		PasDeHandle			; on effectue une copie du handle			move.l	d7,a0				_HandTohand			move.l	a0,Undo_StyleHandle(a4)			move.l	d7,a0			_DisposHandlePasDeHandle						; on rend la selection précédente			moveq	#0,d0			move.w	Startselection(A6),d0			move.l	d0,-(sp)			moveq	#0,d0			move.w	EndSelection(A6),d0			move.l	d0,-(sp)			move.l	Data(a6),-(sp)			_TeSetSelect			; on recopie le texte dans le sous-titre						move.l	Data(a6),a0			move.l	(a0),a3				; c'est un handle						moveq	#0,d0			move.w	teLength(a3),d0			beq		Unlock_the_handle		; pas de texte			; on recopie le texte dans le handle				_NewHandle			tst.w	D0			bne		Exit		; pas de handle dispo			move.l	A0,Undo_TexteHandle(a4)					_Hlock						move.l	tetextH(a3),a0			_Hlock						move.l	(a0),a0			;handle source						move.l	Undo_TexteHandle(a4),a1			move.l	(a1),a1	; handle (destination)						moveq	#0,d0			move.w	teLength(a3),d0	; longueur			_BlockMove				; on recopie le handle			; on unlock le data handle			move.l	Undo_TexteHandle(a4),a0			_HUnlock			move.l	tetextH(a3),a0			_HUnlock			Unlock_the_handle						move.l	Data(a6),a0			_HUnlock						Exit		movem.l	(sp)+,d0-d7/a1-a4			UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.New	DoMakeUndo			endP				* ================================================* PROCEDURE DoMakeRedo(Type,ticks,Abs_num,Data);* ================================================; Cette routine créé /ajoute un élément dans la table des Redo;;;	Undo sur les times code :;;	Entrée:;			N° de  l'élément Mêmechose que pour les TE;			ticks;			 N°du sous-titre Absolu ? (ou N° du sous-titre);			TimeCode  à sauvegarder / pointeur du TE;	Sortie: False/true si undo faitDoMakeRedo	FUNC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordResult		ds.w	1ParamBegin		EQU	*			; start parameters after this pointthe_type		ds.w	1		;the_ticks		ds.l	1Abs_Num			ds.l	1		;Data			ds.l	1		;timecode ou TEHandleParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkVisRect			ds	RectTEStyleRecPtr	ds.l	1Startselection	ds.l	1EndSelection	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow 		IMPORT	UpdateControlsDansLaFenetre		WITH	StackFrame,Undo_Structure		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		move.w	#false,Result(a6)		movem.l	d0-d7/a1-a4,-(sp)		; on regarde si l'on a un pointeur de mémoire pour la liste undo		tst.l	G.Redo_StackPtr		bne.s	PointeurOK		; oui on en a un				move.l	#(Undo_spare+8)*36,d0		_NewPtr		move.l	a0,G.Redo_StackPtr		tst.w	d0		bne		Exit	;erreur		clr.l	(a0)	;PasdeUndo; ----PointeurOK; on vérifie que le parramètres type est ok		cmp.w	#Texte_SousTitre,the_type(a6)		blo		Exit		cmp.w	#TimecodeOut_SousTitrebcd,the_type(a6)		bhi		Exit		; on regarde s'ilfaut effectuer le Undo		move.l	the_ticks(a6),d0	; si ticks NUL on le fait		beq		Make_the_Undo		; on regarde si c'est le même type de undo que le dernier				move.l	G.Redo_StackPtr,a0		adda.l	#00000002,a0				move.w	the_type(a6),d0		cmp.w	Undo_Type(a0),d0		bne		Make_the_Undo				move.L	Abs_Num(a6),d0		cmp.l	Undo_AbsST(a0),d0		bne		Make_the_Undo				move.l	G.Redo_LastTicks,d1	; 		move.l	the_ticks(a6),d0		move.l	d0,G.Redo_LastTicks 	; 		sub.l	d1,d0	; 		cmp.l	#10,d0			; 4 secondes minimum		blo		Exit				; on ne fait rien				Make_the_Undo		; on décale la liste			move.l	G.Redo_StackPtr,a0		add.l	#00002,A0		move.l	G.Redo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy				move.w	(a1),(a1,d0.w)		suba.l	#0000000002,a1		cmpa.l	a0,a1		bhs		Loop_Copy		; on regarde s'il faut disposer de la mémoire du dernier élément		move.l	G.Redo_StackPtr,a0		move.w	Undo_NumberOfItem(a0),d0		cmp.w	#31,d0		blo		PasDisposeHandle				move.l	#(Undo_spare+8)*31+2 ,d0		move.L	G.Redo_StackPtr,a4				adda.l	d0,a4		cmp.w	#TimecodeIn_SousTitrebcd-1,Undo_Type(a4)		bhi.s	PasDisposeHandle	; c'est un timecode BCD on ne dispose rien		; on dispose les handles du dernier élément qui va ètre éliminé		move.l	Undo_TexteHandle(a4),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_disposHandle@1		move.l	Undo_StyleHandle(a4),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_disposHandle@2						PasDisposeHandle; ----; on créé un nouveau élément; on incrémente le nombre d'élément en mémoire		move.l	G.Redo_StackPtr,a0		move.w	Undo_NumberOfItem(a0),d0		addq.w	#1,d0		cmp.w	#31,d0		blo		PasSup32		Move.w	#31,d0PasSup32		move.w	D0,Undo_NumberOfItem(a0)		adda.l	#0000002,a0		; on place les éléments dans la structure						move.w	the_type(a6),Undo_Type(a0)		move.l	the_ticks(a6),Undo_Ticks(a0)		MOVE.L	Abs_Num(A6),Undo_AbsST(A0)		clr.l	Undo_TexteHandle(a0)		clr.l	Undo_StyleHandle(a0)		clr.l	Undo_spare(a0)		clr.l	4+Undo_spare(a0)		; on s'occupe de la data ; 		cmp.w	#TimecodeIn_SousTitrebcd,the_type(a6)		blo		TypeTE		cmp.w	#TimecodeOut_SousTitrebcd,the_type(a6)		bhi		Exit	; on ne connait pas ce type; ------ type	TimecodeBCD ON STOCKE LA VALEUR				move.l	Data(A6),Undo_Data(a0)		move.w	#true,Result(a6)		bra		Exit		; ------ C'est un type TE; il nous faut faire une copie du TE pour le stocker en mémoireTypeTE			move.l	G.Redo_StackPtr,a4			adda.l	#0000002,a4			move.l	Data(a6),a0			_Hlock	; on lock le handle;on sauvegarde la selection courante						move.l	Data(a6),a0			move.l	(a0),a0		;handle									move.w	teSelStart(a0),Startselection(A6)			move.w	teSelEnd(a0),EndSelection(A6)						; on selectionne tous le texte						move.l	#0,-(sp)			move.l	#32767,-(sp)			move.l	Data(a6),-(sp)			_TeSetSelect			clr.l	Undo_StyleHandle(a4)						clr.l	-(sp)			move.l	Data(a6),-(sp)			move.w	#6,-(sp)		;	_GetStylScrap			_TEDispatch			move.l	(sp)+,d7			beq		PasDeHandle			; on effectue une copie du handle			move.l	d7,a0				_HandTohand			move.l	a0,Undo_StyleHandle(a4)			move.l	d7,a0			_DisposHandlePasDeHandle						; on rend la selection précédente			moveq	#0,d0			move.w	Startselection(A6),d0			move.l	d0,-(sp)			moveq	#0,d0			move.w	EndSelection(A6),d0			move.l	d0,-(sp)			move.l	Data(a6),-(sp)			_TeSetSelect			; on recopie le texte dans le sous-titre						move.l	Data(a6),a0			move.l	(a0),a3				; c'est un handle						moveq	#0,d0			move.w	teLength(a3),d0			beq		Unlock_the_handle		; pas de texte			; on recopie le texte dans le handle				_NewHandle			tst.w	D0			bne		Exit		; pas de handle dispo			move.l	A0,Undo_TexteHandle(a4)					_Hlock						move.l	tetextH(a3),a0			_Hlock						move.l	(a0),a0			;handle source						move.l	Undo_TexteHandle(a4),a1			move.l	(a1),a1	; handle (destination)						moveq	#0,d0			move.w	teLength(a3),d0	; longueur			_BlockMove				; on recopie le handle			; on unlock le data handle			move.l	Undo_TexteHandle(a4),a0			_HUnlock			move.l	tetextH(a3),a0			_HUnlock			Unlock_the_handle						move.l	Data(a6),a0			_HUnlock			Exit		movem.l	(sp)+,d0-d7/a1-a4			UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.New	DoMakeRedo			endP	* ================================================* PROCEDURE DoUseUndo();* ================================================; Cette routine effectue le Undo c'est à dire; qu'il prend l'élément en haut de la liste de Undo; et effectue le changement. En plaçant le dernier contenu; de l'élément sélectionner dans une table de Redo (même principe);;;	Undo sur les times code :;;	Entrée:;			N° de  l'élément Mêmechose que pour les TE;			ticks;			 N°du sous-titre Absolu ? (ou N° du sous-titre);			TimeCode  à sauvegarder / pointeur du TE;	Sortie: False/true si undo faitDoUseUndo	PROC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkVisRect			ds		RectTEStyleRecPtr	ds.l	1Startselection	ds.l	1EndSelection	ds.l	1ItemType		ds.w	1ItemHandle		ds.l	1itemRect		ds	RectTheEvent		DS	EventRecordtexteStyle		ds.b	12				; st style elementrectangle		ds	RectLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow,TransfertSaisieMemoire		IMPORT	UpdateControlsDansLaFenetre,DoMakeRedo,ConversionNumeroSTPointeur,CalculDuree		import	CentreListingWindow,TransfertMemoireSaisie,DoMakeRedo		WITH	StackFrame,Undo_Structure,SoustitreRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d0-d7/a1-a4,-(sp)		; on regarde si l'on a un pointeur de mémoire pour la liste undo			tst.l	G.Undo_StackPtr			beq		Exit		; Il n'y en a pas on ne fait rien		; on commence par regarder s'il y a un évènement dans la liste			move.l	G.Undo_StackPtr,a0			tst.w	(a0)			beq		Exit	; il n'y en a pas; on regarde si le n° de l'undo correspond au sous-titre en cour						adda.l	#0000002,a0			move.l	Undo_AbsST(a0),d7			cmp.w	G.General_SousTitreEncour,d7			beq		MemeSoustitre		; c'est le même sous-titre			; ----  ce n'est pas le même sous-titre on passe à celui qui doit ètre changé				jsr		TransfertSaisieMemoire		move.l	d7,d0		and.l	#$ffff,d0		move.w	d0,G.General_SousTitreEncour		and.l	#$ffff,d0		move.l	G.ListingVScroll,-(sp)		move.w	d0,-(sp)		_SetCtlValue		; il faut dire à QUICKDRAW que le port de la fenètre est listing		pea		G.ListingWindow		_SetPort			; initialisation de quick-draw de la police et tout et tout		MOVE.W		#SrcOr,-(SP)					; source mode		_TextMode		MOVE.W		#Monaco,-(SP)					; Monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace		move.w	#1,-(sp)	   	move.w	#1,-(sp)	   	_PenSize	   	move.w	#SrcOr,-(sp)	   	_PenMode				jsr		CentreListingWindow		pea		G.DialogSaisie		_SetPort		 ; 		jsr		AFFICHENUMSAISIE		jsr		TransfertMemoireSaisie		jsr		CalculDuree; ------------------------------------MemeSoustitre		; nous sommes dans le sous-titre en question; on prépare le redo; est-ce une time code BCD ?		move.l	G.Undo_StackPtr,a0		adda.l	#0000002,A0		cmp.w	#TimecodeIn_SousTitrebcd,Undo_Type(a0)		blo		DoRedoTexteEdit	; non c'est un texte edit				move.w	Undo_Type(a0),d0		case#.w	(d0,if),\				(TimecodeIn_SousTitrebcd,DoRedoTcIn),\				(TimecodeOut_SousTitrebcd,DoRedoTcout)		bra		Exit ; ---		; oui c'est un time code BCD; on recupère l'ancienne valeur; Redo Tc in		DoRedoTcIn			clr.w	-(sp)		move.w	d0,-(sp)		move.l	ticks,-(sp)			moveq	#0,d0		move.w	G.General_SousTitreEncour,d0		move.l	d0,-(sp)		jsr		ConversionNumeroSTPointeur		move.l	st_timeCodeIN(a0),-(sp)		jsr		DoMakeRedo		move.w	(sp)+,d0		; on effecte le undo		moveq	#0,d0		move.w	G.General_SousTitreEncour,d0		jsr		ConversionNumeroSTPointeur		move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_Data(a1),d0		move.l	d0,st_timeCodeIn(a0)				import	ForceUpdateWindow		jsr		ForceUpdateWindow				bra		DecaleListeUndo		; -----------; redo tc outDoRedoTcout		clr.w	-(sp)		move.w	d0,-(sp)		move.l	ticks,-(sp)			moveq	#0,d0		move.w	G.General_SousTitreEncour,d0		move.l	d0,-(sp)		jsr		ConversionNumeroSTPointeur		move.l	st_timeCodeOut(a0),-(sp)		jsr		DoMakeRedo		move.w	(sp)+,d0; maintenant on effectue le undo		moveq	#0,d0		move.w	G.General_SousTitreEncour,d0		jsr		ConversionNumeroSTPointeur		move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_Data(a1),d0		move.l	d0,st_timeCodeOut(a0)				import	ForceUpdateWindow		jsr		ForceUpdateWindow				bra		DecaleListeUndo				; ----------------------------------		DoRedoTexteEdit		;Redo texte edit		; on regarde si la Fenêtre saisie est ouverte		lea		G.DialogSaisie,a0		tst.b	wVisible(a0)		bne.s	SaisieOuverte	; non saisie n'est pas ouverte; -----------------  on ouvre saisie  -------------		lea		G.DialogSaisie,a0				move.l	a0,-(sp)			move.w	#true,-(sp)		_ShowHide; on place la fenètre en bas de l'ecran						pea		rectangle(a6)		import	GetMainScreenRes		jsr		GetMainScreenRes				move.w	right+rectangle(a6),d1			sub.w	left+rectangle(a6),d1				lea		G.DialogSaisie,a4		move.w	right+portrect(a4),d0		sub.w	left+portrect(a4),d0		sub.w	d0,d1	; largeur de listing		lsr.w	#1,d1	; ÷2 pour calculer position en x		add.w	left+rectangle(a6),d1		move.w	d1,d6 				move.w	bottom+rectangle(a6),d0 ; y ,x début écran		lea		G.DialogSaisie,a4		move.w	bottom+portrect(a4),d1		sub.w	top+portrect(a4),d1		sub.w	d1,d0		sub.w	#1,d0				move.w	d0,d7		 		pea		G.DialogSaisie		move.w	d6,-(sp)		move.w	d7,-(sp)		move.w	#true,-(sp)		_MoveWindow		pea		G.DialogSaisie		_SetPort		lea		G.DialogSaisie,a0		pea		PortRect(a0)		_InvalRect; on dessine la fenètre		pea		G.DialogSaisie		import	DoUpdate		jsr		DoUpdate;--; saisie est ouverte SaisieOuverte; il y a t-il un TE ouvert dans saisie		tst.l	G.saisieTe		beq		OuvrirTE	; non il n'y en a pas on en ouvre un; il y a un te ouvert; on regarde si le texte Edit correspondant à l'undo est ouvert		move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.w	Undo_Type(a1),d7	; le type de TE 		cmp.w	G.saisieTeStItem,d7		beq		TeDejaOuvert		; c'est le même TE; on ferme le TE déjà ouvert		jsr		TransfertSaisieMemoire	OuvrirTE				; comme je suis fainéant j'utilise la routine saisie event		pea		G.DialogSaisie 		_setPort				move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.w	Undo_Type(a1),d7	; le type de TE 				move.w	d7,d0			add.w	#DialSaisie_TexteSTTEItem-1,d0	; on ajoute 12-1		pea		G.DialogSaisie 		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem									pea		G.DialogSaisie 		_SelectWindow; on place les coordonnées du bouton 		lea		TheEvent(a6),a0				move.w	Top+itemRect(a6),d0		add.w	#5,d0		move.w	d0,top+evtMouse(a0)				move.w	left+itemRect(a6),d0		add.w	#5,d0		move.w	d0,left+evtMouse(a0)				pea		evtMouse(a0)		_LocalToGlobal; on appelle la routine MouseDownSaisie		pea		TheEvent(a6)		import	DoDialogSaisieEvent		jsr		DoDialogSaisieEvent		; le te est ouvertTeDejaOuvert				; on prépare le Redo			clr.w		-(sp)		move.w		G.SaisieTEstItem,-(sp)		move.l		#0,-(sp)				; on ne tient pas compte du temps		move.l		G.SaisieTEstNum,-(sp)		move.l		G.SaisieTE,-(sp)		import		DoMakeRedo		jsr			DoMakeRedo		move.w		(sp)+,d0				; on effectue le Undo; on y place le texte et le style placeTexteEtStyle		MOVE.W		#SrcOr,-(SP)					; source mode		_TextMode		MOVE.W		#Monaco,-(SP)					; Monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace		move.w	#1,-(sp)	   	move.w	#1,-(sp)	   	_PenSize	   	move.w	#SrcOr,-(sp)	   	_PenMode		; on selectionne tous le texte		move.l	#0,-(sp)		move.l	#32767,-(sp)		move.l	G.SaisieTE,-(sp)		_TESetSelect			; on l'efface		MOVE.w	#$8,-(sp)							move.l	G.SaisieTE,-(sp)		_TEKey								move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_TexteHandle(a1),d0		; le type de TE 			bne		DoInsertText				; il y a du texte		move.l	#0,-(sp)	; pointeur du texte		move.l	#0,-(sp)	; longueur du texte				move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_StyleHandle(a1),-(sp)		move.l	G.SaisieTE,-(sp)		move.w	#7,-(sp)		;_teStylInsert		_TEDispatch				bra		DoSizeOftheTexte; --- 		DoInsertText		move.l	d0,A0		_Hlock		move.l	(a0),-(sp)	; pointeur du texte				move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_TexteHandle(a1),a0			_GetHandleSize		move.l	d0,-(sp)				move.l	G.Undo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_StyleHandle(a1),-(sp)		move.l	G.SaisieTE,-(sp)		move.w	#7,-(sp)		;_teStylInsert		_TEDispatchDoSizeOftheTexte; on attribut la taille des caractères; 9 pour durée et commentaire et 14 pour les autres		cmp.w	#Commentaire_SousTitre,G.saisieTeStItem	; commentaire		beq		PasModifTaille				cmp.w	#Duree_SousTitre,G.saisieTeStItem	; durée		beq		PasModifTaille				move.w	#14,4+texteStyle(a6)  ; taille des caractères dans la fenètre listing				move.w	#doSize,-(sp)		pea		texteStyle(a6)		move.w	#true,-(sp)  ; on redessine 		move.l	G.SaisieTE,-(sp)		move.w	#1,-(sp)			;_TeSetStyle		_TEDispatch		; on place le curseur à la fin du texte				move.l	#32767,-(sp)		move.l	#32767,-(sp)		move.l	G.SaisieTE,-(sp)		_TESetSelect		PasModifTaille		_PenNormal		; on dispose les pointeurs de l'undo 		move.l	G.Undo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_TexteHandle(a0),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_disposHandle		@1		move.l	G.Undo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_StyleHandle(a0),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_disposHandle@2						; maintenant on enlève l'élément dans la liste des undo; on décale la liste vers le haut.DecaleListeUndo				move.l	G.Undo_StackPtr,a0		add.l	#00002,A0		move.l	G.Undo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy				move.w	(a0,D0.w),(a0)		adda.l	#0000000002,a0		cmpa.l	a1,a0		bls		Loop_Copy						move.l	G.Undo_StackPtr,a0		move.w	(a0),d0		subq.w	#1,d0		move.w	d0,(a0)Exit					import	DrawSt_enCourDansListing			jsr		DrawSt_enCourDansListing			movem.l	(sp)+,d0-d7/a1-a4			UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.New	DoUseUndo			endP	* ================================================* PROCEDURE DoUseRedo();* ================================================; Cette routine effectue le Undo c'est à dire; qu'il prend l'élément en haut de la liste de Undo; et effectue le changement. En plaçant le dernier contenu; de l'élément sélectionner dans une table de Redo (même principe);;;	Undo sur les times code :;;	Entrée:;			N° de  l'élément Mêmechose que pour les TE;			ticks;			 N°du sous-titre Absolu ? (ou N° du sous-titre);			TimeCode  à sauvegarder / pointeur du TE;	Sortie: False/true si undo faitDoUseRedo	PROC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkVisRect			ds		RectTEStyleRecPtr	ds.l	1Startselection	ds.l	1EndSelection	ds.l	1ItemType		ds.w	1ItemHandle		ds.l	1itemRect		ds	RectTheEvent		DS	EventRecordtexteStyle		ds.b	12				; st style elementrectangle		ds	RectLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow,TransfertSaisieMemoire		IMPORT	UpdateControlsDansLaFenetre,DoMakeRedo,ConversionNumeroSTPointeur,CalculDuree		import	CentreListingWindow,TransfertMemoireSaisie,DoMakeRedo		WITH	StackFrame,Undo_Structure,SoustitreRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d0-d7/a1-a4,-(sp); on regarde si l'on a un pointeur de mémoire pour la liste undo			tst.l	G.Redo_StackPtr			beq		Exit		; Il n'y en a pas on ne fait rien		; on commence par regarder s'il y a un évènement dans la liste			move.l	G.Redo_StackPtr,a0			tst.w	(a0)			beq		Exit	; il n'y en a pas; on regarde si le n° de l'undo correspond au sous-titre en cour						adda.l	#0000002,a0			move.l	Undo_AbsST(a0),d7			cmp.w	G.General_SousTitreEncour,d7			beq		MemeSoustitre		; c'est le même sous-titre			; ----  ce n'est pas le même sous-titre on passe à celui qui doit ètre changé				jsr		TransfertSaisieMemoire		move.l	d7,d0		and.l	#$ffff,d0		move.w	d0,G.General_SousTitreEncour		and.l	#$ffff,d0		move.l	G.ListingVScroll,-(sp)		move.w	d0,-(sp)		_SetCtlValue		; il faut dire à QUICKDRAW que le port de la fenètre est listing		pea		G.ListingWindow		_SetPort			; initialisation de quick-draw de la police et tout et tout		MOVE.W		#SrcOr,-(SP)					; source mode		_TextMode		MOVE.W		#Monaco,-(SP)					; Monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace		move.w	#1,-(sp)	   	move.w	#1,-(sp)	   	_PenSize	   	move.w	#SrcOr,-(sp)	   	_PenMode				jsr		CentreListingWindow		pea		G.DialogSaisie		_SetPort		 ; 		jsr		AFFICHENUMSAISIE		jsr		TransfertMemoireSaisie		jsr		CalculDuree; ------------------------------------MemeSoustitre		; nous sommes dans le sous-titre en question; on prépare le redo; est-ce une time code BCD ?		move.l	G.Redo_StackPtr,a0		adda.l	#0000002,A0		cmp.w	#TimecodeIn_SousTitrebcd,Undo_Type(a0)		blo		DoRedoTexteEdit	; non c'est un texte edit				move.w	Undo_Type(a0),d0		case#.w	(d0,if),\				(TimecodeIn_SousTitrebcd,DoRedoTcIn),\				(TimecodeOut_SousTitrebcd,DoRedoTcout)		bra		Exit ; ---		; oui c'est un time code BCD; on recupère l'ancienne valeur; Redo Tc in		DoRedoTcIn	; on effecte le Redo		moveq	#0,d0		move.w	G.General_SousTitreEncour,d0		jsr		ConversionNumeroSTPointeur		move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_Data(a1),d0		move.l	d0,st_timeCodeIn(a0)				import	ForceUpdateWindow		jsr		ForceUpdateWindow				bra		DecaleListeUndo		; -----------; redo tc outDoRedoTcout		moveq	#0,d0		move.w	G.General_SousTitreEncour,d0		jsr		ConversionNumeroSTPointeur		move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_Data(a1),d0		move.l	d0,st_timeCodeOut(a0)				import	ForceUpdateWindow		jsr		ForceUpdateWindow				bra		DecaleListeUndo				; ----------------------------------		DoRedoTexteEdit		;Redo texte edit		; on regarde si la Fenêtre saisie est ouverte		lea		G.DialogSaisie,a0		tst.b	wVisible(a0)		bne.s	SaisieOuverte	; non saisie n'est pas ouverte; -----------------  on ouvre saisie  -------------		lea		G.DialogSaisie,a0				move.l	a0,-(sp)			move.w	#true,-(sp)		_ShowHide; on place la fenètre en bas de l'ecran						pea		rectangle(a6)		import	GetMainScreenRes		jsr		GetMainScreenRes				move.w	right+rectangle(a6),d1			sub.w	left+rectangle(a6),d1				lea		G.DialogSaisie,a4		move.w	right+portrect(a4),d0		sub.w	left+portrect(a4),d0		sub.w	d0,d1	; largeur de listing		lsr.w	#1,d1	; ÷2 pour calculer position en x		add.w	left+rectangle(a6),d1		move.w	d1,d6 				move.w	bottom+rectangle(a6),d0 ; y ,x début écran		lea		G.DialogSaisie,a4		move.w	bottom+portrect(a4),d1		sub.w	top+portrect(a4),d1		sub.w	d1,d0		sub.w	#1,d0				move.w	d0,d7		 		pea		G.DialogSaisie		move.w	d6,-(sp)		move.w	d7,-(sp)		move.w	#true,-(sp)		_MoveWindow		pea		G.DialogSaisie		_SetPort		lea		G.DialogSaisie,a0		pea		PortRect(a0)		_InvalRect; on dessine la fenètre		pea		G.DialogSaisie		import	DoUpdate		jsr		DoUpdate;--; saisie est ouverte SaisieOuverte; il y a t-il un TE ouvert dans saisie		tst.l	G.saisieTe		beq		OuvrirTE	; non il n'y en a pas on en ouvre un; il y a un te ouvert; on regarde si le texte Edit correspondant à l'undo est ouvert		move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.w	Undo_Type(a1),d7	; le type de TE 		cmp.w	G.saisieTeStItem,d7		beq		TeDejaOuvert		; c'est le même TE; on ferme le TE déjà ouvert		jsr		TransfertSaisieMemoire	OuvrirTE						; comme je suis fainéant j'utilise la routine saisie event		pea		G.DialogSaisie 		_setPort				move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.w	Undo_Type(a1),d7	; le type de TE 		move.w	d7,d0			add.w	#DialSaisie_TexteSTTEItem-1,d0	; on ajoute 12-1		pea		G.DialogSaisie 		move.w	d0,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem									pea		G.DialogSaisie 		_SelectWindow; on place les coordonnées du bouton 		lea		TheEvent(a6),a0				move.w	Top+itemRect(a6),d0		add.w	#5,d0		move.w	d0,top+evtMouse(a0)				move.w	left+itemRect(a6),d0		add.w	#5,d0		move.w	d0,left+evtMouse(a0)				pea		evtMouse(a0)		_LocalToGlobal; on appelle la routine MouseDownSaisie		pea		TheEvent(a6)		import	DoDialogSaisieEvent		jsr		DoDialogSaisieEvent		; le te est ouvertTeDejaOuvert		; on effectue le Redo; on y place le texte et le style placeTexteEtStyle		MOVE.W		#SrcOr,-(SP)					; source mode		_TextMode		MOVE.W		#Monaco,-(SP)					; Monaco		_TextFont		MOVE.W		#9,-(SP)						; 9 point		_TextSize		MOVE.W		#0,-(SP)						; plain		_TextFace		move.w	#1,-(sp)	   	move.w	#1,-(sp)	   	_PenSize	   	move.w	#SrcOr,-(sp)	   	_PenMode		; on selectionne tous le texte		move.l	#0,-(sp)		move.l	#32767,-(sp)		move.l	G.SaisieTE,-(sp)		_TESetSelect			; on l'efface		MOVE.w	#$8,-(sp)							move.l	G.SaisieTE,-(sp)		_TEKey								move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_TexteHandle(a1),d0		; le type de TE 			bne		DoInsertText				; il y a du texte		move.l	#0,-(sp)	; pointeur du texte		move.l	#0,-(sp)	; longueur du texte				move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_StyleHandle(a1),-(sp)		move.l	G.SaisieTE,-(sp)		move.w	#7,-(sp)		;_teStylInsert		_TEDispatch				bra		DoSizeOftheTexte; --- 		DoInsertText		move.l	d0,A0		_Hlock		move.l	(a0),-(sp)	; pointeur du texte				move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_TexteHandle(a1),a0			_GetHandleSize		move.l	d0,-(sp)				move.l	G.Redo_StackPtr,a1		adda.l	#0000002,a1		move.l	Undo_StyleHandle(a1),-(sp)		move.l	G.SaisieTE,-(sp)		move.w	#7,-(sp)		;_teStylInsert		_TEDispatchDoSizeOftheTexte; on attribut la taille des caractères; 9 pour durée et commentaire et 14 pour les autres		cmp.w	#Commentaire_SousTitre,G.saisieTeStItem	; commentaire		beq		PasModifTaille				cmp.w	#Duree_SousTitre,G.saisieTeStItem	; durée		beq		PasModifTaille				move.w	#14,4+texteStyle(a6)  ; taille des caractères dans la fenètre listing				move.w	#doSize,-(sp)		pea		texteStyle(a6)		move.w	#true,-(sp)  ; on redessine 		move.l	G.SaisieTE,-(sp)		move.w	#1,-(sp)			;_TeSetStyle		_TEDispatch		; on place le curseur à la fin du texte				move.l	#32767,-(sp)		move.l	#32767,-(sp)		move.l	G.SaisieTE,-(sp)		_TESetSelect		PasModifTaille		_PenNormal		; on dispose les pointeurs de l'undo 		move.l	G.Redo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_TexteHandle(a0),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_disposHandle		@1		move.l	G.Redo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_StyleHandle(a0),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_disposHandle@2						; maintenant on enlève l'élément dans la liste des undo; on décale la liste vers le haut.DecaleListeUndo		move.l	G.Redo_StackPtr,a0		add.l	#00002,A0		move.l	G.Redo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy				move.w	(a0,D0.w),(a0)		adda.l	#0000000002,a0		cmpa.l	a1,a0		bls		Loop_Copy						move.l	G.Redo_StackPtr,a0		move.w	(a0),d0		subq.w	#1,d0		move.w	d0,(a0)Exit					import		DrawSt_enCourDansListing			jsr		DrawSt_enCourDansListing			movem.l	(sp)+,d0-d7/a1-a4			UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.New	DoUseRedo			endP																								* ================================================* PROCEDURE ClearUndoListe();* ================================================;; Efface la liste des undoClearUndoListe	PROC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow,TransfertSaisieMemoire		IMPORT	UpdateControlsDansLaFenetre,DoMakeRedo,ConversionNumeroSTPointeur,CalculDuree		import	CentreListingWindow,TransfertMemoireSaisie,DoMakeRedo		WITH	StackFrame,Undo_Structure,SoustitreRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		move.l	G.Undo_StackPtr,d0		cmpa.l	#00000000,a0		beq		Exit			; pas de liste undo		move.l	d0,A0		tst.w	(a0)		beq		Exit			; pas de liste undoDecaleListeUndo; on regarde s'il faut disposer des handles				move.l	G.Undo_StackPtr,a0		adda.l	#00000002,a0		cmp.w	#TimecodeIn_SousTitrebcd,Undo_Type(a0)		blo		PasDisposeHandle	; type time code			; on dispose les pointeurs de l'undo 		move.l	G.Undo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_TexteHandle(a0),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_disposHandle		@1		move.l	G.Undo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_StyleHandle(a0),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_disposHandle@2						PasDisposeHandle				move.l	G.Undo_StackPtr,a0		add.l	#00002,A0		move.l	G.Undo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy				move.w	(a0,D0.w),(a0)		adda.l	#0000000002,a0		cmpa.l	a1,a0		bls		Loop_Copy						move.l	G.Undo_StackPtr,a0		move.w	(a0),d0		beq		Exit			; on a fini		subq.w	#1,d0		move.w	d0,(a0)				bra		DecaleListeUndoExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ClearUndoListe		endP		* ================================================* PROCEDURE ClearRedoListe();* ================================================;; Efface la liste des undoClearRedoListe	PROC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow,TransfertSaisieMemoire		IMPORT	UpdateControlsDansLaFenetre,DoMakeRedo,ConversionNumeroSTPointeur,CalculDuree		import	CentreListingWindow,TransfertMemoireSaisie,DoMakeRedo		WITH	StackFrame,Undo_Structure,SoustitreRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		move.l	G.Redo_StackPtr,a0		cmpa.l	#00000000,a0		beq		Exit			; pas de liste undo		tst.w	(a0)		beq		Exit			; pas de liste undoDecaleListeRedo; on regarde s'il faut disposer des handles				move.l	G.Redo_StackPtr,a0		adda.l	#00000002,a0		cmp.w	#TimecodeIn_SousTitrebcd,Undo_Type(a0)		blo		PasDisposeHandle	; type time code			; on dispose les pointeurs de l'undo 		move.l	G.Redo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_TexteHandle(a0),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_disposHandle		@1		move.l	G.Redo_StackPtr,a0		adda.l	#0000002,a0		move.l	Undo_StyleHandle(a0),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_disposHandle@2						PasDisposeHandle				move.l	G.Redo_StackPtr,a0		add.l	#00002,A0		move.l	G.Redo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy				move.w	(a0,D0.w),(a0)		adda.l	#0000000002,a0		cmpa.l	a1,a0		bls		Loop_Copy						move.l	G.Redo_StackPtr,a0		move.w	(a0),d0		beq		Exit			; on a fini		subq.w	#1,d0		move.w	d0,(a0)				bra		DecaleListeRedoExit		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ClearRedoListe		endP						* ================================================* PROCEDURE ManageUndoRedoListeForInsert();* ================================================;; Cette fonction réorganise la liste des undo/redo en fonction; d'un insert dans la liste des sous-titres ManageUndoRedoListeForInsert	PROC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointThe_ST			ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow,TransfertSaisieMemoire		IMPORT	UpdateControlsDansLaFenetre,DoMakeRedo,ConversionNumeroSTPointeur,CalculDuree		import	CentreListingWindow,TransfertMemoireSaisie,DoMakeRedo		WITH	StackFrame,Undo_Structure,SoustitreRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame				movem.l	d0-d7/a1-a4,-(sp)		move.l	G.Undo_StackPtr,a0		cmpa.l	#00000000,a0		beq		Exit			; pas de liste undo		tst.w	(a0)		beq		Exit			; pas de liste undo; on passe en revu les évènements dans la liste des undo		move.w	(a0),d7		subq.w	#1,d7		adda.l	#0000002,a0		; le premiers undo		Loop_ForDeleteST_Undo				move.l	Undo_AbsST(a0),d4		cmp.l	The_ST(A6),d4		blo		Passe_AuSuivant_Undo	; c'est avant l'insert on ne fait rien; c'est au dessus donc on incrémente de 1 le absNum				add.l	#1,Undo_AbsST(a0)Passe_AuSuivant_Undo				move.l	#(Undo_spare+8),d0		adda.l	d0,A0		dbra	D7,Loop_ForDeleteST_Undo;----------------------------------; la même chose pour le redo				move.l	G.Redo_StackPtr,a0		cmpa.l	#00000000,a0		beq		Exit			; pas de liste undo		tst.w	(a0)		beq		Exit			; pas de liste undo; on passe en revu les évènements dans la liste des undo		move.w	(a0),d7		subq.w	#1,d7		adda.l	#0000002,a0		; le premiers undo		Loop_ForinsertST_Redo		move.l	Undo_AbsST(a0),d4		cmp.l	The_ST(A6),d4		blo		Passe_AuSuivant_Redo	; c'est avant l'effacement on ne fait rien; c'est au dessus donc on incrémente de 1 le absNum				sub.l	#1,Undo_AbsST(a0)Passe_AuSuivant_Redo				move.l	#(Undo_spare+8),d0		adda.l	d0,A0		dbra	D7,Loop_ForinsertST_Redo		Exit	movem.l	(sp)+,d0-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ManageUndoRedoListeForInsert		endP						* ================================================* PROCEDURE ManageUndoRedoListeForDelete();* ================================================;;; Cette fonction réorganise la liste des undo/redo en fonction; d'un effacement dans la liste des sous-titres. ManageUndoRedoListeForDelete	PROC	export	StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointThe_ST			ds.l	1ParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linkLocalSize	EQU 	*			; size of all the local variables		ENDR				IMPORT	IsAppWindow,HiliteOnlyThisWindow,DrawListingWindow,TransfertSaisieMemoire		IMPORT	UpdateControlsDansLaFenetre,DoMakeRedo,ConversionNumeroSTPointeur,CalculDuree		import	CentreListingWindow,TransfertMemoireSaisie,DoMakeRedo		WITH	StackFrame,Undo_Structure,SoustitreRecord		; cover our local stack frame		LINK	A6,#LocalSize		; allocate our local stack frame		movem.l	d0-d7/a1-a4,-(sp)		move.l	G.Undo_StackPtr,d0		beq		Exit			; pas de liste undo		move.l	d0,A4		tst.w	(A4)		beq		Exit			; pas d'élement dans la liste undo; on passe en revu les évènements dans la liste des undo		move.w	(A4),d7		subq.w	#1,d7			; nombre d'évènement-1		move.l	#2,d0		; le premiers undo		adda.l	d0,A4		; le premiers undo		Loop_ForDeleteST_Undo				move.l	Undo_AbsST(A4),d4		cmp.l	The_ST(A6),d4		blo		Passe_AuSuivant_Undo	; c'est avant l'effacement on ne fait rien		beq		EffaceLe_Undo			; c'est l'évènement effacé; c'est au dessus donc on décrémente de 1 le absNum				sub.l	#1,Undo_AbsST(A4)		bra		Passe_AuSuivant_Undo;-------- on efface le undoEffaceLe_Undo		; on regarde s'il faut disposer les handles				cmp.w	#TimecodeIn_SousTitrebcd-1,Undo_Type(A4)		bhi	PasDisposeHandle_Undo	; type time code		; on dispose les pointeurs de l'undo 		move.l	Undo_TexteHandle(A4),d0		beq.s	@1	; pas de handle		move.l	d0,a0		_disposHandle		@1		move.l	Undo_StyleHandle(A4),d0		beq.s	@2	; pas de handle		move.l	d0,a0		_disposHandle@2						PasDisposeHandle_Undo; on efface ce undo de la liste				move.l	A4,a2		move.l	G.Undo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy_undo			move.w	(a2,D0.w),(a2)		adda.l	#0000000002,a2		cmpa.l	a1,a2		bls		Loop_Copy_undo				subq	#1,d7	; un st de moins			Passe_AuSuivant_Undo				move.l	#(Undo_spare+8),d0		adda.l	d0,A4		dbra	D7,Loop_ForDeleteST_Undo;----------------------------------; la même chose pour le redo				move.l	G.Redo_StackPtr,d0		beq		Exit			; pas de liste undo		move.l	d0,a4		tst.w	(a4)		beq		Exit			; pas de liste undo; on passe en revu les évènements dans la liste des undo		move.w	(a4),d7		subq.w	#1,d7		adda.l	#0000002,a4		; le premiers undo		Loop_ForDeleteST_Redo				move.l	Undo_AbsST(a4),d4		cmp.l	The_ST(A6),d4		blo		Passe_AuSuivant_Redo	; c'est avant l'effacement on ne fait rien		beq		EffaceLe_Redo			; c'est l'évènement effacé; c'est au dessus donc on décrémente de 1 le absNum				sub.l	#1,Undo_AbsST(a4)		bra		Passe_AuSuivant_Redo;-------- on efface le undoEffaceLe_Redo		; on regarde s'il faut disposer les handles				cmp.w	#TimecodeIn_SousTitrebcd-1,Undo_Type(a4)		bhi		PasDisposeHandle_Redo	; type time code		; on dispose les pointeurs du Redo 		move.l	Undo_TexteHandle(a4),d0		beq.s	@11	; pas de handle		move.l	d0,a0		_disposHandle		@11		move.l	Undo_StyleHandle(a4),d0		beq.s	@22	; pas de handle		move.l	d0,a0		_disposHandle@22						PasDisposeHandle_Redo; on efface ce Redo de la liste				move.l	a4,a2		move.l	G.Redo_StackPtr,a1				move.l	#(Undo_spare+8)*31+2,d0		add.l	d0,a1		move.l	#(Undo_spare+8),d0		Loop_Copy_Redo			move.w	(a2,D0.w),(a2)		adda.l	#0000000002,a2		cmpa.l	a1,a2		bls		Loop_Copy_Redo				subq	#1,d7	; un st de moins			Passe_AuSuivant_Redo				move.l	#(Undo_spare+8),d0		adda.l	d0,a4		dbra	D7,Loop_ForDeleteST_Redo		Exit	movem.l	(sp)+,d0-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ManageUndoRedoListeForDelete		endP						End