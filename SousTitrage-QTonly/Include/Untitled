			align 4				ENDP														* ========================================		* PROCEDURE	Transfert_BlockTTI_Soustitre()			* ========================================**	Cette routine convertie les caractères de block TTI vers des caractères*	Utilisés par Bon Bougre™, Que faire des systèmes Double Hauteur etc.. ???.**	Entrée: A0 contient le pointeur sur un block TTI*			A1 pointeur du sous-titre de destination (qui doit ètre créer avant cette routine)*	*Transfert_BlockTTI_Soustitre 		PROC	EXPORT		with	StackFrameImportationFichier,N19_GSI,N19_TTI,SOUSTITRERECORD		move.l	G.General_DernierSTPtr,a2		; pointeur du sous-titre en cour 		move.l	Pointeur(a6),a3					; pointeur du block TTI;------- on récupère le handle de la table de conversion.		move.l	G.ResourceDATA1000,a4		cmpa.l	#00000,a4		bne		ResourceExiste		; la resource existe		; on récupère la resource puisqu'elle n'est pas en mémoire				clr.l	-(sp)		move.l	#'DATA',-(SP)		move.W	#1000,-(SP)		_GetResource		suba.l	a4,a4		; on raz a4		move.L	(SP)+,D0		beq.s	TexteOuCommentaire			; la resource n'est pas présente		move.L	D0,G.ResourceDATA1000			move.l	d0,a4		ResourceExiste				move.l	(a4),a4					; Handle		;-------  Texte ou commentaireTexteOuCommentaire						cmp.b	#01,CF(a3)		; Drapeau de remarque ?		beq 	Commentaire		cmp.b	#00,CF(a3)		; Drapeau de texte ?		bne 	Exit			; pas texte on ignore le block TTI; --------------------------------------------------------------------; traitement du texteTexte	; on initialise la couleur par défaut du texte (noir à l'affichage Blanc à l'incrustation);		lea		texteStyle(a6),a0		move.w	#0,tsColor+red(a0)			move.w	#0,tsColor+blue(a0)			move.w	#0,tsColor+green(a0)	; on initialise la police par défaut		move.w	G.General_FontNumber,tsFont(a0); le style par défaut		clr.w	tsFace(a0); la taille par défault			; note cette valeur est changée entre les deux fenêtres listing et saisie		move.w	#9,tsSize(a0)	; 9 pour la fenètre listing; on raz les flags	du sous-titres		clr.l	st_Flags(a2); un ligne de texte				move.w	#1,st_Nlines(a2)		; on  détermine la longueur max du texte; pour déterminer le pointeur du style 		lea		TF(a3),a0		move.w	#111,d7			; longueur maxRecherche_Longueur_Texte_Loop		cmp.b	#$8f,(a0,d7.w)	; $8f octets non utilisé		bne.s	Found_LongueurTexte		dbra 	d7,Recherche_Longueur_Texte_Loop		moveq	#0,d7	; pas de caractèresFound_LongueurTexte		move.w	d7,d0		addq.w	#1,d0		; longueur du texte		ext.l	d0		import	AligneD0		jsr		AligneD0	; longueur du texte aligné sur mots long			add.l	#st_sizeOf,d0	; longueur du header du sous-titre			move.l	a2,a0		adda.l	d0,a0		move.l	a0,st_StylePTR(a2)	; pointeur du style rec					move.l	#st_sizeOf,d0	; longueur du header du sous-titre			move.l	a2,a1		adda.l	d0,a1			; pointeur du texte dans le sous-titre; on place un style neutre au début de ligne				move.w	#-1,-(sp)		; tous les parramètres		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	#0,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style		; ---- on recopie le texte dans le sous-titre 						lea		TF(a3),a3		moveq	#0,d6			; compteur pour écriture dans sous-titre		RecopieTexte_Loop				move.b	(a3)+,d0	; lecture d'un octets		; on détermine la signification du caractères		cmp.b	#$20,d0		blo 	Code_Teletexte				cmp.b	#$8f,d0		beq 	fin_recopie_texte; code de fin du texte				cmp.b	#$A0,d0		bhi.s	Caracteres		cmp.b	#$80,d0		blo.s	Caracteres; --------------------; c'est un code de contrôle $80 -> $a0		cmp.b	#$8a,d0			; retour chariot ?		bne.s	PasCr			; non		move.b	#$0d,(a1,d6.w)	; on place le retour chariot		add.w	#1,D6		add.w	#1,st_Nlines(a2)	; on augmente le nombre de ligne; on regaarde s'il est suivi par un autre CR (dans le cas d'une double hauteur !); il faudra vérifier si double hauteur #########		cmp.b	#$8a,(a3)		bne 	Fin_loop_Recopie_Texte	; non ce nest pas le cas; oui il y a un autre CR		move.b	(a3)+,d0	; on l'élimine		bra 	Fin_loop_Recopie_Texte	; non ce nest pas le cas	; -----PasCr	cmp.b	#$80,d0			; début italique		bne.s	Pas_DebutItalique; c'est l'attribut pour les italiques, on ajoute un style				move.w	#2,tsFace+texteStyle(a6)		; style italic		move.w	#doFace+doColor+doFont,-(sp)	; la fonction		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style		bra 	Fin_loop_Recopie_Texte; -----Pas_DebutItalique				cmp.b	#$81,d0			; fin italique ?		bne.s	Pas_FinItalique				move.w	#0,tsFace+texteStyle(a6)		; plus style		move.w	#doFace+doColor+doFont,-(sp)	; la fonction		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style				bra 	Fin_loop_Recopie_Texte; -----Pas_FinItalique; on ne gère pas les autres attributs (sous-lignage, emboîtage)				bra 	Fin_loop_Recopie_Texte; ---------------------------------------------------------; c'est un caractères affichable $20 -> $7f et $a1-> $FFCaracteres			; si char < $80 sauf $ on ne change rien		cmp.b	#'$',d0		bne.s	PasCaractereSpecial_txt		move.b	#'€',(a1,d6.w)	; on place le caractère		add.w	#1,D6			bra 	Fin_loop_Recopie_Texte; -----PasCaractereSpecial_txt				cmp.b	#$7f,d0		bhi		Conversion_caractere_Txt		move.b	d0,(a1,d6.w)	; on place le caractère		add.w	#1,D6			bra 	Fin_loop_Recopie_Texte		; -----		; il faut effectuer une conversion Conversion_caractere_txt				bsr		ConversionChar		move.b	d0,(a1,d6.w)	; on place le caractère		add.w	#1,D6					bra 	Fin_loop_Recopie_Texte		; ---------------------------------------------------------; c'est un code de contrôle Teletexte >$20Code_Teletexte;		bra 	Fin_loop_Recopie_Texte	; ############ !!!!!!!!!!!!!!				cmp.b	#$07,d0			; alphaNoir ?		bra.s	Pas_Alpha;		bhi.s	Pas_Alpha	; ################; couleur des caractères		lea		tableCouleur(pc),a0		and.l	#$7,d0		mulu	#6,d0	; poiteur sur la couleur		move.w	red(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+red(a6)		move.w	green(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+green(a6)		move.w	blue(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+blue(a6)						move.w	#doColor,-(sp)	; uniquement couleur		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style				bset	#9,st_Flags(a2)	; couleur type teletext				bra.s		Fin_loop_Recopie_Texte; table de conversion couleurs ceefax => RBGColor 		tableCouleur			dc.w	$0000,$0000,$0000	; noir		dc.w	$8080,$0000,$0000	; rouge		dc.w	$0000,$8080,$0000	; vert		dc.w	$8080,$8080,$0000	; jaune		dc.w	$0000,$0000,$ffff	; bleu		dc.w	$8080,$0000,$8080	; magenta		dc.w	$0000,$8080,$8080	; cyan		dc.w	$ffff,$ffff,$ffff	; blanc; -------		Pas_Alpha				cmp.b	#$0c,d0					; hauteur normale ?		beq.s	Fin_loop_Recopie_Texte	; par défaut; -------				cmp.b	#$0d,d0					; double hauteur ?		bne.s	pas_DoubleHauteur		; non				bset	#11,st_Flags(a2)			; double hauteur 		bra.s	Fin_loop_Recopie_Texte	; -------		pas_DoubleHauteur			cmp.b	#$0e,d0					; double largeur ?		bne.s	pas_DoubleLargeur		; non				bset	#10,st_Flags(a2)			; double largeur		bra.s	Fin_loop_Recopie_Texte	; -------pas_DoubleLargeur		cmp.b	#$0e,d0					; double taille ?		bne.s	Fin_loop_Recopie_Texte	; non				bset	#10,st_Flags(a2)			; double largeur		bset	#11,st_Flags(a2)			; double hauteur Fin_loop_Recopie_Texte		dbra	d7,RecopieTexte_Loopfin_recopie_texte	; on regarde s'il y a un cr à la fin du texte; si oui on l'élimine		cmp.b	#$0d,-1(a1,d6.w)		bne.s	PasDeCr_alafindutexte				move.w	st_Nlines(a2),d0		sub.w	#1,d0			beq.s	LaisseUneLigne		; il faut une ligne au moins, que diable !		move.w	d0,st_Nlines(a2)LaisseUneLigne				subQ.w	#1,d6						; on ne peut pas faire dbra		bne		fin_recopie_texte		PasDeCr_alafindutexte		and.l	#$ffff,d6		bne.s	ChainePAsVide		; si texte vide pas de style				clr.l	st_StyleLenth(a2)		clr.l	st_StylePtr(a2)		ChainePAsVide				move.l	d6,st_TexteLenth(a2)		bra		Fin_Block_TTI; -------------------------------------------------; traitement des commentaireCommentaire		bra		Fin_Block_TTI		; --------------------------------------------------------------; On regarde l'état du parramètre d'extension EBN du block TTIFin_Block_TTI; faut-il prendre le tc ; on prend le tc du premier block TTI ? 		move.l	Pointeur(a6),a3					; pointeur du block TTI		cmp.b	#1,CS(a3)		bhi 	PasPremier_BlockTTI; on récupère le tc in		lea		TCI(a3),a0		import	Conversion_TCN19__Bcd		jsr		Conversion_TCN19__Bcd		move.l	d0,st_TimeCodeIn(a2)		; on récupère le tc Out		lea		TCO(a3),a0		import	Conversion_TCN19__Bcd		jsr		Conversion_TCN19__Bcd		move.l	d0,st_TimeCodeOut(a2)		; on récupère la position verticale du sous-titre		moveq	#0,d0		move.b	VP(A3),d0		clr.w	st_YOffset(A2); ##		move.w	d0,st_YOffset(A2); on indique que c'est une position verticale télétexte				move.w	st_flags(a2),d0		bset	#12,d0		move.w	d0,st_flags(a2)				; on récupère la justification du sous-titre		lea 	tableConversionJustif(pc),a0		moveq	#0,D0		move.b	JC(A3),d0		cmp.b	#4,d0	; on prévient les erreurs		blo.s	@SupJustif		moveq	#2,D0@SupJustif				move.b	(a0,d0.w),d0		move.b	d0,st_Justification(a2)						; maintenant on regarde s'il faut remonter les sous-titres; c'est à dire que la position de départ est différentes		; on regarde si ce sont des caractères double-hauteur		; si double hauteur départ en ligne 22; si simple hauteur départ en ligne 23		string pascal		Pea		#'Verif hauteur soustitre'		_DebugSTR						btst	#11,st_Flags(a2)			; double hauteur 		beq.s	Pas_double_Hauteur		move.b	VP(A3),d0		; c'est une double hauteur		move.l	#24,D0		sub.b	VP(A3),d0		divu	#2,D0; nombre de ligne		sub.w	st_Nlines(a2),d0				bra.s	Add_CR; -----Pas_double_Hauteur		move.w	#23,D0		sub.b	VP(A3),d0Add_CR; on additionne des cr à la fin du texte		tst.l	st_TexteLenth(a2)		beq		PasPremier_BlockTTI ; si pas de texte pas de cr en plus 				tst.w	d0		beq.S	PasPremier_BlockTTI; pas de cr		lea		(a1,D6.w),A1; on ajoute le nombre de ligne // nombre de cr				add.w	d0,st_Nlines(A2)		subq.w	#1,d0Add_CR_loop		addi.l	#1,st_TexteLenth(a2)		move.b	#$0d,(a1)+		dbra	d0,Add_CR_loop								PasPremier_BlockTTI		cmp.b	#$ff,EBN(a3)				; dernier Block TTI ?		bne.s	Exit						; non		; on calcule la taille du sous-titre		move.l	st_stylePtr(a2),d0		beq.s	pasdestyle		sub.l	a2,d0				; début du sous-titre		sub.l	#st_sizeOf,d0		; espace aloué au texte				move.l	st_styleLenth(a2),d1	; taille des styles		import	aligned1		jsr		aligned1		add.l	d1,d0pasdestyle		move.l	st_CommentaireLenth(a2),d1		import	aligned1		jsr		aligned1		add.l	d1,d0		add.l	#8,d0		; en secu			move.l	d0,st_LenthST(a2)	; longueur du sous-titre		; oui on insert un sous-titre	pour le prochain ST				move.l	a2,a0		move.l	#0,d0		import	InsertST		jsr		InsertSTExit	rts; sous-routine de conversion caractère N19 => mac; a4 pointe sur la table de conversionConversionChar		movem.l	a4,-(sp)		; on sauvegarde a4		move.b	d0,d1				and.b	#$F0,d1		cmp.b	#$c0,d1		beq.s	accentuation; c'est un caractère simpleLoop_Recherche_Single_Char				move.w	2(a4),d1				; code n19			beq.s	Exit_Conv_char			; fin de la table pas trouvé on sort directement		cmp.b	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.S	Loop_Recherche_Single_CharFound_The_Char		move.b	1(a4),d0Exit_Conv_char		movem.l	(sp)+,a4		; récupération a4		rts; --------------------------------------	; c'est une accentuation		accentuation		; on lit le caractère suivant		asl.w	#8,d0		; code accent b15-b8		move.b	(a3)+,d0	; lecture d'un octets	(le caractère b7-b0)Loop_Recherche_double_Char				move.w	2(a4),d1				; code n19			beq.s	Exit_Conv_char			; fin de la table,on sort avec le caractère simple dans d0		cmp.w	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.S	Loop_Recherche_double_ChartableConversionJustif			dc.b	00	; 0= centrée			dc.b	01	; gauche			dc.b	00	; centrée			dc.b	02	; justif droite						dc.b	02	; 0= centrée			dc.b	01	; 1= gauche			dc.b	03	; 2=Droite			dc.b	00	; 		DbgInfo.new	Transfert_BlockTTI_Soustitre		align 4			ENDP						* ================================================* PROCEDURE		Add_style()* ================================================; Cette routine ajoute un style dans un sous-titre; si le style existe déja, il change les  parramètres désignée par Fonct_demande;;				SEG	'Conversions'			; case sensitiveAdd_style	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFonct_demande		ds.w	1	; la fonctionThe_StyleRec		ds.l	1	; le recordSTPtr				ds.l	1	; le sous-titreStartChar			ds.w	1	; la position de départ du styleParamSize			EQU	ParamBegin-*				; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,SOUSTITRERECORD		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				import	ConversionTrames_TimeCode,CopySTR		movem.l	d0-d7/a1-a4,-(sp)	; sauvegarde des registres		; on commence par déterminer s'il ya un style à la position demandée			move.l	stPtr(a6),d0		beq		Exit			; Pas de pointeur de sous-titre on ne fait rien		move.l	d0,a4		move.l	st_StylePtr(A4),d0		beq		Exit			; pas de pointeur de style ; on ne fait rien pour l'instant		move.l	d0,A3			; pointeur du style; on regarde le nombre de style			tst.l	st_styleLenth(a4)		beq		Nouveau_Style_Vierge	; il n'y a pas de style on en ajoute 1				move.w	(a3),d7		; nombre de style en mémoire; on recherche s'il y a un style du même numéro		subq.w	#1,d7		move.w	d7,d0		mulu	#20,d0		; offset dans la table		move.l	a3,a2		adda.l	#0000002,a2			adda.l	d0,a2		; dernier styleLoop_recherche_Style				move.w	StartChar(a6),d6		and.l	#$ffff,d6		cmp.l	scrpStartChar(a2),d6		beq		Found_Same_style		bhi		Found_style_Sup				suba.l	#00000020,a2			; style précédent		dbra	d7,Loop_recherche_Style; si nous sommes ici dans la boucle c'est qu'il y a un pb; --------- on ajoute un nouveau style ---------------Nouveau_Style	; on créer un style		move.l	a3,a0	; pointeur de style		move.w	(a0),d0	; nombre de style		addq.w	#1,d0		move.w	d0,(a0)+	; nombre de style +1		; on recopie le style précédent		mulu	#20,d0		adda.l	d0,a0		move.l	a0,a3		; on sauvegarde le pointeur de style				move.l	a0,a1		; le nouveau style				sub.l	#00020,a0	; l'ancienne valeur		move.l	#20,d0		_BlockMove				move.l	a3,a0	;on récupère le pointeur de style		bsr		Fill_The_Style	; on place les attributs demandés		add.l	#20,st_StyleLenth(a4)	; longueur des styles		bra		Exit; --------- on créer un  style ---------------Nouveau_Style_Vierge		move.l	a3,a0	; pointeur de style		move.w	#1,(a0)+	; nombre de style		move.w	#-1,Fonct_demande(a6)		bsr		Fill_The_Style	; on place les attributs demandés		move.l	#22,st_StyleLenth(a4)	; longueur des styles+octet de nombre		bra		Exit; -----------------------------------------; il y a déja un style à cette position de style; on replace le par les nouvelles valeurs demandée; d7 contient le nombre de style à changer; a2 pointe sur le style en questionFound_Same_style		move.l	a2,a0		bsr		Fill_The_Style	; on place le style		bra		Exit; -----------------------------------------; la position du caractère n'existe pas dans les styles; Il faut insérer un style avant celui pointé par a2Found_style_Sup; on recopie le style précédent				move.l	a2,a0	; source		move.l	a2,a1			move.l	#20,d0		adda.l	d0,a1	; destination		move	#20,d0		; taille du déplacement				_BlockMove			; déplacement		add.w	#1,(a3)		; un style de plus		move.L	a1,a0		; on insère le style		bsr		Fill_The_Style	; on place le style		add.l	#20,st_StyleLenth(a4)	; longueur des styles				Exit	movem.l	(sp)+,d0-d7/a1-a4	; récupération des registres		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller; routine pour changer le style; A0 pointe sur le style Fill_The_Style		move.w	StartChar(a6),d6		and.l	#$ffff,d6		move.l	d6,scrpStartChar(a0)				move.l	The_StyleRec(a6),a1	; the style rec		; changement de font	?		move.w	Fonct_demande(a6),d0		and.w	#DoFont,d0		beq.s	Do_Size		; non		move.l	tsFont(a1),scrpFont(a0)			; Changement de tailleDo_Size			move.w	Fonct_demande(a6),d0		and.w	#DoSize,d0		beq.s	Do_Face		; non		move.w	tsSize(a1),scrpSize(a0)			; Changement de styleDo_Face			move.w	Fonct_demande(a6),d0		and.w	#DoFace,d0		beq.s	Do_Color		; non		move.b	tsFace+1(a1),scrpFace(a0)			move.b	tsFace+1(a1),scrpFace+1(a0)			; Changement de couleurDo_Color			move.w	Fonct_demande(a6),d0		and.w	#DoColor,d0		beq.s	Exit_sub		; non		 		move.w	tsColor+red(a1),scrpColor+red(a0) 		move.w	tsColor+green(a1),scrpColor+green(a0) 		move.w	tsColor+blue(a1),scrpColor+blue(a0)Exit_sub			move.w	scrpSize(a0),d0			move.w	d0,scrpAscent(a0)		; au pif		move.w	d0,d1		lsr.w	#1,d2		and.w	#$00ff,d1		add.w	d1,d0			move.w	d0,scrpHeight(a0)		; au pif		rts		DbgInfo.new		Add_style	; this name will appear in the debugger		align 4			ENDP* ========================================		* PROCEDURE	Rafraichi_Curseur()			* ========================================** Cette routine rafraichie le dialogue de progression de lecture du fichierRafraichi_Curseur 		PROC	EXPORT						with	StackFrameImportationFichier,N19_GSI,N19_TTI						import	SpinCursor; on effectue le rafraichissement du dialog; on calcule la position en x de la reglette		move.l	pointeur(a6),d0		SUB.L	BufferTransfer(A6),D0		lsr.l	#3,d0; multiplication 32*16 => 32 bits		move.l	d0,d1		move.w	LargeurReglette(a6),d2		and.l	#$fff,d2			swap	d1		and.l	#$ffff,d1		mulu.w	d2,d1		swap	d1		and.l	#$ffff0000,d1		and.l	#$ffff,d0		mulu	d2,d0		add.l	d1,d0		; resultat sur 32 bits dans d0		move.w	LongueurFichier(a6),d1		divu	d1,d0	; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas		move.w	d0,LastXpos(a6)				BSR		Draw_Reglette 		move.w	#32,-(sp)  		JSR	SpinCursor	; spin the ball		move.l	#BlueColor,-(sp)		_ForeColor				_PenNormal		:				; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.l	G.General_NombreSt,d0		cmp.l	#704,d0				lea		buff2(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff2(a6)		_DrawString					onnedessinepas		Exit	rts		Draw_Reglette; cette routine rafraichie la reglette				move.l	d0,d6		; sécu de la valeur				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	LastXpos(a6),d0		cmp.w	left+itemRect(a6),d0		bhi.s	@123		move.w	left+itemRect(a6),d0@123				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts						DbgInfo.new	Rafraichi_Curseur		align 4			ENDP				* ========================================		* PROCEDURE	Conversion_TCN19__Bcd()			* ========================================** Cette routine convertie le format de time code de la norme N19* vers le format utilisé par le logiciel** entrée: a0 pointe sur la chaîne tc N19	; * sortie: D0 contient le tc en BCD***Conversion_TCN19__Bcd 		PROC	EXPORT						with	StackFrameImportationFichier,N19_GSI,N19_TTI						import	SpinCursor		movem.l	d1,-(sp)						moveq	#0,d0; heure				moveq	#0,d1		move.b	(a0),d1				divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0		asl.l	#4,d0; minute				moveq	#0,d1		move.b	1(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0				asl.l	#4,d0;seconde				moveq	#0,d1		move.b	2(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0				asl.l	#4,d0				;images				moveq	#0,d1		move.b	3(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0		Exit	movem.l	(sp)+,d1		rts				DbgInfo.new	Conversion_TCN19__Bcd		align 4			ENDP								* ===============================================*	Procedure	ExportationDeFichier_N19()* ===============================================; Cette procédure exporte le fichier en cour dans la norme N19;StackFrameExportN19	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètreReply				ds.l	1	; nom du fichierParamSize	EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	256	; buffer temporaire	n°2ItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1DateTime			ds		DateTimeRecBlockGSI			ds.b	1028		; le block GSISTPtr				ds.l	1			; pointeur du sous-titre en courRGB_Color			ds.W	3			; pour la reglettePopUp_PaysOrigine	ds.l	1			; NombreTotalST		ds.w	1TheDialogPtr		ds.l	1; attributs caarctère// charactèresthejust			ds.w	1			; la justification du textethestyle		ds.w	1			; le style en courstheLaststyle	ds.w	1			; le dernier style utiliséNextStyle		ds.l	1			; pointeur du prochain style theChar			ds.w	1			; le caractèretheFont			ds.w	1			; la policeThe_color		ds.w	3			; rgbColorLocalSize	EQU 	*			; size of all the local variables		ENDRExportationDeFichier_N19			PROC	EXPORT		WITH	StackFrameExportN19,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame		with	N19_GSI,N19_TTI,DateTimeRec; on utilise le même stackframe		LINK	A6,#LocalSize		; allocate our local stack frame				import	ConversionNumeroSTPointeur,TraitementErreurFichier,\				AFFICHENUMSAISIE,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR					; on ouvre un dialogue pour indiquer à l'utilisateur que nous sommes en train d'Exporter; un fichier au norme N19									clr.l	-(sp)			move.w	#138,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)			_DrawDialog						move.l	TheDialogPtr(a6),-(sp)			_SetPort		; on dit que c'est pour exporter un fichier N19				move.l	TheDialogPtr(a6),-(sp)			move.w	#5,-(sp)	; item 5			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	ItemHandle(a6),-(sp)			pea	#'Exportation de fichier  N19-1991'			_SetItext					move.l	TheDialogPtr(a6),-(sp)			move.w	#9,-(sp)	; item 9			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem								move.l	ItemHandle(a6),-(sp)			pea	#'        '			_SetItext							; on affiche le nom du fichier				move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						move.l	ItemHandle(a6),-(sp)			move.l	Reply(a6),-(sp)			_SetItext							; on trace la ligne sous le titre			move.l	TheDialogPtr(a6),-(sp)			move.w	#4,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						_penNormal						move.w	#SrcCopy,-(sp)			_TEXTMode					pea		itemRect(a6)			_FrameRect				;on entoure la reglette				move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem								_penNormal						pea		itemRect(a6)			_FrameRect						move.w	right+itemRect(a6),d0			sub.w	left+itemRect(a6),d0			sub.w	#6,d0			move.w	d0,LargeurReglette(a6)									move.w	bottom+itemRect(a6),bottom+rectangle(a6)			subq.w	#2,bottom+rectangle(a6)			move.w	top+itemRect(a6),top+rectangle(a6)			addq.w	#2,top+rectangle(a6)						move.w	left+itemRect(a6),left+Rectangle(a6)			add.w	#2,left+rectangle(a6)				move.l	TheDialogPtr(a6),-(sp)			move.w	#2,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		NombreSTLusRect(a6)			_GetDItem						move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem		; on récupère la table de conversion mac N19;------- on récupère le handle de la table de conversion.		move.l	G.ResourceDATA1000,a4		cmpa.l	#00000,a4		bne		ResourceExiste		; la resource existe		; on récupère la resource puisqu'elle n'est pas en mémoire				clr.l	-(sp)		move.l	#'DATA',-(SP)		move.W	#1000,-(SP)		_GetResource		suba.l	a4,a4		; on raz a4		move.L	(SP)+,D0		move.L	D0,G.ResourceDATA1000			ResourceExiste				; On Génère le block d'information GSI;------------ on transfère les attributs généraux; transfert des nom de film etc...						lea		BlockGSI(a6),a4		; buffer pour le block gsi; on raz le block GSI			move.w	#1024,d0			subq.w	#1,d0LoopClearGSI			move.b	#' ',(a4)+			dbra	d0,LoopClearGSI						lea		BlockGSI(a6),a4		; buffer pour le block gsi; -------- on place le n° de page de code			move.b	#'8',cpn(a4)			move.b	#'5',cpn+1(a4)			move.b	#'0',cpn+2(a4)			; -------- on place le code du format de disquette DFC			move.b	#'S',3(a4)			move.b	#'T',3+1(a4)			move.b	#'L',3+2(a4)			move.b	#'2',3+3(a4)			move.b	#'5',3+4(a4)			move.b	#'.',3+5(a4)			move.b	#'0',3+6(a4)			move.b	#'1',3+7(a4); -------- on place le type norme d'affichage			move.b	#'0',DSC(a4)	; sous-titrage ouvert			move.w	G.Preference_N19_TypeTeletexte,d0			beq.S	@1						move.b	#'1',DSC(a4)	; télétexte niveau 1@1; --- on place le code caractère				move.w	G.CodeCaractere,d0						sub.w	#1,d0			add.w	#$30,d0			move.b	d0,CCT+1(a4)			move.b	#'0',CCT(a4)			; --- lecture code de langue												Pea		buff1(a6)			move.w	#130,-(sp)			move.w	G.CodeLangue,-(sp)			import	GetIndString			jsr		GetIndString			move.w	buff1+1(a6),d0			move.w	d0,LC(a4)			; --- lecture du pays d'origine									clr.l	-(sp)			move.w	#2007,-(sp)			_GetRMenu			move.l	(sp)+,PopUp_PaysOrigine(a6)						move.w	G.PaysOrigine,d0						move.l	PopUp_PaysOrigine(a6),-(sp)			move.w	d0,-(sp)			pea		Buff1(a6)			_GetItem			; on recherche la parenthèse			lea		buff1+1(a6),a0			moveq	#0,d6				move.b	buff1(a6),d6	; nombre max de char			RechercheParenthese_Loop						cmp.b	#'(',(a0,d6.w)			beq.s	Found_Parenthese			dbra	d6,RechercheParenthese_Loop				bra.s	Titre_original_Programme	; pas trouvé (			; On place les trois lettres dans le block GSIFound_Parenthese								lea		1(a0,d6.w),a0			lea		CO(a4),a1			move.b	(a0)+,(a1)+			move.b	(a0)+,(a1)+			move.b	(a0)+,(a1)+			; -------- on recopie le titre original du programmeTitre_original_Programme			lea	G.Preference_TitreOriginal,a0			lea		OPT(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le titre original de l'épisodeTitre_original_Episode						lea	G.Preference_TitreEpisodeOriginal,a0			lea		OET(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie la traduction titre original du programmeTraduction_Titre_original_programme			lea	G.Preference_TitreFrancais,a0			lea		TPT(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie la traduction titre original de l'épisodeTraduction_Titre_original_Episode						lea	G.Preference_TitreEpisodeTraduit,a0			lea		TET(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC; -------- on recopie Le nom du traducteurNom_du_traducteur						lea	G.Preference_NomAdaptateur,a0			lea		TN(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie Les coordonnées du traducteurCoordonnees_du_traducteur						lea	G.Preference_CoordonneesAdaptateur,a0			lea		TCD(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le code de référence de la liste des sous-titresCode_de_reference			lea	G.CodeDeReference,a0			lea		SLR(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC						; ------- Date de création			move.l	G.DateDeCreation,d0			lea		Buff1(A6),a0			_Secs2Date			lea		Buff1(A6),a0			moveq	#0,D0			move.w	Year(a0),d0			lea		Buff2(A6),a0			clr.w	-(sp)			_PacK7						lea		Buff2(A6),a0			move.b	3(A0),CD(a4)			move.b	4(A0),CD+1(a4)						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Month(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+2(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+3(a4)						moveq	#0,D0			move.w	Day(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+4(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+5(a4); ------- Date de révision						move.l	G.ModifieLe,d0			lea		Buff1(A6),a0			_Secs2Date						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Year(a0),d0			lea		Buff2(A6),a0			clr.w	-(sp)			_PacK7						lea		Buff2(A6),a0			move.b	3(A0),RD(a4)			move.b	4(A0),RD+1(a4)						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Month(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+2(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+3(a4)						moveq	#0,D0			move.w	Day(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+4(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+5(a4)			; ------- Numéro de la révision			moveq	#0,d1			move.w	G.Revision,d1			divu.w	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RN(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RN+1(a4)			; -------- on recopie l'éditeur de la liste des sous-titreEditeur_liste						lea		G.EditeurListe,a0			lea		PUB(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le nom du monteur de la liste des sous-titreMonteur_liste						lea		G.NomDuMonteur,a0			lea		EN(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC; -------- on recopie les coordonnées du monteur de la liste des sous-titreCoordonnee_Monteur_liste						lea		G.CoordonneeMonteur,a0			lea		ECD(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			* ###* ###	Il faudrait en théorie faire du code pour gérer plusieures disquettes* ###		; ----   on place ne nombre de disquette		move.b	#'1',TND(a4)	; un disquette; ----   le numéro d'ordre de la disquette		move.b	#'1',DSN(a4)PasErreurNumeroDisquette; ----    on place Le nombre de block TTI pour cette disquette			move.l	G.General_NombreST,d0			lea		Buff1(a6),a0			clr.w	-(sp)			_Pack7						move.b	#'0',TNB(a4)			move.b	#'0',TNB+1(a4)			move.b	#'0',TNB+2(a4)			move.b	#'0',TNB+3(a4)			move.b	#'0',TNB+4(a4)			moveq	#0,d0			move.b	Buff1(a6),d0			beq		Nombre_ST						lea		TNB+5(a4),a1			lea		Buff1+1(a6),a0			adda.l	d0,a0			subq.W	#1,d0loop_NumberTTI			move.b	-(a0),-(a1)			dbra	d0,loop_NumberTTI							; ----    Le nombre de sous-titre pour cette disquette; on converti ascii décimal => binaireNombre_ST			move.l	G.General_NombreST,d0			lea		Buff1(a6),a0			clr.w	-(sp)			_Pack7						move.b	#'0',TNS(a4)			move.b	#'0',TNS+1(a4)			move.b	#'0',TNS+2(a4)			move.b	#'0',TNS+3(a4)			move.b	#'0',TNS+4(a4)			moveq	#0,d0			move.b	Buff1(a6),d0			beq		Nombre_ST			lea		TNS+5(a4),a1			lea		Buff1+1(a6),a0			adda.l	d0,a0			subq.W	#1,d0loop_NumberST			move.b	-(a0),-(a1)			dbra	d0,loop_NumberST@1			; ----    Le nombre de Groupe de sous-titre pour cette disquette; on converti ascii décimal => binaire						move.b	#'0',TNG(a4)			move.b	#'0',TNG+1(a4)			move.b	#'0',TNG+2(a4)			;Nombre maximum de lignes						move.b	#'2',MNR(a4)			move.b	#'3',MNR+1(a4)			;Nombre maximal de caractères par ligne			move.b	#'4',MNC(a4)			move.b	#'0',MNC+1(a4)			; ----   Le time code début du programme			move.l	G.TcDebutFilm,d0			lea		buff1(a6),A0			import	ConversionTCstASCII			jsr		ConversionTCstASCII			lea		buff1(a6),A0			Lea 	TCP(a4),a1			move.b	1(a0),(A1)			move.b	2(a0),1(A1)			move.b	4(a0),2(A1)			move.b	5(a0),3(A1)			move.b	7(a0),4(A1)			move.b	8(a0),5(A1)			move.b	10(a0),6(A1)			move.b	11(a0),7(A1); ----   Le premier st du programme			lea		buff1(a6),A0			move.l	G.General_PremierTC,d0			import	ConversionTCstASCII			jsr		ConversionTCstASCII 						lea		buff1(a6),A0			Lea 	TCF(a4),a1			move.b	1(a0),(A1)			move.b	2(a0),1(A1)			move.b	4(a0),2(A1)			move.b	5(a0),3(A1)			move.b	7(a0),4(A1)			move.b	8(a0),5(A1)			move.b	10(a0),6(A1)			move.b	11(a0),7(A1); ----  Le status du time code			move.b	#'1',TCS(a4)		; utilisation prévu du time code			; on écrit le block TTI dans le fichier						move.l	paramBlock(a6),a0			move.l	#1024,ioReqCount(a0)			move.l	a4,ioBuffer(a0)			move.w	#fsfromStart,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						; maintenant on effectue l'écriture des blocks TTI 			; ---------------- Ecriture du fichier ----------------------------						; boucle nombre de diskette ; boucle nombre de sous-titre ; initialisation			move.l	G.BufferTransfert,Pointeur(a6)			sub.l	#128,Pointeur(a6)	; pour la boucle						move.l	G.SIZEBufferTransfert,D7			move.l	G.General_PremierSTPtr,STPtr(a6)	; le premier sous-titre			move.l	st_AbsNUMST,d0			move.w	d0,NombreTotalST(a6)			; -------	boucle de recopie des sous-titresLoop_Nombre_de_Soustitre						add.l	#128,Pointeur(a6)	; block TTI suivant			; a t-on rempli le buffer de transfert ?			move.l	G.BufferTransfert,d0			add.l	G.SIZEBufferTransfert,d0			sub.l	#256,d0						; taille du buffer- 256 octets						cmp.l	Pointeur(a6),d0						bhi.s	PasRempliBuffer						; on écrit le buffer dans le fichier						move.l	paramBlock(a6),a0			move.l	Pointeur(a6),d0			;l'octet suivant le dernier block TTI fabriqué			sub.l	G.BufferTransfert,d0			move.l	d0,ioReqCount(a0)			move.l	G.BufferTransfert,ioBuffer(a0)			move.w	#fsatMark,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						move.l	G.BufferTransfert,Pointeur(a6)PasRempliBuffer			;le block TTI est entier donc nous le plaçons dans un sous-titreTTI_EnEntier 			import	Transfert_Soustitre_BlockTTI	; ## on utilise la même pile 			jsr		Transfert_Soustitre_BlockTTI		; incrémentation du curseur du dialogue			bsr		Rafraichi_Curseur_ExportN19; fin de boucle block TTI			move.l	STPtr(a6),a0			move.l	st_NextST(a0),d0			beq.S	PlusDeSous_titre	; c'est fini			move.l	d0,STPtr(a6)			Sub.w	#1,NombreTotalST(a6)			bne.s	Loop_Nombre_de_Soustitre		PlusDeSous_titre; fin de boucle disquette			move.l	paramBlock(a6),a0			move.l	Pointeur(a6),d0			sub.l	G.BufferTransfert,d0			add.l	#128,d0			move.l	d0,ioReqCount(a0)		; dernier block TTI +128 octets			move.l	G.BufferTransfert,ioBuffer(a0)			move.w	#fsatMark,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						move.l	paramBlock(a6),a0			move.l	46(a0),d0	;ioPosOffset			move.l	d0,28(a0)	; iomisc			_SetEOFexit		move.l	TheDialogPtr(a6),-(sp)			_DisposDialog			PEA	QD.Arrow		; got arrow cursor at InitGraf			_SetCursor								UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.new		ExportationDeFichier_N19	; this name will appear in the debugger			align 4				* --- Cette routine rafraichie le dialog de progression d'écriture du fichier type N19Rafraichi_Curseur_ExportN19 ; on effectue le rafraichissement du dialog; on calcule la position en x de la reglette		move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d0		mulu	LargeurReglette(a6),d0				move.l	G.General_NombreST,d1		divu	d1,d0	; resultat dans d0				cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas				move.w	d0,LastXpos(a6)		; on dessine la reglette								bsr		Draw_Reglette		; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d0				lea		buff2(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff2(a6)		_DrawString					onnedessinepas				rts						Draw_Reglette; cette routine rafraichie la reglette				move.l	d0,d6		; sécu de la valeur				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		;largeur reglette		move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d1		mulu	d1,d0				move.l	G.General_NombreST,d1		divu	d1,d0	; resultat dans d0		add.w	left+itemRect(a6),d0				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts				ENDP								* ==============================================*	Procedure	RECOPIE_STRINGMACPC()* ==============================================; cette routine convertie une chaîne Mac en une chaîne PC;;	entrée: D0 longueur;			A0 source ptr ;			A1 destination ptr RECOPIE_STRINGMACPC	proc export		movem.l	d7,-(sp)		move.w	d0,d7		beq.S	Exit	; rien à faire		subq.W	#1,d7Loop_recopieChar		move.b	(A0)+,d0		cmp.b	#$0d,d0		bne.s	LRC_PasOD		move.b	#$0d,(a1)+		move.b	#$0A,(a1)+		bra.s	LRC_FinRecopieLRC_PasOD				moveq	#1,d1	; conversion Mac => PC		bsr		CONVERSIONChar		move.b	d0,(a1)+LRC_FinRecopie			dbra	d7,Loop_recopieCharExit	movem.l	(sp)+,d7		rts		dbgInfo.new	RECOPIE_STRINGMACPC		endP* ===============================================*	Procedure	Transfert_Soustitre_BlockTTI()* ===============================================; Cette procédure Fabrique un block TTI à partir d'un sous-titre; en fct des parramètres d'initialisation;Transfert_Soustitre_BlockTTI			PROC	EXPORT		WITH	StackFrameExportN19,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame		with	N19_GSI,N19_TTI,DateTimeRec; on utilise le même stackframe; on garde la même pile que la routine appelante		import	ConversionNumeroSTPointeur,TraitementErreurFichier,\				AFFICHENUMSAISIE,SpinCursor,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR,ConversionBcd_TCN19					; on commence par placer le n° de sous-titre						move.l	Pointeur(a6),A3			move.l	StPtr(a6),A4			move.l	st_ABSNUMST(A4),d0	;(LSB)			move.b	d0,SN(a3)	; poids faible			asr.l	#8,D0		; (MSB)			move.b	d0,SN+1(a3)	; poids fort								; numéro block st extension etc...			move.b	#0,SGN(a3)		; pas de groupe			move.b	#$FF,EBN(a3)	; pas de block d'extension			move.b	#0,CS(a3)		; pas état cumulatif (sous-titres ajouté)					; la justification	du texte 								lea 	tableConversionJustif(pc),a0			moveq	#0,D0			move.b	st_Justification(a4),d0			cmp.b	#3,d0	; on prévient les erreurs			blo.s	@SupJustif			moveq	#0,D0@SupJustif					move.b	(a0,d0.w),d0			move.b	d0,JC(A3)			; drapeau de remarque ######## pour l'instant pas de remarque			move.b	#0,CF(a3)										; position verticale			move.w	st_Nlines(a4),d0	; nombre de ligne			bne		do_vp				move.b	#23,VP(A3)			; si pas de ligne on ce place à la ligne 23			bra.s	doTCIndo_vp						tst.w	G.Preference_DoubleHauteur			beq.S	PasDoubleHauteur_1			mulu	#2,d0PasDoubleHauteur_1			move.w	#24,d1			sub.w	d0,d1			move.b	d1,VP(A3)			; time code in		doTCIn						move.l	st_TimeCodeIN(a4),d0			lea		TCI(a3),a0			jsr	ConversionBcd_TCN19			; time code out								move.l	st_TimeCodeOUT(a4),d0			lea		TCO(a3),a0			jsr	ConversionBcd_TCN19			; fini pour les attributs du sous-titre on passe au texte du sous-titre			move.l	a4,a2			move.l	#st_sizeOf,d0			adda.l	d0,a2			; pointeur du texte					lea		TF(a3),a3	; champ de texte; ------- on raz la zone de texte on place $8f partout			move.w	#111,d6LoopEraseTF	move.b	#$8F,(a3,d6.w)						dbra	d6,LoopEraseTF						clr.w	theLaststyle(a6)	; style normal			clr.w	thestyle(a6)		; style normal			clr.l	NextStyle(a6)			 			moveq 	#0,d7		; compteur de lecture de char dans ST			moveq	#0,d6		; compteur du nombre de char dans ce block TTI			; --------- boucle caractère//caractère	; on ouvre une première ligne; texte vide ?			move.l	StPTR(a6),a0			tst.l	st_texteLenth(a0)			beq		FinRecopieCaracteres	; texte vide									tst.w	G.Preference_N19_TypeTeletexte			beq.s	RecopieCaractere_LOOP			; non pas télétexte			bsr		NouvelleLigne	; on place les attributs d'une nouvelle ligne			RecopieCaractere_LOOP			move.l	d7,d0			bsr		GiveChar_et_style	; on récupère le style et le char			addq.w	#1,d7			move.w	theChar(a6),d0			cmp.w	#-1,d0			beq		FinRecopieCaracteres		; c'est fini								tst.w	G.Preference_N19_TypeTeletexte			bne 	PasGestionstyle			; mode télétexte	pas de style		; --- on gère les style	-------------------------------------------------------				move.w	thestyle(a6),d1			cmp.w	theLaststyle(a6),d1			beq		PasGestionstyle				;c'est le même on ne fait rien; - on change de style; on regarde ce qui change			move.w	theLaststyle(a6),d1	;			move.w	thestyle(a6),d2			eor.w	d1,d2	; ce qui change est à 1						btst	#1,d2		; changement dans les italiques			beq.s	PasChangementdansitalique; ----			; changement dans italique			moveq	#0,d1			move.w	thestyle(a6),d1			eor.w	#$2,d1			and.w	#$2,d1			lsr		#1,d1			move.w	#$80,d0			or.w	d1,d0				; 80 si italique, 81 si fin italique									move.b	d0,(a3)+			addq.W	#1,d6; -----PasChangementdansitalique						btst	#0,d2		; changement dans les gras			beq.s	PasChangementdansGras			; -----			; changement dans gras  ### (gras = emboitage ???)			move.w	thestyle(a6),d1			eor.w	#$1,d1			and.w	#$1,d1			move.w	#$82,d0			or.w	d1,d0				; 84 si emboitage, 85 si fin emboitage						move.b	d0,(a3)+			addq.W	#1,d6PasChangementdansGras			btst	#2,d2		; changement souligné			beq.s	PasGestionSouligne			; -----			; changement dans souligné			move.w	thestyle(a6),d1			eor.w	#$4,d1			and.w	#$4,d1			lsr		#2,d1			move.w	#$82,d0			or.w	d1,d0				; 82 si souligné, 83 si plus souligné						move.b	d0,(a3)+				; début des italiques			addq.W	#1,d6PasGestionSouligne			move.w	thestyle(a6),theLaststyle(a6)			move.w	theChar(a6),d0; -----------------------------------------------------------------------------PasGestionstyle					cmp.b	#$d,d0			; CR/LF	?			beq.s	findeligne						cmp.b	#'$',d0			bne.s	pasChar24			move.b	#$a4,d0			; conversion à la main du char '$'pasChar24									cmp.b	#$7f,d0			bhi.s	ConverttheChar	; il faut convertir les caractères			move.b	d0,(a3)+			addq.w	#1,d6			bra		FinBoucle_Char			; il faut convertir les caractères	(accentuation ...)		ConverttheChar			bsr		conversion_Char				bra		FinBoucle_Char			;---------------- fin de la ligne en cour -------------findeligne		; sommes nous en mode télétexte ?			tst.w	G.Preference_N19_TypeTeletexte			bne.s	TeletexteFinligne			; nous ne sommes pas en télétexte;			move.b	#$8a,(a3)+	;CR/LF;			add.w	#1,d6		; 1 chars de plus						bra		FinBoucle_Char			; ---------			; oui nous sommes en telétexte; double hauteur ?TeletexteFinligne			tst.w	G.Preference_DoubleHauteur			beq.s	PasDoubleHauteur; ----------  nous sommes en double hauteur						move.b	#$0a,(a3)+	; fin incrustation			move.b	#$0a,(a3)+	; fin incrustation			move.b	#$8a,(a3)+	; CR/LF			move.b	#$8a,(a3)+	;CR/LF			add.w	#4,d6		; 4 chars de plus						bra		FinNouvelleLigne			; ---------- nous ne sommes pas en double hauteurPasDoubleHauteur			move.b	#$0a,(a3)+	; fin incrustation			move.b	#$8a,(a3)+	;CR/LF			add.w	#2,d6		; 1 chars de plusFinNouvelleLigne; on place les attributs d'une nouvelle ligne			bsr		NouvelleLigne			bra		FinBoucle_Char; ------------------------------------------------						FinBoucle_Char					cmp.w	#111,d6			bhi		SupauTTI						bra		RecopieCaractere_LOOP; c'est fini de recopié			FinRecopieCaracteres			 			move.b	#$8a,(a3)+			; #### normalement pas besoin			add.w	#1,d6		; 1 chars de plus						bra		Exit						; --------- il faut ajouter un block TTI car nous n'avons pas -----------; --------- assez de place pour tous nos caractères	---------------------						; c'est fini pour ce TTI #### attention pour ètre en règle avec N19; il faudrait prévoir la possibilité de créer des block TTI d'extensions; pour des sous-titres dépassant 112 chars; nb: avec les attributs télétexte cela peut aller vite; 3 lignes de 32 chars :;   96 (chars) +6*13 (attributs)  +4*2(fin de ligne) + 2 cr/lf =182; sans compter les caractères accentués cela peut ne pas rentré dans un seul TTISupauTTI			break							; on retourne à l'appeleur; À TCIAO BONSOIR .....exit		rts* ============================= SUB ROUTINES =============================; ----- routine pour créer une nouvelle ligne ----------------------------NouvelleLigne			tst.w	G.Preference_N19_TypeTeletexte			bne.s	NL_Teletexte			; pas mode télétexte			rts		; on ne fait rien si pas télétexte			; Mode télétexte on ajoute des codes d'attributs pour la ligne à venirNL_Teletexte			move.b	#$1c,(a3)+		; fond noir  ####(code inutile car valeur par defaut)			move.b	#$07,(a3)+		; charBlanc  ####(code inutile car valeur par defaut)						tst.w	G.Preference_DoubleHauteur			bne.s	NL_DoubleHauteur			tst.w	G.Preference_DoubleLargeur			bne.s	NL_DoubleLargeur			; donc simple hauteur simple largeur						move.b	#$0b,(a3)+	; début d'incrustation			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#2,d6				rts			; -------NL_DoubleHauteur			tst.w	G.Preference_DoubleLargeur			bne.s	NL_TailleDouble			move.b	#$0d,(a3)+	; double hauteur			move.b	#$0b,(a3)+	; début d'incrustation			move.b	#$0b,(a3)+	; début d'incrustation 	;#### (pourquoi en mettre 2 ?)			move.w	G.Preference_Couleur,d0				move.b	d0,(a3)+	; couleur du texte			addq.w	#4,d6				rts			; -------	; largeur double			NL_DoubleLargeur			move.b	#$0e,(a3)+	; double largeur			move.b	#$0b,(a3)+	; début d'incrustation			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#3,d6				rts; -------		; taille doubleNL_TailleDouble			move.b	#$0f,(a3)+	; double hauteur			move.b	#$0b,(a3)+	; début d'incrustation			move.b	#$0b,(a3)+	; début d'incrustation	;#### (pourquoi en mettre 2 ?)			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#4,d6				rts; -------------------------------------------------------------------;  sous-routine qui donne l'ascii et le style d'un caractère	GiveChar_et_style		; d0 = indice du caractère 0 ≈ Nmax		movem.l	d1-d2/a1-a2,-(sp)		move.l	StPtr(a6),a0		cmp.l	st_TexteLenth(a0),d0	; dans le st ?		blo.S	Char_Exist		move.w	#-1,d0					; caractère pas dans la liste		move.w	d0,theChar(a6)				movem.l	(sp)+,d1-d2/a1-a2		rts; ---------------------------------------		Char_Exist				move.l	a0,a1		move.l	#st_sizeOf,d1		adda.l	d1,a1				; pointeur du texte		move.l	d0,d1				; sauvegarde du n° de char			tst.l	st_StylePtr(a0)		; il y a t-il des styles dans ce sous-titre ?			bne.s	RechercheProchainStyle;non, pas de style => parramètre par défaut				clr.w	thestyle(a6)			; style normal 		move.w	#1,theJust(a6)			; centrée		move.w	#0,theFont(a6)			; 1 ère font de la liste		move.l	#-1,NextStyle(a6)		; pas de prochain style		bra.s	PasDeStyle RechercheProchainStyle		move.l	NextStyle(a6),d2		beq.s	RechercheCont			; il n'y en a pas il faut le rechercher		cmp.l	d2,d1					; char pos <inférieur au prochain style ?		blo.s	PasDeStyle				; on ne change pas; -------------------		; on détermine quel style appartient au caractèreRechercheCont		move.l	st_StylePtr(a0),a2		; pointeur du style		move.w	(a2)+,d2				; nombre de style		subq.w	#1,d2		move.l	#20,d0		sub.l	d0,a2		LoopStyle			move.l	#20,d0		add.l	d0,a2			;scrpRecSize (décimal 20) on est obligé de forcer l'ASM en Long mode		cmp.l	(a2),d1		blo.s	FoundNext		move.w	scrpFont(a2),theFont(a6)		moveq	#0,d0		move.b	scrpFace(a2),d0		move.w	d0,thestyle(a6); style suivant				dbra	d2,LoopStyle				move.w	#-1,NextStyle(a6)			; pour indiquer qu'il n'y a plus de style		bra.s	PasDeStyle		FoundNext		move.l	(a2),NextStyle(a6); ---------PasDeStyle; on récupère le caractère		moveq	#0,d0		move.b	(a1,d1.w),d0					; caractère (long)		move.w	d0,thechar(a6)			movem.l	(sp)+,d1-d2/a1-a2		rts; --------------------------------------------------------------------; sous-routine de conversion caractère mac => n19; a4 pointe sur la table de conversionconversion_Char		movem.l	d1-d2/a4,-(sp)		; on sauvegarde d1-d2/a4		move.l	G.ResourceDATA1000,d1		beq		pasDeResource1000		move.l	d1,a4				move.l	(a4),a4			; handle	Loop_Recherche_double_Char				move.w	(a4),d1				; code Mac dans la table de conversion		beq.s	pasDeResource1000	; fin de la table,on sort avec le caractère simple dans d0		cmp.w	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.s	Loop_Recherche_double_Char; erreur diverses on ne modifie pas le caractèrepasDeResource1000		move.b	d0,(a3)+		addq.w	#1,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rts		; -----Found_The_Char		move.w	2(a4),d1		asr.w	#8,d1		; 8bits poids fort		move.w	2(a4),d2		tst.b	d1			; accentutation ?		beq		PasAccentuation				move.b	d1,(a3)+		move.b	d2,(a3)+		addq.w	#2,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rtsPasAccentuation				move.b	d2,(a3)+		addq.w	#1,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rts		; -----------------------------------------------------------tableConversionJustif			dc.b	02	; 0= centrée			dc.b	01	; 1= gauche			dc.b	03	; 2=Droite			dc.b	00	; 			DbgInfo.new		Transfert_Soustitre_BlockTTI	; this name will appear in the debugger			align 4				endp			* ========================================		* PROCEDURE	ConversionBcd_TCN19()			* ========================================** Cette routine convertie le time code bcd en format N19l** entrée: D0 contient le tc en BCD*		  A0 pointe sur letc n19 qui doit ètre rempli* sortie: D0 contient le tc N19**ConversionBcd_TCN19 		PROC	EXPORT		with	StackFrameImportationFichier,N19_GSI,N19_TTI		import	SpinCursor		movem.l	d1-d2,-(sp)						move.l	d0,d1	; sauvegarde du timecode		; si tc =-1 vide on place 00 00 00 00		cmp.l	#-1,d0		bne.s	DoConversionTC		move.b	#0,3(a0)		move.b	#0,2(a0)		move.b	#0,1(a0)		move.b	#0,0(a0)		movem.l	(sp)+,d1-d2		rtsDoConversionTC		; images				and.l	#$f,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,3(a0)				; secondes		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,2(a0)		; minutes		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,1(a0)		; heures		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,0(a0)							Exit	movem.l	(sp)+,d1-d2		rts				DbgInfo.new	ConversionBcd_TCN19		align 4			ENDP						