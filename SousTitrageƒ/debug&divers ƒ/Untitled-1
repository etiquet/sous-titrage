* ================================================* PROCEDURE		WriteBonBougreFormat()* ================================================WriteBonBougreFormat	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètrereply				ds.l	1AutoSave			ds.w	1	; flag pour autosaveParamSize			EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkTheDialogPtr		ds.l	1Buffer				ds.l	1	; adresse du bufferMaxBuffer			ds.l	1	; adresse haute du bufferPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	48	; buffer temporaire n°2NumST				ds.w	1	;Numéro du sous-titre en coursItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1RGB_Color			ds.w	3DateTime			ds		DateTimeRecsecu				ds.l	2ResourceRefNum		ds.w	1saveResourceRef		ds.w	1oldport				ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD,\				SOUSTITREformat,FontRenderRecord ; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				import	EffaceTouslesSousTitres,FindFrameType_Ascii_CMC,\				ConversionNumeroSTPointeur,TraitementErreurFichier,InsertST,\				CentreListingWindow,AFFICHENUMSAISIE,\				TransfertMemoireSaisie,CalculDuree,Waitaicks,WaitTicks,DrawWindow,\				INITCURSORCTL,ROTATECURSOR,Show_cursor,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR		; on recherche une zone de travail			move.l	G.BufferTransfert,d0			move.l	d0,Buffer(a6)			add.l	G.SIZEBufferTransfert,d0			move.l	D0,MaxBuffer(a6); on arrète la lecture du port serie		tst.w	G.ModemInRefNum		beq.s	PasArreteLectureTC			 		;	lea		G.Rx_modem_paramblock,a0 		;	clr.w	22(a0) 		;	move.w	G.ModemInRefNum,ioRefNum(a0) 		;	clr.l	ioCompletion(a0) 		;	_KillIO	PasArreteLectureTC; on recopie le nom de la dernière police d'affichage utilisée (si elle existe)		lea 	G.LastFontUsed,a1		clr.w	(a1)		lea 	G.Display_Font,a0		lea		FontName(a0),a0		moveq	#0,d0		move.b	(a0),d0		beq		Pasrecopie		addq.l	#1,d0		cmp.l	#32,d0	; on limite à 32 caractères		blo		recopieStringlastfont		move.l	#32,d0recopieStringlastfont		_BlockMovePasrecopieNonFontName; ok on peut bosser; on ouvre un dialog			pea	oldport(a6)			_GetPort			clr.l	-(sp)			move.w	#154,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)			_SetPort			move.l	TheDialogPtr(a6),-(sp)			_DrawDialog			; on dit que c'est pour convertir un fichier ASCII					move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						pea		itemRect(a6)			_EraseRect						move.w	left+itemRect(a6),-(sp)			move.w	top+itemRect(a6),d0			add.w	#12,d0			move.w	d0,-(sp)			_moveTo						tst.w	AutoSave(a6)			bne.s	SayAutoSave							pea	#'Sauvegarde du fichier: '		_drawString		bra.s	NomDeFichierSayAutoSave				pea	#'Sauvegarde Automatique du fichier: '		_drawString; on affiche le nom du fichierNomDeFichier				move.l	Reply(a6),-(sp)		_drawString		; on dessine la réglette			move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem								_PenNormal						move.w	#SrcCopy,-(sp)			_TEXTMode						move.w	#SrcCopy,-(sp)			_PenMode						tst.b	G.Mac.HasCOloRQD			bne.s	Zob1					bra.s	Zob3Zob1													Zob3			;on entoure la reglette			move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem						_PenNormal				pea		itemRect(a6)		_FrameRect				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#6,d0		move.w	d0,LargeurReglette(a6)		clr.w	LastXpos(a6)				move.w	bottom+itemRect(a6),bottom+rectangle(a6)		subq.w	#2,bottom+rectangle(a6)		move.w	top+itemRect(a6),top+rectangle(a6)		addq.w	#2,top+rectangle(a6)				move.w	left+itemRect(a6),left+Rectangle(a6)		add.w	#2,left+rectangle(a6)		Start_theSave		; ok le dialog est ouvert; on se positionne au début du fichier		move.l	paramBlock(a6),a0			move.w	#fsFromStart,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)		_SetFPos; ok on est au début du fichier			move.l	G.General_PremierSTPtr,Pointeur(a6)		clr.w	NumST(a6)* ------------------------------------------------; on place l'en tête pour les fichiers bon bougre		clr.w	G.versionLogiciel		clr.l	-(sp)		move.l	#'vers',-(sp)		move.w	#1,-(sp)		_GetResource		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	PasResourcevers	; pas trouvé resource		move.l	(a0),a1		; handle		; on recopie la version du logiciel dans l'en tête du fichier ; pour de futur problèmes de compatibilitée		move.w	(a1),G.versionLogiciel		move.l	a0,-(sp)		_ReleaseResource; ---PasResourcevers; on écrit le header dans le fichier		lea.l	G.Preference_Header_SizeOf,a0	; fin du header		move.l	a0,d0		lea.l	G.preference,a1		; début du header		sub.l	a1,d0				; longueur à écrire				move.l	paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)		_Write		;		move.l	paramBlock(a6),a0;		clr.l	ioCompletion(a0);		_FlushFile				jsr		TraitementErreurFichier			* -------------------------------------------------				; on prépare l'écriture sur disque		move.l	Buffer(a6),a3	; début de la zone de travail		move.l	G.General_PremierSTPtr,pointeur(a6); ----		TransfertFichierLoop; on transfert le header dans la mémoire		move.l	pointeur(a6),a0		move.l	st_TimeCodeIn(a0),file_TimeCodeIn(a3) 		move.l	st_TimeCodeOut(a0),file_TimeCodeOut(a3) 		move.l	st_NumeroST(a0),file_NumeroST(a3) 		move.l	st_TexteLenth(a0),file_TexteLenth(a3)		move.l	st_StyleLenth(a0),file_StyleLenth(a3) 		move.l	st_CommentaireLenth(a0),file_CommentaireLenth(a3) 		move.w	st_XOffset(a0) ,file_XOffset(a3) 		move.w	st_YOffset(a0) ,file_YOffset(a3)		move.w	st_Error(a0) ,file_Error(a3) 		move.w	st_Flags(a0) ,file_Flags(a3)		move.w	st_Nlines(a0) ,file_Nlines(a3)		move.l	st_PosOffsetTable(a0),file_PosOffsetTable(a3)  		move.b	st_Justification(a0),file_Justification(a3)    		move.b	st_MasKType(a0),file_MasKType(a3)   		move.l	st_spare(a0),file_spare(a3) 		move.w	4+st_spare(a0),4+file_spare(a3)		move.l	#file_sizeOf,file_LenthST(a3)		; on place la longueur du header				add.l	#file_sizeOf,a3			move.l	a0,a4					; on sauvegarde le pointeur du sous-titre; -------; on recopie le texte		tst.l	st_TexteLenth(a4)		beq.s	RecopieCommentaire		; la chaine est vide donc pas de style		move.l	#st_sizeOf,d1		add.l	d1,a0					; a1 pointe sur le début du texte dans le sous-titre		move.l	a3,a1					; début du texte		move.l	st_TexteLenth(a4),d0	; longueur du texte				_blockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	st_TexteLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l			move.l	Buffer(a6),a1	; début de la zone de travail		add.l	d0,file_LenthST(a1)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone; ----------		; on recopie les styles		tst.l	st_StyleLenth(a4)		beq.s	RecopieCommentaire		; il n'y a pas de style		move.l	st_StylePtr(a4),a0		move.l	a3,a1		move.l	st_StyleLenth(a4),d0		_BlockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	st_StyleLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	Buffer(a6),a1	; début de la zone de travail		add.l	d0,file_LenthST(a1)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone		; -------RecopieCommentaire					tst.l	st_CommentaireLenth(a4)		beq.s	WriteThisOnDisk		; il n'y a pas de commentaire		move.l	st_CommentairePtr(a4),a0		move.l	a3,a1		move.l	st_CommentaireLenth(a4),d0		_BlockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	st_CommentaireLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	Buffer(a6),a1	; début de la zone de travail		add.l	d0,file_LenthST(a1)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone	; --------	; on écrit sur le disqueWriteThisOnDisk			move.l	a3,d0				; a3 = adresse de fin du sous-titre placer en mémoire		sub.l	Buffer(a6),d0		; longueur à écrire		move.l	paramBlock(a6),a0		move.l	d0,ioReqCount(a0)		move.l	buffer(a6),a1		move.l	a1,ioBuffer(a0)				move.w	#fsAtMark,ioPosMode(a0)		move.l	#0,ioPosOffset(a0)				_Write; ---		; on rafraichie la reglette, et le curseur		move.l	pointeur(a6),a0		move.l	st_AbsNumSt(a0),d0		move.w	LargeurReglette(a6),d1		and.l	#$fff,d1			mulu.w	d1,d0; resultat sur 32 bits dans d0		move.l	G.General_NombreST,d1		divu	d1,d0; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas		move.w	d0,LastXpos(a6); on dessine la reglette								add.w	Left+ItemRect(a6),d0		add.w	#2,d0		move.w	d0,Right+rectangle(a6)		 		bsr		Draw_Reglette						move.w	#32,-(sp) 		JSR	SpinCursor	; spin the ball				_PenNormal		onnedessinepas:				; --------------------------------------------------------	; on teste si l'écriture est terminée; on regarde si le next pointeur = 0 		move.l	pointeur(a6),a0		move.l	st_NextST(a0),a0		cmp.l	#0,a0		beq		finEcriture		; oui c'est le dernier sous-titre; non on continue		move.l	a0,Pointeur(a6)	; pointeur du sous-titre à traiter		move.l	Buffer(a6),a3	; début de la zone de travail		bra 	TransfertFichierLoop		; non on continu		; oui, on se casse de là			FinEcriture				; on place le end of file à l'endroit où nous sommes			;		clr.w	-(sp);		move.l	paramBlock(a6),a0;		move.w	ioVrefNum(a0),-(sp);		move.l	46(a0),-(sp)	;ioPosOffset;		import	SetEOF;		jsr		Seteof;		move.w	(sp)+,d0			 		move.l	TheDialogPtr(a6),-(sp) 		_SetPort	 		move.l	TheDialogPtr(a6),-(sp) 		_DisposDialog				move.l	oldport(a6),-(sp)		_SetPort		Exit	tst.w	G.ModemInRefNum		beq.s	PasDemandeLectureTC					;	lea		G.Rx_modem_paramblock,a0      	;	clr.w	22(a0)     	;	lea.l	G.Rx_Modem_Buffer,a1	      	;	move.l	a1,32(a0)      	;	move.l	#1,ioReqCount(a0)      	;	move.w	#fsfromStart,ioPosMode(a0)     	;	move.w	G.ModemInRefNum,ioRefNum(a0)      	;	clr.l	ioPosOffset(a0)     	;	import	SERIAL     	;	lea.l	SERIAL,a1					; routine de gestion du port serie     	;	move.l	a1,ioCompletion(a0)        ;	_Read ,asyncPasDemandeLectureTC				UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		string	PASCALGroundColor		dc.w	30962,20192,16402	Draw_Reglette; cette routine rafraichie la reglette		movem.l	d0-d7/a0-a4,-(sp)				move.l	TheDialogPtr(a6),-(sp)		_SetPort						move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	LastXpos(a6),d0		cmp.w	left+itemRect(a6),d0		bhi.s	@123		move.w	left+itemRect(a6),d0@123				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				movem.l	(sp)+,d0-d7/a0-a4		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						movem.l	(sp)+,d0-d7/a0-a4		rts						DbgInfo.new		WriteBonBougreFormat	; this name will appear in the debugger		align 4			ENDP* ================================================* PROCEDURE		ReadBonBougreFormat()* ================================================ReadBonBougreFormat	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètrereply				ds.l	1FileLenth			ds.l	1	; longueur du fichier luParamSize	EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkBuffer				ds.l	1	; adresse du bufferMaxBuffer			ds.l	1	; adresse haute du bufferPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	48	; buffer temporaire n°2NumST				ds.w	1	;Numéro du sous-titre en coursItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1DateTime			ds		DateTimeRecCourantSTPtr		ds.l	1			; Pointeur du début du sous-titre en coursCaracteresLus		ds.l	1			; nombres de cractères lusStPtr				ds.l	1			; variable du st en mémoireNombreST			ds.l	1			; nombre de sous-titre dans le fichier en mémoireRGB_Color			ds.w	3TheDialogPtr		ds.l	1oldport				ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD,\				SOUSTITREformat; cover our local stack frame								LINK	A6,#LocalSize		; allocate our local stack frame				import	EffaceTouslesSousTitres,FindFrameType_Ascii_CMC,\				ConversionNumeroSTPointeur,TraitementErreurFichier,InsertST,\				CentreListingWindow,AFFICHENUMSAISIE,\				TransfertMemoireSaisie,CalculDuree,Waitaicks,WaitTicks,DrawWindow,\				INITCURSORCTL,ROTATECURSOR,Show_cursor,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR,EffaceTouslesSousTitres		; on recherche une zone de travail			move.l	G.BufferTransfert,d0			move.l	d0,Buffer(a6)			add.l	G.SIZEBufferTransfert,d0			move.l	D0,MaxBuffer(a6)  ; ok on peut bosser; on ouvre un dialog		pea		oldport(a6)		_GetPort				clr.l	-(sp)		move.w	#154,-(sp)		clr.l	-(sp)		move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp),TheDialogPtr(a6)		_SetPort				move.l	TheDialogPtr(a6),-(sp)		_DrawDialog		move.l	TheDialogPtr(a6),-(sp)		move.w	#1,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem; affichage 'Lecture du fichier : Nom de Fichier'		pea		itemRect(a6)		_EraseRect		move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),d0		add.w	#12,d0		move.w	d0,-(sp)		_moveTo			pea	#'Lecture du fichier: '		_drawString				move.l	Reply(a6),-(sp)		_drawString		; on dessine la réglette		move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem				_PenNormal			   	move.w	#SrcCopy,-(sp)	   	_TEXTMode			   	move.w	#SrcCopy,-(sp)	   	_PenMode				tst.b	G.Mac.HasCOloRQD 		bne.s	Zob1				bra.s	Zob3Zob1													Zob3			;on entoure la reglette		move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)	; item 1		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		; coordonnées de la reglette		_GetDItem						_PenNormal				pea		itemRect(a6)		_FrameRect				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		sub.w	#6,d0		move.w	d0,LargeurReglette(a6)		clr.w	LastXpos(a6)				move.w	bottom+itemRect(a6),bottom+rectangle(a6)		subq.w	#2,bottom+rectangle(a6)		move.w	top+itemRect(a6),top+rectangle(a6)		addq.w	#2,top+rectangle(a6)				move.w	left+itemRect(a6),left+Rectangle(a6)		add.w	#2,left+rectangle(a6)				move.l	G.General_PremierSTPtr,Pointeur(a6)		clr.w	NumST(a6)		* ------------------------------------------------; on lit le fichier de la longueur du buffer				move.l	paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.l	G.BufferTransfert,ioBuffer(a0)		move.l	G.SIZEBufferTransfert,ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)		clr.l	ioPosOffset(a0)				; du début		_Read		jsr		TraitementErreurFichier			move.l	G.SIZEBufferTransfert,CaracteresLus(a6); on vérifie que la version du fichier est compatible avec le logiciel en cour		clr.l	-(sp)		move.l	#'vers',-(sp)		move.w	#1,-(sp)		_GetResource		move.l	(sp)+,a0		cmp.l	#0,a0		beq.s	PasResourcevers	; pas trouvé resource				move.l	(a0),a1		; handle		move.w	(a1),d7				move.l	a0,-(sp)		_ReleaseResource						move.l	G.BufferTransfert,a0		move.w	(a0),d0		cmp.w	d7,d0		bge.s	PasDeProbleme	; version supérieur à cette version de logicielle; donc alerte		; ---PasDeProblemePasResourcevers; on efface le fichier en cours		move.l	Buffer(a6),a3	; début de la zone de travail		pea		2(a3)		; nom du film => nom dans le fenètre		import	EffaceTouslesSousTitres		jsr		EffaceTouslesSousTitres		; on lit le header dans le fichier			lea.l	G.Preference_Header_SizeOf,a0	; fin du header		move.l	a0,d0		lea.l	G.preference,a1		; début du header		sub.l	a1,d0				; longueur à lire				move.l	G.BufferTransfert,a0		_BlockMove				move.l	G.General_NombreST,d0		move.l	d0,NombreST(a6)		; on met de cote le nombre de sous-titre		move.l	#1,G.General_NombreST* -------------------------------------------------				; on prépare la lecture du fichier		move.l	Buffer(a6),a3	; début de la zone de travail				lea.l	G.Preference_Header_SizeOf,a0	; fin du header		move.l	a0,d0		lea.l	G.preference,a1		sub.l	a1,d0				; longueur du header		add.l	d0,a3				; adresse du premier sous-titre		move.l	a3,pointeur(a6)			move.l	G.general_PremierSTPtr,StPtr(a6); ----		lectureFichierLoop		move.l	pointeur(a6),a3				; nouveau sous-titre à lire dans le fichier		move.l	(a3),d0						; d0 longueur du sous-titre		move.l	a3,d1								add.l	d0,d1						; d1 ptr fin du sous-titre; on teste si le sous-titre est entier		move.l	MaxBuffer(a6),d0		cmp.l	d0,d1				       ;// max buffer		ble.s	LeSousTitreEstEntier		; comme son nom l'indique; on regarde si nous sommes à la fin du fichier; si non on lit a partir du début de sous-titre en cour j'usqu'a la fin; calcul de la longueur	à lire; longueur déjà lue du fichier+(pointeurbuffer-pointeurdébutsous-titre)		move.l	CaracteresLus(a6),d1		add.l	pointeur(a6),d1		sub.l	Buffer(a6),d1		; d1 = position dans le fichier pour le contenu de a3; longueur à lire		move.l	G.SIZEBufferTransfert,d2		move.l	FileLenth(a6),d0		sub.l	d1,d0		sub.l	d2,d0		bpl.s	PasSupBuffer	; ok cela rentre	; cela ne rentre pas dans le buffer, il y aura un autre passage !		move.l	d2,d0			; taille du bufferPasSupBuffer		add.l	d0,CaracteresLus(a6)				move.l	paramBlock(a6),a0		clr.l	ioCompletion(a0)		move.w	sfsvRefNum(a6),ioVrefNum(a0)		move.l	G.BufferTransfert,ioBuffer(a0)		move.l	d0,ioReqCount(a0)		move.w	#fsFromStart,ioPosMode(a0)			; référence //au début		move.l	d1,ioPosOffset(a0)					; à partir du sous-titre		_Read		jsr		TraitementErreurFichier	; on raz les pointeurs 				move.l	G.BufferTransfert,pointeur(a6)LeSousTitreEstEntier; on insert un soustitre		move.l	STPtr(a6),a0		move.l	pointeur(a6),a3	; on transfert le header dans la mémoire				move.l	file_TimeCodeIn(a3),st_TimeCodeIn(a0) 		move.l	file_TimeCodeOut(a3),st_TimeCodeOut(a0)		move.l	file_NumeroST(a3),st_NumeroST(a0)		move.l	file_TexteLenth(a3),st_TexteLenth(a0)		move.l	file_StyleLenth(a3),st_StyleLenth(a0)		move.w	file_XOffset(a3),st_XOffset(a0) 		move.w	file_YOffset(a3),st_YOffset(a0) 		move.w	file_Error(a3),st_Error(a0) 		move.w	file_Flags(a3),st_Flags(a0) 		move.w	file_Nlines(a3),st_Nlines(a0) 		move.l	file_PosOffsetTable(a3),st_PosOffsetTable(a0)		move.b	file_Justification(a3),d0				cmp.b	#4,d0		blo.s	PasSupJustif		moveq	#0,d0		; par défault centréePasSupJustif				move.b	d0,st_Justification(a0)    		move.b	file_MasKType(a3),d0		cmp.b	#4,d0		blo.s	PasSupMask		moveq	#0,d0		; par défault centréePasSupMask		move.b	d0,st_MasKType(a0)   		move.l	file_spare(a3),st_spare(a0)		move.w	4+file_spare(a3),4+file_spare(a0)		move.l	file_LenthST(a3),d0		sub.l	#file_sizeOf,d0		clr.l	st_LenthST(a0)		move.l	a3,a4			 	; sauvegarde du ptr		add.l	#file_sizeOf,a3	;   start offset pointer pour les data		move.l	#st_sizeOf,d7; -------; on recopie le texte		tst.l	file_TexteLenth(a4)		beq.s	RecopieCommentaire		; la chaine est vide donc pas de style										move.l	STPtr(a6),a1		move.l	st_NumeroST(a1),d0		cmp.l	#2003,d0		blo.s	@12231		;break@12231	add.l	d7,a1 					; a1 pointe sur le début du texte dans le sous-titre		move.l	a3,a0					; début du texte dans le fichier		move.l	file_TexteLenth(a4),d0	; longueur du texte				_blockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	file_TexteLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	STPtr(a6),a0			; début du sous-titre		add.l	d0,st_LenthST(a0)		; on ajoute la longueur du texte à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone		add.l	d0,d7					; start offset du suivant en mémoire; ----------		; on recopie les styles		tst.l	file_StyleLenth(a4)		beq.s	RecopieCommentaire		; il n'y a pas de style; on  calcule le pointeur des styles				move.l	STPtr(a6),a0		move.l	a0,a1		add.l	d7,a1					; longueur du texte ajustée en .l		move.l	a1,st_StylePtr(a0)		; a1 pointe sur le début du style dans le sous-titre		move.l	file_StyleLenth(a4),d0	; longueur des styles		move.l	a3,a0 					; a0 début style dans le fichier		_BlockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	file_StyleLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	STPtr(a6),a0			; début du sous-titre		add.l	d0,st_LenthST(a0)		; on ajoute la longueur du style à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone				add.l	d0,d7; -------RecopieCommentaire				clr.l	st_CommentairePtr(a0)		clr.l	st_Commentairelenth(a0)				tst.l	file_CommentaireLenth(a4)		beq.s	DessinCurseur		; il n'y a pas de commentaire; on  calcule le pointeur du commentaire				move.l	STPtr(a6),a0		move.l	a0,a1		add.l	d7,a1						; a1 pointe début commentaire ajusté .l		move.l	a1,st_CommentairePtr(a0)				move.l	file_CommentaireLenth(a4),d0	; longueur des commentaires		move.l	d0,st_Commentairelenth(a0)		move.l	a3,a0 							_BlockMove; on calcule l'adresse du prochain block à recopier, alignement sur ds.l 		move.l	file_CommentaireLenth(a4),d0	; longueur du texte		import	AligneD0		jsr		AligneD0; longueur ajustée sur ds.l		move.l	STPtr(a6),a0			; début du sous-titre		add.l	d0,st_LenthST(a0)		; on ajoute la longueur du commentaire à la taille du sous-titre 		add.l	d0,a3					; pointeur de la prochaine zone				; ---	; on rafraichie la reglette, et le curseurDessinCurseur		move.l	a3,pointeur(a6)			; on sauvegarde ce pointeur car c'est le début du prochain		move.l	stPtr(a6),a0		move.l	st_AbsNumSt(a0),d0		move.w	LargeurReglette(a6),d1		and.l	#$fff,d1			mulu.w	d1,d0; resultat sur 32 bits dans d0		move.l	NombreST(a6),d1		divu	d1,d0; resultat dans d0		cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas		move.w	d0,LastXpos(a6) 		bsr		Draw_Reglette				move.w	#16,-(sp) 		JSR	SpinCursor	; spin the ball				_PenNormal		onnedessinepas:				; --------------------------------------------------------	; on teste si la lecture est terminée; on regarde si le numéro absolu est >= nombre de st				move.l	stPtr(a6),a0		move.l	st_AbsNumST(a0),d0		move.l	NombreST(a6),d1		cmp.l	d1,d0		bge.s	finLecture		; le fichier entier a été lu; non on continue, on insert un sous-titre				move.l	G.General_DernierSTPtr,a0		move.l	#0,d0			; longueur par défaut		jsr		InsertST		move.l	G.General_DernierSTPtr,a0		move.l	a0,stPtr(a6)			; adresse début prochain sous-titre		bra 	lectureFichierLoop		; non on continu		; oui, on se casse de là			finLecture		move.l	NombreST(a6),G.General_NombreST		move.l	TheDialogPtr(a6),-(sp)		_DisposDialog		Exit	move.l	d1,d7		move.w	#$0505,-(sp)			jsr		Show_cursor		move.l	oldport(a6),-(sp)		_SetPort				UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		string	PASCALGroundColor		dc.w	30962,20192,16402	Draw_Reglette; cette routine rafraichie la reglette				movem.l	d0-d7/a0-a5,-(sp)				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	LastXpos(a6),d0		cmp.w	left+itemRect(a6),d0		bhi.s	@123		move.w	left+itemRect(a6),d0@123				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		movem.l	(sp)+,d0-d7/a0-a5		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				movem.l	(sp)+,d0-d7/a0-a5		rts				DbgInfo.new		ReadBonBougreFormat	; this name will appear in the debugger		align 4			ENDP		