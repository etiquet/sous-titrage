short  C_fastFont_Calcul_char(	FontRenderRecordPtr FontRender,	CharHeaderPtr chptr, 	CharHeaderPtr rend_chptr ,	short charnum ,	short StyleType,	unsigned long *FontCurrentPtr,	Ptr FontBitmapPtr);				short	C_Create_FastFont(FontRenderRecordPtr FontRender,short DestinationSize ,Ptr RenderEffect   ){long		total,contig,FontBitmapSize,mem,TotalChar,CharCounter,style,charnum,Date,estTime,StartDate;Str255	st0,st1;Handle	mymemH,renderH,RPD;Ptr		mymemPtr,FontBitmapPtr;DialogPtr	dlog;short 	Itemchoisi,StyleType,err;	unsigned long FontCurrentPtr,PreviousFontCharPtr,FontCharPtr,FontStylePtr,a,Row_Bytes;CharHeaderPtr	chptr,prchptr,tmpPtr;DateTimeRec	datrec;Rect			myrect;Boolean		flag,docharloop;						// on regarde si parametre "font render" valide									if (! FontRender->Render_handle) {	// il n'y a pas de "font" en memoire			// alert			AlertUser(31);			return -1;				}/* on demande une zone mémoire pour pouvoir dessiner un caractère dans un plan	on reserve un espace mémoire =4 fois la taille de la lettre 			pour permettre le rendu d'un plan*/		mem=(FontRender->FontSize)*(FontRender->FontSize)*32 +10240;		mymemH=NewHandle(mem);		HLock(mymemH); 		mymemPtr=*mymemH; 	//handle => pointeur/*on effectue un calcul préalable de l'espace mémoire nécessaire pour contenirla police	d'affichage. on récupère la taille du handle display font on ouvre un dialog pour indiquer que nous recherchons de la mémoire*/		dlog=GetNewDialog(176,nil,(WindowPtr)-1);		DrawDialog(dlog);						mem= GetHandleSize(FontRender->Render_handle);		// on regarde s'il y a un probleme				if (mem<=0) {			// on dispose la memoire			AlertUser(31);			if (mymemH)	DisposeHandle(mymemH);			return -1;					} // on regarde s'il y a déjà un handle aloué (dejà un calcul précédent)		if (FontRender->RenderColor_handle) {				// oui on le dispose			DisposeHandle(FontRender->RenderColor_handle);			FontRender->RenderColor_handle=nil;		}		//on demande un handle de 4 fois la taille 		FontBitmapSize=mem*4;		renderH=NewHandle(FontBitmapSize);						// on ferme le dialog demande de mémoire		DisposeDialog(dlog);						// probleme de mémoire ?		if (renderH) { 						// il n'y a pas assez de mémoire	// non on indique la mémoire dispo et on demande son choix à l'utilisateur						PurgeSpace(&total,&contig); 		NumToString(contig/1024-32,&st1);		NumToString(FontBitmapSize/1024,&st0);		ParamText(&st0,&st1,nil,nil);		Itemchoisi=Alert(194,nil);		if (Itemchoisi == 1){	// on quitte la routine			if (mymemH)	DisposeHandle(mymemH);			return -1;		}		// l'utilisateur a demandé que l'on essaye le rendu (à ses risques et perils)		renderH=NewHandle(contig-32*1024);						} //if (renderH<=0)// on place le handle dans la structure		FontRender->RenderColor_handle=renderH;		FontBitmapPtr=*renderH;		FontRender->interligne=1;// on initialise le  Font record de la police		FontRender->First_Char=33;		FontRender->last_Char=255;/* ---; on reserve de la place pour le header du font bitmaps;; rappel  :     	ptr style 1		<-  début du font bitmaps	);				  / / / / 									) header font bitmap;				ptr style n									) ;;				headerCharN°1	<- début 1 er style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn;				    / / / /;				headerCharN°1	<- début n ème style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn; (il faut réserver un  long ptr pour chaque style) ; il faudra changer le nom face number par style number (nombre de style dans le bitmap); initialisation du Displayfont header en tête ; réservation de la place nombre de style à rendre* taille du "styleHeader" ; réservation de la place*/	FontCurrentPtr=sizeof(MasterPlaneInfo)*FontRender->Face_Number;	FontRender->max_descent=0;	FontRender->max_Ascent=0;	// on calcule le nombre total de caractères		TotalChar=(FontRender->last_Char-FontRender->First_Char)*FontRender->Face_Number;	CharCounter=0; 	//reset du compteur	// on ouvre une réglette de progression		GetIndString(&st0,129,55); // "CALCUL D'UNE POLICE D'AFFICHAGE"	RPD=RPInitReglette(&st0,&FontRender->FontName,1,TotalChar,true);	// LE NOM DE LA POLICE"	GetDateTime(&StartDate);			// la boucle de rendu	//  c'est parti pour la grande boucle			for (style=0; style<FontRender->Face_Number;style++){	// on calcule le pointeur (relatif // au debut de la zone mémoire )		FontCurrentPtr=((FontCurrentPtr+3)/4)*4;		FontStylePtr=FontCurrentPtr;		PreviousFontCharPtr=0;				// on le place dans la table en début		((MasterPlanePtr)FontBitmapPtr)->styleoffset[style].offset=(Ptr)FontStylePtr;				// on détermine quel style il faut calculer (normal, italique, gras)		// car si nb de style =3 (0,1,2) pas de difficultée		// si nb de style =2 (0,1) il faut déterminer de quel style il s'agit,  gras ou italique ?				docharloop=true;				switch(style) {		case 0:			StyleType=0;		break;				case 1: // style italique ou gras ?			if ( FontRender->FontStyle&1) {				 StyleType=1; 				 break;			 } else {			 	if (! FontRender->FontStyle&2)  docharloop=false;				StyleType=2;				break;				}		break;				case 2: // style gras ?			if (! FontRender->FontStyle&1)  docharloop=false;			StyleType=1;		break;				} //switch(style)				if (docharloop) { // on fait la boucle de calcule des caractères	 	 	// boucle de calcul caratères				for (charnum=FontRender->First_Char; charnum<=FontRender->last_Char;charnum++){			// initialisation des pointeurs "Display font" boucle caractères			FontCharPtr=FontCurrentPtr;			FontCurrentPtr=FontCharPtr+sizeof(CharHeader);						// on update les pointeurs de cet en tête						a=(unsigned long)FontBitmapPtr+FontCharPtr;			chptr=(CharHeaderPtr)a; //						chptr->CH_PreviousChar=(char*)PreviousFontCharPtr;			chptr->CH_NextChar=0;			chptr->CH_CharNumber=charnum;			chptr->CH_Spare=0xdada;						// raz le rectangle du caractère			chptr->CH_Rect.top=-1;			chptr->CH_Rect.left=-1;			chptr->CH_Rect.bottom=0;			chptr->CH_Rect.right=0;			//  on update le "CH_NextChar" du char précédent (s'il existe)				if (	PreviousFontCharPtr){											// on calcule le pointeur absolu du char precedent							a=(unsigned long)FontBitmapPtr+PreviousFontCharPtr; //(CharHeaderPtr)				prchptr=(CharHeaderPtr)a;				prchptr->CH_NextChar=(char*)FontCharPtr;	// le ptr courant			}					// l'actuel char devient le précédent   au prochain passage			PreviousFontCharPtr=FontCharPtr;															//  ----- on dessine le caractère dans un buffer -------------						//tmpPtr=(CharHeaderPtr)GIVEDISPLAYFONT_CHARINFO(FontRender,charnum,StyleType);		tmpPtr=C_GiveDisplayFont_CharInfo(FontRender,charnum,StyleType);				flag=false;				if (tmpPtr ) {					// on calcule le row bytes de ce caractère			Row_Bytes=(tmpPtr->CH_Rect.right+1)*4;						// on recopie les dimensions du caractère.			myrect=tmpPtr->CH_Rect;			chptr->CH_Rect=tmpPtr->CH_Rect;							}		// 	on test si rectangle coherent pour une police & char <> 0xca									if ( (myrect.bottom-myrect.top)>0 &  (myrect.bottom-myrect.top)<500 ) {			if ( (myrect.right-myrect.left)>0 &  (myrect.right-myrect.left)<500 ) {			 	if (charnum!=0xca) flag=true;			}		}					// si pas de pointeur de caractères <=> problème -> on ne fait rien					if (! tmpPtr ) 	flag=false; ;					if (charnum ==0xca) flag=false;		if (charnum ==0xff) flag=false;		// ------ 										if (flag){				//on effectue le calcul du ffont du char								err= C_fastFont_Calcul_char( FontRender,chptr, tmpPtr ,charnum , StyleType,&FontCurrentPtr,FontBitmapPtr);				if (err) goto onsortdela; 								//FontCurrentPtr+=16; // pour que le ptr suivant soit valide (optionel)						}	else {				FontCurrentPtr+=16; // pour que le ptr suivant soit valide (optionel)								chptr->CH_Spare=0;				chptr->CH_Rect.top=0;						chptr->CH_Rect.left=0;						chptr->CH_Rect.bottom=0;						chptr->CH_Rect.right=0;								}	// if (flag)																// -----------------------------	// on indique l'état de progression						CharCounter++;										// on rafraichie la réglette					// on essaye d'estimer de temps restant					GetDateTime(&Date);					Date-=StartDate; 	//le temps ecoulé EN SECONDE										if (Date>10){	// on ne le fait pas pendant les 10 première secondes												estTime=((TotalChar-CharCounter)*Date)/CharCounter;						SecondsToDate((unsigned long )estTime, &datrec); // on transforme les secondes en minute,secondes												st0[0]=0;						// les minutes						NumToString(datrec.minute,&st1); 						if (st1[0]==1) {st0[0]++;  st0[st0[0]]='0';} // on ajoute un leading zero						BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);						st0[0]+=st1[0];						// les secondes						NumToString(datrec.second,&st1); 						st0[0]++;  st0[st0[0]]=':';						if (st1[0]==1) {st0[0]++;  st0[st0[0]]='0';} // on ajoute un leading zero						BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);						st0[0]+=st1[0];											} else st0[0]=nil;				if ( RPIdleWText(RPD,CharCounter,st0,nil/*&DoUpdate*/,true) ) // on rafraichi la reglette de progression						if (CautionAlert (295,nil)==1){  // l'utilisateur demande l'arrêt, on demande confirmation								HUnlock(FontRender->Render_handle);// il souhaite arrêter								DisposeHandle((Handle)FontRender->Render_handle); // on dispose le handle								FontRender->Render_handle=nil;								RPDispose(RPD);								return -2;							} //vraiment arrêter						} // for (charnum=0)			    } // if (dothechar)		} // for (style=0; style<FontRender->Face_Number,style++)onsortdela:	// on dispose l'indicateur de progression	RPDispose(RPD);// on taille le handle à la taille voulue		HUnlock (FontRender-> RenderColor_handle);	SetHandleSize (FontRender-> RenderColor_handle,FontCurrentPtr);	if (mymemH) DisposeHandle(mymemH);	return 0;		} //Create_FastFont		short  C_fastFont_Calcul_char(	FontRenderRecordPtr FontRender,	CharHeaderPtr chptr, 	CharHeaderPtr rend_chptr ,	short charnum ,	short StyleType,	unsigned long *FontCurrentPtr,	Ptr	FontBitmapPtr){unsigned long 	Row_Bytes,a,b;PlaneInfoPtr	planeinfo;short		item,i;Ptr			mem=nil;Ptr			P,P1,P2;								Row_Bytes=(rend_chptr->CH_Rect.right+1)*4; 	// le row byte du caractère sur 32 bits    														//!!!! pourquoi   CH_Rect.right+ 1?????							/*	on recupère le "base line" maximum  */				a=(unsigned long)rend_chptr+sizeof(CharHeader);		// on calcule l'adresse du plane info 1 du caractère				planeinfo=(PlaneInfo*)a;								b=planeinfo->pi_Baseline; 				//!!! note: la base line est une valeur négative								if (FontRender->Plane_Number==2){ //si 2 plans					a+=sizeof(PlaneInfo);					planeinfo=(PlaneInfo*)a;					if (b>planeinfo->pi_Baseline) 		b=planeinfo->pi_Baseline;				}								if (FontRender->Plane_Number==3){ //si 3 plans					a+=sizeof(PlaneInfo);					planeinfo=(PlaneInfo*)a;					if (b>planeinfo->pi_Baseline) 		b=planeinfo->pi_Baseline;				}				chptr->CH_Spare=b;					// on utilise le  spare pour placer la base ligne				b=-b;								// base line*-1 => ascent	// on calcule les caractèristiques génerale de la police				if (b>FontRender->max_Ascent)	FontRender->max_Ascent=b;				b=rend_chptr->CH_Rect.bottom-b;				if (b>FontRender->max_descent)	FontRender->max_descent=b;						b=rend_chptr->CH_Rect.bottom-chptr->CH_Rect.top;				if (b>FontRender->interligne)	FontRender->interligne=b;			// maintenant on effectue le calcul de la lettre ----------------	// on regarde si l'on va dépasser la  mémoire 	// l'espace pris par le caractère à calculer				a= (rend_chptr->CH_Rect.right+1);				a=a*(rend_chptr->CH_Rect.bottom+1);				a=a*4; 													//  assez de mémoire ?	/* on demande son avis à l'utilisateur */								if ( GetHandleSize(FontRender->RenderColor_handle) <  (  ((unsigned long) *FontCurrentPtr) +a ) ) {					item=StopAlert(293,nil); 															switch (item){						case 1: // ne pas garder							DisposeHandle(FontRender->RenderColor_handle);							FontRender->RenderColor_handle=nil;														return -1;						break;												case 2: //garder							SetHandleSize(FontRender->RenderColor_handle, (long) *FontCurrentPtr+16);														return nil;						break;					} // switch 				}																									/*pascal short Draw_A_Char(FontRenderRecordPtr  FontRender,short  TheChar,short TheStyle,							long  FaceColor, long BorderColor, long ShadowColor, long bgdColor,							 char  flags, short Xpos,short Ypos, char* DisplayRamPtr, long RowBytes);*/				/*b=C_Draw_A_Char(	FontRender,TheChar,TheStyle,								G.RGB_FaceColor, G.RGB_BorderColor,G.RGB_ShadowColor,0x00000000,								0xcacacaca,0,CHeader->CH_Spare,P1,Row_Bytes);*/										//saveregisteronstack();										mem=NewPtr(100*1024);							if (mem) {							b=A_Draw_A_Char(FontRender,charnum,StyleType,								G.RGB_FaceColor, G.RGB_BorderColor,								G.RGB_ShadowColor,0x00000000,								0,0,chptr->CH_Spare,(char *)mem,Row_Bytes);																				}												if (mem ) DisposePtr(mem);													// restoreregisterfromstack();								// on recopie le char 				// on calcule l'adresse absolue en mémoire du caractère à dessiner				a=(unsigned long )*FontCurrentPtr+(unsigned long )FontBitmapPtr;				P1 =	(char*) a;				P =	(char*) mem;				for (i=0;i<chptr->CH_Rect.bottom;i++){									BlockMove(P,P1,(long)Row_Bytes);					P+=Row_Bytes;					P1+=Row_Bytes;																}										//										chptr->CH_Rect=rend_chptr->CH_Rect;	// on place le rectangle pour indiquer que le caractère à bien été calculé				a= (rend_chptr->CH_Rect.right+1);				a=a*(rend_chptr->CH_Rect.bottom+1);				a=a*4; // l'espace pris par le caractère calculé				*FontCurrentPtr+=a;						// on incrémente le pointeur général sur le prochain caratère de la structure																				return nil;} //C_fastFont_Calcul_charinline asm void saveregisteronstack( void ){					move.l 	(sp)+,a0			//on recupère l'adresse de retour					movem.l 	d1-d7/a1-a4,-(sp)	//sauvegarde des registres					jmp (a0)				}				inline asm void restoreregisterfromstack( void ){										move.l 	(sp)+,a0			//on recupère l'adresse de retour					movem.l 	(sp)+,d1-d7/a1-a4	//sauvegarde des registres					jmp (a0)				}			