/*		Cette routine effectue le rendu d'une police d'affichage colorée	à partir d'une font déjà calculée, pour une grande rapiditée d'affichage  */pascal void Create_FastFont(FontRenderRecordPtr FontRender,short mode,long RenderEffect){unsigned long 		MemoireNecessaire,ul;Ptr	 			FontBitmapPtr;DialogPtr			tempdialog;long 				total,contig,TotalChar,CharCounter,Row_Bytes;Str255			st0,st1;Handle			hndl;long				PreviousFontCharOffset,FontCharOffset,a;Handle			RPD;short			TheStyle,TheChar,StyleType,First_Char,Last_Char,itemhit,b;CharHeaderPtr		PrevCHeader,CHeader,FontCharPtr,CurrentChar;PlaneInfoPtr		planeinfo,planeinfo2;char*			P1;LPtr				P2;Boolean			DotheChar;	// on regarde s'il y a un font bitmap dans le font render		if (! FontRender->Render_handle) return; // on ne fait rien// on regarde s'il y a déjà un color handle si oui on le dispose		if (! FontRender->RenderColor_handle) DisposeHandle(FontRender->RenderColor_handle);/* on effectue un calcul préalable de l'espace mémoire nécessaire pour contenir	la police d'affichage.  On ouvre un dialog pour indiquer que nous recherchons de la mémoire */		tempdialog=GetNewDialog(176,0,(WindowPtr)-1);		DrawDialog(tempdialog);			// on récupère la taille du handle display font		MemoireNecessaire=GetHandleSize(FontRender->Render_handle)*3+16000;	// on tente une allocation de mémoire		FontRender->RenderColor_handle=NewHandleClear(MemoireNecessaire);		DisposeDialog(tempdialog);				if (MemError()){			// pas assez de mémoire			// on commence par purger la mémoire			// on ouvre une alert pour indiquer le problème			PurgeSpace(&total,&contig);			NumToString(MemoireNecessaire/1024,&st0);			NumToString(contig/1024,&st1);			ParamText(&st0,&st1,nil,nil);					if (StopAlert(205,nil)==1) return; // si oui on ne fait rien				// l'utilisateur souhaite continuer			tempdialog=GetNewDialog(176,0,(WindowPtr)-1);	// dialog d'attente			DrawDialog(tempdialog);						FontRender->RenderColor_handle=NewHandleClear(contig);						if (MemError()){ // erreur on ne peut pas avoir toute cette place				DisposeDialog(tempdialog);	// on enlève le dialogue				Alert(159,nil);				return;			} else  DisposeDialog(tempdialog); 	// on enlève le dialogue		}// allocation mémoire	//  ok il y a assez de mémoire -----------------------------		HLock(FontRender->RenderColor_handle); // on lock le handle		FontBitmapPtr=*(FontRender->RenderColor_handle); // on déréférence le handle		// note: "FontCharOffset" permet l'adressage relatif// on initialise le  Font record de la police		FontRender->interligne=1;		First_Char=FontRender->First_Char=33;		Last_Char=FontRender->last_Char=255;		FontRender->max_Ascent=0;		FontRender->max_descent=0;// on prépare le "fast render handle"		FontCharOffset=FontRender->Face_Number*styleHeaderSize; // on réserve de la place pour les ptr des plans// on ouvre un indicateur de progression		TotalChar=FontRender->Face_Number*(255-33); // le nombre total de char		CharCounter=0;								// init à zéro		PreviousFontCharOffset=0; 						// raz		GetIndString(&st0,129,36); // "progression"		GetIndString(&st1,129,52); // "mise en forme police"		RPD=RPInitReglette(&st0,&st1,1,TotalChar,true);	// ouverture progression"		/*  boucle 1 : boucle	style ( normal, gras, italique )*/	for (TheStyle=0;TheStyle<FontRender->Face_Number;TheStyle++){		// initialisation pointeurs "Display font" boucle style			FontCharOffset=((FontCharOffset+3)/4)*4; //alignement sur 32 bits (plus de vitesse)						//on initialise le header du style 						ul=styleHeaderSize*TheStyle+(unsigned long) FontBitmapPtr;			P2=(long*)ul;			*(P2)=(long)0;						/*			a=styleHeaderSize*TheStyle;			P2=(long*)FontBitmapPtr;			P2+=(long*)a;			*(P2)=(long)0;					// raz		*/			StyleType=0;				// raz						if  (TheStyle==1){				if (FontRender->FontStyle&0x1) StyleType=1;				// bold ?				else   if (FontRender->FontStyle&0x2) StyleType=2; 		// si pas bold on fait italique					else  continue; 								// on ne fait pas le style			}						if  (TheStyle==2){				if (FontRender->FontStyle&0x2) 	StyleType=2; 			// on fait italique				else 	continue;									// on ne fait pas le style			}		 						//on stocke l'adresse du style en cours dans l'en tête			*(P2)=(long)FontCharOffset; // boucle caractère------			for (TheChar=First_Char;TheChar<=Last_Char;TheChar++){				// initialisation des pointeurs "Display font" boucle caractères		// on update l'en tête du caractère				if (TheChar==129) SysBreak();												ul=(unsigned long) FontBitmapPtr+(unsigned long)FontCharOffset;				/*CHeader=(CharHeaderPtr)(FontBitmapPtr+FontCharOffset);*/				CHeader=(CharHeaderPtr)ul;						CHeader->CH_NextChar=0; 				CHeader->CH_PreviousChar=(char*)PreviousFontCharOffset; 				CHeader->CH_CharNumber=TheChar; 								CHeader->CH_Rect.top=0; 				CHeader->CH_Rect.left=0; 				CHeader->CH_Rect.bottom=0; 				CHeader->CH_Rect.right=0; 												ul=(unsigned long) FontBitmapPtr+(unsigned long)PreviousFontCharOffset;				PrevCHeader=(CharHeaderPtr)ul;				/*PrevCHeader=(CharHeaderPtr)(FontBitmapPtr+PreviousFontCharOffset);*/				PrevCHeader->CH_NextChar=(char*)FontCharOffset;						// pour le coup suivant				PreviousFontCharOffset= FontCharOffset;				DotheChar=true;																										if (TheChar==0xCA) DotheChar=false; //altspace on ne le traite pas						CurrentChar=C_GiveDisplayFont_CharInfo(FontRender,TheStyle,TheChar); // on demande le header du caractère								if (!CurrentChar)    DotheChar=false; 								if ( (CurrentChar->CH_Rect.bottom-CurrentChar->CH_Rect.top ) > 300) DotheChar=false; 				if ( (CurrentChar->CH_Rect.bottom-CurrentChar->CH_Rect.top ) <=0) DotheChar=false; 				if ( (CurrentChar->CH_Rect.right-CurrentChar->CH_Rect.left ) > 300) DotheChar=false;				if ( (CurrentChar->CH_Rect.right-CurrentChar->CH_Rect.left ) <=0) DotheChar=false;								if (DotheChar) {// si le caractère n'existe pas alors on ne le traite pas					Row_Bytes=(CurrentChar->CH_Rect.right+1)*4; 	// le row byte du caractère sur 32 bits    															//!!!! pourquoi   CH_Rect.right+ 1?????									/*	on recupère le "base line" maximum  */					ul=(unsigned long) CurrentChar+ sizeof(CharHeader);					P1=(Ptr)ul;					planeinfo=(PlaneInfo*)P1;									/*P1= (Ptr)CurrentChar;		// on calcule l'adresse du plane info 1 du caractère					P1+=(Ptr)sizeof(CharHeader);					planeinfo=(PlaneInfo*)P1;					*/					a=planeinfo->pi_Baseline; 			//!!! note: la base line est une valeur négative										if (FontRender->Plane_Number==2){ //si 2 plans						planeinfo+=(PlaneInfoPtr)sizeof(PlaneInfo);						if (a>planeinfo->pi_Baseline) 		a=planeinfo->pi_Baseline;					}										if (FontRender->Plane_Number==3){ //si 3 plans						planeinfo+=(PlaneInfoPtr)sizeof(PlaneInfo);						if (a>planeinfo->pi_Baseline) 		a=planeinfo->pi_Baseline;					}					CHeader->CH_Spare=a;					// on utilise le  spare pour placer la base ligne					a=-a;								// base line*-1 => ascent		// on calcule les caractèristiques génerale de la police					if (a>FontRender->max_Ascent)	FontRender->max_Ascent=a;					a=CurrentChar->CH_Rect.bottom-a;					if (a>FontRender->max_descent)	FontRender->max_descent=a;							a=CurrentChar->CH_Rect.bottom-CurrentChar->CH_Rect.top;					if (a>FontRender->interligne)	FontRender->interligne=a;					// maintenant on effectue le calcul de la lettre ----------------		// on regarde si l'on va dépasser la  mémoire 					a= (CurrentChar->CH_Rect.right+1);					a=a*(CurrentChar->CH_Rect.bottom+1);					a=a*4; // l'espace pris par le caractère à calculer										if (   GetHandleSize(FontRender->RenderColor_handle) - (FontCharOffset+a)<0){						// problème pas assez de mémoire						itemhit=StopAlert(293,nil); // on demande son avis à l'utilisateur						switch (a){							case 1: // ne pas garder								DisposeHandle(FontRender->RenderColor_handle);								FontRender->RenderColor_handle=nil;							break;														case 2: //garder								SetHandleSize(FontRender->RenderColor_handle,FontCharOffset+16);							break;						} // switch								RPDispose(RPD);						return;					}										// on calcule l'adresse absolue en mémoire du caractère à dessiner													ul=(unsigned long) FontCharOffset+FontBitmapPtr; 										/*P1=(char*)FontCharOffset;					P1+=FontBitmapPtr;*/					P1=(char*)ul;													/*pascal short Draw_A_Char(FontRenderRecordPtr  FontRender,short  TheChar,short TheStyle,								long  FaceColor, long BorderColor, long ShadowColor, long bgdColor,								 char  flags, short Xpos,short Ypos, char* DisplayRamPtr, long RowBytes);*/									b=Draw_A_Char(FontRender,TheChar,TheStyle,									/*G.RGB_FaceColor*/-1, /*G.RGB_BorderColor*/0,									G.RGB_ShadowColor,0x00000000,									0,0,CHeader->CH_Spare,P1,Row_Bytes);																/*b=C_Draw_A_Char(	FontRender,TheChar,TheStyle,									G.RGB_FaceColor, G.RGB_BorderColor,G.RGB_ShadowColor,0x00000000,									0xcacacaca,0,CHeader->CH_Spare,P1,Row_Bytes);*/														a= (CurrentChar->CH_Rect.right+1);					a=a*(CurrentChar->CH_Rect.bottom+1);					a=a*4; // l'espace pris par le caractère à calculer					CHeader->CH_Rect=CurrentChar->CH_Rect;	// on place le rectangle pour indiquer que le caractère à bien été calculé					FontCharOffset+=a;						// on incrémente le pointeur général sur le prochain caratère de la structure					} else { //if (CurrentChar) 				FontCharOffset+=16;				}	// on incrémente la réglette	// et on regarde si l'utilisateur demande l'arrêt du calcul				CharCounter++;								if ( RPIdle(RPD,CharCounter,&DoUpdate,nil) ){					// on demande l'arrêt					itemhit=CautionAlert (294,nil); // on demande son avis à l'utilisateur					switch (itemhit){						case 1:  	// ne pas garder							DisposeHandle(FontRender->RenderColor_handle);							FontRender->RenderColor_handle=nil;						break;												case 2: 	// garder les info							SetHandleSize(FontRender->RenderColor_handle,FontCharOffset+16);						break;												case 3:	// continuer						break;					} // switch										// on dispose l'indicateur de progression					RPDispose(RPD);					return;	// on s'en va									}// si arrêt mise en forme		} // for char	} // for style...	// le rendu est terminé// on ajuste le handle à la taille exacte		SetHandleSize(FontRender->RenderColor_handle,FontCharOffset+16);// on dispose l'indicateur de progression		RPDispose(RPD);}*/