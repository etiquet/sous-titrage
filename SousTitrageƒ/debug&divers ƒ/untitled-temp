/** ================================================* PROCEDURE Create_FastFont(); * ================================================**	Cette routine effectue le rendu d'une police d'affichage colorée*  à partir d'une font déjà calculée, pour une grande rapiditée d'affichage*  *Create_FastFont 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFontRender			ds.l	1		; record pour le passage des parramètres de rendusDestinationSize		ds.w	1		; 16 ou 32 bits mode ?RenderEffect		ds.l	1		; effet de rendu ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256XOffset					ds.w	1YOffset					ds.w	1Pointeur				ds.l	1			; déréférence du handlehandle					ds.l	1			; handle pour le dessinRGB_Color				ds.W	3Itemchoisi				DS.w	1		; Item choisi par l'utilisateuritemType				ds.w	1		; stockage du type de ItemitemHandle				ds.L	1		; stockage	du handle du itemitemRect				ds		Rect	DialogStorage			ds		dWindLenWaitingDialogStorage	ds		dWindLenThepoint				ds.l	1TotalChar				ds.w	1		; nb total de caractère à rendreCharCounter				ds.w	1		; total de caractère rendubaseLine				ds.w	1		; cf Render sub routineStyleType				ds.w	1		; style en cour	type style MAC   (cf Quick Draw)theStyle				ds.w	1		; style en cour compteur 0....nTheChar					ds.w	1		; caractère en courThePlane				ds.w	1		; plan en cour (face/bordure/ombre)CharRect				ds		Rect	; carré du plan dessinéFontBitmapPtr			ds.l	1		; pointeur du début du bitmap de la policeFontBitmapSize			ds.l	1		; taille du "font bitmaps"  FontBitmapHimem			ds.l	1		; pointeur de la fin du bitmap de la police n.u.FontCurrentPtr			ds.l	1		; pointeur relatif positiion dans  le handleFontStylePtr			ds.l	1		; pointeur relatif du styleFontCharPtr				ds.l	1		; pointeur relatif du caractère (Charheader) dans le stylePreviousFontCharPtr		ds.l	1		; pointeur relatif au précédent caarctèreFontPlanePtr 			ds.l	1		; pointeur relatif du plan dans le caractèreSavePort				ds.l	1		; save portsaveD1					ds.l	1		;Row_Bytes				ds.l	1Base_Adresse 			ds.l	1	Row_BytesVX				ds.l	1spare					ds.l	2ItemHit		ds.w	1CurrentcharRect	ds		rect		;LocalSize	EQU 	*			; size of all the local variables		ENDR		SEG	'Rendering'			; case sensitive			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor	;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,Rendering_font_SubRoutine; 		movem.l d1-d7/a1-a4,-(sp)	; sauvegarde des registres* ----- pour les tests on dessine également dans la vidéo explorer; on recherche la base adresse et le rowbyteFontRender			ds.l	1		; record pour le passage des parramètres de rendusDestinationSize		ds.w	1		; 16 ou 32 bits mode ?RenderEffect		ds.l	1		; effet de rendu 		*/														/*		; on calcule le nombre de caractère à rendre; pour l'indicateur d'état.		move.l	FontRender(a6),a0		; font record		move.w	Face_Number(a0),d0		mulu.w	#255-33,d0				; nombre total de caractère à rendre (sauf espace)		move.w	d0,TotalChar(a6)				move.w	#0,CharCounter(a6)		; reset du compteur			move.l	FontRender(a6),a1		clr.w	max_descent(a1)		clr.w	max_Ascent(a1); calcul de l'espace; -------------------------	 boucle 1 : boucle	style	-------------------;( normal, gras, italique ); initialisation boucle style		move.w	#0,TheStyle(a6)		; initialisation	Style_Loop; initialisation pointeurs "Display font" boucle style		move.l	FontBitmapPtr(a6),a0		; abs ptr du Displayfont	move.l	FontCurrentPtr(a6),d0		; on calcule l'adresse du style	import	aligneD0	jsr		aligneD0	move.l	d0,FontStylePtr(a6)				; adresse du "style"	move.l	d0,FontCurrentPtr(a6)			; aligné sur dc.l	move.l	#0,d1	move.w	theStyle(a6),d1	move.l	d0,(a0,d1.l*styleHeaderSize)		; on stocke l'adresse du style dans l'en tête	move.l	#0,PreviousFontCharPtr(a6)	; raz; on indique le style du caractère				move.w	TheStyle(a6),d0			case#.w	(d0,if),\ 			(0,Normal_style),\			(1,Italique_style),\			(2,Bold_style) 			bra		EndLoop_Style			; style pas connu on ne le fait pas		Normal_style					clr.w	StyleType(a6)					bra		start_CharLoop		; on y va; ------------ Bold_style; on regarde si le style italique est demandé										move.l	FontRender(a6),a0		; font record					move.w	FontStyle(a0),d0					and.w	#1,d0					beq		EndLoop_Style			;pas bold donc ?: on passe au suivant					move.w	#1,StyleType(a6)					bra		start_CharLoop		; on y va; ------------Italique_style; on regarde si le style italique est demandé					move.l	FontRender(a6),a0		; font record					move.w	FontStyle(a0),d0					and.w	#2,d0					beq		Bold_style				; pas italique , bold ?					move.w	#2,StyleType(a6); ------------------------start_CharLoop		; boucle 2 : boucle caractères ; de 33 à 255 pour l'instant							move.w	#33,TheChar(a6)		; initialisation		Loop__Char; initialisation des pointeurs "Display font" boucle caractères	move.l	FontBitmapPtr (a6),a0		; abs ptr du Displayfont	move.l	FontCurrentPtr(a6),d0		; pointeur courant	move.l	d0,FontCharPtr(a6)			; pointeur courant => fontchar	add.l	#CharHeaderSize,d0			; header du caractère	move.l	d0,FontCurrentPtr(a6)		; réservation de l'espace----------; on update les pointeurs de cet en tête		move.l	PreviousFontCharPtr(a6),d0	move.l	FontCharPtr(a6),d1	move.l	d0,CH_PreviousChar(a0,d1.l)					; previous Ptr	clr.l	CH_NextChar(a0,d1.l)						; next Ptr		move.w	TheChar(a6),CH_CharNumber(a0,d1.l)		; n° de caractère rendu 												move.w	#$caca,CH_Spare(a0,d1.l)			; le spare je met $caca pour mieux identifier cette position; on raz le rectangle 			move.w	#32000,left+CH_Rect(a0,d1.l)	; ≈ valeur maximum		move.w	#32000,top+CH_Rect(a0,d1.l)		; ≈ valeur maximum		move.w	#0,right+CH_Rect(a0,d1.l)	; ≈ valeur maximum		move.w	#0,bottom+CH_Rect(a0,d1.l)		; ≈ valeur maximum	; on update le nextPtr du char précédent (s'il existe)														move.l	PreviousFontCharPtr(a6),d0	beq.s	PasPreviousChar				; nous sommes au premier caractère	move.l	FontCharPtr(a6),CH_NextChar(a0,d0.l)		; ptr next du précédent	PasPreviousChar				move.l	FontCharPtr(a6),PreviousFontCharPtr(a6)		; l'actuel char devient le précédent 															; au prochain passage																																				; ----- on dessine le caractère dans un buffer -------------				move.l	FontRender(a6),a0		move.w	theStyle(a6),d1		move.w	TheChar(a6),d0		import	GiveDisplayFont_CharInfo		jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan		tst.w	d0		bne  	fin_loop_char			; il y a une erreur							move.w	right+CH_Rect(a0),d0		addq.w	#1,d0		mulu	#4,d0					; row bytes (mot long)		move.l	d0,Row_Bytes(a6)						move.l	FontBitmapPtr (a6),a1		; abs ptr du Displayfont		move.l	FontCharPtr(a6),d2				move.w	top+CH_Rect(a0),top+CH_Rect(a1,d2.l)		move.w	left+CH_Rect(a0),left+CH_Rect(a1,d2.l)		move.w	right+CH_Rect(a0),right+CH_Rect(a1,d2.l)		move.w	bottom+CH_Rect(a0),bottom+CH_Rect(a1,d2.l)				move.l	CH_Rect(a0),CurrentcharRect(a6)		move.l	4+CH_Rect(a0),4+CurrentcharRect(a6); on test si rectangle coherent; pour la police		move.w	bottom+CH_Rect(a0),d0	; en hauteur		sub.w	top+CH_Rect(a0),d0		bmi     paschar		cmp.w	#300,d0		bhi		paschar		move.w	right+CH_Rect(a0),d0	; en largeur		sub.w	left+CH_Rect(a0),d0		bmi     paschar		cmp.w	#300,d0		bhi		paschar				cmp.w	#$ca,TheChar(a6)		bne.s	PasCapaschar				clr.l	CH_Rect(a1,d2.l)		clr.l	4*CH_Rect(a1,d2.l)		clr.w	CH_Spare(a1,d2.l)				bra		fin_loop_char		; on ne dessine pas le caractère $CA		PasCa		; on recupère le max base line; !!! note: la base line est une valeur négative !		move.w	pi_Baseline+CharHeaderSize(a0),d0	; base line de la face		cmp.w	#2,d1		; border ?			blo.s	FoundMaxBaseLine		cmp.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0	; base line border		blt.s	@shadowMax		move.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0	; base line border@shadowMax		cmp.w	#3,d1		; shadow ?			blo.s	FoundMaxBaseLine		cmp.w	pi_Baseline+PlaneInfoSize*2+CharHeaderSize(a0),d0	; base line border		blt.s	FoundMaxBaseLine		move.w	pi_Baseline+PlaneInfoSize*2+CharHeaderSize(a0),d0	; base line borderFoundMaxBaseLine						move.w	d0,CH_Spare(a1,d2.l)		; spare pour base ligne		neg.w	d0							; base line*-1 => ascent		move.l	FontRender(a6),a1; calcul de max Ascent				cmp.w	max_Ascent(a1),d0		blo.s	not_MaxAscent		move.w	d0,max_Ascent(a1)not_MaxAscent		; on calcule du descent du char		move.w	bottom+CH_Rect(a0),d1		add.w	pi_Baseline+CharHeaderSize(a0),d1	; descent= bottom-baseline (face)		cmp.w	max_descent(a1),d1		blo.s	not_Maxdescent		move.w	d1,max_descent(a1)		not_Maxdescent		move.w	max_Ascent(a1),d1		add.w	max_descent(a1),d1;		move.w	bottom+CH_Rect(a0),d1		cmp.w	interligne(a1),d1		blt.s	Not_MaxHeight		move.w	d1,interligne(a1)		Not_MaxHeight				; --------------------------------------------------						clr.w	-(sp)					move.l	FontRender(a6),-(sp)		move.w	TheChar(a6),-(sp)		move.w	theStyle(a6),-(sp)		move.l	G.RGB_FaceColor,-(sp)			move.l	G.RGB_BorderColor,-(sp)		move.l	G.RGB_ShadowColor,-(sp)		move.l	#0,-(sp)		; Bgdcolor				move.w	#0,-(sp)		; transparent black for bgd					move.w	#0,-(sp)	;x		move.w	d0,-(sp)	;y  ; base line 		move.l	Pointeur(a6),-(sp)		; block mémoire temporaire		move.l	Row_Bytes(a6),-(sp)		; largeur pour des long word		import		Draw_A_Char		jsr			Draw_A_Char				move.w		(sp)+,d0		; largeur du carctère (on s'en fout ici); ----- on recopie ce caractère dans le fast font bitmap --------; boucle de recopie		move.w	#0,d6						move.l	Base_Adresse(a6),a4		; base VX				move.l	Pointeur(a6),a0						;bitmap source		move.l	Row_Bytes(a6),d5		move.l	FontCurrentPtr(a6),a1		adda.l	FontBitmapPtr (a6),a1				; pointeur absolu pour recopie		; on calcule le row byte pour l'arrivée 16 ou 32 bits				move.l	Row_Bytes(a6),d4					;row byte source bitmap		cmp.w	#16,DestinationSize(a6)				; 16 ou 32 bits		bne.s	Boucle_recopieVerticale				; non, mode 32 bits		lsr.l	#1,d4								; row byte sur 16 bits		; d5 = row byte de la source; d4 = row byte de l'arrivée; a0 = ptr de la source; a1 = ptr de l'arrivée ; d7= X ; d6= Y		Boucle_recopieVerticale		move.w	#0,d7		; largeur (pts)Boucle_recopieHorizontale		move.l	(a0,d7.w*4),d0						; données de la source		; mode 16 ou 32 bits		cmp.w	#32,DestinationSize(a6)						beq.s	Mode32bits; -----   mode 16 bits; on convertie le mots long en word, pour les détails voir Color QuickDraw direct color ; RGB 8888 en   RGB1555 (alpha, red,green,blue)		move.l	d0,d2		clr.l	d0		; alpha channel		move.l	d2,d1		and.l	#$ff000000,d1		beq.s	MakeBlue					;  =0 => alphabit=0 		or.w	#$8000,d0					; ≠0 alphabit =1MakeBlue		; blue 						|... aaaaaaaa rrrrrrrr gggggggg (bbbbb)| bbb 		lsr.l	#3,d2		move.l	d2,d1		and.l	#%0000000000011111,d1				or.w	d1,d0; green 					|......	aaaaaaaa rrrrrrrr (ggggg)ggg bb| bbbbbb					lsr.l	#3,d2		move.l	d2,d1		and.l	#%0000001111100000,d1		or.w	d1,d0; red	 					|.........	aaaaaaaa (rrrrr)rrr ggggggg| g bbbbbbbb					lsr.l	#3,d2		move.l	d2,d1		and.l	#%0111110000000000,d1		or.w	d1,d0; on le place dans la mémoire		move.w	d0,(a1,d7.w*2)		; word		bra.s	finligne; ----Mode32bits; on le place dans la mémoire		move.l	d0,(a1,d7.w*4)		; long;		move.l	d0,(a4,d7.w*4)		; dans la VXfinligne		addq.W	#1,D7			cmp.w	right+CurrentcharRect(a6),d7		bls		Boucle_recopieHorizontale				add.l	d5,a1			; ligne suivante destination		add.l	d5,a0			; ligne suivante source		add.l	Row_BytesVX(a6),a4				addq.W	#1,D6			cmp.w	bottom+CurrentcharRect(a6),d6		bls		Boucle_recopieVerticale; ----- update du ptr de la zone mémoire --------------				move.w	bottom+CurrentcharRect(a6),d0				addq.w	#1,d0				move.w	right+CurrentcharRect(a6),d1				addq.w	#1,d1				mulu	d1,d0				lsl.l	#1,d0		; pour 16 bits				cmp.w	#16,DestinationSize(a6)				; mode 16 ou 32 bits				beq.s	M_16				lsl.l	#1,d0		; pour 32 bitsM_16					import	aligneD0				jsr		aligneD0				; il vaut mieux car si la base est dc.l												; on peut travailler en mot long (plus rapide) 				add.l	FontCurrentPtr(a6),d0	; "reservation de l'espace" 				move.l	d0,FontCurrentPtr(a6)				move.l	d0,FontPlanePtr(a6)		* -------- fin loop des plans incr loop caractèresfin_loop_char*/