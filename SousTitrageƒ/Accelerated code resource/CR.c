/****************************************************************************					CR.c11/29/94This file is for building an accelerated PPC resource that can be called by either a 68K app or a PPC app.  Please see the accompanying file "About Accelerated Resources" in this directory for more information.If your resource type isn't one of the normal system resources like WDEF, DRVR, etc.,you will need to give an appropriate value to __procinfo for the linker.  __procinfo, a global variable is of ProcInfoType informs the Mixed Mode Manager of the parameters and return type of your main entry point (main in this case).  The Universal Headers have countless examples of how to do this but in particular, you should look at MixedMode.h.  As an example, AppleEvents.h has:enum {	uppAEEventHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(AppleEvent*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(AppleEvent*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))};If this set of parameters and return value match your main function, thenyou would use the above enum and  ProcInfoType __procinfo = uppAEEventHandlerProcInfo;If not, you will need to insert your return value and paramater sizes.  Since this code resource's main is void, all you need to have is kThinkCStackBased by itself(kCStackBased uses MPW calling conventions).  However, to avoid problems with 68K parameter passing conventions, it is usually best to have the main entry point be pascal and use kPascalStackBased instead of kThinkCStackBased.  If you do want to use C calling conventions, you will need to use kThinkCStackBased.  Our Technical Notes mention some of the differences between MPW and CW calling conventions.  There is a limitation with both kPascalStackBased and kThinkCStackBased also.  Do not have a parameter or a return value of more than 4 bytes (pass a pointer instead) with either kPascalStackBased and kThinkCStackBased.  If you are calling a C++ member function as an entry point (that has an implicit thisPtr), I wouldn't recommend it since CW puts the thisPtr into the A0 register.  Please note that the calling app has to match the calling convention used in the code resource.What to do:1.  Build 68K App.¹.2.	Build PPC ACR.¹.  Select to merge its output into 68K App.3.  Launch the app and it beeps.  Pretty neat, huh?4.  Build PPC App.¹.5.	Build PPC ACR.¹. Select to merge its output into PPC App.6.  Launch the app and it beeps.  OK, maybe this time you weren't impressed.Mark Andersonmetrowerks****************************************************************************/#include <MixedMode.h>ProcInfoType __procinfo = kThinkCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(char*)));void main(char * str){	StringPtr pStr;	SysBeep(2);		pStr = c2pstr(str);  //Converts C string from testing App to Pascal string	//DebugStr(pStr);  //Uncomment this line to drop into Macsbug to monitor use of ACR}