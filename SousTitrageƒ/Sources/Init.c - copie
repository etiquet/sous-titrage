#include "BB.Globals_C.h"#include "E3DEMO.H"#include "appleEventHandlers.h"#include <QuickTimeComponents.h>#include <ImageCompression.h>//#define __Debug__ 1pascal short 	FIRSTVE (void);pascal void	DoPrepareVBLJump	(void);pascal void 	LitPreferenceGenerale(void);DialogPtr 		OpenErrorWindow(WindowPtr behind);static void 	InitialisationCarteGraphique(void) ;pascal OSErr	launchMoniteurVideo(void);pascal void	QuitMoniteurVideo(void);pascal OSErr	launchSFG(void);pascal void 	DoInitAV(void);pascal void 	InitUndoRedo(void);void 			Pre_InitAV(void);static void 	InitSomeGlobals_1(void);static void 	InitNuVistaExplorer(void);static void	SetUpAppleEvents(void);static void 	DrawInitDialog (void);void 			GiveMeMoreMaster(void);void 			InitTheMac(void);void 			DoInitSomeValue2(void);void 			InitialiseLalistedesSousTitres(void);pascal void 	TestAdresseGlobales(void);static pascal void InitialisationMenus(void);pascal void	GetMainScreenRes(Rect *rect);Boolean 		IsMemoryConfigurationOK(void);void 			essais(TMXTaskPtr Xtask:__A1);void 			MesureCpuVitesse(TMXTaskPtr myTask:__A1);void 			CalcVtr_Speed(TMXTaskPtr myTask:__A1);void 			GenerateurInterne(TMXTaskPtr myTask:__A1);extern void 	VBL_STARTCODE(void);extern void 	SERIAL(void);void 			Termine_BonBougre(void);pascal void 	CloseErrorWindow(DialogPtr dlog);void 			DoDisposeAV(void);void 			FadeInDialog(void);static void 	ShowMyWindows(void);static void 	GetMyWindows(void);pascal void 	EcritPreferenceTravail(void);pascal void 	InitUndoRedo(void);void 			CentreLAFenetreAV(Boolean always);static void 	MakeCarteGraphiqueListe(void);void 			InitialiseLacarte(short index);void 			InitMacPourVersionBroadcast(void);pascal void	DisposeBazardGraphique(void);OSErr  		FindBoardsResource(short slot,Str255 name);int	  		GetLicenseInfo(void);void 	  		Install_XTask(void);void     		Dispose_XTask(void);void 	  		Patch_ExitToshell(void);void    		jumpExitToshell( void );void 			C_DoPrepareVBLJump( void );asm void 		C_DoPrepareVBLJumpCode(void);pascal void 	VBLMAINTASK(void);long  getserialnumber (void);// les globalsextern AppGlobals G;extern MyQDGlobals QD;// globales pour le mode AVextern WindowPtr 	gMonitor;extern 			SeqGrabComponent gSeqGrabber;extern GDHandle 	gAVDevice;static long	 		total,contig;static short 		MinDepth;static DialogPtr 	StartUpDialog;extern long 		gValue;static Str255 		st0,st1,st2,st3;extern DialogPtr	gBlankingVerticalWindow,gPaletteKaraoke;extern Boolean 		gCanReadVitc,gCodageBlanckingVerticalActif,gGenereSousTitreBlankInterval,gDecodeBlanckingVertical;short			gAppResFileNumber;Boolean			gModeKaraoke,gTaskInstalled,gUtiliseXTask;short 			gDecalText;extern short 		gCurResNum;DialogPtr 			gDialogProchainSousTitre,gtestDecodageWindow;static 			UniversalProcPtr gOldExitToShellTrap; // la vieille adresse de ExiToshellshort			gNombreCarteGraphique,gVBLInstalled;CarteGraphElement 	gListeCarteGraph[6];Boolean 			IsQuickTimeInstalled (void) ;extern Ptr		SerBuff1,SerBuff2;TMXTask 			gMesureVtrSpeed;extern long		DoVitcReadSerialRequest;extern Ptr		SerBuff1,SerBuff2;// nouveau mode saisie des tcshort			gModeSaisieTC;void C_QuitApplication(void){DialogPtr	wait_dlog;	 wait_dlog= GetNewDialog(140,nil,(WindowPtr)-1);	 SetPort(wait_dlog);		 TextFont(geneva); 	 TextSize(9); 	 DrawDialog(wait_dlog);		Dispose_XTask();// on update le fichier préférence 	EcritPreferenceTravail(); 	PutFonctionKeyinPref(); 	/* on arrête la cassette , on la met en sbof */	if (G.ModemOutRefNum){			// on raz les " Pending IO "		if (G.ModemInRefNum) KillIO(G.ModemInRefNum); 		KillIO(G.ModemOutRefNum); 				TxRS422('STOP',0x5F,G.ModemOutRefNum);		TxRS422('SBOF',0x5F,G.ModemOutRefNum);				// on désactive le relais		Control(G.ModemOutRefNum, 17, nil);		Control(G.ModemOutRefNum, 18, nil);		WaitTicks(10);				SerSetBuf(G.ModemInRefNum,SerBuff1,0); //{set the buffer}		SerSetBuf(G.ModemOutRefNum,SerBuff2,0); //{set the buffer}		WaitTicks(30);		// on ferme les ports 		if (G.ModemInRefNum) FSClose(G.ModemInRefNum); 		WaitTicks(10); 		FSClose(G.ModemOutRefNum);	}	// on quitte les applications que l'on a lancée (s'il elle existent bien sûr).	if (IsQuickTimeInstalled ()) DoDisposeAV();	if(gVBLInstalled)  DisposeBazardGraphique();	// on ferme les fenêtre flotante/*		if (G.TELECOMMANDEWindow) 			DisposeDialog(G.TELECOMMANDEWindow);	if (G.ChenilleWindow) 				DisposeDialog(G.ChenilleWindow);	//if (G.LogoWindow) 				DisposeDialog(G.LogoWindow);	if (G.BlockNoteWindow) 				DisposeDialog(G.BlockNoteWindow);	if (G.ServiceWindow) 				DisposeDialog(G.ServiceWindow);	if (G.ErrorsWindow) 					CloseErrorWindow(G.ErrorsWindow);	if (gPaletteKaraoke)					ClosePaletteKaraoke(gPaletteKaraoke);*/// on dispode les gworlds	if (G.OffscreenSaisie) 				DisposeGWorld(G.OffscreenSaisie);	if (G.OffscreenChenille) 				DisposeGWorld(G.OffscreenChenille);	if (G.OffscreenRendering)				DisposeGWorld(G.OffscreenRendering);	if (G.OffscreenListing)				DisposeGWorld(G.OffscreenListing);	if(G.DuplicateOffscreenBuffer) 			DisposePtr(G.DuplicateOffscreenBuffer);		QuitSansFauteGrammaire();	DisposeDialog(wait_dlog);}void Initialise_BonBougre(void){	short 			itemtype;	Handle			item;	WindowPtr		w;	Rect 				rect;	long				RAF;	Handle			h;/* on alloue des Masters Pointeurs pour des handles */			 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();		 GiveMeMoreMaster();	/* on initialise les Manager etc..*/			InitTheMac();// on configure le logiciel		InitSomeGlobals_1();		/* on initialise Quelques globales */		gAppResFileNumber=CurResFile();		gGenereSousTitreBlankInterval=false;		gDecodeBlanckingVertical=false;		gCodageBlanckingVerticalActif=false;		gTaskInstalled=false;		gUtiliseXTask=true;/* on ouvre la fenètre back drop (fond de l'écran)*/		w=GetNewCWindow(130,(WindowPtr)&G.BackDropWindow,(WindowPtr)-1);		SetWRefCon(w,1000);		rect=(**GetMainDevice()).gdRect;		MoveWindow(w,rect.left,rect.top+20,true);		SizeWindow(w,rect.right-rect.left,rect.bottom-rect.top,true);		DoUpdate(w);				rect=(**GetMainDevice()).gdRect;/* 	On commence par dire à l'utilisateur ce que l'on fait.		On ouvre un dialog	on récupère les informations de licence (sauf le N° de série)*/// on regarde si les information de license existe 		h=Get1Resource('STR#',136);		if (h)  ReleaseResource(h);		if (!h) {			// on demande les information de license			if (!GetLicenseInfo())  ExitToShell();			UpdateResFile(gCurResNum);			w=(WindowPtr)&G.BackDropWindow;			SetPort((GrafPtr)w);			InvalRect(&w->portRect);			DoUpdate((WindowPtr)w);			SetPort(StartUpDialog);				} 		GetIndString(&st0,136,2); // nom prenom		GetIndString(&st1,136,5); // société		GetIndString(&st2,136,1); // modèle		//GetIndString(&st3,136,7); // n° de série		NumToString(getserialnumber(),&st3);		ParamText(&st0,&st1,&st2,&st3);				StartUpDialog=GetNewDialog(191,(Ptr)nil,(WindowPtr)-1);		SetPort(StartUpDialog);		/* on fait l'anim d'entrée*/  		FadeInDialog();  		/* on dessine vraiment le bazar*/		DrawInitDialog ();				MinDepth=GiveMinDepth(&StartUpDialog->portRect);		if (MinDepth==1) AlertUser(16);		DrawInitDialog ();		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,18);		SetIText(item,&st3);  // on indique ce que l'on fait/* on regarde s'il faut créer le dossier préf etc.*/		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,19);		SetIText(item,&st3);  // on indique ce que l'on fait		/* on récupère les préférences */		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,20);		SetIText(item,&st3); 		 	// on indique ce que l'on fait		G.Preference_PourTravail=nil;		// on raz le pointeur	 		 	LitPreferenceGenerale();// on vérifie les paramêtre de PPatpour les fonds de fenêtres (erreurs dans les préférences entre v1.4 et V1.5)		if (G.BackDrop_PatNum<128 || G.BackDrop_PatNum>200) 	G.BackDrop_PatNum=134;		if (G.Listing_PatNum<128 || G.Listing_PatNum>200)G.Listing_PatNum=140	;		if (G.Saisie_PatNum<128 || G.Saisie_PatNum>200)G.Saisie_PatNum=129;/*on démarre le programme*//* on regarde s'il faut fermer la fenêtre backdrop (en fct des préférences)*/		if (G.Preference_MultiFinder) HideWindow(w); 		SetPort(StartUpDialog); 		/*Demande de mémoire pour le logiciel*/		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,22);		SetIText(item,&st3);  // on indique ce que l'on fait init mémoire/* Gestion de la Clef de  protection du logiciel */#ifndef	__NoProtect__		DoInitSomeValue2();#endif 		ParamText(&st0,&st1,&st2,&st3);/* maintenant, on demande de la mémoire*/		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,24);		SetIText(item,&st3);  // on indique ce que l'on fait init mémoire -3-				G.General_PremierSTPtr=(SousTitreRecordPtr)NewPtrClear(1048576); //1Mo		if (MemError()) { 			AlertUser(2);			ExitToShell();   			}   					G.BufferTransfert=NewPtrClear(204800); //200Ko				if (MemError()) { 			AlertUser(2);			ExitToShell();   			}   					GetDItem(StartUpDialog,11,&itemtype,&item,&rect);		SetIText(item,"\pInitialisation de la mémoire.....");  // on l'indique		G.SIZEBufferTransfert=204800;		G.General_HIMEMST=1048576;		G.General_HIMEMST=G.General_HIMEMST+(long)G.General_PremierSTPtr;/*  on rafraichi les fenêtres */		DrawInitDialog ();		w=(WindowPtr)&G.BackDropWindow;		SetPort((GrafPtr)w);		InvalRect(&w->portRect);		DoUpdate((WindowPtr)w);		SetPort(StartUpDialog);		/*	 	On initialise la routine Timer 		Elle permet de généré un time code interne*/		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,31);		SetIText(item,&st3);  // on indique ce que l'on fait loadage timer					RAF=C_AdditionTimeCode(1,1);	// on charge le segment main.a.o pour cette routine				Install_XTask();		SetPort(StartUpDialog);		GetIndString(&st0,136,1);		GetIndString(&st1,136,2);		GetIndString(&st2,136,3);	 	ParamText(&st0,&st1,&st2,nil);/*on installe les apple events que l'on supporte Open,print,open file,quit */		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,28);		SetIText(item,&st3);  		SetUpAppleEvents();		/*  on place les menus */		InitialisationMenus();		/* On initialise les carte graphiques */				GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,29);		SetIText(item,&st3); 		 		InitialisationCarteGraphique(); 		 /* on rafraichi les fenêtres */				DrawInitDialog ();		DoUpdate((WindowPtr)&G.BackDropWindow);		SetPort(StartUpDialog);/* on ouvre les fenêtre */		GetMyWindows();/* On initialise la liste de sous-titres */		InitialiseLalistedesSousTitres();				/* ON INITIALISE LE PORT SERIE */		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st3,129,27);		SetIText(item,&st3);  // on indique ce que l'on fait init mémoire -3-						// on initialise la séquence de lecture du port série				G.SerialError=0;		G.Serial_WatchDog=120;		G.SendVtrTime_state=0;		#ifdef __NoProtect__		InitSerial();#endif#ifndef __NoProtect__		// on ouvre le port modem		if (!G.FindFirstKey_error)InitSerial();		 else  if (G.SoftProtect==1)InitSerial();					#endif	DrawInitDialog ();	/* on ferme le dialog d'acceuil */			DisposeDialog(StartUpDialog);			ShowMyWindows();	SelectReferencedWindow((WindowReference) &G.DialogSaisie); 	ActivateFloatersAndFirstDocumentWindow();/* on dispose le fichier préférence de travail */ 	if (G.Ve_GDHandle )OpenLastDisplayFontUsed(); 	if (G.Preference_PourTravail) DisposeHandle( (Handle)G.Preference_PourTravail);// on ouvre la dernière police d'affichage utilisée// et le dernier fichier s'il existe. 	Adjust_BB_Menu(); 	if (G.AutoOpenLastFile) OpenLastFileUsed();}void InitTheMac(void){short count;EventRecord event;	InitGraf((Ptr) &QD.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	/*initialisation du module de simulmation */	Pre_InitAV();			C_InitMyCursor();	for (count = 1; count <= 3; count++)		EventAvail(everyEvent, &event);	 	SysEnvirons(kSysEnvironsVersion, &G.Mac);	if (G.Mac.machineType < 0) AlertUser(1);		if ((long) GetApplLimit() - (long) ApplicZone() < kMinHeap) AlertUser(2);		/* ZeroScrap(); *//* on regarde s'il y a assez de mémoire */	PurgeSpace(&total,&contig);	if (contig<=2000*1000) {		AlertUser(1);		ExitToShell();		}		if (contig<=2600*1000) AlertUser(15);}//InitTheMac/* routine de dessin du dialog d'initialisation */static void DrawInitDialog (void){		SetPort(StartUpDialog);		TextMode(srcOr);		TextFont(geneva);		TextSize(9);		BeginUpdate(StartUpDialog);		DrawDialog(StartUpDialog);		EndUpdate(StartUpDialog);}		//Draw init dialogpascal short DoAlertNotKeyPresent(void){short result=0;		result=Alert(169,(ModalFilterProcPtr)nil);		return result-1;}pascal Boolean AlertFilterProc(theDialog ,event,itemhit)	DialogPtr	theDialog;	EventRecord	*event;	short		*itemhit;{	short		itemtype, value;	Point		The_point;	unsigned char		key;	GrafPtr		oldport;	Boolean		result=false,extend=false;	Handle	item;	Rect		rect;				GetPort(&oldport);		SetPort((GrafPtr)theDialog);		switch (event->what ) {				case 0:			break;				case mouseDown:					The_point=event->where;					GlobalToLocal(&The_point);										value=FindDItem(theDialog,The_point);					if (value!=-1) {						value++;						GetDItem(theDialog,value,&itemtype,&item,&rect);						if ((itemtype&0x6f)== iconItem || (itemtype&0x6f)== picItem) {							*itemhit=value;							result=TrackCurseur(theDialog,value);						}					} 			break;					case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;						switch(key) {					case 3: // ok bouton					case 13: // ok bouton						*itemhit=1;						result=true;						C_Hilite_icon_button(theDialog,1);						WaitTicks(8);						C_Unhilite_icon_button(theDialog,1);						break;											case 27:	// esc						*itemhit=2;						result=true;						C_Hilite_icon_button(theDialog,2);						WaitTicks(8);						C_Unhilite_icon_button(theDialog,2);						break;				}			break;		case activateEvt:			break;				case updateEvt:			break;				}//	switch		SetPort(oldport);		return (result);}		pascal void AlertUser(short error){	short		itemHit;	Str255		message,st1;	short		dlgFont;	dlgFont=LMGetDlgFont();	LMSetDlgFont(geneva);	SetCursor(&QD.arrow);	GetIndString(&message,137, error);	GetIndString(&st1,137, 7);	ParamText(&st1, "",&message, "");	itemHit = Alert(129,(ModalFilterProcPtr)nil);	LMSetDlgFont(dlgFont);} /* AlertUser *//* *=====================================================================**Diverses routines utilisées pour la gestion des boutons dans un dialog **=====================================================================**/pascal void AlertCarteDaffichage(){	AlertUser(30);}pascal void EffaceTouslesSousTitres(Str255 name){Str255	st0,st1;Ptr		P;short	i;SousTitreRecordPtr	st;/* on configure le control v de listing 	/!\ note on ne fait pas l'initialisation si pas fenêtre listing et saisie*/		 if (G.ListingVScroll){ 			SetControlMinimum(G.ListingVScroll,1); 			SetControlValue(G.ListingVScroll,1); 			SetControlMaximum(G.ListingVScroll,1); 		/* ______________   on configure les nom des fenètre par défauts ________________ 			; fenètre saisie							; si pas de nom			; on place celui par défaut 		*/	 		if (name)	 			BlockMove((Ptr)name,&st1,256);	 		else	GetIndString(&st1,129,5);		//texte par défaut !(film sans titre)			 		GetIndString(&st0,129,3); 				//saisie name	 		BlockMove(&st1[1],&st0[st0[0]+1],(long)st1[0]);	 		st0[0]+=st1[0];							 		SetWTitle((WindowPtr)&G.DialogSaisie,&st0);				 		GetIndString(&st0,129,4); 				//listing name	 		BlockMove(&st1[1],&st0[st0[0]+1],(long)st1[0]);			st0[0]+=st1[0];	 		SetWTitle((WindowPtr)&G.ListingWindow,&st0);		}//  if (G.ListingVScroll)		/* le nom de la préférence titre original */// 		BlockMove(&st1,&G.Preference_TitreOriginal,256);			G.Preference_TitreEpisodeOriginal[0]=0;			G.Preference_TitreFrancais[0]=0;			G.Preference_TitreEpisodeTraduit[0]=0; 			G.Preference_NomAdaptateur[0]=0;			G.Preference_CoordonneesAdaptateur[0]=0;			G.Preference_commentaire[0]=0;			G.CodeDeReference[0]=0;			//	 on place bon bougre par défaut// 	et le nom de la société et son adresse  	 			GetIndString(&G.EditeurListe,136,4)	; 			GetIndString(&G.NomDuMonteur,136,5);	 			GetIndString(&G.CoordonneeMonteur,136,6);	// divers valeur pour le N19 			G.PaysOrigine=12;			G.CodeLangue=16;			G.CodeCaractere=1;			G.TcDebutFilm=-1; 			GetDateTime(&G.DateDeCreation); 			//date du jour 			GetDateTime(&G.ModifieLe); 				//date du jour			G.Revision=1;			G.Preference_commentaire[0]=0;			G.Preference_Interval=4;				//interval minimum					G.Preference_LisiValue=12;			// lisibilité			G.General_StartNumberForST=1;			G.General_IncrementPourST=1;			//G.Preference_Enchaine=0;  			// on prépositionne soustraction tc out			G.General_Preference_flag_1=true ;  	 // pour le dialog recherche ST			G.Preference_UtilCheck=1;						//------------- préférence pour exportation de fichier ----------- 			G.Preference_TypeExport=1;			G.Preference_ConvertMsDos=true;			G.Preference_InclureCommentaire=false;			G.Preference_InclureSousNumero=false;			G.Preference_N19_TypeTeletexte=true;			G.Preference_DoubleHauteur=true;			G.Preference_DoubleLargeur=false;			G.Preference_Couleur=3;		// -------------- on créé un premier sous-titre bidon -----------			G.General_NombreST=0;			G.General_PremierTC=-1;			G.General_DernierTC=-1;			G.General_DernierSTPtr=G.General_PremierSTPtr;			G.General_DernierNumConvertiPtr=G.General_PremierSTPtr;			st=G.General_PremierSTPtr;			(st)->st_PreviousST=nil;			(st)->st_NextST=nil;			 			(st)->st_TimeCodeIn=-1; 			(st)->st_TimeCodeOut=-1; 						(st)->st_NumeroST=1;			(st)->st_OldNumeroST=1;			(st)->st_AbsNUMST=1;			(st)->st_TexteLenth=nil;			(st)->st_CommentaireLenth=nil;			(st)->st_LenthST=32;					(st)->st_CommentairePtr=nil;			(st)->st_PosOffsetTable=nil;			(st)->st_StylePtr=nil;			(st)->st_StyleLenth=nil;			(st)->st_Nlines=1;			(st)->st_XOffset=0;			(st)->st_YOffset=0;			(st)->st_Error=0;			(st)->st_Justification=0;			(st)->st_MasKType=0;			G.General_NombreST=1;			G.General_PremierTC=-1;			G.General_DernierTC=-1;			G.General_SousTitreEncour=1;			G.General_FontNumber=geneva;				// police par défaut// on raz le block note 			P=(Ptr)&G.BlockNote_tc;			for (i=0;i<32;i++){				*P=-1;				P++;				}			G.BlockNote_texte[0]=0;//-------------    On raz l'offset 			G.offsetTC=0;// ______________  initialisation des modes de fonctionnement  _________________			G.SaisieModePreferenciel=3;// ______________  Prépositionnement du dialog change style et font _____________			G.ChangeStyleDialog_Mode=0;		// style uniquement			G.ChangeStyleDialog_style=2;		// italique			G.ChangeStyleDialog_font=geneva	;		// font courante			//ChangeStyleDialog_debut			ds.l	1//ChangeStyleDialog_fin			ds.l	1			InitUndoRedo();} // Efface_Tous_Les soustitres/* Cette routine initialise les valeurs par défaut du logiciel pour le fonctionnement*/static void InitSomeGlobals_1(void){short	i;			G.InBackground = false;	// in the front			G.HasWNEvent = 0x0101;  // on force WaitNextEvent Pour Do Event			G.AutoOpenLastFile=true;			gModeKaraoke=nil;			gDecalText=0;						gModeSaisieTC=0;					// on prépositionne pas de passage automatique			G.Preference_Enchaine=0;  			// on prépositionne soustraction tc out/*Initialisation des variables par défaut*/			G.HauteurST=ListingHauteurCarreST; 	// pour le moment on force la hauteur de listing (54)			G.ListeError=nil;					// pas de fichier liste d'erreur			G.Preference_NombreSauv=10; 		//valeur d'attente pour wait value( en minutes)			G.Preference_AutoCheck=true	;		// sauvegarde auto par défaut			G.Preference_KernCheck=1	;		// auto kern			G.SaisieModePreferenciel=3;			//SaisieMode_Aucun			G.Preference_MultiFinder=0x0000 ; 	//fenêtre de fond de l'écran présente			G.General_Preference_flag_1=true ; 	//pour le dialog recherche ST			G.General_Preference_DessinGris=nil ; 	//desactivé			G.Preference_TypeExport=1;			//exportion Fichier_TypeTexte			G.Preference_ConvertMsDos=nil;		// conversion caractères MSDos			G.Preference_InclureCommentaire=nil;	//on ne met pas les commentaires			G.Preference_InclureSousNumero=nil;	//Pas les sous-numéros			G.Preference_DisplayTimeCode=-1;		//on valide tout			G.Echelle_Bandeau=2;				//pour la chenille 2 images par pixels			G.PopUp_FontNumberList=nil;			G.N19_VPStart=21;/*On raz différents pointeurs de mémoire*/			G.FindFirstKey_error=-1;							G.RenderingFont_handle=nil;			G.DuplicateOffscreenBuffer_handle=nil;			G.OffscreenDisplayBase=nil;			G.RenderingFont_handle=nil;			gVBLInstalled=0;/*Init timer pour version limitée du logiciel*/			G.StartTicks=TickCount()+60*60*15; 	// le temps max de fonctionnement 15 minutes			G.democount=50; 					//50 sous-titre affiché/*valeur par défaut lecteur TC (tc interne) */			G.LecteurTimeCode_Type=3/*0*/; 	//	lecteur vitc			G.Player_TC_src=0; 		//	auto ltc/vitc			G.Mode_Commutateur=0; 		//	momentané			G.ModemOutRefNum=0;			G.ModemInRefNum=0;			/* initialisation des parramètres d'affichage*/			G.RGB_FaceColor=0xffffffff;			G.RGB_BorderColor=0xff000000;			G.RGB_ShadowColor=0x60000000;			G.RGB_OutlineBoxColor=0x90000000;			G.X_Offset=0;								G.Y_Offset=518;				// 518= 576*90% 				G.Outline_Box=nil;				G.Overriding_All_Attribute=false;				G.ListingVScroll=nil;/* upstream ou downstreamkeyer */			G.VE_Mode=1 ;			// on preset la valeur DowstreamKeyer/* cut fon du ,vitesse */			G.EffectMode=0;		//effect Cut			G.FadeTime=8;/* initialisation des fonction keys */			for (i=0;i<16;i++) 	G.TableFonctionKeys[i]=i;		// on modifie quelque peu le 0-0						G.TableFonctionKeys[1]=6;			G.TableFonctionKeys[2]=7;			G.TableFonctionKeys[3]=8;			G.TableFonctionKeys[4]=26;			G.TableFonctionKeys[9]=13;			G.TableFonctionKeys[10]=14;			G.TableFonctionKeys[11]=15;			G.TableFonctionKeys[12]=16;									/* Pattern de fenêtres par défaut */						G.BackDrop_PatNum=134;			G.Listing_PatNum=140	;			G.Saisie_PatNum=129;		/* font pour saisie*/			G.General_FontNumber=geneva;					G.General_TextSize=14;// on ouvre la resource DATA 128	=> CONVERSION de caractères// ouverture de la resource DATA 129 conversion majuscule <=> minuscule// ouverture de la resource DATA 130 conversion Accentué => majuscule non accentué	// ouverture de la resource 1000 pour la conversion N19 <=> mac				G.ResourceDATA128=GetResource('DATA',128);		HLock(G.ResourceDATA128);		G.ResourceDATA129=GetResource('DATA',129);		HLock(G.ResourceDATA129);		G.ResourceDATA130=GetResource('DATA',130);		HLock(G.ResourceDATA130);		G.ResourceDATA1000=GetResource('DATA',1000);		HLock(G.ResourceDATA1000);		// ouverture de quelques color icon courament utilisé		G.IconHandle1=GetCIcon(144);		HLock((Handle)G.IconHandle1);		G.IconHandle2=GetCIcon(143);		HLock((Handle)G.IconHandle2);		G.IconSauvegardeOn=GetCIcon(130);		HLock((Handle)G.IconSauvegardeOn);		G.IconSauvegardeOff=GetCIcon(131);		HLock((Handle)G.IconSauvegardeOff);		// chargement de quelques curseurs couleurs		G.CurseurDessineST=GetCCursor(132);		HLock((Handle)G.CurseurDessineST);		G.CurseurClearBuffer=GetCCursor(133);		HLock((Handle)G.CurseurClearBuffer);		G.CurseurTransfert=GetCCursor(134);		HLock((Handle)G.CurseurTransfert);// on demande un handle pour la clef eve3		G.EveHandle=nil;		G.EveHandle=RBEHANDLE();		/* on regarde s'il y a une fichier nommé preférence pour clef de protection logiciel pour audiophase */ 		G.SoftProtect=0xaefc;		 /* on initialise les liste undo/redo		*/ 		InitUndoRedo();}//initsomeglobalsvoid InitialiseLalistedesSousTitres(void){Ptr P;short i;long	a5;short Everesult,count;// -------------- on créer un premier sous-titre bidon -----------			G.General_SousTitreCourantPtr=G.General_PremierSTPtr;			G.General_LastSousTitrecourant =1;			G.General_SousTitretrouve=nil;			G.General_SousTitrecourant=1;			G.Rechercher_STR[0]=0;			G.Remplacer_STR[0]=0;			// ---------------------------// on place la valeur de a5 en tête de chaque buffer série			a5=SetCurrentA5();			G.General_A5register_1=a5;			G.General_A5register_2=a5;			G.General_A5register_3=a5;			G.General_A5register_4=a5;			G.General_A5register_5=a5;			G.General_A5register_6=a5;			// --------------  on initialise le font record -----------------// on raz le Display_Font			P=(Ptr)&G.Display_Font;				for (i=0;i<sizeof(FontRenderRecord)/2;i++) {				SetShort(P,0);				P=P+2;				}// on initialise quelques valeurs			G.Display_Font.First_Char=0x21;			G.Display_Font.last_Char=0x33;				G.Display_Font.FontSize=28;				G.Display_Font.FontNumber=1;				G.Display_Font.FontStyle=3; //normal + bold + italic				G.Display_Font.FontRatio=0x403; //4:3 ration			G.Display_Font.BorderBlur=1;			G.Display_Font.BorderThickness=2; 			// on demande de la mémoire pour les paramBlocks			G.Main_Rx_PB_Buffer=NewPtrClear(128);			G.Sony_Rx_Buffer=NewPtrClear(128);			G.Vitc_Rx_PB_Buffer=NewPtrClear(128);			G.Tx1_PB_Buffer=NewPtrClear(64);			G.Spare_PB_Buffer=NewPtrClear(64);			G.Spare1_PB_Buffer=NewPtrClear(64);					// on initialise la liste des sous-titres				  			EffaceTouslesSousTitres(nil);	}/* ----------------------------*/static void GetMyWindows(void){WindowPtr	w,w1;Rect			rect;short 		x,i,j;short		count,Everesult;/* ----------- ouverture des fenètres ------------------; à partir des resources ; on affecte un numéro unique pour chaque fenètre 1 à 1000; dans la case REFCON de la fenètre; pour permettre la gestion update click inside etc...; ces fenètres sont sont stockée dans les variables globales; mais il serait sage de demander un pointeur pour chaque fenètre; plutôt que de prendre cette espace dans les variables globales*/			GetMainScreenRes(&rect);			// fenêtre Block note						G.BlockNoteWindow=GetNewDialog(261,(WindowPtr)nil,(WindowPtr)StartUpDialog);		// ouverture fenètre listing (fenètre 2) et saisie (un dialog)			w=GetNewCWindow(129,(WindowPtr)&G.ListingWindow,(WindowPtr)StartUpDialog);			SetWRefCon(w,2);		//  on récupère le control vertical				G.ListingVScroll=GetNewControl(128,(WindowPtr)&G.ListingWindow);			SetControlValue(G.ListingVScroll,1);			SetControlMinimum(G.ListingVScroll,1);			SetControlMaximum(G.ListingVScroll,1);			// on ouvre le dialog saisie			w=GetNewDialog(148,(WindowPtr)&G.DialogSaisie,(WindowPtr)StartUpDialog);			SetWRefCon(w,1);			/*	on place les fenètres dans l'écran en fct des dimensions de celui ci	 on place les fenètres au milieu de l'écran */			rect=(**GetMainDevice()).gdRect;			w1=(WindowPtr)&G.DialogSaisie;			i=(w1->portRect.right)-(w1->portRect.left);			j=(w1->portRect.bottom)-(w1->portRect.top);			x=(rect.right-rect.left)-i;			x=x/2+rect.left;			MoveWindow((WindowPtr)&G.ListingWindow,x,40+rect.top,false);			SizeWindow((WindowPtr)&G.ListingWindow,i,rect.bottom-3-j-60,false);			MoveWindow((WindowPtr)w1,x,rect.bottom-j-3,false); 			Adjust_ListingScrollBar(); 			/* 				Si nous disposons d'assez de mémoire on ouvre un buffer offscreen 				pour les dessins des fenêtres listing et saisie*/			G.OffscreenListing=nil;			if (contig>=2400*1000)	{				w=(WindowPtr)&G.ListingWindow;				rect.top=0;				rect.left=0;				rect.bottom=w->portRect.bottom-w->portRect.top;				rect.right=w->portRect.right-w->portRect.left;					if (MinDepth==1) NewGWorld(&G.OffscreenListing,8,&rect,nil,nil,0);					else NewGWorld(&G.OffscreenListing,0,&rect,nil,nil,0);			}						G.OffscreenSaisie=nil;			if (contig>=2400*1000)	{				w=(WindowPtr)&G.DialogSaisie;				rect.top=0;				rect.left=0;				rect.bottom=w->portRect.bottom-w->portRect.top;				rect.right=w->portRect.right-w->portRect.left;									if (MinDepth==1)  NewGWorld(&G.OffscreenSaisie,8,&rect,nil,nil,0);					else	NewGWorld(&G.OffscreenSaisie,0,&rect,nil,nil,0);			}						// ouverture fenètre  diverses/*						w=GetNewCWindow(133,(WindowPtr)&G.RenderingWindow,(WindowPtr)StartUpDialog);			SetWRefCon(w,128);*//* on ouvre les palettes flotantes */			G.TELECOMMANDEWindow=nil;			G.ErrorsWindow=nil;			G.ChenilleWindow=nil;			G.ServiceWindow=nil;			G.LogoWindow=nil;			gBlankingVerticalWindow=nil;			gPaletteKaraoke=nil;			gDialogProchainSousTitre=nil;			gtestDecodageWindow=nil;					 	G.ErrorsWindow=OpenErrorWindow((WindowPtr)-1);	// palette erreurs 			GetNewWindowReference((DialogPtr*)&G.TELECOMMANDEWindow,2002,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette télécommande 			GetNewWindowReference((DialogPtr*)&G.ChenilleWindow,2003,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette chenille 			GetNewWindowReference((DialogPtr*)&G.ServiceWindow,262,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info 			GetNewWindowReference((DialogPtr*)&G.LogoWindow,263,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info 			GetNewWindowReference((DialogPtr*)&gBlankingVerticalWindow,267,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info 			GetNewWindowReference((DialogPtr*)&gDialogProchainSousTitre,171,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info 			if (gGenereSousTitreBlankInterval || 	gDecodeBlanckingVertical) //si mode codage decodage VISTC 			GetNewWindowReference((DialogPtr*)&gtestDecodageWindow,283,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette info			//gPaletteKaraoke=OpenPaletteKaraoke();						// un peu de protection de logiciel,  sauf si mode __NoProtect__ (sans protection )		#ifndef	__NoProtect__	#ifndef	__Demo__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}				if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}				#endif#endif/* s'il y a assez de mémoire on ouvre un offscreen pour la pallette chenille*/			G.OffscreenChenille=nil;			if (contig>=2400*1000)	{				w=(WindowPtr)G.ChenilleWindow;				rect.top=0;				rect.left=0;				rect.bottom=w->portRect.bottom-w->portRect.top;				rect.right=w->portRect.right-w->portRect.left;					if (MinDepth==1) NewGWorld(&G.OffscreenChenille,8,&rect,nil,nil,0);					else	NewGWorld(&G.OffscreenChenille,0,&rect,nil,nil,0);			} // (contig>=2400*1000)			}// GetMyWindows/* ----------------------------*/static void ShowMyWindows(void){WindowPtr	w,w1;Point			point;Rect			rect;short 		count,Everesult;/* 	on active et update	 les fenêtres saisie et listing */		ShowHide((WindowRef)&G.DialogSaisie,true);		DoUpdate((WindowPtr)&G.DialogSaisie);			ShowHide((WindowRef)&G.ListingWindow,true);		DoUpdate((WindowPtr)&G.ListingWindow);			/* maintenant on place la fenêtre télécommande en fonction du fichiers préférence*/		GetMainScreenRes(&rect);		if (G.Preference_PourTravail){  // si le fichier préférence existe					/* on place la fenêtre listing en fonction du fichiers préférence*/			w1=(WindowPtr)&G.ListingWindow;			{				point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_ListingWindowRect.top;				point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_ListingWindowRect.left;				rect=(**GetMainDevice()).gdRect;				// on vérifie les cordonnées				if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){					w=(WindowPtr)&G.ListingWindow;					SetPort(w);					point.h=w->portRect.left;					LocalToGlobal(&point);				}				if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){					w=(WindowPtr)&G.ListingWindow;					SetPort(w);					point.v=w->portRect.bottom-(w1->portRect.bottom-w1->portRect.top);					LocalToGlobal(&point);				}				MoveWindow((WindowPtr)w1,point.h,point.v ,false);			}											/* maintenant on place la fenêtre télécommande en fonction du fichiers préférence*/			w1=G.TELECOMMANDEWindow;			if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteTelecommandeVis ) {										point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteTelecommandeRect.top;										point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteTelecommandeRect.left;										rect=(**GetMainDevice()).gdRect;										// on vérifie les cordonnées										if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.h=w->portRect.left;											LocalToGlobal(&point);										}										if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.v=w->portRect.bottom-(w1->portRect.bottom-w1->portRect.top);											LocalToGlobal(&point);										}										MoveWindow((WindowPtr) G.TELECOMMANDEWindow,point.h,point.v ,false);										ShowHide((WindowRef)G.TELECOMMANDEWindow,true);										DoUpdate((WindowPtr)G.TELECOMMANDEWindow);									}																					// un peu de protection de logiciel						#ifndef	__NoProtect__	#ifndef	__Demo__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}				if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}			#endif#endif											/* maintenant on place la fenêtre chenille en fonction du fichiers préférence*/			w1=G.ChenilleWindow;			if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteChenilleVis ) {										point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteChenilleRect.top;										point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteChenilleRect.left;										rect=(**GetMainDevice()).gdRect;										// on vérifie les cordonnées										if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.h=w->portRect.left;											LocalToGlobal(&point);										}																				if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.v=w->portRect.bottom-(w1->portRect.bottom-w1->portRect.top);											LocalToGlobal(&point);										}																				MoveWindow((WindowPtr) G.ChenilleWindow,point.h,point.v ,false);										ShowHide((WindowRef)G.ChenilleWindow,true);										DoUpdate((WindowPtr)G.ChenilleWindow);									}		/* maintenant on place la fenêtre block en fonction du fichiers préférence*/			w1=(WindowPtr)G.BlockNoteWindow;			ShowHide((WindowRef)w1,false);			if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_BlockNoteVis ) {										point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_BlockNoteRect.top;										point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_BlockNoteRect.left;										rect=(**GetMainDevice()).gdRect;																				// on vérifie les cordonnées										if (point.h<rect.left || point.h>(rect.right -(w1->portRect.right-w1->portRect.left)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.h=w->portRect.left+3;											LocalToGlobal(&point);										}																				if (point.v<LMGetMBarHeight() || point.v>(rect.bottom -(w1->portRect.bottom-w1->portRect.top)) ){											w=(WindowPtr)&G.ListingWindow;											SetPort(w);											point.v=LMGetMBarHeight() +3;											LocalToGlobal(&point);										}																				MoveWindow((WindowPtr)w1,point.h,point.v ,false);										ShowHide((WindowRef)w1,true);										DoUpdate((WindowPtr)w1);									}		/* maintenant on place la fenêtre simu en fonction du fichiers préférence*/			if (gMonitor)				if (  (**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteSimuVis) {										point.v=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteSimuRect.top;										point.h=(**(PreferenceTravail_ResourceHandle)G.Preference_PourTravail).Pt_PaletteSimuRect.left;																				CentreLAFenetreAV(TRUE);										MoveWindow((WindowPtr)gMonitor,point.h,point.v ,false);										// on vérifie les cordonnées														// on ouvre  la fenêtre										ShowHide((WindowRef)gMonitor,true);										DoUpdate((WindowPtr)gMonitor);										SGPause(gSeqGrabber, false);									}																						}  else {// if (PreferenceTravail_ResourceHandle )exist				if(gMonitor) {						CentreLAFenetreAV(true);				ShowHide((WindowRef)gMonitor,true);				DoUpdate((WindowPtr)gMonitor);				SGPause(gSeqGrabber, false);			}		} // si pas de resource préférence														}// ShowMyWindows/*	Set up the AppleEvent dispatch table */static void SetUpAppleEvents(void){	OSErr	installAppleEventError=0;		installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, (AEEventHandlerUPP) &OAPPHandler, 0, false);	installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, (AEEventHandlerUPP) &ODOCHandler, 0, false);	installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, (AEEventHandlerUPP) &PDOCHandler, 0, false);	installAppleEventError = installAppleEventError|AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, (AEEventHandlerUPP) &QUITHandler, 0, false);	if (installAppleEventError)		AlertUser(19); // pb installation Apple Event} //SetUpAppleEventsvoid GiveMeMoreMaster(void){	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		MoreMasters();		}	static pascal void InitialisationMenus(void){Str255	st4;Ptr	P;short 	count,familyID,itemtype,total,Everesult;Handle 	menuBar,item;Rect		rect,r;RGBColor	M_color,M_color1,M_save_color,M_black;		SetPort(StartUpDialog);				GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st4,129,25);		SetIText(item,&st4);  // on indique ce que l'on fait				GetForeColor(&M_save_color);				M_black.red=0; 		M_black.green=0;		M_black.blue=0;				M_color1.red=42000;		M_color1.green=-1;		M_color1.blue=-1;				M_color.red=30000; 		M_color.green=30000;		M_color.blue=30000;				 //    on récupère la barre des menus		menuBar = GetNewMBar(128);			/* read menus into menu bar */		if ( menuBar == nil ) AlertUser(4);		SetMenuBar(menuBar);					/* install menus */		DisposHandle(menuBar);		AddResMenu(GetMHandle(128), 'DRVR');	/* add DA names to Apple menu */ 		InsertMenu(GetMenu(138),-1);	// le menu pour AV	/* on recupère les pop up menus			Et les sous menus*/		 		G.QuickOpenMenuHandle=GetMenu(136); 	// resultat dans la pile	 		InsertMenu(G.QuickOpenMenuHandle,-1);  		C_MakeTheBbdfMenu('Bbof',G.QuickOpenMenuHandle,&G.QuickOpenHandle);/*  ------  on recherche les polices utilisables en affichage vidéo  et on créé une table de correspondance entre le n° d'item et le n° de font*/		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		GetIndString(&st4,129,26);		SetIText(item,&st4);  // on indique ce que l'on fait 		G.SoftProtect=OpenBBPreferenceFile(false); // pour la protection par fichier caché dans le système 		G.PopUp_Font=nil; 		G.PopUp_Font=GetMenu(2006); 		if( G.PopUp_Font){	 		AddResMenu(G.PopUp_Font,'FONT');	 		InsertMenu(G.PopUp_Font,-1);		/* on recherche les polices "true type"	  on désactive les autres	  on fabrique une table de correspondance	*/		/* on créer une réglette */			GetDItem(StartUpDialog,3,&itemtype,&item,&rect);			GetIndString(&st4,129,33); 	// progression			SetIText(item,&st4);  		// on indique ce que l'on fait						GetDItem(StartUpDialog,4,&itemtype,&item,&rect);			r=rect;				RGBForeColor(&M_black);			FrameRect(&rect);						RGBForeColor(&M_color1);				do{	// on fait une animation pour effacer le rectangle				InsetRect(&r,1,1);				FrameRect(&r);				WaitTicks(8);			}while(r.bottom-r.top);				RGBForeColor(&M_color);		/* maintenant on check les polices */			r=rect;			InsetRect(&r,1,1);			total=CountMItems(G.PopUp_Font);	 		G.PopUp_FontNumberList=NewHandle(2048);	//on reserve un espace de 1000 polices (un max !?)	   		MoveHHi(G.PopUp_FontNumberList);	 		HLock(G.PopUp_FontNumberList);			count=1;	 		P=(Ptr)*G.PopUp_FontNumberList+2;	 			 		do{				GetItem(G.PopUp_Font,count,&st4);	 			GetFNum(&st4,&familyID);					// on place le n° dans la table corespondance				SetShort(P,familyID);				P=P+2;								// on regarde si la police est "true type"				if (st4[0] )					if (!RealFont(familyID,80)  ) DisableItem(G.PopUp_Font,count);					r.right=r.left+(count*(rect.right-rect.left-2))/total;					if (r.right>=rect.right) r.right= rect.right;					PaintRect(&r);	 				C_SpinCursor(16);	//spin the ball						count++;			} while (st4[0] !=nil);		}					RGBForeColor(&M_save_color);		SetCursor(&QD.arrow);		// on place le nombre d'item 		P=(Ptr)*G.PopUp_FontNumberList; 		SetShort(P,count); 		// on rafraichie le dialog 		 		GetDItem(StartUpDialog,4,&itemtype,&item,&rect);		InvalRect(&rect); 		GetDItem(StartUpDialog,3,&itemtype,&item,&rect);		GetIndString(&st4,129,32);		SetIText(item,&st4);  // on indique ce que l'on fait				// un peu de protection de logiciel		#ifndef	__Demo__	#ifndef	__NoProtect__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}						if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}				#endif#endif		 		DrawInitDialog (); }// initialisation menus/*	/!\	/!\ Protection de logiciel contre le piratage	/!\ on regarde si l'on a une clef présente	/!\	/!\	/!\	/!\*/void DoInitSomeValue2(void){ DateTimeRec			d;short	count,Everesult;		G.FindFirstKey_error=E3ERR_NOTFOUND;	d.month=8;	d.day=1;	d.hour=0;	d.year=1996;	d.minute=0;	d.second=0;	d.dayOfWeek=1;// pour la version de demo on ne met pas le code de protection , on ne sait jamais#ifndef	__Demo__	#ifndef	__NoProtect__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}			if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}					#endif#endif#ifdef	__Demo__// on récupère la date de CRÉATION du programme		GetDateTime(&(pb1.fileParam.ioFlCrDat));		a=LMGetCurApRefNum();				fcb.ioCompletion=(IOCompletionUPP)nil;		fcb.ioNamePtr=(Ptr)&st0;		fcb.ioFCBIndx=0;		fcb.ioVRefNum=0;		fcb.ioRefNum=a;			err = PBGetFCBInfo(&fcb, false);		if (!err ){			pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;			pb1.ioParam.ioNamePtr=(Ptr)&st0;			pb1.ioParam.ioVRefNum=fcb.ioFCBVRefNum;			pb1.fileParam.ioDirID=fcb.ioFCBParID;			pb1.fileParam.ioFDirIndex=0;			err=PBHGetFInfo((HParmBlkPtr)&pb1,false);		}				// pas de protection mais, on limite le logiciel jusqu'au 31 janvier 1996	 	// et on vérifie que nous ne sommes pas en dessous de la dernière date d'utilisation	// et puis on place la date courante dans une resource en mémoire			G.FindFirstKey_error=E3ERR_NOTFOUND;		DateToSeconds(&d, &limite);		oldresfile=CurResFile();		UseResFile(gCurResNum);				GetDateTime(&lo);		h=Get1Resource('FreP',130); // la resource où l'on planque la valeur						//si  la date courante est inférieur à la dernière date d'utilisation		if (h){			oldlo= *((unsigned long*)*h);			if (lo<oldlo) {		// on tente de forcer la protection, mais on ne se laisse pas faire				ReleaseResource(h);				G.FindFirstKey_error=E3ERR_NOTFOUND;				return;			} 		} 								if (!h){ // pas de resource on place la date de modification du logiciel comme date initiale				// si la date du jours est plus avancée, on prend la date du jour												if  (lo>pb1.fileParam.ioFlCrDat)  pb1.fileParam.ioFlCrDat=lo;								h=NewHandle(256);				*((unsigned long*)*h)=pb1.fileParam.ioFlCrDat;				AddResource(h, 'FreP', 130, "\pPréférences locales");						ReleaseResource(h);				UpdateResFile(gCurResNum);				h=nil;				if ((lo <limite)) G.FindFirstKey_error=0;				UseResFile(oldresfile);  // on update le fichier				return;		} 					// on efface la resource, du fichier		// et on efface la resource de la mémoire				if (lo<limite){ // on est en dessous de la valeur limite			G.FindFirstKey_error=0;									if (h){				RemoveResource(h);				ReleaseResource(h);				h=nil;			}			// maintenant on crée la resource, avec la date du jour			h=NewHandle(256);			*((LPtr)*h)=lo;			AddResource(h, 'FreP', 130, "\pQuelques Préférences Initiales");					UpdateResFile(gCurResNum);			} 		UseResFile(oldresfile);  // on update le fichier#endif#ifdef	__NoProtect__		G.FindFirstKey_error=0;#endif}//DoInitSomeValue2void FadeInDialog(void){GWorldPtr		drawWorldP;PixMapHandle 	thePixMapH;PicHandle		pic1;GDHandle		gdh;CGrafPtr		oldport;RGBColor		noir,blanc,color;long		i;short		mode=srcCopy;			noir.red=0;			noir.green=0;			noir.blue=0;						blanc.red=-1;			blanc.green=-1;			blanc.blue=-1;						GetGWorld(&oldport,&gdh);			NewGWorld(&drawWorldP,0,&StartUpDialog->portRect,nil,nil,0);		// on commence par un écran noir (on efface l'écran)			RGBForeColor(&noir);			PaintRect(&StartUpDialog->portRect);			// on y va pour le dissolve			SetGWorld(drawWorldP, nil);			thePixMapH = GetGWorldPixMap(drawWorldP);			LockPixels(thePixMapH);			pic1=GetPicture(131);			DrawPicture(pic1,&StartUpDialog->portRect);			ReleaseResource((Handle)pic1);						// on fait le fondu						for (i=0;i<=65535;i+=0x1000) {				if (i>65535) i=65535;				// on copie le  drawWorldP1->drawWorldP2				//SetGWorld(drawWorldP2, nil);				SetGWorld((CGrafPtr)StartUpDialog,gdh);				RGBForeColor(&noir);				RGBBackColor(&blanc);				PenNormal();				//PenMode(mode);				color.red=i;				color.green=i;				color.blue=i;				RGBBackColor(&color);				CopyBits((BitMapPtr)(*thePixMapH),(BitMapPtr)&((GrafPtr)StartUpDialog)->portBits,		//*thePixMapH2						&StartUpDialog->portRect, &StartUpDialog->portRect, mode, nil);				WaitTicks(2);					}			WaitTicks(67);					UnlockPixels(thePixMapH);			DisposeGWorld(drawWorldP);			SetGWorld(oldport,gdh);}/* Cette routine initialise l'environnement des cartes graphiques */static void InitialisationCarteGraphique(void){short 	index=1;// on détermine les cartes graphiques présentes		MakeCarteGraphiqueListe();// on affiche les cartes présentes		if (gNombreCarteGraphique>1){			index=ChooseTheGraphicCard(&gListeCarteGraph,gNombreCarteGraphique, index);		} else index=1;				/*  on rafraichi les fenêtres */		DrawInitDialog ();		DoUpdate((WindowPtr)&G.BackDropWindow);		SetPort(StartUpDialog);				// on initialise la carte choisie#ifdef __NoProtect__					InitialiseLacarte(index-1);#endif#ifndef __NoProtect__					// on initialise la carte AV					if (!G.FindFirstKey_error)InitialiseLacarte(index-1);					 else  if (G.SoftProtect==1)InitialiseLacarte(index-1);#endif} // InitialisationCarteGraphiquestatic void MakeCarteGraphiqueListe(void){SpBlock			slotpmb;GDHandle			NextDevice=NULL;short			depth=32,newdepth,RefNum,Slot,BoardID;PixMapHandle		pmh;Str255			name,st0;	// on boucle dans la liste des devices et on détermine les cartes présentent	// on recherche pour l'instant les cartes AV		gNombreCarteGraphique=0;// test // à la vidéo explorer	Slot=FIRSTVE();  	if (Slot>8 ) {	//Vx ? oui					RefNum=slot2Refnum(Slot);					NextDevice=SLOT2GDHANDLE(Slot);					slotpmb.spSlot=Slot;					slotpmb.spID=0x80;					slotpmb.spExtDev=0;					slotpmb.spDrvrHW=0;					SRsrcInfo(&slotpmb);					BoardID=slotpmb.spDrvrHW;										gListeCarteGraph[gNombreCarteGraphique].GDH=NextDevice;					gListeCarteGraph[gNombreCarteGraphique].boardID=0x2a2; // on décide 0x0x2a2					gListeCarteGraph[gNombreCarteGraphique].slot=Slot;					gListeCarteGraph[gNombreCarteGraphique].RefNum=RefNum;					gListeCarteGraph[gNombreCarteGraphique].spare=0;					gNombreCarteGraphique++;				} 	  	NextDevice =GetDeviceList();	do{		// regarde si offscreendevice ?		if ((TestDeviceAttribute(NextDevice,screenDevice) == 0)||			(TestDeviceAttribute(NextDevice,screenActive) == 0)) {} 		else {		// un vrai ecran			newdepth = (*(*NextDevice)->gdPMap)->pixelSize;			pmh=(**NextDevice).gdPMap;			// on recupère les informations sur la carte			Slot=GDHandle2slot(NextDevice); // on recupère le slot			RefNum=slot2Refnum(Slot); // on recupère le RefNum du driver			slotpmb.spSlot=Slot;			slotpmb.spID=0x80;			slotpmb.spExtDev=0;			slotpmb.spDrvrHW=0;			SRsrcInfo(&slotpmb);			BoardID=slotpmb.spDrvrHW;/* type de carte */			if(IsQuickTimeInstalled()) // seulement si quicktime installé				if (Slot==0xE) {	// Carte AV ?		6110/7100/8110						FindBoardsResource(Slot,&name); // on récupère le nom de la carte 					GetIndString(&st0,141,1); // on lit la string en resource donnant le nom Built-in AV ...					if (EqualString(&st0,&name,true,true)){ // on compare les deux, si c'est pareil on y va						gListeCarteGraph[gNombreCarteGraphique].GDH=NextDevice;						gListeCarteGraph[gNombreCarteGraphique].boardID=1;						gListeCarteGraph[gNombreCarteGraphique].slot=Slot;						gListeCarteGraph[gNombreCarteGraphique].RefNum=RefNum;						gListeCarteGraph[gNombreCarteGraphique].spare=0;						gNombreCarteGraphique++;					}				} 			 		 	if (BoardID==kNuVistaBoardID ||			     BoardID==kDrHwNuVista4Meg 					) {	//NuVistaClassic					gListeCarteGraph[gNombreCarteGraphique].GDH=NextDevice;					gListeCarteGraph[gNombreCarteGraphique].boardID=BoardID;					gListeCarteGraph[gNombreCarteGraphique].slot=Slot;					gListeCarteGraph[gNombreCarteGraphique].RefNum=RefNum;					gListeCarteGraph[gNombreCarteGraphique].spare=0;					gNombreCarteGraphique++;				} 												 if (BoardID==kDrHwNuVistaPlusPAL ||			    	 BoardID==kDrHwNuVistaPlusNTSC					) {	//NuVista+					gListeCarteGraph[gNombreCarteGraphique].GDH=NextDevice;					gListeCarteGraph[gNombreCarteGraphique].boardID=BoardID;					gListeCarteGraph[gNombreCarteGraphique].slot=Slot;					gListeCarteGraph[gNombreCarteGraphique].RefNum=RefNum;					gListeCarteGraph[gNombreCarteGraphique].spare=0;					gNombreCarteGraphique++;				}  	 	}// reel device		NextDevice =GetNextDevice(NextDevice);	 } while (NextDevice);	} // MakeCarteGraphiqueListevoid InitialiseLacarte(short index){short 		slot;short 		id,RefNum;GDHandle		gdh;PixMapHandle 	Pmh;// on récupère les infos de la carte		slot=gListeCarteGraph[index].slot;		id=gListeCarteGraph[index].boardID;		gdh=gListeCarteGraph[index].GDH;		RefNum=gListeCarteGraph[index].RefNum;		gAVDevice=nil;// carte AV		if (slot==14){			gAVDevice=gdh;			DoInitAV();			InitialiseAffichageSimulation();		}	 						// carte NuVista			 		if (	id==kNuVistaBoardID ||			id==kDrHwNuVista4Meg ||			id==kDrHwNuVistaPlusPAL ||			id==kDrHwNuVistaPlusNTSC ) {			G.Ve_Slot=slot;			G.Ve_RefNum=RefNum;			G.Ve_GDHandle=gdh;			Pmh=(**G.Ve_GDHandle).gdPMap;			G.Base_Adresse=(**Pmh).baseAddr;			G.Row_Bytes=(long)(**Pmh).rowBytes & 0x7fff;			G.VE_pixelDeph=(**Pmh).pixelSize;			G.VE_BoardID=GetBoardID(G.Ve_Slot);			G.VE_BoardID=id;			// on vérifie que la carte est correctement configurée			if ( 	((**Pmh).bounds.right-(**Pmh).bounds.left)<720 ||					((**Pmh).bounds.bottom-(**Pmh).bounds.top)<576 ||					G.VE_pixelDeph<31)  {					AlertCarteDaffichage();			}		else 					InitMacPourVersionBroadcast();	  } 	  // carte explorer	if (id==0x2a2) {			G.Ve_Slot=slot;			G.Ve_RefNum=RefNum;			G.Ve_GDHandle=gdh;			Pmh=(**G.Ve_GDHandle).gdPMap;			G.Base_Adresse=(**Pmh).baseAddr;			G.Row_Bytes=(long)(**Pmh).rowBytes & 0x7fff;			G.VE_pixelDeph=(**Pmh).pixelSize;			G.VE_BoardID=GetBoardID(G.Ve_Slot);			G.VE_BoardID=id;						// on vérifie que la carte est correctement configurée						if ( 	((**Pmh).bounds.right-(**Pmh).bounds.left)<720 ||					((**Pmh).bounds.bottom-(**Pmh).bounds.top)<576 ||					G.VE_pixelDeph<31)  {					AlertCarteDaffichage();			} else {				// configuration Upstream ou down stream ?				if (G.VE_Mode){			// DownStreamKeyer ?					ConfigureVX_DownStreamKeyer();						} else {					ConfigureVX_UpStreamKeyer();				}				InitMacPourVersionBroadcast();			  }	} // initialise Vx}void InitMacPourVersionBroadcast(void){Point 		point;WindowPtr	w;PixMapHandle	Pmh;GDHandle	CurrentGDevice;Rect				rect;OSErr			err;		CurrentGDevice=GetGDevice();		G.OffscreenDisplay=nil;		G.DuplicateOffscreenRendering=nil;		G.OffscreenRendering=nil;		if (G.Ve_GDHandle) {/*On créer un color graphic port pour dessiner offscreen les sous-titres	On récupère les info de la carte graphique*/					SetRect(&rect,0,0,1024,600);					Pmh=(**G.Ve_GDHandle).gdPMap;					 G.OffscreenDisplay=nil;					err= NewGWorld(&G.OffscreenDisplay,32,&rect,nil,0,0);					if (err) SysBeep(1);					/* on vérouille le pixmap handle */					LockPixels(GetGWorldPixMap((GWorldPtr)G.OffscreenDisplay));					/* on récupère l'adresse du buffer */					G.OffscreenDisplayBase=GetPixBaseAddr(GetGWorldPixMap((GWorldPtr)G.OffscreenDisplay));					/* on n'aloue pas pour l'instant la mémoire pour les rendus de caractères */					G.OffscreenRendering=nil;					G.DuplicateOffscreenBuffer=nil;					//on installe la VBL task 					// on attache le slot à la gestion des interruption					//AttachVBL(G.Ve_Slot); // ???????????					// on recopie le code de lancement (ce qui nous permet d'accéder au global du programme)										C_DoPrepareVBLJump();					//DoPrepareVBLJump();										gVBLInstalled=true;					// on initialise la structure vbl					// on active la vbl					// on active les interruptions de la carte d'affichage (Vidéo explorer)							//dans le cas nu vista+ il y a erreur c'est tout										point.v=0;					point.h=1;					//VEerr=VESetAbsoluteInterruptMode(G.Ve_RefNum,interruptEveryField,point);							w=GetNewCWindow(134,(WindowPtr)&G.DisplayWindow,(WindowPtr)StartUpDialog);					SetWRefCon(w,256);					Pmh=(**G.Ve_GDHandle).gdPMap;					MoveWindow(w,(**Pmh).bounds.left,(**Pmh).bounds.top,false);					SizeWindow(w,(**Pmh).bounds.right-(**Pmh).bounds.left,						(**Pmh).bounds.bottom-(**Pmh).bounds.top,true);					SetPort(w);						ShowHide((WindowRef)w,true);											BeginUpdate(w);					EraseRect(&w->portRect);					EndUpdate(w);					SetPort(StartUpDialog);				}		// on efface les buffers ecrans				SetRect(&rect,0,0,767,575);		Hand_EraseRect(G.Base_Adresse,G.Row_Bytes,&rect);		Hand_EraseRect(G.OffscreenDisplayBase,G.Row_Bytes,&rect);// on raz les pointeurs des buffers		G.Sous_titre_dessined=nil;		G.Sous_titreInOffscreen=nil; 		SetRect(&G.OffscreenRenderedRect,0,0,0,0); 		SetRect(&G.ScreenRenderedRect,0,0,0,0);		G.DrawState=0x8000;		// on désactive la vram		//do{}while(G.DrawState&0x8000);		G.Sous_titre_dessined=nil;		G.DrawState=0;			// on affecte le flag 		}// initialisecartepourfinalisationBoolean IsQuickTimeInstalled (void) {	short		error;	long		result;		error = Gestalt (gestaltQuickTime, &result);	return (error == noErr);	//return (false);}OSErr  FindBoardsResource(short slot,Str255 name){SpBlock	mySpBlk;OSErr	myErr;long		size;	/*{First, get a pointer to the board sResource for the slot.}*/	mySpBlk.spSlot= slot;					// {start searching in this slot, }{ and continue until found}	mySpBlk.spID= 0;	mySpBlk.spCategory= 1;					// {sRsrcType values for a board sResource}	mySpBlk.spCType= 0;	mySpBlk.spDrvrSW= 0;	mySpBlk.spDrvrHW= 0;	myErr= SNextTypeSRsrc(&mySpBlk);	if ( myErr) return myErr;			/*{The spsPointer field of mySpBlock now contains a pointer to the }	{ board sResource list. The SGetCString function uses this field }	{ as one of two input fields.}*/	mySpBlk.spID= 2;										// {sRsrcName entry}	myErr= SGetCString(&mySpBlk);		if (myErr==noErr) {		size=GetPtrSize((Ptr)mySpBlk.spResult);		if (size>255) size=255;		BlockMove((Ptr)mySpBlk.spResult,name+1,size-1);		*(name)=size-1;		DisposePtr((Ptr)mySpBlk.spResult);			} else {		*(name)=0;	}		return nil;}/*{	G.Ve_GDHandle=FindFirstPlus();			short		     	gNombreCarteGraphique;CarteGraphElement 	gListeCarteGraph[6];														gAVDevice=NextDevice;#ifdef __NoProtect__					DoInitAV();#endif#ifndef __NoProtect__					// oninitialise la carte AV					if (!G.FindFirstKey_error)DoInitAV();					 else  if (G.SoftProtect==1)DoInitAV();			#endif}*/void Install_XTask(void){	gTaskInstalled=false;	if (gUtiliseXTask) {		DoVitcReadSerialRequest=0;				// on installe le générateur interne		G.General_PseudoTimeCode=0x01000000;		G.GenerateurTask.tmRefCon=SetCurrentA5();	// Le pointeur A5		G.GenerateurTask.tmAddr=(ProcPtr)&GenerateurInterne;		G.GenerateurTask.tmWakeUp=0;		G.GenerateurTask.tmReserved=0; 		InsXTime((QElemPtr)&G.GenerateurTask); 		PrimeTime((QElemPtr)&G.GenerateurTask,300);				// on installe le système pour mesurer les performances		G.performanceTask.tmRefCon=SetCurrentA5();	// Le pointeur A5		G.performanceTask.tmAddr=(ProcPtr)&MesureCpuVitesse;		G.performanceTask.tmWakeUp=0;		G.performanceTask.tmReserved=0; 		InsXTime((QElemPtr)&G.performanceTask); 		PrimeTime((QElemPtr)&G.performanceTask,300); 		gTaskInstalled=true;				// système qui calcule la vitesse du VTR		gMesureVtrSpeed.tmRefCon=SetCurrentA5();	// Le pointeur A5		gMesureVtrSpeed.tmAddr=(ProcPtr)&CalcVtr_Speed;		gMesureVtrSpeed.tmWakeUp=0;		gMesureVtrSpeed.tmReserved=0; 		InsXTime((QElemPtr)&gMesureVtrSpeed); 		PrimeTime((QElemPtr)&gMesureVtrSpeed,300);  				gTaskInstalled=true;				//On patch ExitToshell(); pour ètre sûr de d'arrêter les x task sinon crash assuré		gOldExitToShellTrap=NGetTrapAddress(0xA9F4,ToolTrap);		NSetTrapAddress((UniversalProcPtr)&Patch_ExitToshell,0xA9F4,ToolTrap);				}	WaitTicks(67);// on attend un peu}void Dispose_XTask(void){   	if (!gTaskInstalled) return;	// on enlève les timer task présentent 	RmvTime((QElemPtr)&G.GenerateurTask); 	RmvTime((QElemPtr)&G.performanceTask); 	RmvTime((QElemPtr)&gMesureVtrSpeed);	WaitTicks(12);	// on rend le véritable exit to shell	NSetTrapAddress(gOldExitToShellTrap,0xA9F4,ToolTrap);}// si on est ici , cc'est que exit to shell demandé// on dispose les xtasks// et on saute au vrai exittoshell void Patch_ExitToshell(void){	// on enlève les timer task présentent 	RmvTime((QElemPtr)&G.GenerateurTask); 	RmvTime((QElemPtr)&G.performanceTask); 	RmvTime((QElemPtr)&gMesureVtrSpeed); 		/* on enlève la vbl si elle existe */		if(gVBLInstalled)  SlotVRemove((QElem*)&G.VBL_Structure,G.Ve_Slot);	NSetTrapAddress(gOldExitToShellTrap,0xA9F4,ToolTrap);		jumpExitToshell();	}	asm void jumpExitToshell( void ){		move.l	gOldExitToShellTrap,a0		jmp  		(a0) }pascal long GETLONG(Ptr adr);void C_DoPrepareVBLJump(void){OSErr	err;			G.VBL_A5=(Ptr)SetCurrentA5();						// on appelle une fois la routine pour ètre sûr que lsegment est chargé			VBLMAINTASK();						G.VBL_Structure.qType=vType;			G.VBL_Structure.vblAddr=(void*)&C_DoPrepareVBLJumpCode/*G.VBL_StartRoutinePtr*/;			G.VBL_Structure.vblCount=1;			G.VBL_Structure.vblPhase=0;			err=SlotVInstall((QElem*)&G.VBL_Structure,G.Ve_Slot);}asm void C_DoPrepareVBLJumpCode( void ){		movem.L   d0-d7/a0-A5,-(A7)		movea.L   sizeof(VBLTask)(a0),A5  		/*		move.w	G.DrawState,d0		and.l		#0xff,d0		move.w	d0,G.DrawState*/		jsr		VBLMAINTASK						move.w	#0,G.VBL_Structure.vblPhase		move.w	#1,G.VBL_Structure.vblCount		movem.l	(a7)+,d0-d7/a0-A5		rts		//jmp       	VBLMAINTASK}// Cette fonction vérifie que le panneau de control de la mémoire // est correctement configuré// mode 32 bits// pas de mémoire virtuelle (ram logique <= ram physique)Boolean IsMemoryConfigurationOK(){Boolean		ProblemConfigMemoire=true;long		physicalRam,logicalRam;// on regarde si la mémoire logique est supérieur à la mémoire physique// si oui,   	Gestalt ('ram ',&physicalRam);	Gestalt ('lram',&logicalRam);		if (!GetMMUMode())				ProblemConfigMemoire=false;		if (logicalRam> physicalRam)				ProblemConfigMemoire=false;	return  ProblemConfigMemoire;}void GetMyMenuPrefFile(void );void GetMyMenuPrefFile(void ){short count, Everesult;#ifndef	__Demo__	#ifndef	__NoProtect__		if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xB581,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			G.FindFirstKey_error=Everesult;		}						if (G.FindFirstKey_error) { // on ne fait le test tant que erreur			count=6;		//17 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&G.Eve_SerialNumber,G.EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&G.Eve_SerialNumber,G.EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);			if (!Everesult) G.SoftProtect=0xaefc;			G.FindFirstKey_error=Everesult;		}				#endif#endif}/* 	Cette routine retourne les dimensions h & v de l'écran principal, 	ainsi que ses coordonnées*/void C_GETMAINSCREENRES (Rect *rect){short	err;		if (!G.FindFirstKey_error) {/* on effectue la lecture de la clef eve3 pour les options du logiciel*/			G.Options_dansLaClef=0;			err=RBEREAD(2,&G.Options_dansLaClef,0x3232,G.EveHandle);			err=RBEREAD(4,&G.Gfr4_inkey,0x5454,G.EveHandle);		}			*rect=(**GetMainDevice()).gdRect;}long  getserialnumber (void){short	err,count,FindFirstKey_error,Everesult;Handle	EveHandle=RBEHANDLE();unsigned long		Eve_SerialNumber;// un peu de protection de logiciel					count=6;		//7 essais			do{				Everesult=RBEFINDFIRST(0xB581,&Eve_SerialNumber,EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&Eve_SerialNumber,EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);						if (	Everesult == E3_SUCCESS) {				DisposeHandle(EveHandle);				return Eve_SerialNumber;			}					count=6;		//7 essais			do{				Everesult=RBEFINDFIRST(0xFD34,&Eve_SerialNumber,EveHandle);				if (Everesult==E3ERR_NOTFOUND) RBEFINDNEXT(&Eve_SerialNumber,EveHandle); 				count--;			} while ( count !=0 && Everesult!=E3_SUCCESS);				DisposeHandle(EveHandle);		if (	Everesult == E3_SUCCESS) return Eve_SerialNumber;		else return -1;} //giveserial