#include "BB.Globals_C.h"#include <Devices.h>// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;/* *	Dialog Module, created by Resorcerer		light Modified by Eric Tiquet  */#include <StdArg.h>#include <stdio.h>// en attendant MPW Pro .... pour etre compatible avec la nouvelle version des includespascal void DlgCut(DialogPtr theDialog); pascal void DlgPaste(DialogPtr theDialog); pascal void DlgCopy(DialogPtr theDialog); pascal void DlgDelete(DialogPtr theDialog); typedef struct {	Rect box,bounds,shadow,prompt;	short currentChoice,menuID;	MenuHandle menu;	unsigned char str[256];	long roomToGrow[2];		} UserPopUp;#define lMargin 13#define rMargin 5#define bMargin 5#define thisDialogID 245/* Symbolic Dialog Item Numbers */static enum {	BUT1_OK = 1,	BUT2_Annuler,	EDIT3,	EDIT4,	EDIT5,	EDIT6,	EDIT7,	EDIT8,	EDIT9,	EDIT10,	EDIT11,	EDIT12,	POP13,	POP14,	POP15,	EDIT16,	STXT17,	STXT18_12,	STXT19,	EDIT20_1,	ICON21,	ICON22,	STXT23_Titre,	STXT24_Titre,	STXT25_Traduction,	STXT26_Nom,	STXT27_Traduction,	STXT28_Coordonn,	STXT29_Date,	STXT30_Modifi,	STXT31_r,	STXT32_Pays,	STXT33_Code,	STXT34_Tc,	STXT35_Tc,	STXT36_Langue,	STXT37_Caract,	STXT38_Editeur,	STXT39_Nom,	STXT40_Coordonn,	USER41,	USER42,	USER43,	USER44,	LASTITEM	};#define OK_ITEM 	BUT1_OK#define CANCEL_ITEM 	BUT2_Annuler/* Useful constants */#ifndef ENTERkey#define ENTERkey	0x3#endif#ifndef DELETEkey#define DELETEkey	0x8#endif#ifndef NIL#define NIL ((void *)0)#endif#ifndef TRUE#define TRUE 1#endif#ifndef FALSE#define FALSE 0#endif#ifndef FRONT_WINDOW#define FRONT_WINDOW  ((WindowPtr) (-1L))#endif/* Prototypes */int					EnTeteDuFilm(void);DialogPtr 				OpenThisDialog(void);void					CloseThisDialog(DialogPtr dlog);void					DoDialogUpdate(DialogPtr dlog);void					DoDialogActivate(DialogPtr dlog, int activ);void					DoDialogContent(DialogPtr dlog, EventRecord *evt);int						DoDialogItem(DialogPtr dlog, short itemHit);pascal  Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit);Boolean CheckUserItems(Point where, short *itemHit);int     AnyBadValues(DialogPtr dlog);static long    strlen(char *);char   *strcpy(char *dst, char *src);char   *PascalToC(char *pstr);char   *CToPascal(char *cstr);void    PutDlgString(DialogPtr dlog, int item, char *str, int sel);void    PutDlgWord(DialogPtr dlog, int item, int val, int sel);void    PutDlgLong(DialogPtr dlog, int item, long val, int sel);void    PutDlgChkRadio(DialogPtr dlog, int item, int val);static int     GetDlgString(DialogPtr dlog, int item, char *str);static int     GetDlgWord(DialogPtr dlog, int item, short *val);static int     GetDlgLong(DialogPtr dlog, int item, long *val);static int     GetDlgChkRadio(DialogPtr dlog, int item);static int     TextSelected(DialogPtr dlog);OSType  CanPaste(int n, ...);void    FrameDefault(DialogPtr dlog, int item, int frame);static void    GetDlgPanel(DialogPtr dlog, int item, Rect *panel);static void    DrawPopUp(UserPopUp *popup);static void    TruncPopUp(UserPopUp *popup);static int     InitPopUp(DialogPtr dlog, UserPopUp *p, int item, int pItem, int menuID, int choice);static void    SetPopUpChoice(UserPopUp *p, int choice);static void    DisposePopUp(UserPopUp *p);static int     DoUserPopUp(UserPopUp *p);static Point where;static int modifiers;/* Lists and/or popups */static UserPopUp popup13;static UserPopUp popup14;static UserPopUp popup15;/* *	Display this modal dialog.  Return TRUE if OK, FALSE if CANCEL or error. *	If the dialog displays values from outside this module, you should either *	import them from globals, or change the argument list of this routine to *	bring them in and pass them to OpenThisDialog(), DoDialogItem(), etc. *///#pragma segment Dialogsint EnTeteDuFilm()	{		short itemHit,okay,keepGoing=TRUE;		register DialogPtr dlog; GrafPtr oldPort;		Str255		st0,st1;		/* Build dialog window and install its item values */				GetPort(&oldPort);		dlog = OpenThisDialog();		if (dlog == NIL) return(FALSE);		/* Entertain filtered user events until dialog is dismissed */				while (keepGoing) {			ModalDialog(MyFilter,&itemHit);			keepGoing = DoDialogItem(dlog,itemHit);			}				/*		 *	Do final processing of item values, such as exporting them to caller.		 *	DoDialogItem() has already called AnyBadValues().		 */				if (okay = (itemHit==OK_ITEM)) {		/* Or whatever is equivalent */			/* initialisation du dialog */						/* les cha”nes de caractres */				GetDlgString(dlog,EDIT3,(char *)&G.Preference_TitreOriginal);				GetDlgString(dlog,EDIT4,(char *)&G.Preference_TitreFrancais);				GetDlgString(dlog,EDIT5,(char *)&G.Preference_TitreEpisodeOriginal);				GetDlgString(dlog,EDIT6,(char *)&G.Preference_TitreEpisodeTraduit);				GetDlgString(dlog,EDIT7,(char *)&G.Preference_NomAdaptateur);				GetDlgString(dlog,EDIT8,(char *)&G.Preference_CoordonneesAdaptateur);				GetDlgString(dlog,EDIT9,(char *)&G.CodeDeReference);				GetDlgString(dlog,EDIT10,(char *)&G.EditeurListe);				GetDlgString(dlog,EDIT11,(char *)&G.NomDuMonteur);				GetDlgString(dlog,EDIT12,(char *)&G.CoordonneeMonteur);					/* les pop-up */				G.PaysOrigine=popup13.currentChoice;				G.CodeLangue=popup14.currentChoice;				G.CodeCaractere=	popup15.currentChoice;			/* tc dŽbut programme */				GetDlgString(dlog,EDIT16,(char *)&st0);	 			G.TcDebutFilm=C_ConversionChaineASCIITc(&st0);				G.BlockNote_tc[0]=G.TcDebutFilm;			/* n¡ de rŽvision */				 GetDlgWord(dlog,EDIT20_1,(short*)&G.Revision);			/* 				les items suivant sont non modifiables, il ne faut pas les rŽinsŽrer dans les globales.					- tc premier sous-titre 					 -date de crŽation  					- date de modification 			*/			G.ChangeSinceLastSave=true; // il ya eu du changement			// on affecte le titre original aux fentres listing et saisie	 		BlockMove(&G.Preference_TitreOriginal,&st1,256);	 		GetIndString(&st0,129,3); 				//saisie name	 		BlockMove(&st1[1],&st0[st0[0]+1],(long)st1[0]);	 		st0[0]+=st1[0];							 		SetWTitle((WindowPtr)&G.DialogSaisie,&st0);				 		GetIndString(&st0,129,4); 				//listing name	 		BlockMove(&st1[1],&st0[st0[0]+1],(long)st1[0]);			st0[0]+=st1[0];	 		SetWTitle((WindowPtr)&G.ListingWindow,&st0);			}		/* That's all, folks! */				CloseThisDialog(dlog);		SetPort(oldPort);		SetDAFont(0); 		return(okay);	}/* *	We have to have a filter function, at the very least so that we can outline *	any default button, entertain keyboard editing commands, cmd-period canceling, etc. *	Note that you do not need to have a special user item covering the default button *	in your dialog item list. */static pascal Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit)	{		Boolean ans=FALSE,doHilite=FALSE; WindowPtr w,window;		short type,ch,part; Handle hndl; Rect box;		static long then; static Point clickPt;				w = (WindowPtr)(evt->message);		switch(evt->what) {			case updateEvt:				if (w == dlog) {					/* Update our dialog contents */					DoDialogUpdate(dlog);					ans = TRUE; *itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoUpdate(w) routine here if you					 *	don't want unsightly holes in background windows caused					 *	by nested alerts, balloon help, or screen savers (see					 *	Tech Note #304).					 */					DoUpdate(w);					}				break;			case activateEvt:				if (w == dlog) {					DoDialogActivate(dlog,(evt->modifiers & activeFlag)!=0);					*itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoActivate(w) routine here if					 *	you want to deactivate the former frontmost window, in order					 *	to unhighlight any selection, scroll bars, etc.					 */					}				break;			case mouseDown:					where = evt->where;		/* Make info available to DoDialog() */					part = FindWindow(evt->where, &window);				if ( part==inDrag)               /* pass screenBits.bounds to get all gDevices */						if	(window==(WindowPtr)FrontNonFloatingWindow()) {							 DragWindow(window, evt->where,&QD.screenBits.bounds); //&QD.screenbit bounds); //							 ans=true;							*itemHit = 0;						 } 			case mouseUp:				where = evt->where;		/* Make info available to DoDialog() */				GlobalToLocal(&where);				modifiers = evt->modifiers;				ans = CheckUserItems(where,itemHit);				break;			case keyDown:				if ((ch=(unsigned char)evt->message)=='\r' || ch==ENTERkey) {					*itemHit = OK_ITEM /* Default Item Number here */;					doHilite = ans = TRUE;				}				if ((ch=(unsigned char)evt->message)==27 ) {					*itemHit = 2 /* Default Item Number here */;					doHilite = ans = TRUE;				  }				if (evt->modifiers & cmdKey) {					ch = (unsigned char)evt->message;					switch(ch) {						case 'x':						case 'X':							if (TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DlgCut(dlog); TEToScrap(); }							 else {								/* Cut from anything else cuttable, like a list */								}							break;						case 'c':						case 'C':							if (TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DlgCopy(dlog); TEToScrap(); }							 else {								/* Copy from anything else copyable, like a list */								}							break;						case 'v':						case 'V':							if (CanPaste(1,'TEXT'))								{ TEFromScrap(); DlgPaste(dlog); }							 else {							 	/* Deal with any other pasteable scraps here */								}							break;						case 'a':						case 'A':							if (((DialogPeek)dlog)->editField >= 0) {								/* Dialog has text edit item: select all */								SelIText(dlog,((DialogPeek)dlog)->editField+1,0,32767);								}							 else {								}							*itemHit = 0;							break;						case '.':							*itemHit = CANCEL_ITEM;							doHilite = TRUE;							break;						}					ans = TRUE;		/* Other cmd-chars ignored */					}				break;			}		if (doHilite) {			GetDItem(dlog,*itemHit,&type,&hndl,&box);			/* Reality check */			if (type == (btnCtrl+ctrlItem)) {				long soon = TickCount() + 7;		/* Or whatever feels right */				HiliteControl((ControlHandle)hndl,1);				while (TickCount() < soon) ;		/* Leave hilited for a bit */				}			}		return(ans);	}/* * Mouse down event: * Check if it's in some user item, and convert to itemHit if appropriate. */static Boolean CheckUserItems(Point where, short *itemHit)	{		if (PtInRect(where,&popup13.shadow))			{ *itemHit = DoUserPopUp(&popup13) ? POP13 : 0; return(TRUE); }		if (PtInRect(where,&popup14.shadow))			{ *itemHit = DoUserPopUp(&popup14) ? POP14 : 0; return(TRUE); }		if (PtInRect(where,&popup15.shadow))			{ *itemHit = DoUserPopUp(&popup15) ? POP15 : 0; return(TRUE); }		return(FALSE);	}/* * Redraw the contents of this dialog due to update event. * If you have not installed UserItem draw routines, you should redraw * them explicitly here; otherwise, UpdtDialog() will call your routines. */static void DoDialogUpdate(DialogPtr dlog){short type; Handle hndl; Rect box,rect;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;					GrafPtr oldPort;		GetPort(&oldPort);		SetPort(dlog);		TextFont(geneva);		BeginUpdate(dlog);		DrawDialog(dlog);		DrawPopUp(&popup13);		DrawPopUp(&popup14);		DrawPopUp(&popup15);		TextFont(geneva);	// on entoure la fentre d'une ppat		pixpat=GetPixPat(129);						if (pixpat!=nil){			rgn=NewRgn();			rgn1=NewRgn();			RectRgn(rgn,&dlog->portRect);			GetDItem(dlog,1,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDItem(dlog,2,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);						GetDItem(dlog,41,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDItem(dlog,42,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDItem(dlog,43,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDItem(dlog,44,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);						FillCRgn(rgn,pixpat);			DisposePixPat(pixpat);			DisposeRgn(rgn);			DisposeRgn(rgn1);		}		GetDItem(dlog,41,&type,&hndl,&box);		MakeReliefRectangle1(&box);		GetDItem(dlog,42,&type,&hndl,&box);		MakeReliefRectangle1(&box);		GetDItem(dlog,43,&type,&hndl,&box);		MakeReliefRectangle1(&box);		GetDItem(dlog,44,&type,&hndl,&box);		MakeReliefRectangle1(&box);		FrameDefault(dlog,BUT1_OK,TRUE);		EndUpdate(dlog);		SetPort(oldPort);	}/* * Activate event: Activate or deactivate this dialog and any items in it */static void DoDialogActivate(DialogPtr dlog, int activ)	{		SetPort(dlog);	}/* * Build this dialog's window on desktop, and install initial item values. * Return the dlog opened, or NIL if error (no resource, no memory). */static DialogPtr OpenThisDialog()	{		short type; Handle hndl; Rect box; GrafPtr oldPort;		DialogPtr dlog; unsigned char *p,str[256];		Str255 st0;		GetPort(&oldPort);		SetDAFont(geneva); 		dlog = GetNewDialog(thisDialogID,NIL,FRONT_WINDOW);		if (dlog == NIL) { SysBeep(1); return(NIL); }	/* Poor man's error message */		SetPort(dlog);		TextFont(geneva); 	/* initialisation du dialog */		{		TEHandle textH = ((DialogPeek)dlog)->textH;		if (textH)			if ((**textH).txSize>=0){				(**textH).txSize=9;				(**textH).txFont=geneva;			}		}		/* les cha”nes de caractres */		PutDlgString(dlog,EDIT4,(char*)&G.Preference_TitreFrancais, FALSE);		PutDlgString(dlog,EDIT5,(char*)&G.Preference_TitreEpisodeOriginal, FALSE);		PutDlgString(dlog,EDIT6,(char*)&G.Preference_TitreEpisodeTraduit, FALSE);		PutDlgString(dlog,EDIT7,(char*)&G.Preference_NomAdaptateur, FALSE);		PutDlgString(dlog,EDIT8,(char*)&G.Preference_CoordonneesAdaptateur, FALSE);		PutDlgString(dlog,EDIT9,(char*)&G.CodeDeReference, FALSE);		PutDlgString(dlog,EDIT10,(char*)&G.EditeurListe, FALSE);		PutDlgString(dlog,EDIT11,(char*)&G.NomDuMonteur, FALSE);		PutDlgString(dlog,EDIT12,(char*)&G.CoordonneeMonteur, FALSE);		if (!InitPopUp(dlog,&popup13,POP13,32, 2007 /* = ResID of MENU */, G.PaysOrigine))			goto broken;		if (!InitPopUp(dlog,&popup14,POP14,36, 2008 /* = ResID of MENU */, G.CodeLangue))			goto broken;		if (!InitPopUp(dlog,&popup15,POP15,37, 2009 /* = ResID of MENU */, G.CodeCaractere))			goto broken;		/* tc dŽbut programme */		C_ConversionTCstASCII(G.TcDebutFilm,&st0);		if (G.TcDebutFilm!=-1) PutDlgString(dlog,EDIT16,(char *)&st0, FALSE);		/* tc premier sous-titre */		C_ConversionTCstASCII(G.General_PremierTC,&st0);		if (G.General_PremierTC!=-1) PutDlgString(dlog,17,(char *)&st0, FALSE);		/* date de crŽation */		IUDateString(G.DateDeCreation,shortDate,&st0);		PutDlgString(dlog,18,(char *)&st0, FALSE);		/* date de modification */		IUDateString(G.ModifieLe,shortDate,&st0);		PutDlgString(dlog,19,(char *)&st0, FALSE);		/* n¡ de rŽvision */		PutDlgWord(dlog,EDIT20_1,G.Revision,FALSE);		/* le titre original en dernier pour qu'il soit sŽlectionnŽ dans la liste */ 		PutDlgString(dlog,EDIT3,(char*)&G.Preference_TitreOriginal, TRUE);		ShowWindow(dlog);		InvalRect(&dlog->portRect);		return(dlog);		/* Error return */broken:		CloseThisDialog(dlog);		SetPort(oldPort);		return(NIL);	}/* * Clean up any allocated stuff, and return dialog to primordial mists */static void CloseThisDialog(DialogPtr dlog)	{		DisposePopUp(&popup13);		DisposePopUp(&popup14);		DisposePopUp(&popup15);		DisposDialog(dlog);	/* Call CloseDialog if you provide storage to GetNewDialog */	}/* * Deal with user clicking on an item in this dialog, either modal or non-modal. * The local point is in where; modifiers in modifiers. * Returns whether or not the dialog should be closed (keepGoing). */static int DoDialogItem(DialogPtr dlog, short itemHit)	{		short type,okay=FALSE,keepGoing=TRUE,val;		Handle hndl; Rect box; Point pt;		long	a;		unsigned char *p,str[256];		if (itemHit<1 || itemHit>=LASTITEM)			return(keepGoing);				/* Only legal items, please */		GetDItem(dlog,itemHit,&type,&hndl,&box);		switch(type) {			case ctrlItem+btnCtrl:				switch(itemHit) {					case BUT1_OK:						keepGoing = FALSE; okay = TRUE;						break;					case BUT2_Annuler:						keepGoing = FALSE;						break;					}				break;			case ctrlItem+chkCtrl:				break;			case ctrlItem+radCtrl:				break;			case ctrlItem+resCtrl:				break;			case statText:				switch(itemHit) {					case STXT17:						break;					case STXT18_12:						break;					case STXT19:						break;					case STXT23_Titre:		/* NOT Enabled */						break;					case STXT24_Titre:		/* NOT Enabled */						break;					case STXT25_Traduction:		/* NOT Enabled */						break;					case STXT26_Nom:		/* NOT Enabled */						break;					case STXT27_Traduction:		/* NOT Enabled */						break;					case STXT28_Coordonn:		/* NOT Enabled */						break;					case STXT29_Date:		/* NOT Enabled */						break;					case STXT30_Modifi:		/* NOT Enabled */						break;					case STXT31_r:		/* NOT Enabled */						break;					case STXT32_Pays:		/* NOT Enabled */						break;					case STXT33_Code:		/* NOT Enabled */						break;					case STXT34_Tc:		/* NOT Enabled */						break;					case STXT35_Tc:		/* NOT Enabled */						break;					case STXT36_Langue:		/* NOT Enabled */						break;					case STXT37_Caract:		/* NOT Enabled */						break;					case STXT38_Editeur:		/* NOT Enabled */						break;					case STXT39_Nom:		/* NOT Enabled */						break;					case STXT40_Coordonn:		/* NOT Enabled */						break;					}				break;			case editText:				switch(itemHit) {					case EDIT3:						break;					case EDIT4:						break;					case EDIT5:						break;					case EDIT6:						break;					case EDIT7:						break;					case EDIT8:						break;					case EDIT9:						break;					case EDIT10:						break;					case EDIT11:						break;					case EDIT12:						break;					case EDIT16:						break;					case EDIT20_1:		/* NOT Enabled */						break;					}				break;			case iconItem:				switch(itemHit) {					case ICON21:						a=C_IncDecValue(dlog,itemHit,20,0,9,1);						break;					case ICON22:						a=C_IncDecValue(dlog,itemHit,20,0,9,-1);						break;					}				break;			case picItem:				break;			case userItem:				switch(itemHit) {					case POP13:						/* popup13.currentChoice has changed */						break;					case POP14:						/* popup14.currentChoice has changed */						break;					case POP15:						/* popup15.currentChoice has changed */						break;					case USER41:						break;					case USER42:						break;					case USER43:						break;					case USER44:						break;					}				break;			}		if (okay) keepGoing = AnyBadValues(dlog);		return(keepGoing);	}/* * Pull values out of dialog items and deliver TRUE if any of them are * illegal or inconsistent; otherwise deliver FALSE.  If any values are bad, * you should inform your user about the problem here before delivering TRUE. * If any items are missing values, this is the place to assign any defaults. */static int AnyBadValues(DialogPtr dlog)	{		char str[256]; short val,len;		if (GetDlgString(dlog,EDIT3,str)) {			/* Got a string (can also call GetDlgWord(), etc. here) */			}		else {			/* Field was empty */			}		if (GetDlgString(dlog,EDIT4,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT5,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT6,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT7,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT8,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT9,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT10,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT11,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT12,str)) {			}		else {			}		/* ?? = popup13.currentChoice */		/* ?? = popup14.currentChoice */		/* ?? = popup15.currentChoice */		if (GetDlgString(dlog,EDIT16,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT20_1,str)) {			}		else {			}		return(FALSE);	}/*¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥*//* *  The following are various utility routines for general dialog management. *  Typically, you'll want to keep them in a library that is available to all *  your dialog modules; however, they are included here (and declared static) *  as a private library so that you can quickly compile this file for testing. */#define _PrivateLibraries_#ifdef  _PrivateLibraries_/* Local C string length routine */static long strlen(register char *str)	{		register char *p;		p = str;		while (*p++) ;		return((long)(--p - str));	}/* Convert in place a Pascal string to C string, and deliver its address */static char *PascalToC(char *str)	{		register char *p,*q,*end;		end = str + *(unsigned char *)str;		q = (p=str) + 1;		while (p < end) *p++ = *q++;		*p = '\0';		return(str);	}/* *	Convert in place a C string to Pascal string, and deliver its address. *	The C string should not be greater than 255 chars in length, or the *	resulting Pascal string will be truncated to 255 chars. */static char *CToPascal(char *str)	{		register char *p,*q;		register long len;		len = strlen(str);		if (len > 255) len = 255;		p = str + len;		q = p-1;		while (p != str) *p-- = *q--;		*str = len;		return(str);	}/* Dialog Item Stuffers *//* *	Install a given Pascal string, str, into the given static or edit text item *	in the dialog, dlog.  If the item is an edit text item, leave the installed *	text selected or not according to the value of sel (TRUE or FALSE). */static void PutDlgString(DialogPtr dlog, int item, char *str, int sel)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		SetIText(hndl,str);		if (type == editText)			SelIText(dlog,item,sel?0:32767,32767);		InvalRect(&box);	}/* *	Install a given decimal long value into the static or edit text item of the *	given dialog, dlog.  If the item is an edit text item, leave the installed *	text for the number selected or not according to sel (TRUE or FALSE). */static void PutDlgLong(DialogPtr dlog, int item, long val, int sel)	{		char str[32];		NumToString(val,str);		PutDlgString(dlog,item,str,sel);	}/* *	Same as above, only for an int (word) decimal number. */static void PutDlgWord(DialogPtr dlog, int item, int val, int sel)	{		PutDlgLong(dlog,item,(long)val,sel);	}/* *	Set the given check box or radio button item of the given dialog, dlog, to *	on or off, according to val. */static void PutDlgChkRadio(DialogPtr dlog, int item, int val)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		SetCtlValue((ControlHandle)hndl,val!=0);	}/* *	Deliver the value of the checkbox or radio button item of the given dialog. */static int GetDlgChkRadio(DialogPtr dlog, int item)	{		short type; Handle hndl; Rect box;				GetDItem(dlog,item,&type,&hndl,&box);		return(GetCtlValue((ControlHandle)hndl) != 0);	}/* Dialog Item Unstuffers *//* *	Retrieve the value of an edit text item in a given dialog, placing the *	resulting Pascal string in the buffer, str, which is assumed large enough *	to hold the text (256 bytes max).  If item is the number of a static text *	item, the empty string is delivered.  Delivers TRUE or FALSE according to *	whether or not the text so delivered was empty.   */static int GetDlgString(DialogPtr dlog, int item, char *str)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		 GetIText(hndl,str);		return(*str != 0);	}/* *	Retrieve the value of an edit text item in a given dialog, converting the *	Pascal string to a long and setting *val to it.  Delivers TRUE or FALSE *	according to whether or not the text so delivered was empty.  If FALSE, *	*val is set to 0; if TRUE, *val is set to whatever StringToNum() says the *	value is, even if the text contains non-numerical characters. */static int GetDlgLong(DialogPtr dlog, int item, long *val)	{		int ans; char str[256];		*val = 0;		if (ans = GetDlgString(dlog,item,&str))			StringToNum(&str,val);		return(ans);		}/* Same as above, only delivers the value of a word */static int GetDlgWord(DialogPtr dlog, int item, short *val)	{		int ans;		long num;		*val = 0;		if (ans = GetDlgLong(dlog,item,&num))			*val =(short) num;		return(ans);	}/* *	Deliver the number of the current editText item in given dialog if any text *	is selected in it, or 0 if none selected. */static int TextSelected(DialogPtr dlog)	{		register TEHandle textH; int item = 0;				textH = ((DialogPeek)dlog)->textH;		if (*textH)			if ( (*textH)->selStart != (*textH)->selEnd )				item = ((DialogPeek)dlog)->editField+1;		return(item);	}/* *  If any of the variable argument scrap types are available for pasting from *  the scrap, deliver the first one.  Otherwise, deliver 0.  For example, *	 *      if (whichType = CanPaste(3,'TEXT','PICT','STUF')) ... * *  There can be any number of types in the list, as long as the preceding count, n, *  is correct. */static OSType CanPaste(int n, ...)	{		register OSType nextType,ans = 0L;		long err,offset;		va_list nextArg;				va_start(nextArg,n);		nextType = va_arg(nextArg, OSType);				while (n-- > 0) {			err = GetScrap(NIL, nextType, &offset);			if (err >= -1) {				ans = nextType;				break;				}			nextType = va_arg(nextArg, OSType);			}				va_end(nextArg);		return(ans);	}/* *	Get rectangle, *panel, for a given item (usually a user or picture item) *	and then hide the item so that it doesn't interfere with mouse clicking. *	This lets you stop worrying about the item order any user or pict items that *	obscure other items in the item list, which can affect how the DialogMgr *	returns itemHits. */static void GetDlgPanel(DialogPtr dlog, int item, Rect *panel)	{		short type; Handle hndl;				GetDItem(dlog,item,&type,&hndl,panel);		HideDItem(dlog,item);	}/*	Draw a given popup user item in the system font. 	ModifiŽ E.T. 6/95 pour utilisation couleurs du menu*/static void DrawPopUp(UserPopUp *p){short 		font,face,mode,size,sysFontSize,a;RGBColor	color,bcolor,noir,savef,saveb;MCEntryPtr	mcPtr;RgnHandle	rgn;GrafPtr		thePort;		GetPort(&thePort);		// sauvegarde couleurs du port		GetForeColor(&savef);		GetBackColor(&saveb);				// on initialise les couleurs		color.red=0;		color.green=0;		color.blue=0;		bcolor.red=-1;		bcolor.green=-1;		bcolor.blue=-1;				noir=color;		// on rŽcupre la couleur du fond du menu et du texte pour le menu en entier		mcPtr= GetMCEntry(p->menuID,0);		if (mcPtr) {			if (mcPtr->mctID==0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB2;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem!=0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB2;					RGBForeColor(&color);			}					} // if (mcPtr)		mcPtr= GetMCEntry(p->menuID,p->currentChoice);		if (mcPtr) {			if (mcPtr->mctID==0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB2;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem==0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB3;					RGBForeColor(&color);			}						if (mcPtr->mctID!=0 && mcPtr->mctItem!=0){					bcolor=mcPtr->mctRGB4;					RGBBackColor(&bcolor);					color=mcPtr->mctRGB2;					RGBForeColor(&color);			}					} // if (mcPtr)		EraseRect(&p->bounds);		/* And draw the current setting str in */		MoveTo(p->bounds.left+lMargin,p->bounds.bottom-bMargin);		/* Save/restore current window font characteristics while drawing. */				font = thePort->txFont;		size = thePort->txSize;		face = thePort->txFace;		mode = thePort->txMode;				/* Get the system font size and set system font */		sysFontSize = GetDefFontSize();		if (sysFontSize < 1) sysFontSize = 12;		TextFont(systemFont); TextSize(sysFontSize); TextFace(0); TextMode(0);				RGBForeColor(&color);		DrawString(p->str);		/* Kiss and make up after last argument(s) */		TextFont(geneva); TextSize(size); TextFace(face); TextMode(mode);						//on rend la couleur noire pour le dessin du reste du popUp		color.red=0;		color.green=0;		color.blue=0;		RGBForeColor(&color);// on dessine le contour du menu		RGBForeColor(&noir);		FrameRect(&p->bounds);		MoveTo(p->bounds.right,p->shadow.top+2);		LineTo(p->bounds.right,p->bounds.bottom);		LineTo(p->shadow.left+2,p->bounds.bottom);		// on dessine le triangle en fin de texte		rgn=NewRgn();		OpenRgn();		a=p->bounds.bottom-p->bounds.top-8;		MoveTo(p->bounds.right-4,(p->bounds.bottom-p->bounds.top-a/2)/2+p->bounds.top);		Line(-a,0);		Line(a/2,a/2);		Line(a/2,-a/2);		CloseRgn(rgn);		PaintRgn(rgn);		DisposeRgn(rgn);// on dessine le rectangle autour du texte				PenSize(1,1);				RGBForeColor(&savef); RGBBackColor(&saveb);	}/* *	TruncPopUp() fits the string for the current setting into *	the popup item's bounding box by truncating it and adding É */static void TruncPopUp(UserPopUp *p)	{		int width,space; register int len,n; unsigned char *ptr;		if (p->currentChoice) GetItem(p->menu,p->currentChoice,p->str);		 else                 *p->str = 0;		/* Trim off any trailing blanks used to increase width of menu as a whole */				for (len = *(unsigned char *)p->str; len>0; len--) {			ptr = p->str + len;			if (*ptr!=' ' && *ptr!='Ê') break;		/* Option-space as well */			}		*p->str = len;				space = p->bounds.right - p->bounds.left - (lMargin+rMargin)-(p->bounds.bottom-p->bounds.top-8);;		len = *(unsigned char *)p->str;		while (len > 0)			if (p->str[len]!=' ') break; else len--;		*p->str = len;		width = StringWidth(p->str);		/* Assumes the system font is current */		if (width > space) {			len = *p->str;			width += CharWidth('É');			while (len>0 && width>space)				width -= CharWidth(p->str[len--]);			p->str[++len] = 'É';			*p->str = len;		}	}/* *	Initialize a UserPopUp data structure, p, for a given dialog, dlog, and the *	user item, item, in it that represents the popup menu. *	pItem is the item number of the staticText prompt item, or 0 if none. *	menuID is the resource ID of the menu to be popped up; choice is the *	initial choice from the menu to show in the popup field, or 0 if none. *	Returns FALSE if error, TRUE otherwise.  A successful call to this *	should be matched by a call to DisposePopUp, in order to get rid of *	the detached MENU resource. */static int InitPopUp(DialogPtr dlog, UserPopUp *p, int item, int pItem, int menuID, int firstChoice)	{		short type,choice; Handle hndl;		if (pItem) GetDItem(dlog,pItem,&type,&hndl,&p->prompt);		else	   SetRect(&p->prompt,0,0,0,0);		GetDItem(dlog,item,&type,&hndl,&p->box);		p->bounds = p->box; InsetRect(&p->bounds,-1,-1);		p->shadow = p->bounds;		p->shadow.right++; p->shadow.bottom++;		p->currentChoice = firstChoice;		if (p->menu = GetMenu(p->menuID = menuID)) {			InsertMenu(p->menu,-1);			TruncPopUp(p);			if (firstChoice)				SetItemMark(p->menu,firstChoice,(char)checkMark);			}		return(p->menu != NIL);	}/* *	This is called to get rid of the MENU handle, which was detached *	by InitPopUp. */static void DisposePopUp(UserPopUp *p)	{		DeleteMenu(p->menuID);		if (p->menu) ReleaseResource((Handle)p->menu);		p->menu = NIL;	}/* *	Invoke a popup menu; return TRUE if new choice made, which will be *	in p->currentChoice. */static int DoUserPopUp(UserPopUp *p)	{		long choice; int ans = FALSE; Point pt;				InvertRect(&p->prompt);		/* May be empty if no prompt static text item */		pt = *(Point *)(&p->box);		LocalToGlobal(&pt);		choice = PopUpMenuSelect(p->menu,pt.v,pt.h,p->currentChoice);		InvertRect(&p->prompt);		if (choice) {			choice = LoWord(choice);			if (choice != p->currentChoice) {				SetPopUpChoice(p,(short)choice);				ans = TRUE;				}			}		return(ans);	}/* *	Set popup menu to show given choice, or nothing if choice is 0. */static void SetPopUpChoice(UserPopUp *p, int choice)	{		if (p->currentChoice)			SetItemMark(p->menu,p->currentChoice,0);		*p->str = 0;		if (choice>0 && choice<=CountMItems(p->menu)) {			SetItemMark(p->menu,p->currentChoice = choice,checkMark);			TruncPopUp(p);			}		 else			p->currentChoice = 0;		EraseRect(&p->box); DrawPopUp(p);	}#endif