#include 	"BB.Globals_C.h"#include	"FileStruct.h"	#include	"N19.h"	pascal void Date2Secs(const DateTimeRec *d,unsigned long *secs); // les globals 	extern MyQDGlobals QD;	extern AppGlobals G;pascal void	C_ConversionN19_BonBougre(HParmBlkPtr pb ,char* name);short  ConversionPaysOrigine(char *po);short GiveCodeLangue(Byte *input);pascal void C_RecopieStringPC_MAC(char* from,char* to,long longueur);pascal void RPDispose(Handle theRpd);pascal Boolean RPIdle(Handle theRpd,long value,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder);void  C_TransfertStyleTE_Memoire(TEHandle te,SousTitreRecordPtr ST_Ptr);pascal Boolean myStandartfilterproc(DialogPtr theDialog ,EventRecord *event,short *itemhit);pascal Boolean RPIsFrontProcess(Handle theRpd);static short DernierSN;pascal void C_ReadBonBougreFormat(short refNum,Str31 Filename,Boolean Concatene);Boolean CheckStyle(SousTitreRecordPtr ST_Ptr);Boolean MakeOneStyle(SousTitreRecordPtr ST_Ptr);pascal void 	ConvertiTTISousTitre(N19_TTIPtr TTI,SousTitreRecordPtr ST_Ptr);pascal void C_WriteBonBougreFormat(short refNum,Str31 Filename,Boolean saveauto);pascal void C_ReadBonBougreFormat(short refNum,Str31 Filename,Boolean Concatene){GrafPtr	oldport;Ptr		Buffer,MaxBuffer,P,P1,P2;Handle	h,versH,progression;long	L,L1,NombreSTALire,num,OffsetDepuisLedebut,longueurST,pbcount=0,okpourtous=0;OSErr	err,errLecture;short	version,result,vRefNum;EnteteBonBougreFormatHandle	Entete;SousTitreRecordPtr	ST_Ptr;ParamBlockRec		pb;Boolean				done=false,problem,PasInsertLePremierSt=false;Str255				st0,str;FileSTRecordPtr		FileST_Ptr;unsigned long		LL,L2,L3;long				StyleAbime=0;/* on recherche une zone de travail*/		MaxBuffer=G.BufferTransfert+G.SIZEBufferTransfert;		Buffer=	G.BufferTransfert;/* ok on peut bosser on ouvre un dialog */		GetPort(&oldport);	/* on calcule la taille de la zone de preférence */		Entete=(EnteteBonBougreFormatHandle)NewHandle(sizeof(EnteteBonBougreFormat));		if (!Entete) { AlertUser(5); return; }		HLock((Handle)Entete);			/* on lit l'en tête du fichier */		L=sizeof(EnteteBonBougreFormat);		err = FSRead(refNum,&L,(Ptr)*Entete);		if (err) {			AlertUser(26);			DisposeHandle((Handle)Entete);				return;			}		/* on vérifie que la version du fichier est compatible avec le logiciel en cour */		versH=Get1Resource('vers',1);		if (versH){			version=*((SPtr)*versH);			ReleaseResource((Handle)versH);			}						// on prepare la liste si pas concatènation			 		if (!Concatene){			//on efface la liste, on place le Titre original dans les fenêtre			P= &(**Entete).Preference_TitreOriginal;			EffaceTouslesSousTitres(P);			// n recope l'entête dans les globales			BlockMove(*Entete,(Ptr)&G.versionLogiciel,sizeof(EnteteBonBougreFormat));			// On vérifie que le paramètre safearea ne soit pas erroné			// ce qui nécessaire pour les anciennes version du logiciel ....			if (G.safearea >80 ) G.safearea =80 ;			if (G.safearea <30 ) G.safearea =80 ;			G.General_NombreST=1; // on raz le nombre total de sous-titre.			PasInsertLePremierSt=true; // il ne faudra pas insérer le premier sous-titre		}					if ( version>(**Entete).versionLogiciel){			/* version supérieur à cette version de logicielle donc alerte */				// result=CautionAlert(278,(ModalFilterProcPtr)myStandartfilterproc);				// if (result==2) return;		}		/* on lit le maximum du fichier, dans le buffer*/		err = GetVRefNum(refNum,&vRefNum);		if (err) {			AlertUser(26);			DisposeHandle((Handle)Entete);				return;			}		/* on prépare la lecture du fichier	on utilise PBRead car on a besoin de paramétrer la lecture	on effectue la lecture après l'en tête*/		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioResult=0;		pb.ioParam.ioRefNum=refNum;		pb.ioParam.ioVRefNum=vRefNum;		pb.ioParam.ioBuffer=G.BufferTransfert;		pb.ioParam.ioReqCount=G.SIZEBufferTransfert;		pb.ioParam.ioActCount=0;		pb.ioParam.ioPosMode=fsFromStart;		OffsetDepuisLedebut=sizeof(EnteteBonBougreFormat);		pb.ioParam.ioPosOffset=OffsetDepuisLedebut;		errLecture=PBRead(&pb,false);		if (errLecture && (errLecture!=-39)) {			AlertUser(26);			DisposeHandle((Handle)Entete);				return;			}					P=G.BufferTransfert;	/* on prépare la lecture du fichier*/		NombreSTALire=(**Entete).General_NombreST;		if (NombreSTALire==0) {					AlertUser(26);					DisposeHandle((Handle)Entete);						return;				}		if (Concatene)	GetIndString(&st0,129,46);			else 		GetIndString(&st0,129,41);		progression=RPInitReglette(&st0,Filename,1,NombreSTALire,Concatene);		/* Boucle de lecture des sous-titres */				num=1;	do {		problem=false;				FileST_Ptr=(FileSTRecordPtr) P;				/* test de validité du sous-titre */		longueurST=FileST_Ptr->file_LenthST;				// on compare la longueur entre file_LenthST et toutes les longueurs ajoutées		L=FileST_Ptr->file_TexteLenth;		L=((L+3)/4)*4;		if(L){ // pas de texte, pas de style: logique non ....			L+=FileST_Ptr->file_StyleLenth;			L=((L+3)/4)*4;		}		L+=FileST_Ptr->file_CommentaireLenth;		L=((L+3)/4)*4;		L+=sizeof(FileSTRecord);				/* on regarde si les longueurs sont cohérentes*/		if ( L>(longueurST+1)) problem=true;		if (longueurST>32000) problem=true;		if (longueurST>32000) longueurST=32000;				// Il y a un problème		if (problem && (!okpourtous) ){						C_ConvertiNumST_String(FileST_Ptr->file_NumeroST,&st0);				ParamText(&st0,nil,nil,nil);				result=StopAlert(279,(ModalFilterProcPtr)myStandartfilterproc);				if (result==2){ // on a choisi de s'arrêter					SetCursor(&QD.arrow);					if (Entete) DisposeHandle((Handle)Entete);					if (progression) RPDispose(progression);					SetPort(oldport);					return;				}								if (result==3) okpourtous=1; // ok pour tout		} 				if (problem)  pbcount++;	/* on verifie que le sous-titre		est en entier dans le buffer de la mémoire		Note si errLecture==-36 le fichier est lu en entier		*/				if (errLecture==noErr){			if ((P+longueurST)>MaxBuffer) {				// le sous-titre n'est pas lu en entier				// on relie sous-titre que nous étions en train de traiter								pb.ioParam.ioCompletion=(IOCompletionUPP)nil;				pb.ioParam.ioResult=0;				pb.ioParam.ioBuffer=G.BufferTransfert;				pb.ioParam.ioReqCount=G.SIZEBufferTransfert;				pb.ioParam.ioActCount=0;				pb.ioParam.ioPosMode=fsFromStart;				pb.ioParam.ioPosOffset=OffsetDepuisLedebut;				errLecture=PBRead(&pb,false);				if (errLecture && (errLecture!=-39)) {					AlertUser(26);					return;					}									P=G.BufferTransfert;				FileST_Ptr=(FileSTRecordPtr) P;			}		}			/* on insert un nouveau sous-titre*/	/* sauf dans le cas où c'est le premier sous-titre */	ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_NombreST);	if (!PasInsertLePremierSt){		C_InsertSt(ST_Ptr,longueurST);	} else {		PasInsertLePremierSt=false;		ST_Ptr->st_LenthST=longueurST; // on place la longueur du sous-titre	}			/* on récupère les coordonées de ce nouveau sous-titre*/		ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_NombreST);				// on transfert le header dans la mémoire				ST_Ptr->st_TimeCodeIn=FileST_Ptr->file_TimeCodeIn;		ST_Ptr->st_TimeCodeOut=FileST_Ptr->file_TimeCodeOut;		ST_Ptr->st_NumeroST=FileST_Ptr->file_NumeroST;		ST_Ptr->st_XOffset=FileST_Ptr->file_XOffset;		ST_Ptr->st_YOffset=FileST_Ptr->file_YOffset;		ST_Ptr->st_Error=FileST_Ptr->file_Flags;		ST_Ptr->st_Nlines=FileST_Ptr->file_Nlines;		ST_Ptr->st_PosOffsetTable=nil;		/* ()FileST_Ptr->file_PosOffsetTable; */		ST_Ptr->st_Justification=FileST_Ptr->file_Justification;		ST_Ptr->st_MasKType=FileST_Ptr->file_MasKType;				ST_Ptr->st_spare[0]=FileST_Ptr->file_spare[0];		ST_Ptr->st_spare[1]=FileST_Ptr->file_spare[1];		ST_Ptr->st_spare[2]=FileST_Ptr->file_spare[2];		ST_Ptr->st_spare[3]=FileST_Ptr->file_spare[3];		ST_Ptr->st_spare[4]=FileST_Ptr->file_spare[4];		ST_Ptr->st_spare[5]=FileST_Ptr->file_spare[5];		if (ST_Ptr->st_Justification>3) ST_Ptr->st_Justification=0;		if (ST_Ptr->st_MasKType>3) ST_Ptr->st_MasKType=0; /* on raz les pointeurs divers */ 		ST_Ptr->st_StylePtr=nil;		ST_Ptr->st_StyleLenth=nil;		ST_Ptr->st_TexteLenth=nil;		ST_Ptr->st_CommentairePtr=nil;		ST_Ptr->st_CommentaireLenth=nil;/* on recopie le texte */			P2=(Ptr)ST_Ptr+sizeof(SousTitreRecord); 				if (FileST_Ptr->file_TexteLenth){			if (FileST_Ptr->file_TexteLenth>3200) // on limite le texte à 3200 caractères					FileST_Ptr->file_TexteLenth=3200;						ST_Ptr->st_TexteLenth=FileST_Ptr->file_TexteLenth;						P1=(Ptr)FileST_Ptr+sizeof(FileSTRecord); // adresse du texte dans le fichier			BlockMove(P1,P2,FileST_Ptr->file_TexteLenth);			ST_Ptr->st_TexteLenth=FileST_Ptr->file_TexteLenth;						L2=(unsigned long)P1;			L2+=ST_Ptr->st_TexteLenth;			L2=((L2+3)/4)*4; // adresse du style dans le fichier (du prochain éléments)												if (!problem) //s'il y a un problème on ne prend pas les styles (ls doivent ètre corompus)				if (FileST_Ptr->file_StyleLenth){								ST_Ptr->st_StyleLenth=FileST_Ptr->file_StyleLenth;								P1=(Ptr)L2;				// on calcule le pointeur du style				L3=(long)ST_Ptr+sizeof(SousTitreRecord);				L3+=ST_Ptr->st_TexteLenth;				L3=((L3+3)/4)*4;				ST_Ptr->st_StylePtr=(Ptr)L3;								BlockMove(P1,(Ptr)L3,ST_Ptr->st_StyleLenth);				L2=(unsigned long)P1;				L2+=ST_Ptr->st_StyleLenth;				L2=((L2+3)/4)*4;							} else {				//on à détecté un problème dans le fichier...				// donc on check la cohérence du style dans le fichier ...													P1=(Ptr)L2;				// on calcule le pointeur du style				L3=(long)ST_Ptr+sizeof(SousTitreRecord);				L3+=ST_Ptr->st_TexteLenth;				L3=((L3+3)/4)*4;				ST_Ptr->st_StylePtr=(Ptr)L3;								LL=*((short*)P1);				LL=LL*sizeof(ScrpSTElement)+2;				ST_Ptr->st_StyleLenth=LL;								// dernier test au cas ou ....				if (LL<= FileST_Ptr->file_StyleLenth)								BlockMove(P1,(Ptr)L3,ST_Ptr->st_StyleLenth);				else {					ST_Ptr->st_StylePtr=nil;					ST_Ptr->st_StyleLenth=nil;				}								L2=(unsigned long)P1;				L2+=ST_Ptr->st_StyleLenth;				L2=((L2+3)/4)*4;						}								// on check si les styles sont corrects			if (CheckStyle(ST_Ptr)){						//###########################								//###########################								MakeOneStyle(ST_Ptr);					ST_Ptr->st_StylePtr=0;					ST_Ptr->st_StyleLenth=0;					StyleAbime++;					}			// ###################		}// if texte length 				if (!problem) //s'il y a un problème on ne prend pas les commentaires (ils doivent ètre corompus)			if (FileST_Ptr->file_CommentaireLenth){							ST_Ptr->st_CommentaireLenth=FileST_Ptr->file_CommentaireLenth;			if (ST_Ptr->st_CommentaireLenth>255) ST_Ptr->st_CommentaireLenth=255;						// on calcule le pointeur dans le sous-titre dans le fichier			P1=(Ptr)FileST_Ptr+sizeof(FileSTRecord); // adresse du texte dans le fichier			L2=(unsigned long)P1;			L2+=ST_Ptr->st_TexteLenth;			L2=((L2+3)/4)*4; // adresse du style dans le fichier (du prochain éléments)			L2+=ST_Ptr->st_StyleLenth;			L2=((L2+3)/4)*4;			P1=(char*)L2;						// on calcule le pointeur dans le sous-titre en mémoire			L3=(long)ST_Ptr+sizeof(SousTitreRecord);			L3+=ST_Ptr->st_TexteLenth;			L3=((L3+3)/4)*4;			L3+=ST_Ptr->st_StyleLenth;			L3=((L3+3)/4)*4;			ST_Ptr->st_CommentairePtr=(Ptr)L3;			BlockMove(P1,(Ptr)L3,ST_Ptr->st_CommentaireLenth);			L2=(unsigned long)P1;			L2=((L2+3)/4)*4;		}//••••••••••••••••••••			// on recalcule la longueur du soustitre			L3=ST_Ptr->st_TexteLenth;			L3=((L3+3)/4)*4;			L3+=ST_Ptr->st_StyleLenth;			L3=((L3+3)/4)*4;			L3+=ST_Ptr->st_CommentaireLenth;			L3=((L3+3)/4)*4;			ST_Ptr->st_LenthST=L3;/*on vérifie s'il y a des différence entre les 2 pointeurs		L3+=sizeof(FileSTRecord);		if (L3 != longueurST){ 			short a; 			a=L3; 			a=a*a; 			longueurST=L3;		}*/							// on actualise les pointeurs sur le fichier					OffsetDepuisLedebut+=longueurST;	// le prochain sous-tire dans le fichier		P+=longueurST;		num++;				done=done|RPIdle(progression,num,nil/*&DoUpdate*/,Concatene);	} while ( (!done) && (num<=NombreSTALire) );			if (Entete) DisposeHandle((Handle)Entete);		SetCursor(&QD.arrow);	if (progression) RPDispose(progression);	if (StyleAbime) {		NumToString(StyleAbime,&str);		ParamText(&str,nil,nil,nil);		NoteAlert(292,nil);		}		SetPort(oldport);		}pascal void C_WriteBonBougreFormat(short refNum,Str31 Filename,Boolean saveauto){GrafPtr	oldport;Ptr		Buffer,MaxBuffer,P,P1,P2;Handle	h,versH,progression;long	L,L1,NombreSTAecrire,num,OffsetDepuisLedebut,longueurST,pbcount=0,okpourtous=0;OSErr	err,errLecture;short	version,result,vRefNum;SousTitreRecordPtr	ST_Ptr;ParamBlockRec		pb;Boolean				done=false,problem,PasInsertLePremierSt=false;Str255				st0,str;FileSTRecordPtr		FileST_Ptr;unsigned long		LL,L2,L3;long				StyleAbime=0;/* on recherche une zone de travail*/		MaxBuffer=G.BufferTransfert+G.SIZEBufferTransfert;		Buffer=G.BufferTransfert;		FileST_Ptr=(FileSTRecordPtr)Buffer;		/* ok on peut bosser on ouvre un dialog */		GetPort(&oldport);	/* on on récupère le n° de version */		versH=Get1Resource('vers',1);		if (versH){			version=*((SPtr)*versH);			ReleaseResource((Handle)versH);			}					err = GetVRefNum(refNum,&vRefNum);		if (err) {			AlertUser(26);			return;		}							pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioResult=0;		pb.ioParam.ioRefNum=refNum;		pb.ioParam.ioVRefNum=vRefNum;		pb.ioParam.ioBuffer=(Ptr)&G.versionLogiciel;		pb.ioParam.ioReqCount=sizeof(EnteteBonBougreFormat);;		pb.ioParam.ioActCount=0;		pb.ioParam.ioPosMode=fsFromStart;		pb.ioParam.ioPosOffset=0;		err=PBWrite(&pb,false);				if (err) {			AlertUser(26);			return;			}		/* on calcule la taille de la zone de preférence */		if (saveauto)	GetIndString(&st0,129,60);			else 		GetIndString(&st0,129,61);				NombreSTAecrire=G.General_NombreST;		progression=RPInitReglette(&st0,Filename,1,NombreSTAecrire,saveauto);		/* Boucle d'écriture des sous-titres */				num=1;	do {		problem=false;		// on recupere le sous titre		ST_Ptr=C_ConversionNumeroSTPointeur((long)num);		//on converti l'en-tête				FileST_Ptr->file_TimeCodeIn=ST_Ptr->st_TimeCodeIn;		FileST_Ptr->file_TimeCodeOut=ST_Ptr->st_TimeCodeOut;		FileST_Ptr->file_NumeroST=ST_Ptr->st_NumeroST;		FileST_Ptr->file_XOffset=ST_Ptr->st_XOffset;		FileST_Ptr->file_YOffset-ST_Ptr->st_YOffset;		FileST_Ptr->file_Flags=ST_Ptr->st_Error;		FileST_Ptr->file_Nlines=ST_Ptr->st_Nlines;		FileST_Ptr->file_PosOffsetTable=0; //ST_Ptr->st_PosOffsetTable;		FileST_Ptr->file_Justification=ST_Ptr->st_Justification;		FileST_Ptr->file_MasKType=ST_Ptr->st_MasKType;				FileST_Ptr->file_StyleLenth=ST_Ptr->st_StyleLenth;		FileST_Ptr->file_TexteLenth=ST_Ptr->st_TexteLenth;		FileST_Ptr->file_CommentaireLenth=ST_Ptr->st_CommentaireLenth;				FileST_Ptr->file_spare[0]=ST_Ptr->st_spare[0];		FileST_Ptr->file_spare[1]=ST_Ptr->st_spare[1];		FileST_Ptr->file_spare[2]=ST_Ptr->st_spare[2];		FileST_Ptr->file_spare[3]=ST_Ptr->st_spare[3];		FileST_Ptr->file_spare[4]=ST_Ptr->st_spare[4];		FileST_Ptr->file_spare[5]=ST_Ptr->st_spare[5];				// on place le contenu du sous-titre		LL=(long)ST_Ptr+sizeof(SousTitreRecord); // la source		P1=(Ptr)LL;		LL=(long)FileST_Ptr+sizeof(FileSTRecord); // destination		P2=(Ptr)LL;						if (ST_Ptr->st_TexteLenth)			BlockMove((Ptr)P1,(Ptr)P2,ST_Ptr->st_TexteLenth);				L2=ST_Ptr->st_TexteLenth;		L2=((L2+3)/4)*4; // place suivante				LL=(long)P1;		LL+=L2;		P1=(Ptr)LL; //source				LL=(long)P2;		LL+=L2;		P2=(Ptr)LL; //destination				if (ST_Ptr->st_StyleLenth){							BlockMove(P1,P2,ST_Ptr->st_StyleLenth);			L2=ST_Ptr->st_StyleLenth;			L2=((L2+3)/4)*4; // place suivante						LL=(long)P1;			LL+=L2;			P1=(Ptr)LL; //source					LL=(long)P2;			LL+=L2;			P2=(Ptr)LL; //destination					}				if (ST_Ptr->st_CommentaireLenth){			if (FileST_Ptr->file_CommentaireLenth >255) 				FileST_Ptr->file_CommentaireLenth-255; // on limite à 255					BlockMove(P1,P2,ST_Ptr->st_CommentaireLenth);			L2=ST_Ptr->st_CommentaireLenth;			L2=((L2+3)/4)*4; // place suivante					LL=(long)P2;			LL+=L2;			P2=(Ptr)LL; ////destination					}				/* pour pouvoir recuperer le fichier au cas où on place des oxffffffff		 à la fin de chaque sous-titre sous-titre */									*((long*)P2)=0xFFFFFFFF;		P2+=4;		*((long*)P2)=0xFFFFFFFF;			P2+=4;				// on calcule la longueur du sous-titre en cours		LL=(long)P2;		L2=(long)FileST_Ptr;		LL-=L2;				FileST_Ptr->file_LenthST=LL; //-sizeof(FileSTRecord); // taille interieur du st				// on ecrit le sous-titre		pb.ioParam.ioBuffer=(Ptr)FileST_Ptr;		pb.ioParam.ioReqCount=LL; // taille à écrire		pb.ioParam.ioActCount=0;		pb.ioParam.ioPosMode=fsAtMark;		pb.ioParam.ioPosOffset=0;		err=PBWrite(&pb,false);				// au suivant		num++;				done=done|RPIdle(progression,num,nil/*&DoUpdate*/,saveauto);	} while ( (!done) && (num<=NombreSTAecrire) );		SetCursor(&QD.arrow);	if (progression) RPDispose(progression);	SetPort(oldport);		}/* Cette procédure transfert un fichier de norme N19  en mémoire */pascal void	C_ConversionN19_BonBougre(HParmBlkPtr pb,char* name){DialogPtr	dialog;GrafPtr		oldport;short		type,NombreTotalTTI,NombreTotalST,NombreTotalGroupeST,j;Handle		hndl;Rect		rect,regletteRct;Str255		st0;N19_GSIPtr	BlockGSI;DateTimeRec	Date;short		totaldisquette,courantedisquette;Byte		b;OSErr		err;/* on ouvre un dialogue pour indiquer à l'utilisateur,	que nous sommes en train de lire un fichier au norme N19 */						GetPort(&oldport);			dialog=GetNewDialog(138,nil,(WindowPtr)-1);			SetPort(dialog);						DrawDialog(dialog);	/* on dit que c'est pour convertir un fichier N19	*/			GetDItem(dialog,5,&type,&hndl,&rect); // nb de caractère sur la ligne			GetIndString(&st0,129,12);			SetIText(hndl,&st0);					GetDItem(dialog,9,&type,&hndl,&rect); // nb de caractère sur la ligne			SetIText(hndl,"\p        ");							/* on affiche le nom du fichier */				GetDItem(dialog,1,&type,&hndl,&rect); // nb de caractère sur la ligne			SetIText(hndl,name);			GetDItem(dialog,1,&type,&hndl,&rect); // nb de caractère sur la ligne			SetIText(hndl,"\p          ");			/* on trace la ligne sous le titre */			GetDItem(dialog,4,&type,&hndl,&rect); // nb de caractère sur la ligne					FrameRect(&rect);				/* on entoure la reglette */				GetDItem(dialog,3,&type,&hndl,&regletteRct); // nb de caractère sur la ligne					InsetRect(&regletteRct,-1,-1);			FrameRectOneLine(&regletteRct,true);			InsetRect(&regletteRct,1,1);// lecture du block gsi update des attributs généraux			BlockGSI=(N19_GSIPtr)NewPtrClear(sizeof(N19_GSI));						pb->ioParam.ioCompletion=nil;			pb->ioParam.ioBuffer=(Ptr)BlockGSI;			pb->ioParam.ioReqCount=sizeof(N19_GSI);			pb->ioParam.ioPosMode=fsFromStart;			pb->ioParam.ioPosOffset=0;						err=PBRead((ParmBlkPtr)pb,false); 						if (err && err!=eofErr) {				//ShowFileError(err);								goto fin;			}					// on commence par initialiser la liste de sous-titre			C_RecopieStringPC_MAC(&BlockGSI->OPT,&st0,32);			EffaceTouslesSousTitres(&st0);	/*	 on transfère les attributs généraux */		// transfert des nom de film etc...		// --- lecture code caractère			G.CodeCaractere=(short)(BlockGSI->CCT[1]&0x9)+1;								// Recherche dans la table du code de langue			G.CodeLangue=GiveCodeLangue(&BlockGSI->LC);				// lecture du pays d'origine						G.PaysOrigine=ConversionPaysOrigine(&BlockGSI->CO);				//	on recopie le titre original du programme			C_RecopieStringPC_MAC(&BlockGSI->OPT,&G.Preference_TitreOriginal,32);					//	on recopie le titre original de l'épisode			C_RecopieStringPC_MAC(&BlockGSI->OET,&G.Preference_TitreEpisodeOriginal,32);		//	on recopie la traduction titre original du programme			C_RecopieStringPC_MAC(&BlockGSI->TPT,&G.Preference_TitreFrancais,32);					//	on recopie la traduction titre original de l'épisode			C_RecopieStringPC_MAC(&BlockGSI->TET,&G.Preference_TitreEpisodeTraduit,32);		//	on recopie Le nom du traducteur			C_RecopieStringPC_MAC(&BlockGSI->TN,&G.Preference_NomAdaptateur,32);					//	on recopie Les coordonnées du traducteur			C_RecopieStringPC_MAC(&BlockGSI->TCD,&G.Preference_CoordonneesAdaptateur,32);		// on recopie le code de référence de la liste des sous-titres			C_RecopieStringPC_MAC(&BlockGSI->SLR,&G.CodeDeReference,16);			// ------- Date de création		Date.year=(BlockGSI->CD[0]&0xF)*10+(BlockGSI->CD[1]&0xF)+(short)1900;		Date.month=(BlockGSI->CD[2]&0xF)*10+(BlockGSI->CD[3]&0xF);		Date.day=(BlockGSI->CD[4]&0xF)*10+(BlockGSI->CD[5]&0xF);		Date.hour=0;		Date.minute=0;		Date.second=0;		Date.dayOfWeek=0;			Date2Secs(&Date,(unsigned long*)&G.DateDeCreation); 		// ------- Date de révision		Date.year=(BlockGSI->RD[0]&0xF)*10+(BlockGSI->RD[1]&0xF)+(short)1900;		Date.month=(BlockGSI->RD[2]&0xF)*10+(BlockGSI->RD[3]&0xF);		Date.day=(BlockGSI->RD[4]&0xF)*10+(BlockGSI->RD[5]&0xF);		Date.hour=0;		Date.minute=0;		Date.second=0;		Date.dayOfWeek=0;			Date2Secs(&Date,(unsigned long*)&G.ModifieLe);					// ------- Numéro de la révision		G.Revision=(BlockGSI->RN[1]&0xF)*10+(BlockGSI->RN[2]&0xF);					// -------- on recopie l'éditeur de la liste des sous-titre			C_RecopieStringPC_MAC(&BlockGSI->PUB,&G.EditeurListe,32);				// -------- on recopie le nom du monteur de la liste des sous-titre			C_RecopieStringPC_MAC(&BlockGSI->EN,&G.NomDuMonteur,32);		// -------- on recopie les coordonnées du monteur de la liste des sous-titre			C_RecopieStringPC_MAC(&BlockGSI->ECD,&G.CoordonneeMonteur,32);							// --------- on affecte le titre original aux fenètres			C_RecopieStringPC_MAC(&BlockGSI->ECD,&G.CoordonneeMonteur,32);		// on regarde combien de disquettes doivent ètre lus		totaldisquette=BlockGSI->TND&0xF;		// le numéro d'ordre de la disquette		courantedisquette=BlockGSI->DSN&0xF;		// Le nombre de block TTI pour cette disquette		NombreTotalTTI= (BlockGSI->TNB[0]&0xF)*10000+(BlockGSI->TNB[1]&0xF)*1000+						(BlockGSI->TNB[2]&0xF)*100+(BlockGSI->TNB[3]&0xF)*10+						(BlockGSI->TNB[4]&0xF);		// Le nombre de sous-titre pour cette disquette		NombreTotalST= (BlockGSI->TNS[0]&0xF)*10000+(BlockGSI->TNS[1]&0xF)*1000+						(BlockGSI->TNS[2]&0xF)*100+(BlockGSI->TNS[3]&0xF)*10+						(BlockGSI->TNS[4]&0xF);		//	Le nombre de Groupe de sous-titre pour cette disquette		NombreTotalGroupeST=(BlockGSI->TNG[0]&0xF)*100+(BlockGSI->TNG[1]&0xF)*10+						(BlockGSI->TNG[2]&0xF);		//  Le time code début du programme			b=BlockGSI->TCS;			BlockGSI->TCS=8;			G.TcDebutFilm=C_ConversionChaineASCIITc(&BlockGSI->TCS);			BlockGSI->TCS=b;		// ----   Le premier st du programme		/*	On ne récupère pas cette valeur car elle est automatiquement activée			 par la vérification de la liste des sous-titres */											/*		Boucle nombre de disquette, (à faire)		nombre de tti par disquette	*/				/* on vérifie que la disquette introduite est bien la disquette n°1 			car pour l'instant on ne gère pas plus d'une disquette.		*/						if (courantedisquette !=1 ) AlertUser(12);			TextMode(srcCopy);			DernierSN=-1;			for (j=1;j<=NombreTotalTTI;j++){				// lecture d'un block TTI 				pb->ioParam.ioCompletion=nil;				pb->ioParam.ioBuffer=(Ptr)BlockGSI;				pb->ioParam.ioReqCount=128;				pb->ioParam.ioPosMode=fsFromMark;				pb->ioParam.ioPosOffset=0;				err=PBRead((ParmBlkPtr)pb,false); 								if (err) {					//ShowFileError(err);					goto fin;					}								ConvertiTTISousTitre((N19_TTIPtr)BlockGSI,G.General_DernierSTPtr);												/* On s'occupe de la réglette de progression */				C_SpinCursor(16);							 	DessineProgression(&regletteRct,1,NombreTotalTTI,j);								GetDItem(dialog,2,&type,&hndl,&rect); // nb de caractère sur la ligne				NumToString((long)j,&st0);				PenNormal();				MoveTo(rect.left,rect.bottom);				DrawString(&st0);			}// boucle nombre de TTI	// on efface le dernier sous-titre			   C_DeleteST(G.General_DernierSTPtr);	/* fin de la routine */fin:						DisposePtr((Ptr) BlockGSI);			DisposDialog(dialog);			SetCursor(&QD.arrow);			SetPort(oldport);			} //C_ConversionN19_bonBougre	; this name will appear in the debugger// cette routine converti le code langue n19 en idx dans la table BB™		short GiveCodeLangue(Byte *input){short	i=0,val=0,s,v;			Str255	st0;Boolean	trouve=false;		v=(short)(input[0]<<8)+(short)input[1];		do{			i++;						GetIndString(&st0,130,i);			s=(short)(st0[1]<<8)+(short)st0[2];			if (s==v) {val=i; trouve=true;}		} while (!trouve && i<90);					return val;}short ConversionPaysOrigine(char *po){MenuHandle	PopUp_PaysOrigine;short	i=0,result=0,count,maxitem;Str255	st1;Boolean	trouve,trouve1;	/* Recherche dans la table du pays d'origine	; recherche dans le menu  entre (); il faut rechercher dans chaque menu la parenthèse puis comparer les 3 caractères suivants*/	PopUp_PaysOrigine=GetMenu(2007);	if (PopUp_PaysOrigine) {			maxitem=CountMItems(PopUp_PaysOrigine);		do{			i++;			GetItem(PopUp_PaysOrigine,i,&st1);				trouve1=false;			count=1;			//on recherche la parenthèse			do {				if (st1[count]=='(') trouve1=true;				count++;			}while( count<=(short) st1[0] && !trouve1);    			if (trouve1)			   if (st1[count]==po[0] &&				   st1[count+1]==po[1] &&				   st1[count+2]==po[2] ) {trouve=true; result=i;}							} while(i<maxitem && !trouve);				ReleaseResource( (Handle) PopUp_PaysOrigine);				} //if (Menu_paysorigine)	return	result;}		pascal void DessineProgression(Rect *rect,short min, short max,short value ){Rect	rect1;short	a;long	l,m,n;RGBColor	old,color;				GetForeColor(&old);			color.red=24000;		color.green=24000;		color.blue=48000;		RGBForeColor(&color);		rect1=*rect;		l=(long)(*rect).right-(long)(*rect).left-1;		m=(long)value-(long)min;		n=(long)max-(long)min ;		if (n) {			a=(short)((m*l)/n)+(*rect).left;			if (a>(*rect).right) 	a=(*rect).right;			if (a<(*rect).left) 	a=(*rect).left;			rect1.right=a;			PaintRect(&rect1);						a=rect1.right+1;			if (a>(*rect).right) 	a=(*rect).right;			if (a<(*rect).left) 	a=(*rect).left;			rect1.left=a;			rect1.right=(*rect).right;			EraseRect(&rect1);		}		else 	PaintRect(&rect1);		RGBForeColor(&old);}		/* Cette routine converti un block tti en 1 sous-titre*/pascal void ConvertiTTISousTitre(N19_TTIPtr TTI,SousTitreRecordPtr ST_Ptr){  	ST_Ptr->st_NumeroST=TTI->SN[0]+(TTI->SN[1]<<8);	ST_Ptr->st_TimeCodeIn=((TTI->TCI[0]/10)<<28)+						  ( (TTI->TCI[0]-(TTI->TCI[0]/10)*10  ) <<24 )+						  ((TTI->TCI[1]/10)<<20)+						  ( (TTI->TCI[1]-(TTI->TCI[1]/10)*10 )<<16)+						  ((TTI->TCI[2]/10)<<12)+						  ( (TTI->TCI[2]-(TTI->TCI[2]/10)*10  )<<8)+						  ((TTI->TCI[3]/10)<<4)+						  ( (TTI->TCI[3]-(TTI->TCI[3]/10)*10  )); 	ST_Ptr->st_TimeCodeOut=((TTI->TCO[0]/10)<<28)+						  ( (TTI->TCO[0]-(TTI->TCO[0]/10)*10  ) <<24 )+						  ((TTI->TCO[1]/10)<<20)+						  ( (TTI->TCO[1]-(TTI->TCO[1]/10)*10 )<<16)+						  ((TTI->TCO[2]/10)<<12)+						  ( (TTI->TCO[2]-(TTI->TCO[2]/10)*10  )<<8)+						  ((TTI->TCO[3]/10)<<4)+						  ( (TTI->TCO[3]-(TTI->TCO[3]/10)*10  )); 	switch(TTI->JC) {			case 1: // gauche			ST_Ptr->st_Justification=1; 				break;			case 3: // droite			ST_Ptr->st_Justification=2;		break;			   default:			ST_Ptr->st_Justification=0;		break;	}// on recopie le texte.//TTI->TF/*	Byte				VP;			//Emplacement vertical	Byte				CF;			//Drapeau de remarque	Byte				TF[112];	//Champ de textePtr							st_StylePtr;Ptr							st_CommentairePtr;unsigned long			st_TexteLenth;unsigned long			st_StyleLenth;unsigned long			st_LenthST;unsigned long			st_CommentaireLenth;*//*normalement st_LenthST = texte+style lenth; mais il sert à donner la longueur data du ST; entre autre si texte et style = 0; quand on vient de créer un nouveau st */ST_Ptr->st_XOffset=0; ST_Ptr->st_YOffset=0;  ST_Ptr->st_MasKType=0; 			//type de mask box, line, rectangle; = rienST_Ptr->st_PosOffsetTable=nil;	// nu pour l'instantST_Ptr->st_Error=0; 			//16 possibilitées (suffisants je l'espère)/* --------------------- signification des bits ----------------------;Decale_bit 						equ		14	; sous-titre ayant été décalé	|	;outline box_bit 				equ		13	; 1 si outline box				|;XOffsetModel_bit 			equ 	12	; 0 si unité en pixel			|									; 1 mode téletexte (1 à 23)		|;doubleHauteur_bit	 		equ		11	; 1 si double hauteur			|;doubleLargeur_bit 			equ		10	; 1 si double hauteur			|;TeletextColor_bit			equ		9	; 1 siteletext, 0 si RGBColor	|;Suprimme_bit					equ		4	;?								|;TC_error_bit  				equ		3									|;Lisibilite_error_bit			equ		2									|;Interval_error_bit			equ		1									|; ------------------------------------------------------------------- *//*	st_Nlines;			// nombres de lignes dans le sous-titre	*/	   /* On insert un nouveau sous-titre 		   sauf si extension sous-titre 	   */	   	   if ( TTI->EBN==0xff)  C_InsertSt(G.General_DernierSTPtr,112);}/*Cette routine exporte le fichier,du type:	1 ASCII	2 STL	3 CMC	*/ pascal Boolean DoExport_Fichier(ConstStr255Param name,short type){				HParamBlockRec		pb1;		StandardFileReply	TheReply;		OSErr				err;		short				The_Volume;		DialogPtr			TheDialogPtr;		Str255				st0;		Str255*				P;		long				lenth,ptr;		unsigned long		time,oldtotal;				SousTitreRecordPtr	ST_Ptr,oldnext;					 	GetDateTime(&time);         askname:		GetIndString(&st0,129,8); // l'extension de fichier				StandardPutFile(&st0,name,&TheReply);						if	(TheReply.sfGood==true){		// on vérifie que le nom ne commence pas par un point ...			if (TheReply.sfFile.name[1]=='.') {				AlertUser(32);				goto	askname;				}		/* 	si version de demo on regarde si l'on a dépassé la date limite 			si oui on limite le n° de sous-titre à 5 */			#ifdef __Demo__		if(G.FindFirstKey_error){			if (G.General_NombreST>10) {				ST_Ptr=C_ConversionNumeroSTPointeur((long)10);				oldnext=(SousTitreRecordPtr)ST_Ptr->st_NextST;				ST_Ptr->st_NextST=nil;				oldtotal=G.General_NombreST;				G.General_NombreST=10;			}		}#endif												// on génère le param block		pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb1.ioParam.ioNamePtr=(Ptr) &(TheReply.sfFile.name);		pb1.ioParam.ioVRefNum=(short)TheReply.sfFile.vRefNum;		pb1.ioParam.ioPermssn=fsRdWrShPerm;			pb1.ioParam.ioBuffer=(Ptr) nil;		pb1.fileParam.ioDirID=TheReply.sfFile.parID;				if	(TheReply.sfReplacing==false){			err=PBHCreate((HParmBlkPtr)&pb1,false);			//DebugStr("\p");			//TraitementErreurFichier(err);			pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;			pb1.ioParam.ioNamePtr=(Ptr) &(TheReply.sfFile.name);			pb1.ioParam.ioVRefNum=(short)TheReply.sfFile.vRefNum;			pb1.ioParam.ioPermssn=fsRdWrShPerm;				pb1.ioParam.ioBuffer=(Ptr) nil;			pb1.fileParam.ioDirID=TheReply.sfFile.parID;			pb1.fileParam.ioFlCrDat=(unsigned long) time;			pb1.fileParam.ioFlMdDat=(unsigned long) time;						pb1.fileParam.ioFlFndrInfo.fdType='TEXT';			pb1.fileParam.ioFlFndrInfo.fdCreator='Bbou';						err=PBHSetFInfo((HParmBlkPtr)&pb1,false);			TraitementErreurFichier(err);			}					if	(TheReply.sfFile.name[0]>31) TheReply.sfFile.name[0]=31;		PBHOpen((HParmBlkPtr)&pb1,false);		ExportationDeFichierAscii(&pb1,&TheReply.sfFile.name);		// on place la date actuelle 		pb1.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb1.ioParam.ioNamePtr=(Ptr) &(TheReply.sfFile.name);		pb1.ioParam.ioVRefNum=(short)TheReply.sfFile.vRefNum;		pb1.ioParam.ioPermssn=fsRdWrShPerm;			pb1.ioParam.ioBuffer=(Ptr) nil;		pb1.fileParam.ioDirID=TheReply.sfFile.parID;				pb1.fileParam.ioFlMdDat=(unsigned long) time;		pb1.fileParam.ioFlFndrInfo.fdType='TEXT';		pb1.fileParam.ioFlFndrInfo.fdCreator='Bbou';				err=PBHSetFInfo((HParmBlkPtr)&pb1,false);				TraitementErreurFichier(err);		TheDialogPtr=GetNewDialog(140,nil,(WindowPtr)-1);		DrawDialog(TheDialogPtr);				PBFlushFile((ParmBlkPtr)&pb1,false);						err=GetVRefNum(pb1.ioParam.ioVRefNum,&The_Volume);		err=FlushVol(nil,The_Volume);				TraitementErreurFichier(err);		WaitTicks(60);		DisposDialog(TheDialogPtr);		PBClose((ParmBlkPtr)&pb1,false);				/* 	si version de demo on regarde si l'on a dépassé la date limite 			si oui on a limité le n° de sous-titre à 10 pour la sauvegarde,			on rend les dernière valeur, pour continuer à faire le travail */			#ifdef __Demo__		if(G.FindFirstKey_error){			if (oldtotal>10){				ST_Ptr=C_ConversionNumeroSTPointeur((long)10);				ST_Ptr->st_NextST=(Ptr)oldnext;				G.General_NombreST=oldtotal;			}		}#endif						} //reply=good	return  TheReply.sfGood;}