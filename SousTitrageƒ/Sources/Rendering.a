	PRINT	PUSH,OFF				INCLUDE	'NewVista.a'	; pour la nu vista+	INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'FSEqu.a'	INCLUDE	'PackMacs.a';	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.;	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'TimeEqu.a'		; pour utiliser le time manager	include	'PickerEqu.a'	INCLUDE	'Aliases.a'	INCLUDE	'VXEqu.a'	INCLUDE	'VXHWEqu.a'	INCLUDE	'SlotEqu.a'		; pour le slot manager	PRINT	POP		IMPORT	G:AppGlobals		IMPORT	QD:MyQDGlobals	machine	MC68030; cette routine permet de tester la validitée des import de reférence entre routine MPW_asm et Metrowerk_CTestAdresseGlobales_rend 	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointstructure		ds.l	1					; p2				ds.l	1					; ParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkLocalSize		EQU 	*					; size of all the local variables				ENDR								WITH	StackFrame,Rect		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				move.l	structure(a6),a0				lea		QD.dkGray,a1				move.l	a1,(a0)				lea		G.spareForFutur,a1				move.l	a1,4(a0)				move.l	p2(A6),a2				lea		G.performanceTask,a1				move.l	A1,(a2)				lea		G.AskTcTask,a1				move.l	A1,4(a2)				lea		G.Rechercher_STR,a1				move.l	A1,8(a2)				lea		G.EveHandle,a1				move.l	A1,12(a2)				lea		G.versionLogiciel,a1				move.l	A1,16(a2)				lea		G.Justification,a1				move.l	A1,20(a2)				lea		G.SoftProtect,a1				move.l	A1,24(a2)				lea		G.CurrentFileName,a1				move.l	A1,28(a2)							UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)				DbgInfo.new	TestAdresseGlobales_rend			; this name will appear in the debugger		align 4			ENDP			* ================================================* PROCEDURE  CLEARBUFFER(); * ================================================** Cette routine efface le rect dans le plan memoire * à l'aide des processeurs de la vidéo explorer*CLEAR_BUFFER		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkREctangle			ds.w	4spare				ds.l	1theChannel			ds.l	1theCaptureChannel	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor		;			LINK	A6,#LocalSize		machine	MC68020					movem.l d0-d7/a1-a2,-(sp)			move.l	G.CurseurClearBuffer,-(sp)			_SetCCursor			cmp.w	#$118,G.VE_BoardID		;  vista classic			beq.s	vista				cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq.s	vista			cmp.w	#$346,G.VE_BoardID		; nu vista+ ?			bne.s	VideoExplorer	vista				; Nu vista + ==> on effectue le raz à la main; on regarde s'il y a un rectangle cohérent pour le buffer d'affichage; si oui on n'efface que cette portion pour gagner du temps; note on utilise la fonction ecrite en C			import	C_ClrEcran			jsr		C_ClrEcran				bra		Exit					; -------------------------------------------						VideoExplorer									move.l		#0,rectangle(a6)			move.l  	#$04000400,4+rectangle(a6)		; taille maximum d'une VE                							MOVE.W    G.Ve_RefNum,D7                     							pea       theChannel(A6)                            			MOVEQ      #$00,D0         			MOVE.L     D0,-(A7)			EXT.L      D7                                      			MOVE.L     D7,-(A7)   			import 		VEGetChannel   			jsr     	VEGetChannel   			;short VEGetCaptureChannel(short theDriver, short theCaptureBox,short* theChannel);									MOVE.W     D0,D6      						PEA        theCaptureChannel(A6)                           			MOVEQ      #$00,D0 			MOVE.L     D0,-(A7)			EXT.L      D7        			MOVE.L     D7,-(A7) 			import      VEGetCaptureChannel  			JSR         VEGetCaptureChannel  									;short VEGetCaptureChannel(short theDriver, short theCaptureBox,short* theChannel);												MOVE.W     D0,D6                                   			lea			REctangle(A6),a0			MOVE.L     4+REctangle(A6),-(A7)                          			MOVE.L     REctangle(A6),-(A7)                            			MOVEQ      #$00,D0                                			MOVE.L     D0,-(A7)                               			EXT.L      D7                                     			MOVE.L     D7,-(A7)                               			import     VESetCaptureWindow    			JSR        VESetCaptureWindow    			; short VESetCaptureWindow(short theDriver, short theCaptureBox, Rect theRect);						MOVE.W     D0,D6                                  			MOVEQ      #$00,D0                                			MOVE.L     D0,-(A7)                               			MOVE.L     D0,-(A7)                              			EXT.L      D7                                      			MOVE.L     D7,-(A7)                              			import     VESetCaptureFormat    			JSR        VESetCaptureFormat    			;short VESetCaptureFormat(short theDriver, short theCaptureBox,short theCaptureFormat);								MOVE.W     D0,D6                                  			clr.L     -(A7)    				; the color			EXT.L      D7                              			MOVE.L     D7,-(A7)                               			import     VESetCaptureColor    			JSR        VESetCaptureColor 			;short VESetCaptureColor(short theDriver,unsigned long theColor)									MOVE.W     D0,D6                                			MOVEQ      #$10,D0                                			MOVE.L     D0,-(A7)       			MOVEQ      #$00,D1               			MOVE.L     D1,-(A7)			EXT.L      D7 			MOVE.L     D7,-(A7)  			import     VESetCaptureChannel			JSR        VESetCaptureChannel			;short VESetCaptureChannel(short theDriver, short theCaptureBox,short theChannel);									MOVE.W     D0,D6  									MOVEQ      #$01,D0 			MOVE.L     D0,-(A7) 			MOVEQ      #$02,D1 			MOVE.L     D1,-(A7)			MOVEQ      #$00,D0   			MOVE.L     D0,-(A7)  			MOVEQ      #$0F,D0 			MOVE.L     D0,-(A7)    			MOVEQ      #$00,D0                            			MOVE.L     D0,-(A7)  			EXT.L      D7                                 			MOVE.L     D7,-(A7)                       			import     VESetCaptureState      			JSR        VESetCaptureState      ; ------------------------------------------------------									MOVE.W  	D0,D6                     			MOVE.W    	theChannel(A6),D0           			EXT.L  		D0              			MOVE.L  	D0,-(A7) 			MOVEQ 		#$00,D0 			MOVE.L  	D0,-(A7) 			MOVE.W    G.Ve_RefNum,D7 			EXT.L    	D7                                  			MOVE.L   	D7,-(A7)                               			import    	VESetChannel			JSR     	VESetChannel			; short VESetChannel(short theDriver, short	thePriorityControl,short theChannel);								MOVE.W     D0,D6                                			MOVE.W     theCaptureChannel(A6),D0			EXT.L      D0    			MOVE.L     D0,-(A7) 			MOVEQ      #$00,D0 			 MOVE.L     D0,-(A7) 			EXT.L      D7 			MOVE.L     D7,-(A7) 			import     VESetCaptureChannel 			JSR        VESetCaptureChannel 				Exit	move.w	#$0505,-(sp)		import	Show_Cursor		jsr		Show_Cursor		movem.l	(sp)+,d0-d7/a1-a2		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		CLEAR_BUFFER			; this name will appear in the debugger		align 4			ENDP	             		* ================================================* PROCEDURE Not_Display_Buffer(); * ================================================** Cette routine efface le rect dans le plan memoire * Not_Display_Buffer	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkAreaBlock	ds.b	48DataArea	ds.b	48LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame			machine	MC68020							cmp.w	#$118,G.VE_BoardID			beq		Exit				; vista classic carte pas bonne pour nous			move.w	G.VE_BoardID,d0			cmp.w	#$346,d0		; nu vista ou vx			beq 	Nuvista			cmp.w	#$28C,d0		;vista+ ?			beq 	Nuvista; c'est une vidéo explorer	; on active les rectangle									move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a0			; base des registres de la Video Explorer						move.w		#$0,VX_Rectangle1YStart(a0)			move.w		#$0,VX_Rectangle1XStart(a0)			move.w		#0,VX_Rectangle1YEnd(a0)			move.w		#0,VX_Rectangle1XEnd(a0)			move.w		#$5,VX_Rectangle2YStart(a0)			move.w		#$0,VX_Rectangle2XStart(a0)			move.w		#1023,VX_Rectangle2YEnd(a0)			move.w		#1023,VX_Rectangle2XEnd(a0); on coupe le signal de key			move.l	G.Base_Adresse,d0			and.l	#$ff000000,d0			or.l	#$F00661,d0		; défault alpha channel			move.l	d0,a0			move.b	#$ff,(a0)			bra		Exit; --------------------------------------------------------------; code pour la nu vista+; --------------------------------------------------------------Nuvista					lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwWriteRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct			move.l    	a1,csParam(a0)       ; faut voir .....		; on ne modifie que le mixer			lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer						move.b		#0,(a2)			move.b		#0,1(a2)			move.b		#1,2(a2)			move.b		#1,3(a2)			move.b		#0,4(a2)			move.b		#1,5(a2)			move.b		#0,6(a2)			move.b		#0,7(a2)						move.b		#0,8(a2)			move.b		#0,9(a2)			move.b		#0,10(a2)			move.b		#0,11(a2)			move.b		#0,12(a2)			move.b		#0,13(a2)			move.b		#0,14(a2)			move.b		#0,15(a2)						move.b		#$0,16(a2)			move.b		#$0,17(a2)			move.b		#1,18(a2)			move.b		#1,19(a2)			; alpha key			move.b		#1,20(a2)			move.b		#0,21(a2)			move.b		#0,22(a2)			move.b		#0,23(a2)				; 0 pour pas incrust						move.b		#0,24(a2)			move.b		#0,25(a2)			move.b		#0,26(a2)			move.b		#0,27(a2)			move.b		#0,28(a2)			move.b		#0,29(a2)			move.b		#3,30(a2)			move.b		#0,31(a2)						clr.l		AnalogCtlPtr(a1)		; adresse de la structure analog			clr.l		VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec			clr.l		PhasePtr(a1)			; hphase = null			_Control				Exit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.new		Not_Display_Buffer			; this name will appear in the debugger				align 4			ENDP* ================================================* PROCEDURE Display_Buffer(); * ================================================** Cette routine efface le rect dans le plan memoire *  Display_Buffer	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkAreaBlock	ds.b	48DataArea	ds.b	48LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame		machine	MC68020			cmp.w	#$118,G.VE_BoardID			beq		Exit				; vista classic carte pas bonne pour nous			cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq 	Nuvista			cmp.w	#$346,G.VE_BoardID		; nu vista+ ou vx			beq 	Nuvista; c'est une vidéo explorer			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a0			; base des registres de la Video Explorer						move.w		#$0,VX_Rectangle1YStart(a0)			move.w		#$0,VX_Rectangle1XStart(a0)			move.w		#1023,VX_Rectangle1YEnd(a0)			move.w		#1023,VX_Rectangle1XEnd(a0)			move.w		#$0,VX_Rectangle2YStart(a0)			move.w		#$0,VX_Rectangle2XStart(a0)			move.w		#0,VX_Rectangle2YEnd(a0)			move.w		#0,VX_Rectangle2XEnd(a0)			; on active le signal de key			move.l	G.Base_Adresse,d0			and.l	#$ff000000,d0			or.l	#$F00661,d0		; défault alpha channel			move.l	d0,a0			move.b	#$0,(a0)	; same channel			bra		Exit; ----------------------------------------------------------------; code pour la nu vista+; ----------------------------------------------------------------Nuvista				lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwWriteRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct			move.l    	a1,csParam(a0)       ; faut voir .....		; on ne modifie que le mixer			lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer						move.b		#0,(a2)			move.b		#0,1(a2)			move.b		#1,2(a2)			move.b		#1,3(a2)			move.b		#0,4(a2)			move.b		#1,5(a2)			move.b		#0,6(a2)			move.b		#0,7(a2)						move.b		#0,8(a2)			move.b		#0,9(a2)			move.b		#0,10(a2)			move.b		#0,11(a2)			move.b		#0,12(a2)			move.b		#0,13(a2)			move.b		#0,14(a2)			move.b		#0,15(a2)						move.b		#$0,16(a2)			move.b		#$0,17(a2)			move.b		#1,18(a2)			move.b		#1,19(a2)			; alpha key			move.b		#1,20(a2)			move.b		#0,21(a2)			move.b		#0,22(a2)			move.b		#1,23(a2)				; 1 pour incrust						move.b		#0,24(a2)			move.b		#0,25(a2)			move.b		#0,26(a2)			move.b		#0,27(a2)			move.b		#0,28(a2)			move.b		#0,29(a2)			move.b		#3,30(a2)			move.b		#0,31(a2)						clr.l		AnalogCtlPtr(a1)		; adresse de la structure analog			clr.l		VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec			clr.l		PhasePtr(a1)			; hphase = null			_Control			Exit	UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.new		Display_Buffer			; this name will appear in the debugger		align 4			ENDP	* ================================================* PROCEDURE VBLMainTask(); * ================================================** Routine VBL sous intérruption*VBLMainTask	PROC	EXPORT			WITH	SOUSTITRERECORD,FontRenderRecord,HSLColor,\					VDChannelColorState,VDControlState,\					VDLineControl,VDRectangleState,VDAlphaDisplaySource,\					MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec;			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame,\					Display_Buffer,Not_Display_Buffer		machine	MC68020				cmp.w	#$118,G.VE_BoardID		beq		Exit				; vista classic carte pas bonne pour nous		cmp.w	#$346,G.VE_BoardID		beq		CutEffect			; seulement cut pour nuvista+		cmp.w	#$28C,G.VE_BoardID		beq		CutEffect			; seulement cut pour nuvista+   		move.w	G.EffectMode,d0 		cmp.w	#1,d0 		beq		FonduEffect; c'est un cutCutEffect		move.w	G.DrawState,d1		and.w	#$8000,d1		beq 	exit				; si bit 15=0 on ne fait rien		move.w	G.DrawState,d1		tst.b	d1					; que faire ?		beq  	effacecarteCut			; on efface après le fondu			; on affiche la ram				move.l	G.Base_Adresse,d0		beq		Exit		cmp.w	#$346,G.VE_BoardID		;vista+ ?		beq.s	touchapasAmonIcf		cmp.w	#$118,G.VE_BoardID		;vista ?		beq.s	touchapasAmonIcf		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq.s	touchapasAmonIcf		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		move.w	#$40,VX_ICFScaleFactor(a0)		; on reset le icf de la valeur d'incrémentationtouchapasAmonIcf		bsr		Display_Buffer					; on active l'affichage		bra 	exiteffacecarteCut; on affiche la ram				move.l	G.Base_Adresse,d0		beq		Exit		cmp.w	#$346,G.VE_BoardID		;nuvista+ ?		beq.s	touchapasAmonIcf1		cmp.w	#$118,G.VE_BoardID		;nuvista ?		beq.s	touchapasAmonIcf1		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq.s	touchapasAmonIcf1		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		move.w	#$40,VX_ICFScaleFactor(a0)		; on reset le icf de la valeur d'incrémentationtouchapasAmonIcf1		bsr		NOt_Display_Buffer		bra 	exit; ------------------------------------------; c'est un fonduFonduEffect				tst.w	G.FadeTime		beq		CutEffect	; si durée=0 c'est un cut		move.w	G.DrawState,d1		and.w	#$4000,d1		bne		PourIncDEc			; faire incrémentation décrémentation icf factor ?;	non pas inc dec car premier appel ou rien à faire				move.w	G.DrawState,d1				and.w	#$8000,d1		bne		PremierPassageDanslaRoutine						bra		exit				; si bit 15=0 on ne fait rien; ---PourIncDEc; on regarde pour faire fondu ; est-ce une vidéo explorer ?		cmp.w	#$346,G.VE_BoardID		; nu vista+ ou vx 		beq 	Exit		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq 	Exit; on calcule l'adresse des registres		move.l	G.Base_Adresse,d0	; carte présente ?		beq		Exit		and.l	#$ff000000,d0				add.l	#registerSpaceStart,d0		move.l	d0,a0			; base des registres de la Video Explorer; Inc ou Dec		move.w	G.DrawState,d1		tst.b	d1		beq.s		doDisDown	; decdoDisUp ; inc		move.w	G.FadeFactor,d0		addq.w	#1,d0		cmp.w	G.FadeTime,d0		bls		doDisUp1		move.w	G.FadeTime,d0		move.w	d0,G.FadeFactor		bra 	ExitdoDisUp1		move.w	d0,G.FadeFactor		move.w	G.FadeFactor,d0		mulu	#$40,d0		divu	G.FadeTime,d0		move.w	d0,VX_ICFScaleFactor(a0)		bra 	exitpasFini; --------------doDisDown ; out		move.w	G.FadeFactor,d0		subq.w	#1,d0		cmp.w	#0,d0		bhi		doDisDown1		clr.w	G.FadeFactor		bsr		Not_Display_Buffer		;on désactive l'affichage du buffer		bra 	ExitdoDisDown1		move.w	d0,G.FadeFactor		move.w	G.FadeFactor,d0		mulu	#$40,d0		divu	G.FadeTime,d0		move.w	d0,VX_ICFScaleFactor(a0) 		bra		exitpasFini; ---------------------------PremierPassageDanslaRoutine		; on regarde si nu vista classic ?; si oui on ne fait rien		cmp.w	#$118,G.VE_BoardID		beq		Exit		cmp.w	#$346,G.VE_BoardID		beq		Exit		cmp.w	#$28C,G.VE_BoardID		;vista+ ?		beq 	Exit		move.w	G.DrawState,d1		tst.b	d1					; que faire ?		beq.s	DissolveOut			; on commence par le début		move.l	G.Base_Adresse,d0		beq		Exit		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		; on commence par la valeur 1		move.w	#1,G.FadeFactor		move.w	#64,d0		divu	G.FadeTime,d0		move.w	d0,VX_ICFScaleFactor(a0)		bsr		Display_Buffer					; on active l'affichage		bra		exitpasFini						; ; en fait on ne fait rien , mais on place le icf au maximumDissolveOut		move.w	G.FadeTime,d0		move.w	d0,G.FadeFactor		move.l	G.Base_Adresse,d0		beq		Exit		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0							; base des registres de la Video Explorer		move.w	#$40,VX_ICFScaleFactor(a0)		; on démarre de pleine ouverture		bra		exitpasFini; ----------------------------------------; on affiche la ram; au prochain appel de la VRAM on incrémente le icf factor; carte présente ?; on calcule l'adresse des registres		move.l	G.Base_Adresse,d0		beq		Exit		and.l	#$ff000000,d0		add.l	#registerSpaceStart,d0		move.l	d0,a0						; base des registres de la Video Explorer		clr.w	VX_ICFScaleFactor(a0)		; on démarre de zéro		bsr		Display_Buffer		bra.s	exitpasFini; ---------------------------------------Exit; on à fini le travail; on sort de la routine, on raz le bit 15			move.w	G.DrawState,d0		and.w	#$0f,d0		move.w	d0,G.DrawState		rts; on dit que l'on doit faire le fonduexitpasFini		move.w	G.DrawState,d1		or.w	#$C000,d1		move.w	d1,G.DrawState		rts						DbgInfo.new		VBLMainTask			; this name will appear in the debugger		align 4			ENDP			* ====================================* PROCEDURE 	ConfigurationCarteAffichage()* ====================================**   Cette procédure ouvre un dialog pour déterminer une zone d'action*  	dans laquelle on effectue un offset sur les times codes**ConfigurationCarteAffichage 		PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkWindowPtr	DS.L	1			; local Window pointer variableWichControl	DS.L	1			; control en cour de traitementTheDialogSel ds.l	1			; le dialog en questionTheItemHit	ds.w	1			; le item frappéTheItemHitalert	ds.w	1			; le item frappéTheDialogPtr	DS.l	1		; le pointeur local du dialogItemchoisi		DS.W	1		; Item choisi par l'utilisateuritemType		ds.w	1		; stockage du type de ItemitemHandle		ds.L	1		; stockage	du handle du itemitemRect		DS	RectPictHandle		ds.l	1		; picture du dessinsaveVE_Mode		ds.w	1		;sauvegarde du modeDialogStorage			ds	dWindLensaveResourceRef			ds.w	1PrefFileId				ds.w	1Buffer					ds.b	256saveeffectmode			ds.w		1savevalue				ds.w		1LocalSize	EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD,PREF_AFF_REC		; cover our local stack frame		link	a6,#LocalSize				movem.l	d1-d7/a1-a4,-(sp)		clr.l	-(sp)		move.w	#174,-(sp)	; id number		pea		DialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog  ;		; on trace le contour du bouton rechercher				pea		DialogStorage(a6)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		pea		DialogStorage(a6)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect					pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect			pea		DialogStorage(a6)		move.w	#6,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem					move.w	#1,-(sp)		move.w	#1,-(sp)		_PenSize				pea		itemRect(a6)		_FrameRect		move.w	G.VE_Mode,saveVE_Mode(a6)		bsr	ConfigRoutine		move.w	G.EffectMode,saveeffectmode(a6)		move.w	G.FadeTime,savevalue(a6)		bsr configuretransition		; on place le facteur de transition		moveq	#0,d0		move.w	G.FadeTime,d0		divu	#2,d0		clr.w	-(sp)		lea		buffer(a6),a0		_Pack7		pea		DialogStorage(a6)		move.w	#15,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			move.l		ItemHandle(a6),-(sp)		pea			buffer(a6)		_SetItext*******************Rechercher_Oncontinu:				clr.l	-(sp)		pea		Itemchoisi(a6)		_ModalDialog		move.w	Itemchoisi(A6),d0					case#.w	(d0,IF), \		(1,ok),\		(2,Annuler),\		(3,upstreamkeyer ),\			(4,downstreamkeyer),\		(8,cut),\		(9,dissolve),\		(16,TimeUp),\		(17,TimeDown)		bra		Rechercher_Oncontinudownstreamkeyer		move.w	#1,G.VE_Mode		bsr	ConfigRoutine		bra		Rechercher_Oncontinuupstreamkeyer		move.w	#0,	G.VE_Mode		bsr	ConfigRoutine		bra		Rechercher_Oncontinucut		move.w	#0,G.EffectMode		bsr configuretransition		bra		Rechercher_Oncontinudissolve		move.w	#1,G.EffectMode		bsr 	configuretransition		bra		Rechercher_OncontinuTimeUp		clr.l	-(sp)		pea		DialogStorage(a6)		move.w	#16,-(sp)		move.w	#15,-(sp)		move.l	#2,-(sp)		move.l	#37,-(sp)		move.l	#1,-(sp)		import	 C_IncDecValue		jsr		 C_IncDecValue		move.l	(sp)+,d0		bra		Rechercher_OncontinuTimeDown		pea		DialogStorage(a6)		move.w	#17,-(sp)		move.w	#15,-(sp)		move.l	#2,-(sp)		move.l	#37,-(sp)		move.l	#-1,-(sp)		import	 C_IncDecValue		jsr		 C_IncDecValue		move.l	(sp)+,d0		bra		Rechercher_Oncontinu; -------------------------------------ok		; on stocke le mode dans le fichier préférence		pea		DialogStorage(a6)		move.w	#15,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		buffer(a6)		_GetItext				lea		buffer(a6),a0		move.w	#1,-(sp)		_pack7		mulu	#2,d0		move.w	d0,G.FadeTime		import	PutPrefAffInGeneralPref		jsr		PutPrefAffInGeneralPref		bra.s	Exit		; ---------------		Annuler				move.w	saveVE_Mode(a6),G.VE_Mode		bsr	ConfigRoutine		move.w	saveeffectmode(a6),G.EffectMode		move.w	savevalue(a6),G.FadeTimeExit		pea		DialogStorage(a6)		_CloseDialog			movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	ConfigurationCarteAffichage		; this name will appear in the debugger		align 4ConfigRoutine				; on affecte l'etat en cour du mode d'affichage				tst.w	G.VE_Mode		beq 	Do_UpstreamKeyer		; mode downstream keyer				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				pea		DialogStorage(a6)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue		; on affiche le pict		pea		DialogStorage(a6)		move.w	#7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	#133,d7		clr.l	-(sp)		move.w	d7,-(sp)		_GetPicture		move.l	(sp)+,pictHandle(a6)		; picture handle; on affiche le "picture"		move.l	pictHandle(a6),-(sp)		pea		itemRect(a6)		_drawPicture				move.l	pictHandle(a6),-(sp)		_ReleaseResource						import		ConfigureVX_DownStreamKeyer		jsr			ConfigureVX_DownStreamKeyer						rts; ---------------------     mode upstream keyerDo_UpstreamKeyer			; mode downstream keyer				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue				pea		DialogStorage(a6)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue				; on affiche le pict		pea		DialogStorage(a6)		move.w	#7,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				move.w	#132,d7		clr.l	-(sp)		move.w	d7,-(sp)		_GetPicture		move.l	(sp)+,pictHandle(a6)		; picture handle; on affiche le "picture"		move.l	pictHandle(a6),-(sp)		pea		itemRect(a6)		_drawPicture				move.l	pictHandle(a6),-(sp)		_ReleaseResource						import		ConfigureVX_UpStreamKeyer		jsr			ConfigureVX_UpStreamKeyer		rts		; ---------------------------				configuretransition; on configure le transition mode		pea		DialogStorage(a6)		move.w	#8,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem					move.l	ItemHandle(a6),-(sp)		move.w	#false,-(sp)		_SetCtlValue		move.w	G.EffectMode,d0		bne	@azert		move.l	ItemHandle(a6),-(sp)		move.w	#true,-(sp)		_SetCtlValue@azert		pea		DialogStorage(a6)		move.w	#9,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			move.l	ItemHandle(a6),-(sp)		move.w	G.EffectMode,-(sp)		_SetCtlValue		rts		ENDP* ================================================* PROCEDURE ConfigureVX_UpStreamKeyer;* ================================================* configure la vidéo exploreur dans le mode Upstram keyerConfigureVX_UpStreamKeyer	PROC		EXPORT		StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAreaBlock			ds.l	80DataArea			ds.l	80LocalSize			EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,WaitTicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,C_DoFileOpen,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO,VtrTimedTask,\			AdjustMenus	; linked in with Interface.o		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,\				VDInterruptMode,MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec		WITH	HSLColor,VDChannelColorState,VDControlState,\				VDLineControl,VDRectangleState,VDAlphaDisplaySource																		LINK	A6,#LocalSize		; allocate our local stack frame					; on configure le mode des rectangles 1 et 2			cmp.w	#$118,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$346,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq 	Exit 			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a4			; base des registres de la Video Explorer						add.l	#$300,d0			move.l	d0,a0						move.l	#$80/4,d0	; on erase 128 octetsClearVXMemory_loop			clr.l	(a0,d0.W*4)			dbra 	d0,ClearVXMemory_loop; on position les valeurs de configuration								move.b	#$40,VX_PixelControlMode(a4)			; 			move.b	#2,VX_Pixel0MultiplierInputSource1(a4)			move.b	#2,VX_Pixel1MultiplierInputSource1(a4)			move.b	#2,VX_Pixel0MultiplierInputSource2(a4)			move.b	#2,VX_Pixel1MultiplierInputSource2(a4)			move.b	#2,VX_Pixel0MultiplierInputSource3(a4)			move.b	#2,VX_Pixel1MultiplierInputSource3(a4)			move.w	#$0040,VX_ICFScaleFactor(a4)						move.w	#$0204,VX_DefaultDisplaySource(A4)			move.l	#$00000000,VX_DisplayOutputColor1(A4)			move.l	#$00000000,VX_DisplayOutputColor2(A4)			move.b	#$09,VX_MultiplierMode(A4)			move.b	#$0f,VX_MultiplierBWNoiseGenerator(a4)			move.w	#$0080,VX_BlendRatioTotal(a4)			move.w	#$0008,$330(A4)						move.w		#$0,VX_Rectangle1YStart(a4)			move.w		#$0,VX_Rectangle1XStart(a4)			move.w		#0,VX_Rectangle1YEnd(a4)			move.w		#0,VX_Rectangle1XEnd(a4)			move.b		#6,VX_Rectangle1DisplaySource(a4)		; source 6 (blender?)			move.b		#1,VX_Rectangle1PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle1IOControl(a4)			; configuration rectangle 2			move.w		#0,VX_Rectangle2YStart(a4)			move.w		#0,VX_Rectangle2XStart(a4)			move.w		#1023,VX_Rectangle2YEnd(a4)			move.w		#1023,VX_Rectangle2XEnd(a4)			move.b		#6,VX_Rectangle2DisplaySource(a4)		; source 0 (default?)			move.b		#1,VX_Rectangle2PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle2IOControl(a4)			bra			Exit;------------------------------------------------------------------; vieux code pour configuration vx			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a4			; base des registres de la Video Explorer; paramètre par défaut						move.w	#$0300,VX_DefaultDisplaySource(A4)	; alpha off			move.l	#$00000000,VX_DisplayOutputColor1(A4)			move.l	#$00000000,VX_DisplayOutputColor2(A4)			move.b	#$09,VX_MultiplierMode(A4)			move.b	#$0f,VX_MultiplierBWNoiseGenerator(a4)			move.w	#$0080,VX_BlendRatioTotal(a4)			move.w	#$0008,$330(A4)						move.w		#$0,VX_Rectangle1YStart(a4)			move.w		#$0,VX_Rectangle1XStart(a4)			move.w		#1023,VX_Rectangle1YEnd(a4)			move.w		#1023,VX_Rectangle1XEnd(a4)			move.b		#2,VX_Rectangle1DisplaySource(a4)		; source 2 video bus 2			move.b		#1,VX_Rectangle1PriorityLevel(a4)		;priority 1			move.b		#0,VX_Rectangle1IOControl(a4)			; configuration rectangle 2			move.w		#0,VX_Rectangle2YStart(a4)			move.w		#0,VX_Rectangle2XStart(a4)			move.w		#1023,VX_Rectangle2YEnd(a4)			move.w		#1023,VX_Rectangle2XEnd(a4)			move.b		#3,VX_Rectangle2DisplaySource(a4)		; source 3 default color 0			move.b		#1,VX_Rectangle2PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle2IOControl(a4)			Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.new		ConfigureVX_UpStreamKeyer		endP				* ================================================* PROCEDURE ConfigureVX_DownStreamKeyer;* ================================================* configure la vidéo exploreur dans le mode Downstream keyerConfigureVX_DownStreamKeyer	PROC	EXPORT			StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAreaBlock			ds.l	80DataArea			ds.l	80Data_Aray			ds.l	16			; pour le valeurs du multiplierHatcheck			ds.l	1			; le hatcheck pour le blend modeLocalSize			EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,WaitTicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,DoFileOpen,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO,VtrTimedTask,\			AdjustMenus	; linked in with Interface.o		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,\				VDInterruptMode,MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec		WITH	HSLColor,VDChannelColorState,VDControlState,\				VDLineControl,VDRectangleState,VDAlphaDisplaySource																		LINK	A6,#LocalSize		; allocate our local stack frame																			cmp.w	#$118,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$346,G.VE_BoardID		; nu vista ou vx			beq		exit				cmp.w	#$28C,G.VE_BoardID		;vista+ ?			beq 	Exit			move.l	G.Base_Adresse,d0			beq		Exit			and.l	#$ff000000,d0			add.l	#registerSpaceStart,d0			move.l	d0,a4			; base des registres de la Video Explorer						add.l	#$300,d0			move.l	d0,a0						move.l	#$80/4,d0	; on erase 128 octetsClearVXMemory_loop			clr.l	(a0,d0.W*4)			dbra 	d0,ClearVXMemory_loop; on position les valeurs de configuration								move.b	#$40,VX_PixelControlMode(a4)			; 			move.b	#02,VX_Pixel0MultiplierInputSource1(a4)			move.b	#02,VX_Pixel1MultiplierInputSource1(a4)			move.b	#00,VX_Pixel0MultiplierInputSource2(a4)			move.b	#00,VX_Pixel1MultiplierInputSource2(a4)			move.b	#00,VX_Pixel0MultiplierInputSource3(a4)			move.b	#00,VX_Pixel1MultiplierInputSource3(a4)			move.w	#$0040,VX_ICFScaleFactor(a4)						move.w	#$0204,VX_DefaultDisplaySource(A4)			move.l	#$00000000,VX_DisplayOutputColor1(A4)			move.l	#$00000000,VX_DisplayOutputColor2(A4)			move.b	#$09,VX_MultiplierMode(A4)			move.b	#$0f,VX_MultiplierBWNoiseGenerator(a4)			move.w	#$0080,VX_BlendRatioTotal(a4)			move.w	#$0008,$330(A4)						move.w		#$0,VX_Rectangle1YStart(a4)			move.w		#$0,VX_Rectangle1XStart(a4)			move.w		#0,VX_Rectangle1YEnd(a4)			move.w		#0,VX_Rectangle1XEnd(a4)			move.b		#6,VX_Rectangle1DisplaySource(a4)		; source 6 (blender?)			move.b		#1,VX_Rectangle1PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle1IOControl(a4)			; configuration rectangle 2			move.w		#0,VX_Rectangle2YStart(a4)			move.w		#0,VX_Rectangle2XStart(a4)			move.w		#1023,VX_Rectangle2YEnd(a4)			move.w		#1023,VX_Rectangle2XEnd(a4)			move.b		#0,VX_Rectangle2DisplaySource(a4)		; source 0 (default?)			move.b		#1,VX_Rectangle2PriorityLevel(a4)		;priority 4 ######			move.b		#0,VX_Rectangle2IOControl(a4)					Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller		; on configure le multiplier pour faire du alpha blend			; on passe en mode alpha blend			clr.l	-(sp)			MOVE.W   G.Ve_RefNum,-(sp)			move.w	#$0,-(sp)			move.w	#videoBus2Channel,-(sp)	; channel 1			move.w	#inputModuleChannel,-(sp)	; channel 2			move.w	#inputModuleChannel,-(sp)	; channel 3			move.l	#$00010000,-(sp)			; blend total=1			move.l	#$00000000,-(sp)			; icf3 =0			import	AlphaBlendSetup			jsr		AlphaBlendSetup			move.l	(sp)+,G.VE_HATCHECK						clr.l	-(sp)			move.l	G.VE_HATCHECK,-(sp)			move.w	#-1,-(sp)				; blend indéfini dans le temps			import	AlphaBlendRun			jsr		AlphaBlendRun			move.l	(sp)+,d0						DbgInfo.new		ConfigureVX_DownStreamKeyer		endP						* ================================================* PROCEDURE ConfigureNuVista+;* ================================================* configure la carte Nu vista+ pour l'incrustation downstream keyerConfigureNuVistaplus	PROC	EXPORT			StackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize			EQU	ParamBegin-*		; size of all the passed parametersRetAddr 			DS.L	1			; place holder for return addressA6Link				DS.L	1			; place holder for A6 linkAreaBlock			ds.l	80DataArea			ds.l	80LocalSize			EQU 	*			; size of all the local variables		ENDR				IMPORT	GoGetRect,AlertUser,SysEnvirons,EffaceTouslesSousTitres,\			TrapAvailable,WaitTicks,DoUpdate,DoActivate,Show_cursor,\			InitCursorCtl,SpinCursor,DoFileOpen,RAMSDOpen,\			SerReset,SerSetBuff,SerHShake,SerStatus,OpenDriver,\			FSRead,FSWrite,Control,Status,KillIO,VtrTimedTask,\			AdjustMenus	; linked in with Interface.o		WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,\				VDInterruptMode,MixerCtlRec,HdwReqRec,AnalogCtlRec,VideoCtlRec		WITH	HSLColor,VDChannelColorState,VDControlState,\				VDLineControl,VDRectangleState,VDAlphaDisplaySource																		LINK	A6,#LocalSize		; allocate our local stack frame					; on passe en  mode incrustation (alpha blend); lecture du hardware de la nu vista +						lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwReadRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct						move.l    	a1,csParam(a0)       ; faut voir .....					lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer;			lea			G.NuvistaAnalog,a2			move.l		#0,AnalogCtlPtr(a1)		; adresse de la structure analog			;			lea			G.nuvistaCltReg,a2			move.l		#0,VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec						clr.l		PhasePtr(a1)			; hphase = null			_Control			; passage en mode  alpha blendzobuy			lea			AreaBlock(a6),a0			clr.l		ioCompletion(a0)			MOVE.W   	G.Ve_RefNum,ioRefNum(a0)			move.w		#kHdwWriteRequest,csCode(a0)	; lecture hardware						lea			G.NuvistaHardware,a1				; hardware request struct			move.l    	a1,csParam(a0)       ; faut voir .....		; on ne modifie que le mixer			lea			G.NuvistaMixer,a2			move.l		a2,MixerCtlPtr(a1)		; adresse de la structure mixer			move.b		#0,(a2)			move.b		#0,1(a2)			move.b		#1,2(a2)			move.b		#1,3(a2)			move.b		#0,4(a2)			move.b		#1,5(a2)			move.b		#0,6(a2)			move.b		#0,7(a2)			move.b		#0,8(a2)						move.b		#0,9(a2)			move.b		#0,10(a2)			move.b		#0,11(a2)			move.b		#0,12(a2)						move.b		#0,13(a2)			move.b		#0,14(a2)			move.b		#0,15(a2)						move.b		#$0,16(a2)			move.b		#$0,17(a2)			move.b		#1,18(a2)			move.b		#1,19(a2)			; alpha key						move.b		#1,20(a2)			move.b		#0,21(a2)			move.b		#0,22(a2)			move.b		#1,23(a2)			move.b		#0,24(a2)			move.b		#0,25(a2)						move.b		#0,26(a2)			move.b		#0,27(a2)			move.b		#0,28(a2)			move.b		#0,29(a2)						move.b		#3,30(a2)			move.b		#0,31(a2)						clr.l		AnalogCtlPtr(a1)		; adresse de la structure analog			clr.l		VideoCtlPtr(a1)		; adresse de la structure VideoCtlRec			clr.l		PhasePtr(a1)			; hphase = null			_Control						Exit	UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all ofthe caller's parameters		JMP	(A0)			; return to the caller				DbgInfo.new		ConfigureNuVista+		endP						end				