#include "BB.Globals_C.h"#include "E3DEMO.H"#include <SegLoad.h>#include <Slots.h>#include <Menus.h>#include <Devices.h>#include <Events.h>#include <Gestalt.h>#include <Files.h>#include <AppleEvents.h>#include <AERegistry.h>//#pragma segment SansFauteGram// les globals	extern MyQDGlobals QD;	extern AppGlobals G;pascal OSErr	launchMoniteurVideo(void);pascal void		QuitMoniteurVideo(void);pascal OSErr	launchSFG(void);pascal void 	QuitSansFauteGrammaire(void);pascal void 	ActiveSansFauteGrammaire(void);pascal void 	VerifieSFG(SousTitreRecordPtr ST_Ptr);static pascal OSErr SendAECheckToSFG(SousTitreRecordPtr ST_Ptr);static pascal void  TreatActivateUpdateOSDialogEvent (EventRecord* theEvent);static pascal OSErr SFGAnswerHandler( 	AppleEvent* theAppleEvent,										AppleEvent* reply,										long HandlerRefCon);static pascal void MyInitDesc (AEDesc* desc);static pascal void MyDisposeDesc(AEDesc*  desc);static void FinDeLaCorrection(void)	;										/* Works only with the version 2.02 or later version of Sans-FauteGrammaire */#define  SFGsignature  'SFGr'// les globales pour ce fichier static WindowPtr		whichWindow;static EventRecord 		theEvent;static OSErr			err,AEcodeErr;static long				ignore,SFGAevtReturnID;static GrafPtr			oldPort;static ControlHandle 	whichControl;static short			i;static	DialogPtr		checkDialog;static	Boolean			checkDoneFlag,finverif;static SousTitreRecordPtr	ST_PtrEncours;void DrawVerifDlog(DialogPtr dlog,short num,short totalnum);void DrawVerifDlog(DialogPtr dlog,short num,short totalnum){	short type; Handle hndl; Rect box,r;	Str255	st0;		RGBColor		color,oldcolor,oldFcolor;		// on place les couleurs de fond	SetPort(dlog);	GetBackColor(&oldcolor);	color.red=56797;	color.green=56797;	color.blue=56797;	RGBBackColor(&color);	PenNormal();	DrawDialog(dlog);		GetDItem(dlog,7,&type,&hndl,&box);	NumToString(num,&st0);	SetIText(hndl,&st0);		GetDItem(dlog,8,&type,&hndl,&box);	NumToString(totalnum,&st0);	SetIText(hndl,&st0);			GetForeColor(&oldFcolor);	color.red=18000;	color.green=32000;	color.blue=18000;	RGBForeColor(&color);	GetDItem(dlog,3,&type,&hndl,&box);	r=box;	r.right=r.left+((box.right-box.left)*num)/(totalnum+1) ;	PaintRect(&r);	RGBForeColor(&oldFcolor);	InsetRect(&box,-2,-2);	MakeReliefRectangle1(&box);		GetDItem(dlog,11,&type,&hndl,&box);	MakeReliefRectangle1(&box);		GetDItem(dlog,12,&type,&hndl,&box);	PenPat(&QD.gray);	FrameRect(&box);	PenNormal();	RGBBackColor(&oldcolor);}pascal void VerifieTexteListeSousTitre(SousTitreRecordPtr start,SousTitreRecordPtr end){short item,totalnum=((end->st_AbsNUMST)-(start->st_AbsNUMST) );Point MousePt;GrafPtr LoldPort;Boolean	visListing,visSaisie,visBackDrop,visBlockNote,visinfo;// on recupres la visibilitŽ prŽsente des fentres 		visListing=( (WindowRecord*)(&G.ListingWindow) )->visible;		visSaisie=( (WindowRecord*)(&G.DialogSaisie) )->visible;		visBackDrop=( (WindowRecord*)(&G.BackDropWindow) )->visible;		visBlockNote=( (WindowRecord*)(G.BlockNoteWindow) )->visible;		visinfo=( (WindowRecord*)(G.ServiceWindow) )->visible;				// on masque les palettes et toutes les fentres		SuspendFloatingWindows();						ST_PtrEncours=start;		finverif=false;		GetPort(&oldPort);		SetDAFont(geneva);		checkDialog=GetNewDialog(259, nil, (WindowRef)-1);		SetPort(checkDialog);		ShowWindow(checkDialog);		/* For PowerPC native code, use NewAEEventHandlerProc(SFGAnswerHandler)	instead of @SFGAnswerHandler */		err= AEInstallEventHandler(kCoreEventClass, kAEAnswer,				(AEEventHandlerUPP)&SFGAnswerHandler,0, false);		if (err){				Alert(259, nil);				FinDeLaCorrection();				return ;				}						launchSFG();// boucle vŽrification liste sous-titre	do{// on envoie le texte ˆ sans faute grammaire								SendAECheckToSFG(ST_PtrEncours);		SetPort(checkDialog);		DrawVerifDlog(checkDialog,ST_PtrEncours->st_AbsNUMST,totalnum);		checkDoneFlag= false;	// on attend la rŽponse						do{			 if (WaitNextEvent(everyEvent,&theEvent, 30, nil)){								  switch (theEvent.what ){					case activateEvt:							DoActivate((WindowPtr)theEvent.message,theEvent.modifiers&activeFlag);						break;					case updateEvt:						if ( checkDialog== (WindowPtr)theEvent.message){							GetPort(&LoldPort);							SetPort(checkDialog);							BeginUpdate(checkDialog);							DrawVerifDlog(checkDialog,ST_PtrEncours->st_AbsNUMST,totalnum);							EndUpdate(checkDialog);							SetPort(LoldPort);						} else DoUpdate( (WindowPtr)theEvent.message);							break;												case	kHighLevelEvent: 							err= AEProcessAppleEvent(&theEvent);							break;												case	mouseDown: 							switch( FindWindow(theEvent.where,&whichWindow) ){															case inSysWindow: 									SystemClick(&theEvent, whichWindow);								case inDrag: 								if( whichWindow == checkDialog){									DragReferencedWindow((WindowReference)whichWindow,theEvent.where, &QD.screenBits.bounds);									}									break;									case inMenuBar: 										MenuSelect(theEvent.where);									break;								case inContent: 									if( whichWindow == checkDialog){											MousePt =theEvent.where;											SetPort(checkDialog);											GlobalToLocal(&MousePt);											if(FindControl(MousePt, whichWindow,&whichControl)== inButton) 												if(TrackControl(whichControl, MousePt, nil) == inButton) {												item=FindDItem(checkDialog,MousePt)+1;																						if (item==1)ActiveSansFauteGrammaire();												if (item==2) {checkDoneFlag=true; finverif=true;}											}																					}									break; 									default :									SysBeep(1);									break;								//case osEvt:								} // switch mouse down					 break;									} // switch event			  }// waitnextevent								} while (!checkDoneFlag);				/* on passe au sous-titre suivant */			ST_PtrEncours=(SousTitreRecordPtr)ST_PtrEncours->st_NextST;	} while( (!finverif) && (ST_PtrEncours!=nil) && (ST_PtrEncours<=end) );			if ( (AEcodeErr) && (AEcodeErr != errAEWaitCanceled) )Alert(257, nil);		FinDeLaCorrection();						// on rŽaffiche les fentres		if(visListing) 		ShowReferencedWindow((WindowReference)&G.ListingWindow);		if(visSaisie) 		ShowReferencedWindow((WindowReference)&G.DialogSaisie);		if(visBackDrop)		ShowReferencedWindow((WindowReference)&G.BackDropWindow);		if(visBlockNote) 	ShowReferencedWindow((WindowReference)G.BlockNoteWindow);		if(visinfo) 		ShowReferencedWindow((WindowReference)G.ServiceWindow);				// on reaffiche les palettes 		ResumeFloatingWindows();		} // VerifieTexteListeSousTitrepascal void VerifieTexteUnSousTitre(SousTitreRecordPtr ST_Ptr){short item;Point MousePt;		GetPort(&oldPort);		checkDialog=GetNewDialog(256, nil, (WindowRef)-1);		SetPort(checkDialog);		ShowWindow(checkDialog);		checkDoneFlag= false;				ST_PtrEncours=ST_Ptr;/* For PowerPC native code, use NewAEEventHandlerProc(SFGAnswerHandler)	instead of @SFGAnswerHandler */		err= AEInstallEventHandler(kCoreEventClass, kAEAnswer,				(AEEventHandlerUPP)&SFGAnswerHandler,0, false);		if (err){				Alert(257, nil);				FinDeLaCorrection();				return ;				}				// on envoie le texte ˆ sans faute grammaire							SendAECheckToSFG(ST_Ptr);				// on attend la rŽponse					do{		 if (WaitNextEvent(everyEvent,&theEvent, 30, nil)){						  switch (theEvent.what ){				case activateEvt:						DoActivate((WindowPtr)theEvent.message,theEvent.modifiers&activeFlag);					break;				case updateEvt:						TreatActivateUpdateOSDialogEvent(&theEvent);						break;										case	kHighLevelEvent: 						err= AEProcessAppleEvent(&theEvent);						break;										case	mouseDown: 						switch( FindWindow(theEvent.where,&whichWindow) ){													case inSysWindow: 								SystemClick(&theEvent, whichWindow);							case inDrag: 							if( whichWindow == checkDialog){								DragReferencedWindow((WindowReference)whichWindow,theEvent.where, &QD.screenBits.bounds);								}								break;								case inMenuBar: 									MenuSelect(theEvent.where);								break;							case inContent: 								if( whichWindow == checkDialog){										MousePt =theEvent.where;										SetPort(checkDialog);										GlobalToLocal(&MousePt);										if(FindControl(MousePt, whichWindow,&whichControl)== inButton) 											if(TrackControl(whichControl, MousePt, nil) == inButton) {											item=FindDItem(checkDialog,MousePt)+1;																					if (item==1)ActiveSansFauteGrammaire();											if (item==2)checkDoneFlag=true;										}																			}								break; 							default :								SysBeep(1);								break;							//case osEvt:							} // switch mouse down				 break;							} // switch event		  }// waitnextevent							} while (!checkDoneFlag);		if ( (AEcodeErr) && (AEcodeErr != errAEWaitCanceled) )Alert(257, nil);		FinDeLaCorrection();} // VerifieTexteUnSousTitre/* AppleEvent Handler used to receive the answer from Sans-Faute,Grammaire */static pascal OSErr SFGAnswerHandler( 	AppleEvent* theAppleEvent,										AppleEvent* reply,										long HandlerRefCon){AEDesc	result, textDesc, StyleDesc;OSErr	err;long	AevtReturnID;long	actualSize;DescType	actualTypeCode;		launchSFG();	err = AEGetAttributePtr(theAppleEvent, keyReturnIDAttr, typeLongInteger,					&actualTypeCode, &AevtReturnID, sizeof(long),&actualSize);		if(  (err == noErr) && (SFGAevtReturnID == AevtReturnID)  ){				checkDoneFlag = true;				err= AEGetParamPtr(theAppleEvent, keyErrorNumber,									typeShortInteger,&actualTypeCode,									&AEcodeErr, sizeof(OSErr),&actualSize);													if( (!err )&&(!AEcodeErr) ){								MyInitDesc(&result);								MyInitDesc(&textDesc);								MyInitDesc(&StyleDesc);								err= AEGetParamDesc(theAppleEvent, keyDirectObject,														typeAERecord,&result);								if (!err ) err= AEGetKeyDesc(&result,keyAEText,typeChar,&textDesc);								if (!err ) err= AEGetKeyDesc(&result,keyAEStyles,typeScrapStyles,&StyleDesc);																// on a le texte, on prŽpare un undo, et on place le rŽsutat								if (!err ){									// on regarde s'il y a un te d'ouvert									// si non on l'ouvre pour faire un undo										if (G.saisieTE==nil)  DoOpenSaisieTE(Texte_SousTitre);																				// on fait le undo										DoMakeUndo(G.saisieTEStItem,0,G.saisieTEStNum,(long)G.saisieTE);																		// si nous ne sommes pas au bon sous-titre on y va										if (ST_PtrEncours->st_AbsNUMST!=(long)G.General_SousTitreEncour){											TransfertSaisieMemoire(); // on ferme le TE											G.General_SousTitreEncour=ST_PtrEncours->st_AbsNUMST;											UpdateSaisie();												DoOpenSaisieTE(Texte_SousTitre);											}																									// on remplace le texte										TESetSelect(0,32766, G.saisieTE);										TEDelete(G.saisieTE);										TEStylInsert((Ptr)*(textDesc.dataHandle), GetHandleSize(textDesc.dataHandle),(StScrpHandle)StyleDesc.dataHandle,G.saisieTE);														// on rafraichi les fentres listing et saisie										TransfertSaisieMemoire(); // on ferme le TE										CentreListingWindow();																			} else {																			err=AEcodeErr;										MyDisposeDesc(&result);										MyDisposeDesc(&textDesc);										MyDisposeDesc(&StyleDesc);									}							} else	return AEcodeErr;										} // (err = noErr) & (SFGAevtReturnID = AevtReturnID)	return err;}/* Routines used to check the grammar of the styled TEHandle with Sans-Faute Grammaire *//* Build a AEDesc with styled text into it*/static pascal OSErr BuildStyledTextDescforST(AEDesc* resultDesc,SousTitreRecordPtr ST_Ptr){AEDesc				StyleListDesc ;OSErr				err;Ptr					pointeur;			MyInitDesc(resultDesc);			MyInitDesc(&StyleListDesc);			err= AECreateList(nil, 0, true,&StyleListDesc);			pointeur=(Ptr)ST_Ptr+sizeof(SousTitreRecord);	 			if (!err) {				err= AEPutKeyPtr(&StyleListDesc, keyAEText,typeChar,pointeur,ST_Ptr->st_TexteLenth);				err= AEPutKeyPtr(&StyleListDesc,keyAEStyles,typeScrapStyles,					 		ST_Ptr->st_StylePtr,ST_Ptr->st_StyleLenth);				err= AECoerceDesc(&StyleListDesc,typeStyledText,resultDesc);			}						MyDisposeDesc(&StyleListDesc);						return  err;}/* Send the AppleEvent to Sans-Faute/Grammaire *//* Please note that the AppleEvent used in an extension	of the Word Services Suite specific to Sans-Faute/Grammaire */static pascal OSErr SendAECheckToSFG(SousTitreRecordPtr ST_Ptr){OSErr 		err;OSType		targetSignature=SFGsignature;AEDesc		target,directParamDesc;AppleEvent	evt, reply;DescType	actualTypeCode;Size		actualSize;			MyInitDesc(&evt);			MyInitDesc(&reply);			MyInitDesc(&directParamDesc);			MyInitDesc(&target);						err = AECreateDesc(typeApplSignature,&targetSignature,sizeof(targetSignature),&target);			if (!err) err= AECreateAppleEvent('WSrv','Btch',&target,							kAutoGenerateReturnID, kAnyTransactionID,&evt);			if (!err) err= AEGetAttributePtr(&evt, keyReturnIDAttr, typeLongInteger,							&actualTypeCode, &SFGAevtReturnID,sizeof(long),&actualSize);			if (!err) err= BuildStyledTextDescforST(&directParamDesc,ST_Ptr);			if (!err) err= AEPutParamDesc(&evt, keyDirectObject,&directParamDesc);			if (!err) err= AESend(&evt,&reply, kAEQueueReply + kAEAlwaysInteract + kAECanSwitchLayer,							kAENormalPriority, kNoTimeOut, nil, nil);			MyDisposeDesc(&evt);			MyDisposeDesc(&reply);			MyDisposeDesc(&directParamDesc);			MyDisposeDesc(&target);			return	err;}/* Treat ActivateEvt , UpdateEvt and osEvt of the Dialog Event Loop */static pascal void  TreatActivateUpdateOSDialogEvent (EventRecord* theEvent){GrafPtr		LoldPort;			if ( checkDialog== (WindowPtr)theEvent->message) {							BeginUpdate(checkDialog);							GetPort(&LoldPort);							SetPort(checkDialog);							UpdtDialog(checkDialog,checkDialog->visRgn);							SetPort(LoldPort);							EndUpdate(checkDialog);						} else {							DoUpdate( (WindowPtr) theEvent->message);						}}static void FinDeLaCorrection(void)	{OSErr	err;/* For PowerPC native code,	use NewAEEventHandlerProc(SFGAnswerHandler) instead of @SFGAnswerHandler */				err = AERemoveEventHandler(kCoreEventClass, kAEAnswer,						(AEEventHandlerUPP)&SFGAnswerHandler, false);			DisposeDialog(checkDialog);			SetPort(oldPort);			SetDAFont(0);}/* Routine used to initialize a AEDesc */static pascal 	void MyInitDesc (AEDesc* desc){		desc->descriptorType= typeNull;		desc->dataHandle= nil;}/* Routine used to dispose a AEDesc */static pascal void MyDisposeDesc(AEDesc*  desc){OSErr	err;		if (desc->dataHandle){			err=AEDisposeDesc(desc);			desc->dataHandle= nil;			desc->descriptorType= typeNull;			}}