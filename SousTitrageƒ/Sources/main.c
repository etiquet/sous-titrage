#include "BB.Globals_C.h"#include <SegLoad.h>typedef struct verifGlobals{	Ptr	QDdkgray;	Ptr	GspareForFutur;}verifGlobals, *verifGlobalsPtr;/* quelques protos */void 			MainLoop(void);pascal void 	StartXtimeTask(void);pascal void 	EventLoop(void);pascal void		main(void);pascal Boolean 	UpdateAV(void);pascal void 	DrawBlockNoteValue(void);pascal void 	UpdateErrorWindow(void);pascal void 	DrawServiceWindow(void);void 			GiveMeMoreMaster(void);pascal void 	TestAdresseGlobales(verifGlobalsPtr BBglobals);pascal void 	TestAdresseGlobales_conv(verifGlobalsPtr BBglobals,Ptr p2);pascal void 	TestAdresseGlobales_rend(verifGlobalsPtr BBglobals,Ptr p2);pascal void 	TestAdresseGlobalesListe(verifGlobalsPtr BBglobals);void 			UpdateInfoWindow(void);void 			DrawInfowWindValue(void);void 			DrawInfowWindValuePartiel(void);pascal void 	AVIdle(void);void 			DoSerialIdle(void);extern pascal void SauvegardeAutomatique(void);void			ReglageSimuUpdate(void);void			GenereBlanckingVertical(void);void			SauvegardeAutomatique_Idle(short type);void 			UpdateProchainSousTitre(Boolean partiel);void 			LitCodageVertical(void);void 			DrawFenetreDecodageBlancking(void);void 			FenetreDecodageBlanckingIdle(void);void 			Affichage_SousTitreDecodeVISTC(void);Boolean 		IsMemoryConfigurationOK();void 			DoFollowTCForDisplay(void);extern			long 	gtcasked;void gereEventLoop(EventRecord* event,short GotEvent);// quelques globalesextern long		DoMainReadSerialRequest;extern long		DoVitcReadSerialRequest;extern short   	CurrentField;//### debug & testextern short gDrawSTflag;Boolean		gDone,gRefreshInfoW,doTrackingInListing,doTrackingOutListing,doTrackingInSaisie,doTrackingOutSaisie;DialogPtr  	gLogo,gPaletteKaraoke;extern DialogPtr gMonitor,gDialogReglageSimu,gDialogPrefAffichage;extern long	DoAbortIO;extern DialogPtr	gBlankingVerticalWindow;extern Boolean gMaxSpeed,gGenereSousTitreBlankInterval,gDecodeBlanckingVertical,gCodageBlanckingVerticalActif;extern DialogPtr gDialogProchainSousTitre,gtestDecodageWindow;extern Ptr	gBufferEmissionBlancking;short	gCurResNum,gWatchdog;void DoSaisieIdle(void);void DoPreferenceAffichageDlogDialogUpdate(DialogPtr dlog);MyQDGlobals QD;AppGlobals G;pascal void main(void){verifGlobals Glob;Ptr	p[9];Ptr	p2[9];	gDrawSTflag=1;		MaxApplZone();	gCurResNum=CurResFile();	SetDAFont(geneva);/*	p[0]=(Ptr)&G.performanceTask;	p[1]=(Ptr)&G.AskTcTask;	p[2]=(Ptr)&G.Rechercher_STR;	p[3]=(Ptr)&G.EveHandle;	p[4]=(Ptr)&G.versionLogiciel;	p[5]=(Ptr)&G.Justification;	p[6]=(Ptr)&G.SoftProtect;	p[7]=(Ptr)&G.CurrentFileName;*//*	TestAdresseGlobales_rend(&Glob,(Ptr)&p2);	if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(Main - routine rendering .a)");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(Main - routine rendering .a)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;*/	TestAdresseGlobales_conv(&Glob,(Ptr)&p2);		if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(Main -routine conversion )");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(Main -routine conversion)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;	// on vérifie l'identitée des variables globales	TestAdresseGlobales(&Glob);	if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(Main)");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(Main)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;			TestAdresseGlobalesListe(&Glob);	if ( Glob.QDdkgray != (Ptr)&QD.dkGray  )				DebugStr("\perreur: QuickDraw QD differents(liste.a)");	if ( Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) 	DebugStr("\perreur: Globales  G. differents(liste.a)");	if ( (Glob.QDdkgray!= (Ptr)&QD.dkGray) || 		 (Glob.GspareForFutur!= (Ptr)&G.spareForFutur[0]) ) return;		 	Initialise_BonBougre();	// get things the program set up	MainLoop();	C_QuitApplication();	// on dispose tous le bastring}/* Boucle Principale du programme */void MainLoop(void){EventRecord	event;Boolean		GotEvent,pbClef=true;RgnHandle	mouse;	if (!G.FindFirstKey_error) pbClef=false;	else  if (G.SoftProtect==1) pbClef=false;		G.WatchDogSave=TickCount();	gDone=false;	gMaxSpeed=false;	G.InBackground=false;	mouse=NewRgn();		//on vérifie la configuration de la mémoire du mac	// mode 32 bits	// pas de mémoire vituelle		if (!IsMemoryConfigurationOK()){				StopAlert(284,nil);				}		#ifndef __NoProtect__	if (pbClef) NoteAlert(281,nil);#endif	// on vérifie le mode de lecture Vitc si mode av on incite au mode lecteur externe.	if (G.LecteurTimeCode_Type==3) NoteAlert(286,nil);	// on regarde s'il y a un offset sur le TC	if (G.OffsetLectureTCPlay || G.OffsetLectureTCStop ) NoteAlert(288,nil);					// la boucle pricipale du programme ...do{		// gestion multitâche du macintosh	// si nous nes sommes pas le front processe on est très coopératif	// si nous sommes le front process, on augmente la cadence si proche d'1 ST			if (G.InBackground) GotEvent=WaitNextEvent(-1,&event,0,nil);		else {			//AdjustCursor();			if (gMaxSpeed)	GotEvent=false ;/*EventAvail(-1,&event); */				else		 GotEvent=WaitNextEvent(-1,&event,0,nil);		}					 gereEventLoop(&event,GotEvent);	}while(!gDone);		// le programme est fini		DisposeRgn(mouse);	}// event loopvoid gereEventLoop(EventRecord* event,short GotEvent){// on update le compteur pour mesurer la performance de la boucle pricipale		G.EventLoop_Counteur++;				DoSerialIdle();// la gestion des sous-titres mode AV// de la lecture VITC AV// du décodage VISTC// du codage VISTC// la gestion de l'acquisition du time-code				// si carte d'affichage on gère l'incrustation broadcast				if(G.Base_Adresse)  {				Affichage_SousTitreBroadcast();		} else {			if (gMonitor){				AVIdle();								if (G.LecteurTimeCode_Type==3){					 	LitVITCAVIdle();						}										if (G.LecteurTimeCode_Type==4){						LitCodageVertical();						if (!G.InBackground )									Affichage_SousTitreDecodeVISTC();						FenetreDecodageBlanckingIdle();					}						 				if(  (!G.InBackground ) &&(G.LecteurTimeCode_Type<4) ) Affichage_SousTitreSimulation();									// le codage Blancking Vertical							if (					(G.LecteurTimeCode_Type<4) &&					gGenereSousTitreBlankInterval &&					gCodageBlanckingVerticalActif){							*((long*)gBufferEmissionBlancking)=G.General_TCCourant;							GenereBlanckingVertical();					}				 			} else DoFollowTCForDisplay(); // si ni simu ni-broadcast on fait juste le tc courant et listing		}		// on affiche le time code courant		C_ConversionTCstASCII(G.General_TCCourant,&G.bufferTimecodeCourant);		G.bufferTimecodeCourant[0]=12;		G.bufferTimecodeCourant[12]=' ';// les routines idles des fenêtres listing, saisie,  chenille et infos		if ( ((WindowPeek)&G.ListingWindow)->visible) 	DoListingIdle();		if (((WindowPeek)G.ChenilleWindow)->visible) 	DoChenilleIdle();		if (((WindowPeek)&G.DialogSaisie)->visible)  	DoSaisieIdle();								/* pour la fenêtre info, on ne rafraichi seulement le nécesaire */		if ( ((WindowPeek)G.ServiceWindow)->visible ){			if(	gRefreshInfoW){				DrawInfowWindValue();			 	gRefreshInfoW=0;			 } else DrawInfowWindValuePartiel();		}//(InfoWindow->visible )		// les te						if (G.saisieTE) 	TEIdle(G.saisieTE);		if (G.ListingTE) 	TEIdle(G.ListingTE);		if (G.BlockNoteTE)	TEIdle(G.BlockNoteTE);		//chien de garde sauvergarde automatique		SauvegardeAutomatique_Idle(0); // type normal// on gère les events		if (GotEvent) {			DoEvent(event);			SetDAFont(geneva);			}} //gère event record// gestion du port série dans la boucle principalevoid DoSerialIdle(void){OSErr	err;if (G.LecteurTimeCode_Type==5){		TxRS422('W tc',G.General_PseudoTimeCode,G.ModemOutRefNum);}// on interroge le time-code/*	if (G.LecteurTimeCode_Type==2)			switch (G.Player_TC_src){					case 0:						TxRS422('TIME',3,G.ModemOutRefNum);					break;										case 1:						TxRS422('TIME',1,G.ModemOutRefNum);					break;										case 2:						TxRS422('TIME',2,G.ModemOutRefNum);					break;										case 3:						TxRS422('TIME',4,G.ModemOutRefNum);					break;										case 4:						TxRS422('TIME',4,G.ModemOutRefNum);					break;		}//switch */// Gestion de la lecture du timecode			if (gWatchdog) gWatchdog--;// si pas de reception Vitc série on relance une lecture du port			if (G.LecteurTimeCode_Type==1){		if (G.Serial_Vitc_Count==0 && gWatchdog==0){			err=KillIO(G.ModemInRefNum);			DoMainReadSerialRequest=true; 			DoVitcReadSerialRequest=false;			gWatchdog=600; // 2 secondes		}	}	// si pas de reception RS422 on relance une lecture du port					if (G.LecteurTimeCode_Type==2|| G.LecteurTimeCode_Type==5){		if (G.Serial_Sony_Count==0 && gWatchdog==0){						err=KillIO(G.ModemInRefNum);			DoMainReadSerialRequest=true; 			DoVitcReadSerialRequest=false;			gWatchdog=600; //2 secondes					}	}				if (DoMainReadSerialRequest) {			DoMainReadSerialRequest=0;			G.Main_Rx_PB.ioResult=0;			G.Main_Rx_PB.ioReqCount=1;			G.Main_Rx_PB.ioPosMode=fsFromStart;			G.Main_Rx_PB.ioPosOffset=0;			err=PBRead((ParmBlkPtr)&G.Main_Rx_PB,true);			DoAbortIO=0;			return;			}									 	if (gtcasked>10){ // erreur sur le buffer de sortie	au bout de 9 tentatives à 1/25 sec			 			err=KillIO(G.ModemOutRefNum); // on arrête les IO			gtcasked=0;		}		 					 	/* if (DoVitcReadSerialRequest ) {			DoVitcReadSerialRequest=0;			G.Vitc_Rx_PB.ioResult=0;			G.Vitc_Rx_PB.ioReqCount=8;			G.Vitc_Rx_PB.ioPosMode=fsFromStart;			G.Vitc_Rx_PB.ioPosOffset=0;			err=PBRead((ParmBlkPtr)&G.Vitc_Rx_PB,true);			DoAbortIO=0;			}*/			 	if (DoAbortIO) {			err=KillIO(G.ModemInRefNum);			DoMainReadSerialRequest=true; 			DoVitcReadSerialRequest=false; 				}}//Sérialidle/* routine qui gère le rafraichissement	des fenêtres générale du logiciel */pascal void DoUpdate(WindowPtr window){Rect			rect;PixPatHandle	pixpat;GrafPtr			oldport;					if (window){				GetPort(&oldport);		SetPort((GrafPtr)window);		if (window==(WindowPtr)&G.ListingWindow){						//G.SerialError=1; // on force l'update du voyant						update_listingGworld();						BeginUpdate(window);						DrawListingWindow();						/* on regarde s'il y a un te en cour*/						if (G.ListingTE) {							rect=(**G.ListingTE).viewRect;							InsetRect(&rect,-1,-1);							EraseRect(&rect);							TEUpdate(&(**G.ListingTE).viewRect,G.ListingTE);							FrameRect(&rect);							}// if listing TE						EndUpdate(window);						}								if (window==(WindowPtr)gPaletteKaraoke){ 				DoPaletteKaraokeDialogUpdate(gPaletteKaraoke);				}				if (window==(WindowPtr)gDialogProchainSousTitre){ 				BeginUpdate(window);				UpdateProchainSousTitre(false);				EndUpdate(window);				}															if (window==(WindowPtr)G.TELECOMMANDEWindow){ 				BeginUpdate(window);				DoUpdatePaletteTelecommande();				EndUpdate(window);				}						if (window==(WindowPtr)G.ChenilleWindow){				 BeginUpdate(window);				 DoUpdatePaletteChenille();				 EndUpdate(window);				 }					if (window==(WindowPtr)gtestDecodageWindow){				 BeginUpdate(window);				 DrawFenetreDecodageBlancking();				 EndUpdate(window);				 }										if (window==(WindowPtr)gBlankingVerticalWindow){				 BeginUpdate(window);				 DoUpdateVerticalIntervalWindow();				 EndUpdate(window);				 }					 		if (window==(WindowPtr)&G.DialogSaisie){			BeginUpdate(window);			UpdateSaisie();			EndUpdate(window); }					if (window==(WindowPtr)G.BlockNoteWindow){			 BeginUpdate(window);			 DrawBlockNoteValue();			 EndUpdate(window);			 }				if (window==(WindowPtr)G.LogoWindow){			 	BeginUpdate(window);				DrawDialog(window);				EndUpdate(window);		}				if (window==(WindowPtr)G.ServiceWindow){			 	BeginUpdate(window);				UpdateInfoWindow();				EndUpdate(window);		}				if (window==(WindowPtr)&G.DisplayWindow){			 BeginUpdate(window);			 EndUpdate(window);}			 			 		if (window==(WindowPtr)G.ErrorsWindow)			 UpdateErrorWindow();			 		if (window==(WindowPtr)gDialogReglageSimu)			 ReglageSimuUpdate();			 		if (window==(WindowPtr)gMonitor)			 UpdateAV();			 			 		if (window==(WindowPtr)gDialogPrefAffichage)			DoPreferenceAffichageDlogDialogUpdate((DialogPtr)window);	 		if (window==(WindowPtr)&G.BackDropWindow) {			BeginUpdate(window);			pixpat=GetPixPat(G.BackDrop_PatNum);			if (pixpat){				FillCRect(&window->portRect,pixpat);				DisposPixPat(pixpat);				EndUpdate(window);			} else {				PenMode(patCopy);				ForeColor(blackColor);				BackColor(whiteColor);				PenSize(1,1); 				PenPat(&QD.dkGray); 				PaintRect(&window->portRect); 				PenNormal();				EndUpdate(window);		}		}//backdropwindow			SetPort(oldport);	}// if window} // DoUpdate/* Cette routine controle la sauvegarde automatique*/void SauvegardeAutomatique_Idle(short type){long	actualDiff,a,b;		if ( !G.Preference_AutoCheck) 			return; // sauvegarde automatique pas demandée		if ( !G.ChangeSinceLastSave&0x7fff ) 	return; // pas besoin de faire sauvegarde automatique		actualDiff=(TickCount()-G.WatchDogSave)/3660;// on regarde on en est // on regarde ce que l'on nous demande// type==0 mode normal// type ==1 mode on aimerais faire la sauvegarde le plus rapidement possible						if (type==0){ // mode normal				if (actualDiff<G.Preference_NombreSauv) 	return; // on ne fait rien ,il n'y a pas besoin				// on devrais sauvegarder maintenant, mais on regarde si cela dérange								// s'il y a un TE d'ouvert on attend 50% en plus du temps prévus 				if( G.saisieTE || G.ListingTE) 					if ( (actualDiff/2) < G.Preference_NombreSauv ) return;								// on va faire la sauvegarde				// on regarde si nous sommes en affichage dans un sous-titre				// on essaye d'optimiser le bigniou, (seulement si version affichage)								if ( (gMonitor) || (G.Base_Adresse) ){ //						// déjà on regarde si nous sommes dans un sous-titre						if (G.DrawState&0xff) return; // on ne sauvegarde pas quand le sous-titre est affiché 						if (G.General_SousTitreCourantPtr)							if (G.General_SousTitreCourantPtr->st_TimeCodeIn!=-1){														// on regarde le temps qui nous sépare du prochain sous-titre							a=C_ConversionTimeCodeTrames(G.General_TCCourant);							b=C_ConversionTimeCodeTrames(G.General_SousTitreCourantPtr->st_TimeCodeIn);														// on compte 4 secondes env pour faire une sauvegarde							if (b>a) // seulement si cela roule en avant								if ( (b-a)< 100) return; // inf à 4 seconde on ne sauvegarde pas						}				}								// on fait la sauvegarde				C_SaveData(true);				G.ChangeSinceLastSave=0;				G.WatchDogSave=TickCount();							} 						if (type==1){ // mode on force un peu sur la sauvegarde au 3/4 du temps prévus				if (actualDiff< ((G.Preference_NombreSauv*3)/4) ) 	return; // on ne fait rien ,il n'y a pas besoin				// on fait la sauvegarde				C_SaveData(true);				G.ChangeSinceLastSave=0;				G.WatchDogSave=TickCount();			} 			}// sauvegarde automatique