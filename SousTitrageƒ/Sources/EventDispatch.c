#include "BB.Globals_C.h"#include <Devices.h>#include <stdlib.h>// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;extern Ptr		SerBuff1,SerBuff2;//#pragma segment DispatchEventextern short gvarmode,gAntiAlias;/* prototype routines locales */pascal void DoMouseDown(EventRecord  *event);pascal void DoZoomWindow(WindowPtr w,short part);pascal void C_DoGrowWindow(WindowPtr window,EventRecord *event);pascal void DoMouseDownListing(EventRecord  *event);pascal void DoClickInListingWindowContent(EventRecord *event,Point mouse);pascal void GereClickDansSTListing(EventRecord  *event, Point mouse);pascal void DoListingBarreOutils(Point mouse);pascal void DotheDragInListing(Point mouse);pascal void OpenTheTEListing(Point mouse);void FlashTracking(void);pascal void DoDialogBlockNoteEvent(EventRecord *event);pascal void 	initSerial(void); pascal void	DoInitSerial(void);	// pour la palette erreurpascal void DoMouseDownInErrorWindow(DialogPtr w, EventRecord *evt);void DragAVWindow(Point   pt);Boolean IsAvWindow(WindowPtr w);pascal void DoMouseDown(EventRecord  *event);void DessineLaChenille(long TCCentre);pascal void DoContentClick(WindowPtr	window,EventRecord *event);void 	DessineBarreControlListing(void);void DoKeyDownPaletteTelecommande(EventRecord *event);void DoKeyDownPaletteChenille(EventRecord *event);void DoKeyDownListing (EventRecord *event);void DoKeyDownDialogSaisie (EventRecord *event);void DoKeyDownDialogBlockNote (EventRecord *event);pascal void DoKeyInSaisieDialog (EventRecord *event);void DoKeyEvent(EventRecord *event);pascal short DoFonctionKey(EventRecord *event);pascal void	Adjust_BB_Menu(void);void DessineAVST(SousTitreRecordPtr ST_Ptr,Boolean inOffscreen);void EffaceFenetreSimulation(void);void FermeLEsTE(void);void SimulClickInSaisie(short itemNum);void DoCommentaire(short commentaire);extern pascal void Do_Enchaine(SousTitreRecordPtr ST_Ptr, long TC);int DoRechercheST(short flag );pascal void BlankingDialogEvent(EventRecord	*event);void			DoPaletteKaraokeContent(DialogPtr dlog, EventRecord *evt);pascal Boolean 	UpdateAV(void);pascal void 	DrawBlockNoteValue(void);pascal void 	UpdateErrorWindow(void);pascal void 	DrawServiceWindow(void);void 			UpdateInfoWindow(void);void 			DrawInfowWindValue(void);void 			DrawInfowWindValuePartiel(void);void 			ReglageSimuUpdate(void);pascal void 	DrawSaisieValuePartiel(void);void TxVITCReader(long 	code,long message ,short refnum);int OffsetLectureTC(void);short ValidST(SousTitreRecordPtr ST_Ptr);short CC_Draw_SousTitre(SousTitreRecordPtr Str,short X,short Y,Ptr ScreenBase,long RowBytes,Rect *rect);void C_ClearVx (void); void DoPreferenceMouseDownAffichageDlog(DialogPtr w, EventRecord *evt); void DoPreferenceKeyDownAffichageDlog(DialogPtr w, EventRecord *evt);short	gModeSaisieTCState;extern short gModeSaisieTC;extern DialogPtr 	gDialogReglageSimu,gBlankingVerticalWindow,gPaletteKaraoke,gDialogPrefAffichage;extern GDHandle 	gAVDevice;extern GWorldPtr	gMonitorOffscreen,gMonitorOffscreenFinal;extern WindowPtr 	gMonitor;extern Boolean		gMaskingSousTitre,gMaxSpeed,gDecodeBlanckingVertical;/* GESTION DES EVENEMENT UTILISATEUR OU SYSTEME DU PROGRAMME */void DoEvent(EventRecord *event){	Point			aPoint;	OSErr		err;	Boolean		a;	switch ( event->what ) {		case mouseDown:			DoMouseDown(event);		break;					case keyDown:		case autoKey:						/* check for menukey equivalents */			DoKeyEvent(event);		break;					case activateEvt:			if (((WindowPtr) event->message)==(WindowPtr)gPaletteKaraoke) 	{						a=( (event->modifiers & activeFlag) != 0);						DoPaletteKaraokeDialogActivate(gPaletteKaraoke,a);			 }  else			 	 DoActivate((WindowPtr) event->message, (event->modifiers & activeFlag) != 0);			break;		case updateEvt:			DoUpdate((WindowPtr) event->message);			break;		/*	1.01 - It is not a bad idea to at least call DIBadMount in response			to a diskEvt, so that the user can format a floppy. */		case diskEvt:			if ( HiWord(event->message) != noErr ) {				SetPt(&aPoint, kDILeft, kDITop);				err = DIBadMount(aPoint, event->message);			}			break;					case kOSEvent:		/*	1.02 - must BitAND with 0x0FF to get only low byte */			switch ((event->message >> 24) & 0x0FF) {		/* high byte of message */				case kSuspendResumeMessage:		/* suspend/resume is also an activate/deactivate */					G.InBackground = (event->message & kResumeMask) == 0;										if (G.InBackground) G.InBackground =G.InBackground ;/*SuspendFloatingWindows();*/						else ResumeFloatingWindows();										break;			}			break;					// on gère les high level event			case kHighLevelEvent:			if( (event->message)== kCoreEventClass) 					err = AEProcessAppleEvent(event);		 break;	}} /*DoEvent*//* Gestion des clicks  de souris */pascal void DoMouseDown(EventRecord  *event){GrafPtr			saveport;WindowPtr		window;short			part;long				a;		GetPort(&saveport);		part= FindWindow(event->where,&window);				SetDAFont(0); // on raz le da font , il y a une routine qui ne restore pas le DAFont=0; 	/* pour les palettes flottantes */ 	 	if (window) {		if (window==G.TELECOMMANDEWindow) 	{		DoMouseDownPaletteTelecommande(event); }		if (window==G.ChenilleWindow) 	{			DoMouseDownPaletteChenille(event); }		if (window==G.ErrorsWindow)  	{				DoMouseDownInErrorWindow(G.ErrorsWindow,event);  }				if ((window==(WindowPtr)gDialogReglageSimu )&&								gDialogReglageSimu ) SimuDialogEvent (event);														if ((window==(WindowPtr)gBlankingVerticalWindow) &&								gBlankingVerticalWindow) BlankingDialogEvent (event);														if ( (window==(WindowPtr)gPaletteKaraoke &&								 gPaletteKaraoke)  )	 DoPaletteKaraokeContent(window,event);		if ( (window==(WindowPtr)gDialogPrefAffichage && 								gDialogPrefAffichage) )	 DoPreferenceMouseDownAffichageDlog(window,event);	/* si fenêtre back drop ou display on ne fait rien */	}		a=GetWRefCon(window); 		if (a !=1000 && a!=256){  			 switch (part){				 case	inMenuBar:						Adjust_BB_Menu();						 DoMenuCommand(MenuSelect(event->where));						 break;				 break;			 				 case inSysWindow:			/* let the system handle the mouseDown */						 SystemClick(event, window);				 break;				 				 case inContent:					 if ( window != (WindowPtr)FrontNonFloatingWindow() ) {						 SelectReferencedWindow((WindowReference) window);						if (  window == (WindowPtr)&G.ListingWindow )DoMouseDown(event);		/* use this line for "do first click" sauf pour saisie */					 } else						 DoContentClick(window,event);				 break;						 				 case inDrag:	/* pass screenBits.bounds to get all gDevices */				 	if ( window !=(WindowPtr) FrontNonFloatingWindow() ) 	 SelectReferencedWindow((WindowReference) window);					if (IsAvWindow(window) )		 DragAVWindow( event->where);					else   DragReferencedWindow((WindowReference) window, event->where, &QD.screenBits.bounds);				 break;				 				 case	inGoAway:					 if (TrackBox(window, event->where, part)) {						 if (window==(WindowPtr)G.BlockNoteWindow)							 if (G.BlockNoteTE){								 Close_BlockNoteTE();								 }								 						 if (window==(WindowPtr)&G.ListingWindow)							 if (G.ListingTE){								 TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);								 TEDispose(G.ListingTE);								 G.ListingTE=nil;	 								 if (G.ListingTEStNum==G.General_SousTitreEncour){	/* on update si même S/T dans saisie*/									 SetPort((GrafPtr)&G.DialogSaisie);									 InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);									 }								 }								 						 if (window==(WindowPtr)&G.DialogSaisie)								 if (G.saisieTE){									 TransfertSaisieMemoire();	/* on update */									 DrawSt_enCourDansListing();									 }									 						 HideReferencedWindow((WindowReference) window);						 }			 				 break;				 				 case	inGrow:						 C_DoGrowWindow(window,event);				 break;				 				 case	inZoomIn:				 case	inZoomOut:					 /* on teste si la fenetre accepte un zoom event 						 (seulement listing accepte)					 */					 if (GetWRefCon(window)!=2) 	DoZoomWindow(window,part);				 break;			 } // switch 		}// pas fenêtre backdrop ou display 	SetPort(saveport); // on rend le port} // mouse downpascal void DoZoomWindow(WindowPtr window,short part){	SetPort(window);	EraseRect(&window->portRect);	ZoomWindow(window, part, window == (WindowPtr)FrontNonFloatingWindow());	//ResizeWindow(window);} /*  DoZoomWindow */pascal void C_DoGrowWindow(WindowPtr window,EventRecord *event){WindowPtr	w1;long		growResult;Rect		tempRect;		SetPort(window);		if (window==(WindowPtr)&G.ListingWindow){			// fenêtre listing		tempRect.top = 70;		w1=(WindowPtr)&G.DialogSaisie;		tempRect.left= w1->portRect.right-w1->portRect.left; //largeur de saisie		tempRect.right=tempRect.left;		tempRect.bottom = QD.screenBits.bounds.bottom-QD.screenBits.bounds.top;					/* set up limiting values */			growResult = GrowWindow((WindowPtr)&G.ListingWindow, event->where, &tempRect);			/* see if it really changed size */		if ( growResult != 0 ) {				// si un te ouvert on le ferme 			if (G.ListingTE){				TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);				TEDispose(G.ListingTE);				G.ListingTE=nil;				InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}					SizeWindow(window, LoWord(growResult), HiWord(growResult), true);			InvalRect(&window->portRect);			Adjust_ListingScrollBar();		}					} else { 		// pas listing window			tempRect = QD.screenBits.bounds;					/* set up limiting values */		tempRect.left = 50;		tempRect.top = 50;				growResult = GrowWindow(window, event->where, &tempRect);			/* see if it really changed size */		if ( growResult != 0 ) {			SizeWindow(window, LoWord(growResult), HiWord(growResult), true);			InvalRect(&window->portRect);		}	}} /* C_DoGrowWindow *//*	-------------------------------------------------------	Cette routine dispatch les mouse-down 	en fonction de la fenêtre choisie	*/pascal void DoContentClick(WindowPtr	window,EventRecord *event){	if (window==G.TELECOMMANDEWindow) 			DoMouseDownPaletteTelecommande(event);	if (window==G.ChenilleWindow) 				DoMouseDownPaletteChenille(event);	if (window==(WindowPtr)&G.ListingWindow) 		DoMouseDownListing (event);	if (window==(WindowPtr)&G.DialogSaisie) 		DoDialogSaisieEvent (event);	if (window==(WindowPtr)G.BlockNoteWindow) 		DoDialogBlockNoteEvent (event);	if(  (window==(WindowPtr)gPaletteKaraoke)  && gPaletteKaraoke)											DoPaletteKaraokeContent(gPaletteKaraoke,event);}/* 	------------------------------------------------------------------	routines pour saisie 	------------------------------------------------------------------*/pascal void DoDialogSaisieEvent(EventRecord *event){GrafPtr		oldport;SousTitreRecordPtr		ST_Ptr,ST1;short			LastTeItem,originalItem,itemtype,a,j;Point			mouse,pt;DialogPtr		D=(DialogPtr)&G.DialogSaisie;		TextStyle		TheStyle;long				l,TC,ticks,oldstnum,mresult;Boolean			outboucle=false,flag;MenuHandle	menu;Str255			string;Rect				rect;Handle			item;Handle			CursorData,CurD,CurM;Ptr				P;		/* on récupère le tc courant */		TC=G.General_TCCourant;		ticks=TickCount();		GetPort(&oldport);		SetPort(D);				ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);		/* on utilise ce flag pour savoir s'il faut réouvrir le texte te à la fin */		LastTeItem=0;		/* on regarde s'il y a un te d'ouvert si oui on traite le			mouse down pour le te */		if (G.saisieTE) {			LastTeItem=G.saisieTEStItem;		}		TextFont(geneva);		TextSize(14);		TextFace(0);		/* On détermine l'item qui a été frappé */		mouse=event->where;		GlobalToLocal(&mouse);				originalItem=FindDItem((DialogPtr)&G.DialogSaisie,mouse);		if (originalItem !=-1)			GetDItem((DialogPtr)&G.DialogSaisie,originalItem+1,&itemtype,&item,&rect);/* Si l'on a tapé à coté d'item on ferme le te 	sauf si c'est le texte*/		if (G.saisieTE)			if (originalItem==-1 ||				originalItem<11 && originalItem>15 ||				itemtype&0x80!=0 )	/* item disable ?*/								if (G.saisieTEStItem != Texte_SousTitre){					TransfertSaisieMemoire();					DrawSt_enCourDansListing();					}								originalItem++;		/* on gère les event pour les te d'abords*/				if (originalItem>=12 && originalItem<=16){						/* on regarde si l'item correspond à un te ouvert */								if (G.saisieTE &&				(originalItem==G.saisieTEStItem+11) ){					// oui on fait te click						if (event->modifiers&shiftKey) flag=true; else flag=false;						pt=event->where;						GlobalToLocal(&pt);						TEClick(pt,flag,G.saisieTE);				} else {								/* 	Correspond pas au te en cours 					on le ferme et on en ouvre un autre				*/					if (G.saisieTE) {						TransfertSaisieMemoire();					}					/* et on ouvre celui sélectionné */				switch(originalItem) {					case 12:	// Texte TE							DoOpenSaisieTE(Texte_SousTitre);					break;					case 13:	// Commentaire TE							DoOpenSaisieTE(Commentaire_SousTitre);					break;					case 14:	// TC in TE							DoOpenSaisieTE(TimecodeIn_SousTitre);					break;					case 15:	// TC out TE							DoOpenSaisieTE(TimecodeOut_SousTitre);					break;					case 16:	// Durée TE							DoOpenSaisieTE(Duree_SousTitre);					break;						} // switch			} // if(originalItem==saisieTEStItem+12)		} // (originalItem>=12 && originalItem<=16)	/*	On dispatch les ordres reçues */	/* pour un visual feedback on enfonce les boutons*/		if (originalItem>0 && originalItem<12	||			originalItem>25 && originalItem<30	||			originalItem>=36 && originalItem<=43){ 				C_Hilite_icon_button(D,originalItem);				}														switch(originalItem){							case 1:		// ST suivant					TransfertSaisieMemoire();					do{						ST1=(SousTitreRecordPtr)ST_Ptr->st_NextST;					/* on regarde si le st suivant exite							si non, on en rajoute 1 					*/							if (ST1) {							oldstnum=G.General_SousTitreEncour;							G.General_SousTitreEncour=ST1->st_AbsNUMST;								UpdateSaisie();												CentreListingWindowByNumSTSimpleUpdate(G.General_SousTitreEncour,oldstnum);							ST_Ptr=ST1;							} else{							outboucle=true;							oldstnum=G.General_SousTitreEncour;							C_Hilite_icon_button(D,3);							C_InsertSt(ST_Ptr,32);							WaitTicks(20);							C_Unhilite_icon_button(D,3);							UpdateSaisie();										CentreListingWindowByNumSTSimpleUpdate(G.General_SousTitreEncour,oldstnum);						}					} while (Button() && outboucle==false);										GetKaraokeFromST(G.General_SousTitreEncour);					gModeSaisieTCState=0;				break;								case 2:		// ST précédent					TransfertSaisieMemoire();					do{							ST1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;					/* on regarde si le st précedent exite							si non, on s'arrête					*/							if (ST1) {							oldstnum=G.General_SousTitreEncour;							G.General_SousTitreEncour=ST1->st_AbsNUMST;								CentreListingWindowByNumSTSimpleUpdate(G.General_SousTitreEncour,oldstnum);								UpdateSaisie();												ST_Ptr=ST1;						} else	outboucle=true;					} while (Button() && outboucle==false);					gModeSaisieTCState=0;					GetKaraokeFromST(G.General_SousTitreEncour);				break;				case 3: 	// Insérer							TransfertSaisieMemoire();							C_Hilite_icon_button(D,3);							C_InsertSt(ST_Ptr,32);							CentreListingWindow();							UpdateSaisie();								GetKaraokeFromST(G.General_SousTitreEncour);							gModeSaisieTCState=0;				break ;	//----												case 4: 	// Rechercher							DoRechercheST(1); //// selecteur sur saisie 0= listing 1= saisie							gModeSaisieTCState=0;				break;					//----								case 5:	// pop up commentaire										menu=GetMenu(2000);						InsertMenu(menu,-1);						pt.h=190;						pt.v=20;						LocalToGlobal(&pt);						l=PopUpMenuSelect(menu,pt.v,pt.h,2);						DeleteMenu(2000);						ReleaseResource((Handle)menu);												if (LoWord(l)) {							DoCommentaire( LoWord(l) );							G.ChangeSinceLastSave=true; //on indique qu'il y a eu du changement						} // if l				break;						// ----				case 6:		// tc in + images									/* on prépare le undo */					DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);					if (G.saisieTE && G.saisieTEStItem==TimecodeIn_SousTitre)								TransfertSaisieMemoire();										l=1;					if (event->modifiers&optionKey)	l=0x100;								do {					if (ST_Ptr->st_TimeCodeIn!=-1)						ST_Ptr->st_TimeCodeIn=C_AdditionTimeCode(ST_Ptr->st_TimeCodeIn,l);						else outboucle=true;												DrawSaisieValuePartiel();						if ((TickCount()-ticks)<90)  WaitTicks(10);											} while (Button() && outboucle==false);					DrawSt_enCourDansListing();					break;		// ----				case 7:		// tc in - images										/* on prépare le undo */					DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);												if (G.saisieTE && G.saisieTEStItem==TimecodeIn_SousTitre)								TransfertSaisieMemoire();										l=1;					if (event->modifiers&optionKey)	l=0x100;								do {						if (ST_Ptr->st_TimeCodeIn!=-1)							ST_Ptr->st_TimeCodeIn=C_SoustractionTimeCode(ST_Ptr->st_TimeCodeIn,l);							else outboucle=true;												DrawSaisieValuePartiel();						if ((TickCount()-ticks)<90)  WaitTicks(10);					} while (Button() && outboucle==false);						DrawSt_enCourDansListing();					break;		// ----				case 8:		// tc out + images					/* on prépare le undo */					DoMakeUndo(TimecodeOut_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeOut);													if (G.saisieTE && G.saisieTEStItem==TimecodeOut_SousTitre)								TransfertSaisieMemoire();										l=1;					if (event->modifiers&optionKey)	l=0x100;										do {						if (ST_Ptr->st_TimeCodeOut!=-1)							ST_Ptr->st_TimeCodeOut=C_AdditionTimeCode(ST_Ptr->st_TimeCodeOut,l);						else outboucle=true;						DrawSaisieValuePartiel();						if ((TickCount()-ticks)<90) WaitTicks(10);											} while (Button() && outboucle==false);										// on redessine les tc du st dans listing et le suivant					DrawSt_enCourDansListing();						DrawSt_enCourDansListing_ByPointeur(ST_Ptr->st_AbsNUMST+1);												break;		// ----				case 9:		// tc out - images					/* on prépare l'undo */					DoMakeUndo(TimecodeOut_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeOut);												if (G.saisieTE && G.saisieTEStItem==TimecodeOut_SousTitre)								TransfertSaisieMemoire();					l=1;					if (event->modifiers&optionKey)	l=0x100;						do {						if (ST_Ptr->st_TimeCodeOut!=-1)								ST_Ptr->st_TimeCodeOut=C_SoustractionTimeCode(ST_Ptr->st_TimeCodeOut,l);						else outboucle=true;												DrawSaisieValuePartiel();						if ((TickCount()-ticks)<90) WaitTicks(10);					} while (Button() && outboucle==false);										// on redessine les tc du st dans listing et le suivant					DrawSt_enCourDansListing();						DrawSt_enCourDansListing_ByPointeur(ST_Ptr->st_AbsNUMST+1);					break;										// ----						case 10:	// Mark in					/* on prépare l'undo */					DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);												if (G.saisieTE && G.saisieTEStItem==TimecodeIn_SousTitre)								TransfertSaisieMemoire();									ST_Ptr->st_TimeCodeIn=TC;					DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour);						DrawSt_enCourDansListing_ByPointeur((long)(G.General_SousTitreEncour-1));						SetPort(D);					InvalRect(&D->portRect);					DoUpdate(D);				break;		// ----						case 11:	// Mark out									/* on prépare l'undo */					DoMakeUndo(TimecodeOut_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeOut);												if (G.saisieTE && G.saisieTEStItem==TimecodeOut_SousTitre)								TransfertSaisieMemoire();					ST_Ptr->st_TimeCodeOut=TC;					DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour);						DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour+1);						SetPort(D);					InvalRect(&D->portRect);					DoUpdate(D);				break;		// ----				case 26:	// style normal				DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);								if (G.saisieTE)					if (G.saisieTEStItem==Texte_SousTitre){					/* les styles ne sont pas continus on change donc tous les attibuts */					/* on place le nouveau style*/					TheStyle.tsFace=0;					TESetStyle(doFace,&TheStyle,true,G.saisieTE);					/* on indique qu'il y a eu du changement */					G.ChangeSinceLastSave=true;					DrawSt_enCourDansListing();						InvalRect(&D->portRect);				}				break;		//----										case 27:	// style italique						DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);				if (G.saisieTE)					if (G.saisieTEStItem==Texte_SousTitre){					/* les styles ne sont pas continus on change donc tous les attibuts */					/* on place le nouveau style*/					TheStyle.tsFace=italic;					TESetStyle(doFace,&TheStyle,true,G.saisieTE);					/* on indique qu'il y a eu du changement */					G.ChangeSinceLastSave=true;					DrawSt_enCourDansListing();						InvalRect(&D->portRect);					}				break;								case 28:	// style gras					DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);											if (G.saisieTE)					if (G.saisieTEStItem==Texte_SousTitre){					/* les styles ne sont pas continus on change donc tous les attibuts */					/* on place le nouveau style*/					TheStyle.tsFace=bold;					TESetStyle(doFace,&TheStyle,true,G.saisieTE);					/* on indique qu'il y a eu du changement */					G.ChangeSinceLastSave=true;					DrawSt_enCourDansListing();						InvalRect(&D->portRect);				}				break;								case 29:	// dialog fonte						a=0;												if (G.saisieTE){							a=doFont;							if (TEContinuousStyle(&a,&TheStyle, G.saisieTE) ){								a=GiveFontItemNumber(TheStyle.tsFont);								CheckItem(G.PopUp_Font,a,true);							}						}	else {								a=GiveFontItemNumber(G.General_FontNumber);								CheckItem(G.PopUp_Font,a,true);												}												pt.h=rect.left-40;						pt.v=rect.top+8;						LocalToGlobal(&pt);						mresult=PopUpMenuSelect(G.PopUp_Font,pt.v,pt.h,a);						if (mresult) {							TheStyle.tsFont=GiveFontID(mresult&0xffff);							G.General_FontNumber=TheStyle.tsFont;							KeyScript( FontToScript(TheStyle.tsFont));							if (G.saisieTE) TESetStyle(doFont,&TheStyle, true,G.saisieTE);							}						CheckItem(G.PopUp_Font,a,false);											C_Unhilite_icon_button((DialogPtr)&G.DialogSaisie,29);					D=(DialogPtr)&G.DialogSaisie;				break;		//----						case 36:	// tracking saisie time-code									TransfertSaisieMemoire();							/* on recherche le st correspondant au tc courant */					l=G.General_TCCourant;					ST1=C_ConversionTimeCodePointeur(l);					G.General_SousTitreEncour=ST1->st_AbsNUMST;									/* 	On place le st => saisie						On centre la fenêtre listing sur ce nouveau TC				*/									CentreListingWindow();					InvalRect(&D->portRect);				break;						//----						case 37:	// justification gauche					ST_Ptr->st_Justification=1; 					InvalRect(&D->portRect);				/* on indique qu'il ya eu modification */					G.ChangeSinceLastSave=true;					/* on update listing */					DrawSt_enCourDansListing();									/*  on raz le processeur d'affichage */					G.Sous_titre_dessined=nil	;						G.Sous_titreInOffscreen=nil;								/* si carte d'affichage on efface le sous-titre en cours 					travail effectué par la vbl task				*/					if (G.Base_Adresse) {						G.DrawState=0x8000;						do{}while(G.DrawState&0xff00);						}										/* s'il y a un te texte ouvert on change la justif */					if (G.saisieTE) 						if (G.saisieTEStItem==Texte_SousTitre){							a=C_get_STJustification(ST_Ptr);							TESetJust(a,G.saisieTE);						}								break;					//----												case 38:	// justification centrée					ST_Ptr->st_Justification=0; 					InvalRect(&D->portRect);				/* on indique qu'il ya eu modification */				G.ChangeSinceLastSave=true;					/* on update listing */				DrawSt_enCourDansListing();									/*  on raz le processeur d'affichage */					G.Sous_titre_dessined=nil	;						G.Sous_titreInOffscreen=nil;						/* si carte d'affichage on efface le sous-titre en cours 					travail effectué par la vbl task				*/					if (G.Base_Adresse) {						G.DrawState=0x8000;						do{}while(G.DrawState&0xff00);						}										/* s'il y a un te texte ouvert on change la justif */					if (G.saisieTE) 						if (G.saisieTEStItem==Texte_SousTitre){							a=C_get_STJustification(ST_Ptr);							TESetJust(a,G.saisieTE);						}			break;		//----									case 39 : 	// justification droite					ST_Ptr->st_Justification=2; 					InvalRect(&D->portRect);				/* on indique qu'il ya eu modification */				G.ChangeSinceLastSave=true;					/* on update listing */				DrawSt_enCourDansListing();									/*  on raz le processeur d'affichage */					G.Sous_titre_dessined=nil	;						G.Sous_titreInOffscreen=nil;						/* si carte d'affichage on efface le sous-titre en cours 					travail effectué par la vbl task				*/					if (G.Base_Adresse) {						G.DrawState=0x8000;						do{}while(G.DrawState&0xff00);						}										/* s'il y a un te texte ouvert on change la justif */					if (G.saisieTE) 						if (G.saisieTEStItem==Texte_SousTitre){							a=C_get_STJustification(ST_Ptr);							TESetJust(a,G.saisieTE);						}			break;						//----							case 40:  	// position sous titre				// au boulot							// on ajoute une couche alpha au cursor				//CursorMask,CursorData,CurD,CurM;				if(G.Base_Adresse)					do{						CurD=(**G.Ve_GDHandle).gdCCXData;						CurM=(**G.Ve_GDHandle).gdCCXMask;						CursorData=CurD;						//CursorMask=CurM;						//HandToHand(&CurD);						//HandToHand(&CurM);						P=*CursorData;											for (j=0;j<256;j++){								l=*((long*)P)|0xff000000;								*((long*)P)=l;								P=P+4;						}										}while(StillDown());								break;						//----									case 41:	// dessine sous titre								if(G.Base_Adresse) {			/* on force le mode overriding attributs off */					a=G.Overriding_All_Attribute;					G.Overriding_All_Attribute=0; 					/* on arrète l'affichage en cour */					G.DrawState=0x8000;					do{}while(G.DrawState&0xff00);			/* on raz la carte d'affichage */					C_ClearVx();			/* on dessine le sous-titre */					ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);					G.Sous_titre_dessined=ST_Ptr;				if (ValidST(ST_Ptr)==0)					CC_Draw_SousTitre(ST_Ptr,G.X_Offset,G.Y_Offset,												G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect);				/* on affiche le resultat sur l'écran */					G.DrawState=0x8001;					do{}while(G.DrawState&0xff00);						/* on rend le mode */					// on gère le bouton					do{}while(StillDown());										G.DrawState=0x8000;					do{}while(G.DrawState&0xff00);					G.Overriding_All_Attribute=a;					C_Unhilite_icon_button((DialogPtr)&G.DialogSaisie,41);				} // existe t-il une carte d'affichage 				// mode simulation ?				else  if (gAVDevice  &&((WindowPeek)gMonitor)->visible ){					EffaceFenetreSimulation();					DessineAVST( ST_Ptr,(gAntiAlias!=0));					if (gAntiAlias) transfertAVOffscreenInScreen();					do{}while(StillDown());					EffaceFenetreSimulation();					C_Unhilite_icon_button((DialogPtr)&G.DialogSaisie,41);					G.Sous_titreInOffscreen=nil;				}							break;					//----								case 42: 	// configuration cache							a=(short)ST_Ptr->st_MasKType;				a=Configuration_Cache(a);				SetPort(D);				if (a!=-1){					ST_Ptr->st_MasKType=a;					DrawSt_enCourDansListing();					}				C_Unhilite_icon_button((DialogPtr)&G.DialogSaisie,42);				break;				case 43: 	// fermeture case texte						TransfertSaisieMemoire();						CentreListingWindow();						UpdateSaisie();							LastTeItem=-1; //on indique qu'il ne faut pas réouvrir le texte						VerifieTexteUnSousTitre(ST_Ptr);						C_Unhilite_icon_button((DialogPtr)&G.DialogSaisie,43);				break;												case 44: 	// menu couleur						menu=GetMenu(2016);						InsertMenu(menu,-1);						a=0;												if (G.saisieTE){							a=doColor;							if (TEContinuousStyle(&a,&TheStyle, G.saisieTE) ){							}						} else {							a=1;							//CheckItem(G.PopUp_Font,a,true);						}												pt.h=rect.left-40;						pt.v=rect.top+8;						LocalToGlobal(&pt);						mresult=PopUpMenuSelect(menu,pt.v,pt.h,a);												if (mresult) {	//						if (G.saisieTE) TESetStyle(doColor,&TheStyle, true,G.saisieTE);							}						//CheckItem(G.PopUp_Font,a,false);												D=(DialogPtr)&G.DialogSaisie;											DeleteMenu(2016);						ReleaseResource((Handle)menu);												C_Unhilite_icon_button((DialogPtr)&G.DialogSaisie,44);				break;																// l'item qui dit "validation" ou tracking				// ne sert que quand il ya un te				case 46:						GetDItem(D,46,&itemtype,&item,&rect);						TextSize(9);				if (G.saisieTE){					InvertRect(&rect);					do{}while(Button());				// on attend le mouse up					InvertRect(&rect);				// on ferme le te						TransfertSaisieMemoire(); 					G.ChangeSinceLastSave=true;					Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères			/*  on raz le processeur d'affichage */					G.Sous_titre_dessined=nil	;						G.Sous_titreInOffscreen=nil;						LastTeItem=0; // pour ne pas réouvrir le te				}					break;					} // switch item							originalItem=FindDItem((DialogPtr)&G.DialogSaisie,mouse)+1;			ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);			SetPort((DialogPtr)&G.DialogSaisie);// on inhibe le sous-titre in offscreen						G.Sous_titreInOffscreen=nil;// on invalide le sous-titre dans le buffer d'affichage// si le sous-titre est en cours on le rafraichi	if (originalItem>0 && originalItem<43)	// si click dans items 		if(G.Base_Adresse)  // si l'on a une carte			if (G.Sous_titre_dessined==ST_Ptr) {			/* on raz la carte d'affichage */					C_ClearVx();			/* on dessine le sous-titre */					ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);					G.Sous_titre_dessined=ST_Ptr;										if (ValidST(ST_Ptr)==0)						CC_Draw_SousTitre(ST_Ptr,G.X_Offset,G.Y_Offset,												G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect);			} else  G.Sous_titre_dessined=nil; // si non on l'inhibe			ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);						/* on gère le feedback visuel des boutons */		if ( 				(originalItem>0 && originalItem<12) || 		 	(originalItem>25 && originalItem<30) ||			(originalItem>36 && originalItem<=43) 			)	TrackCurseur(D,originalItem);				/* On regarde s'il faut réouvrir le texte handle,	*/			if (!G.saisieTE)			if (LastTeItem==Texte_SousTitre)				DoOpenSaisieTE(Texte_SousTitre);	/*	On vérifie le sous-titre		et on signale les erreurs	*/		VerifieTimeCodes(ST_Ptr);		SignalErreurSousTitre(ST_Ptr);			/* On rafraichie les valeurs générales (1 er tc et dernier TC )*/				UpdateGeneralValue();		SetPort(oldport);} // DoDialogSaisieEvent/* Cette routine ouvre un texte edit dans la fenêtre saisie */pascal void DoOpenSaisieTE(short type){SousTitreRecordPtr ST_Ptr;DialogPtr		D=(DialogPtr)&G.DialogSaisie;short itemtype,a;Handle item;Rect rect,rect1;RGBColor Fcolor,Bcolor,blanc,noir;Str255	string;GrafPtr	oldport;long	l;TextStyle			newStyle;	noir.red=0;	noir.green=0;	noir.blue=0;		blanc.red=-1;	blanc.green=-1;	blanc.blue=-1;		rect1.left=0;	rect1.top=0;	rect1.bottom=0;	rect1.right=0;		GetPort(&oldport);		SetPort(D);	GetForeColor(&Fcolor);	GetBackColor(&Bcolor);		RectRgn(D->clipRgn,&D->portRect);		RGBForeColor(&noir);	RGBBackColor(&blanc);		ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);	SetRect(&rect1,0,0,1,1);	switch (type){				case Texte_SousTitre:		// on prépare le bigniou			GetDItem(D,12,&itemtype,&item,&rect);// on force la police par default// et la taille des caractères			TextFace(0);			TextSize(14);			TextFont(G.General_FontNumber);			KeyScript( FontToScript(G.General_FontNumber));						G.saisieTE=TEStylNew(&rect1,&rect1);			G.saisieTEStNum=(long)G.General_SousTitreEncour;			G.saisieTEStItem=type;			(**G.saisieTE).crOnly=true;			TEAutoView(true,G.saisieTE);			TEFromScrap();			// on place les vrai coordonnées du te			(**G.saisieTE).destRect=rect;			(**G.saisieTE).viewRect=rect;			// on place le texte du sous-titre dans le te			TRANSFERTTEXTE_MEMOIRE_STYLETE(G.saisieTE,ST_Ptr,&rect1,-1);			a=C_get_STJustification(ST_Ptr);			TESetJust(a,G.saisieTE);			// on place les vrai coordonnées du rectangle			(**G.saisieTE).destRect=rect;			(**G.saisieTE).viewRect=rect;// on sélectionne tous le texte et on place la taille 14			TESetSelect(0,32767,G.saisieTE);			newStyle.tsSize=14;			TESetStyle(doSize,&newStyle,false,G.saisieTE);			TECalText(G.saisieTE);					// on dessine le texte du sous-titre , on efface le texte			EraseRect(&rect);			InsetRect(&rect,-1,-1);			FrameRect(&rect);			InsetRect(&rect,1,1);					/* on place le curseur à la fin */			TEUpdate(&rect,G.saisieTE);			TESetSelect(32767,32767,G.saisieTE);			TEActivate(G.saisieTE);			// on prépare les chiffres			Draw_Line_Number_Saisie();		break;		case Commentaire_SousTitre:			GetDItem(D,13,&itemtype,&item,&rect);			EraseRect(&rect);			InsetRect(&rect,-1,-1);			FrameRect(&rect);			InsetRect(&rect,1,1);			TextFace(0);			TextFont(geneva);			TextSize(9);			G.saisieTE=TEStylNew(&rect,&rect);			G.saisieTEStNum=(long)G.General_SousTitreEncour;			G.saisieTEStItem=type;						if (ST_Ptr->st_CommentaireLenth)					TESetText(ST_Ptr->st_CommentairePtr,ST_Ptr->st_CommentaireLenth,G.saisieTE);			/* on place le curseur à la fin */			TESetSelect(32766,32766,G.saisieTE);						/* on place le mode cr only */			(**G.saisieTE).crOnly=true;			TEAutoView(true,G.saisieTE);			TEFromScrap();			TEActivate(G.saisieTE);			TEUpdate(&rect,G.saisieTE);		break;		case TimecodeIn_SousTitre:			GetDItem(D,14,&itemtype,&item,&rect);			EraseRect(&rect);			InsetRect(&rect,-1,-1);			FrameRect(&rect);			InsetRect(&rect,1,1);			TextFace(0);			TextFont(geneva);			TextSize(14);			G.saisieTE=TEStylNew(&rect,&rect);			G.saisieTEStNum=(long)G.General_SousTitreEncour;			G.saisieTEStItem=type;			if (ST_Ptr->st_TimeCodeIn!=-1){					C_ConversionTCstASCII(ST_Ptr->st_TimeCodeIn,&string);					TESetText(&string[1],(long)string[0],G.saisieTE);					}			/* on place le curseur à la fin */			TESetSelect(32766,32766,G.saisieTE);						/* on place le mode cr only */			(**G.saisieTE).crOnly=true;			TEAutoView(true,G.saisieTE);			TEFromScrap();			(**G.saisieTE).destRect=rect;			(**G.saisieTE).viewRect=rect;			TEActivate(G.saisieTE);			TEUpdate(&rect,G.saisieTE);		break;		case TimecodeOut_SousTitre:			GetDItem(D,15,&itemtype,&item,&rect);			EraseRect(&rect);			InsetRect(&rect,-1,-1);			FrameRect(&rect);			InsetRect(&rect,1,1);			TextFace(0);			TextFont(geneva);			TextSize(14);			G.saisieTE=TEStylNew(&rect,&rect);			G.saisieTEStNum=(long)G.General_SousTitreEncour;			G.saisieTEStItem=type;			if (ST_Ptr->st_TimeCodeOut!=-1){					C_ConversionTCstASCII(ST_Ptr->st_TimeCodeOut,&string);					TESetText(&string[1],(long)string[0],G.saisieTE);					}			/* on place le curseur à la fin */			TESetSelect(32766,32766,G.saisieTE);						/* on place le mode cr only */			(**G.saisieTE).crOnly=true;			TEAutoView(true,G.saisieTE);			TEFromScrap();			(**G.saisieTE).destRect=rect;			(**G.saisieTE).viewRect=rect;			TEActivate(G.saisieTE);			TEUpdate(&rect,G.saisieTE);		break;				case Duree_SousTitre:			GetDItem(D,16,&itemtype,&item,&rect);			EraseRect(&rect);			InsetRect(&rect,-1,-1);			FrameRect(&rect);			InsetRect(&rect,1,1);			TextFace(0);			TextFont(geneva);			TextSize(9);			G.saisieTE=TEStylNew(&rect,&rect);			G.saisieTEStNum=(long)G.General_SousTitreEncour;			G.saisieTEStItem=type;			if (ST_Ptr->st_TimeCodeIn!=-1 &&				ST_Ptr->st_TimeCodeOut!=-1 ){					l=C_SoustractionTimeCode(ST_Ptr->st_TimeCodeOut,ST_Ptr->st_TimeCodeIn);					C_ConversionTCstASCII(l,&string);					TESetText(&string[4],8,G.saisieTE);				}			/* on place le curseur à la fin */			TESetSelect(32766,32766,G.saisieTE);						/* on place le mode cr only */			(**G.saisieTE).crOnly=true;			TEAutoView(true,G.saisieTE);			TEFromScrap();			(**G.saisieTE).destRect=rect;			(**G.saisieTE).viewRect=rect;			TEActivate(G.saisieTE);			TEUpdate(&rect,G.saisieTE);					break;	} // switch//	RGBForeColor(&Fcolor);//	RGBBackColor(&Bcolor);		RGBForeColor(&noir);		RGBBackColor(&blanc);				SetPort(oldport);} //pascal void DoOpenSaisieTE(short type);pascal void	SignalErreurSousTitre(SousTitreRecordPtr st){	st=st;}/* 	-------------------------------------------------------------------------------------		Le groupe de routine suivante gèrent les mouse down dans la fenêtre listing  	-------------------------------------------------------------------------------------*//* Cette routine dispatch les mouse down dans la fenêtre listing 	en commençant par déterminer si click dans le control ou non*/pascal void DoMouseDownListing(EventRecord *event){Point			mouse;GrafPtr			savePort;short			part;ControlHandle	control;	GetPort(&savePort);	SetPort((GrafPtr)&G.ListingWindow);	mouse=event->where;	GlobalToLocal(&mouse);		/* on regarde si c'est un click dans le control	*/			part = FindControl(mouse, (WindowPtr)&G.ListingWindow, &control);	/* si click dans control on effectue des taches au préalable */					if (part){				/* On regarde s'il faut	désactiver le tracking temporaire				*/					if (!G.Preference_Tracking&3==3) 						if (G.Preference_Tracking&1) {							G.Preference_Tracking=G.Preference_Tracking&2;							FlashTracking();							}						/* s'il y a un te ouvert on le ferme */					if (G.ListingTE) {					SetPort((WindowPtr)&G.ListingWindow);					TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);					TEDispose(G.ListingTE);					G.ListingTE=nil;					InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					}							switch ( part ) {					case 0:												break;											case inUpButton :					case inDownButton :					case inPageUp :					case inPageDown :						part = TrackControl(control, mouse,(ControlActionUPP)&ControlActionProc);						break;											case inThumb:						part = TrackControl(control, mouse, (ControlActionUPP)nil);						DrawListingWindow();					break;		} // switch control part	 } // if part !=0 (in thumb)	 else DoClickInListingWindowContent(event,mouse);	 	SetPort(savePort);}/*               ------------------------ 	cette routine gère les mouse down dans le contenu de listing */		pascal void DoClickInListingWindowContent(EventRecord *event,Point mouse){Rect				rect;WindowPtr	w=(WindowPtr)&G.ListingWindow;Boolean			gereevent;	/* premiere chose on détermine si l'on a clické dans la barre du bas	*/	rect=w->portRect;	rect.top=rect.bottom-16;	rect.right=rect.right-16;		if (PtInRect(mouse,&rect) ){		DoListingBarreOutils(mouse); // oui c'est la barre du bas		return;		}		/* on regarde si cela est potentiellement dans un sous-titre */	rect=w->portRect;	rect.left+=3;	rect.top+=4;	rect.right-=20;	rect.bottom-=18;		if (PtInRect(mouse,&rect) ) {		// on regarde pour le tracking */			if (!G.Preference_HardTracking&3) 						if (G.Preference_Tracking&1) {							G.Preference_Tracking=G.Preference_Tracking&2;							FlashTracking();							}			gereevent=true; // potentiellement on gère le click						/* On regarde s'il y a un te ouvert et click dedans */				if (G.ListingTE) {				if (PtInRect(mouse,&((**G.ListingTE).viewRect)) ){										/* 	Click dans le TE 						On gère le extend shift					*/										if (event->modifiers&shiftKey)	TEClick(mouse,true,G.ListingTE);														else		TEClick(mouse,false,G.ListingTE);												gereevent=false; // on ne gère pas le click									} else {									/* pas click dans le TE, on le ferme */					SetPort((WindowPtr)&G.ListingWindow);					TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);					TEDispose(G.ListingTE);					G.ListingTE=nil;					InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);										if (G.ListingTEStNum==G.General_SousTitreEncour){	/* on update si même st dans */									 SetPort((GrafPtr)&G.DialogSaisie);									 InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);									 }				 }			}			if (gereevent)  GereClickDansSTListing(event,mouse);	}// oui pontentiellement dans un sous-titre} //DoClickInListingWindowContent/* on gère le click dans un sous-titre */ pascal void GereClickDansSTListing(EventRecord *event,Point mouse){long				a,b,c,d,start,i;Boolean			releve;short		SousTitre,lastteitem,value,laststencours;Rect			box,rect,rect2,rect3;short		type,x,y,dowaittheclick;Handle		hndl;GrafPtr		wMgrCPort,oldport;RgnHandle		rgn;EventRecord 	event2;	/* il y a 3 mode d'actions :			double click : on le descend dans listing			click long : on active un te		click cour + drag on drag le sous-titre (vers saisie)		(on pouurais envisager un palette flottante pour 				l'orthographe + je ne sais pas encore		(anciennement c'était pour faire montée descente liste version<1,5)	*/			SousTitre=(mouse.v-4)/G.HauteurST+GetCtlValue(G.ListingVScroll);	value=SousTitre-GetCtlValue(G.ListingVScroll);	if (((long)SousTitre)<=G.General_NombreST){  // n° de sous-titre valide								/* double click ?*/		a=TickCount()-G.CaseATickCountListing;		if (a<=LMGetDoubleTime()){				/* on fait une animation pour dire que l'on a compris l'ordre */					GetPort(&(GrafPtr)oldport);					SetPort((GrafPtr)&G.DialogSaisie);										// on recupère les coordonées d'arrivée					//GetDialogItem((DialogPtr)&G.DialogSaisie, 12,&type,&hndl,& box);					box=((WindowPtr)&G.DialogSaisie)->portRect;					LocalToGlobal((Point*)&box);	// on converti en coordonnée globales					LocalToGlobal((Point*)&box+1);										// les coordonées de départs					SetPort((GrafPtr)&G.ListingWindow);					SetRect(&rect,4,value*G.HauteurST,4+417,(value+1)*G.HauteurST);					LocalToGlobal((Point*)&rect);	// on converti en coordonnée globales					LocalToGlobal((Point*)&rect+1);															GetWMgrPort(&wMgrCPort);					SetPort(wMgrCPort);	// on dessine dans tous l'espace quickdraw					rgn=NewRgn();					GetClip(rgn);					SetClip(GetGrayRgn());										PenSize(2,2);					PenPat(&QD.gray);					PenMode(srcXor);					SetRect(&rect3,0,0,0,0);					for (i=0;i<201;i++){							a=( (long)box.left*i)/100;							a+=( (long)rect.left*(200-i) )/100; 							a=a/2;														b=( (long)box.top*i)/100;							b+=( (long)rect.top*(200-i) )/100;							b=b/2;							c=( (long)box.right*i)/100;							c+=( (long)rect.right*(200-i) )/100;							c=c/2;							d=( (long)box.bottom*i)/100;							d+=( (long)rect.bottom*(200-i) )/100;							d=d/2;						SetRect(&rect2,a,b,c,d);							FrameRect(&rect2);						FrameRect(&rect3);						rect3=rect2;					}										FrameRect(&rect2);					PenNormal();					SetClip(rgn);					SetPort((GrafPtr)oldport);					DisposeRgn(rgn);										laststencours=G.General_SousTitreEncour;				/* c'est un double click */				if (G.ListingTE) {						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						}										lastteitem=-1;																									// on ferme le te dans saisie s'il était ouvert					if (G.saisieTE) {						lastteitem=G.saisieTEStItem;						TransfertSaisieMemoire();						}					SetPort((GrafPtr)&G.DialogSaisie);										G.General_SousTitreEncour=(short)SousTitre;					CentreListingWindowByNumSTSimpleUpdate(SousTitre,laststencours);										// on selectionne la fenetre saisie					SelectReferencedWindow   ((WindowReference)&G.DialogSaisie);					ShowReferencedWindow	((WindowReference)&G.DialogSaisie);										UpdateSaisie();										// si le te saisie était ouvert on réouvre l'item qui était ouvert					if (lastteitem==Texte_SousTitre) {												// on fait une animation pour dire que l'on ouvre le te saisie	 						GetDialogItem((DialogPtr)&G.DialogSaisie, 12,&type,&hndl,& box);												x=(box.right+box.left)/2;						y=(box.top+box.bottom)/2;											PenPat(&QD.gray);						PenMode(srcXor);						PenSize(2,2);						for (i=0;i<21;i++){							SetRect(&rect,box.left+( x-( x*i)/20),										box.top+(y-( y*i)/20),										box.right-(x-( x*i)/20),										box.bottom-(y-( y*i)/20) );												FrameRect(&rect);							WaitTicks(1);							FrameRect(&rect);						}												DoOpenSaisieTE(Texte_SousTitre);					}										PenNormal();					G.CaseATickCountListing=TickCount();					return;						} else {				G.CaseATickCountListing=TickCount();		/* pas double click */			 /* drag ou open TE ?*/			 /* on attend 1 seconde pour voir si long click ou drag 			 	sauf si appui sur la touche alt			 */			 	dowaittheclick=true;			 	if (event)	{			 		a=event->modifiers;			 		a=a&optionKey;			 		if (a){						dowaittheclick=false;						releve=false;				 	}				}								if (dowaittheclick) {					start=TickCount();					if (!Button()) return;					releve=false;														do{						 EventAvail(-1,&event2); //mDownMask						 // on regarde si l'on a bougé la souris						GlobalToLocal(&event2.where);						if (	abs(event2.where.h-mouse.h)>5 ||								abs(event2.where.v-mouse.v)>5) releve=true;							if (!Button()) releve=true;											 } while ( (TickCount() -start)<50  &&  (!releve) );				} //if (dowaittheclick)																if (releve) 						DotheDragInListing(mouse);					else						OpenTheTEListing(mouse);			} // pas double click			} // selection dans un sous-titre} // gère click dans un sous-titre de listingpascal void DoListingBarreOutils(Point mouse){Rect	rect,rect1,rect2,port_rect;WindowPtr	w=(WindowPtr)&G.ListingWindow;Str255			st0;Boolean			b1,b2;Point			pt;MenuHandle	menu,menu1;long				mresult;short			st_trouve,value,max;			/*s'il y a un ouvert on le ferme (car pas possible que click dedans)  */				if (G.ListingTE) {					TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);					TEDispose(G.ListingTE);					G.ListingTE=nil;										// on redessine le sous-titre du te					DrawSt_enCourDansListing_ByPointeur(G.ListingTEStNum);										/* on update saisie si le même n° de sous-titre*/					if (G.ListingTEStNum==G.General_SousTitreEncour){							SetPort((GrafPtr)&G.DialogSaisie);						 InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);						 SetPort(w);						 }				 }		/* on détermine dans quel bouton on a frappé */		port_rect=w->portRect;		port_rect.right-=16;		port_rect.bottom-=16;				TextFont(geneva);	// pour une version internationnale		TextSize(9);				/* bouton tracking		*/			rect=w->portRect;		rect.top=rect.bottom-14;		rect.right=119; // 1 relief		rect1=rect;		if (PtInRect(mouse,&rect)){			InvertRect(&rect);						if (G.Preference_Tracking&1)	G.Preference_Tracking=G.Preference_Tracking&2;			 else G.Preference_Tracking=G.Preference_Tracking|1;								// on en profite pour centrer la fenêtre su le tc courant					st_trouve=(short) (C_ConversionTimeCodePointeur(G.General_TCCourant))->st_AbsNUMST   ;			max=GetCtlMax(G.ListingVScroll);			value=st_trouve-G.ListingMaxDisplay/2+1;			if (value<(G.ListingMaxDisplay-1)) value=1;			if (value>(max-(G.ListingMaxDisplay/2)) ) value=max-(G.ListingMaxDisplay/2);			SetCtlValue(G.ListingVScroll,value);			DrawListingWindow();						}// bouton tracking		/* 	bouton preset time code			 ou offset lecture TC		*/				rect.left=rect.right+2;		rect.right=257; // 1 relief		rect1=rect;		rect.left=rect.right;		rect.right=457; // 1 relief		rect1=rect;		/* 	mode tc interne  ?		*/						GetIndString(&st0,132,20);		rect2.left=rect.left+136;		rect2.right=rect2.left+StringWidth(&st0)+8;		rect2.top=rect.top+1;		rect2.bottom=rect.bottom-1;					if (PtInRect(mouse,&rect2)){			if (G.LecteurTimeCode_Type==0){// preset interne?				InvertRoundRect(&rect2,4,4);				C_PrepositionneTCInterne();				SetPort(w);				DessineBarreControlListing();			} else {								InvertRoundRect(&rect2,4,4);				OffsetLectureTC(); // non mode offset  tc				SetPort(w);				DessineBarreControlListing();			}			} 		/*	l'icône de sauvegarde		*/		rect1.left=460;		rect1.bottom=w->portRect.bottom;		rect1.top=rect1.bottom-14;		rect1.right=rect1.left+14;		// on check seulement s'il y besoin de sauvegarder		if (G.ChangeSinceLastSave&0x7fff) 		if (PtInRect(mouse,&rect1)){				InvertRect(&rect1);				b1=true;				do{					b2=PtInRect(mouse,&rect1);										if (b2 !=b1) {						InvertRect(&rect1);						b1=b2;						}								}while (Button());				if (b2) C_SaveData(nil);				SetPort((GrafPtr)&G.ListingWindow);				DessineBarreControlListing();			}//icon sauvegarde									/* l'icône reception série		*/			rect1.left+=18;			rect1.right+=18;			if (PtInRect(mouse,&rect1)){				InvertRect(&rect1);								// on actionne le menu				menu1=GetMenu(137);				menu=GetMenu(2013);								InsertMenu(menu,-1);				InsertMenu(menu1,-1);								if (gDecodeBlanckingVertical) EnableItem (menu,5);					else DisableItem (menu,5);									pt.h=rect1.left+8;				pt.v=rect1.top+8;				LocalToGlobal(&pt);								if (G.LecteurTimeCode_Type!=2) CheckItem(menu,G.LecteurTimeCode_Type+1,true);				CheckItem(menu1,G.Player_TC_src+1,true);				mresult=PopUpMenuSelect(menu,pt.v,pt.h,G.LecteurTimeCode_Type+1);								if (G.LecteurTimeCode_Type!=2)CheckItem(menu,G.LecteurTimeCode_Type+1,false);				CheckItem(menu1,G.Player_TC_src+1,false);								DeleteMenu(2013);				DeleteMenu(137);				ReleaseResource((Handle)menu);					ReleaseResource((Handle)menu1);							if (mresult) {					// on ferme le port modem					if (G.ModemInRefNum) KillIO(G.ModemInRefNum); 					if (G.ModemOutRefNum)KillIO(G.ModemOutRefNum); 										SerSetBuf(G.ModemInRefNum,SerBuff1,0); //{set the buffer}					WaitTicks(8);					if (G.ModemInRefNum)FSClose(G.ModemInRefNum);					if (G.ModemOutRefNum)FSClose(G.ModemOutRefNum);															if (HiWord(mresult)==137){						// sous menu lecteur rs 422							G.LecteurTimeCode_Type=2; 	//lecteur rs422							G.Player_TC_src=LoWord(mresult)-1; 				//type de time code					} else {						// pas sousmenu							G.LecteurTimeCode_Type=LoWord(mresult)-1;							G.Player_TC_src=0;					}					// on inscrit le mode dans les préférences					SetSerialPreference();					// on ré-ouvre le port modem					// on tient compte de la protection logicielle					// on inclut des conditions de compilation pour faire des version sans protection, ou de démo#ifdef __NoProtect__					InitSerial();#endif#ifndef __NoProtect__					// on ré-ouvre le port modem					if (!G.FindFirstKey_error)InitSerial();					 else  if (G.SoftProtect==1)InitSerial();					#endif		   									}// un item selected								// on update la barre d'outils de la fenêtre listing				SetPort(w);				DessineBarreControlListing();			}// reception série				/* l'icône commutateur		*/				rect1.left+=18;			rect1.right+=18;			if (PtInRect(mouse,&rect1)){				InvertRect(&rect1);								// on actionne le menu				menu=GetMenu(2005);				InsertMenu(menu,-1);								if (G.LecteurTimeCode_Type!=2) {					DisableItem(menu,1); 					DisableItem(menu,2); 					DisableItem(menu,3); 				} else {					EnableItem(menu,1);					EnableItem(menu,2);					EnableItem(menu,3);				}								pt.h=rect1.left+8;				pt.v=rect1.top+8;				LocalToGlobal(&pt);				CheckItem(menu,G.Mode_Commutateur+1,true);				mresult=PopUpMenuSelect(menu,pt.v,pt.h,G.Mode_Commutateur+1);				DeleteMenu(2005);				ReleaseResource((Handle)menu);						if (mresult) {					// on ferme le port modem					if (G.ModemInRefNum) KillIO(G.ModemInRefNum); 					if (G.ModemOutRefNum)KillIO(G.ModemOutRefNum); 										SerSetBuf(G.ModemInRefNum,SerBuff1,0); //{set the buffer}					WaitTicks(8);					if (G.ModemInRefNum)FSClose(G.ModemInRefNum);					if (G.ModemOutRefNum)FSClose(G.ModemOutRefNum);										G.Mode_Commutateur=LoWord(mresult)-1;										// on ré-ouvre le port modem					// on tient compte de la protection logicielle					// on inclut des conditions de compilation pour faire des version sans protection, ou de démo#ifdef __NoProtect__					InitSerial();#endif#ifndef __NoProtect__					// on ré-ouvre le port modem					if (!G.FindFirstKey_error)InitSerial();					 else  if (G.SoftProtect==1)InitSerial();					#endif#ifndef __NoProtect__	#ifdef __Demo__					InitSerial();	#endif#endif	   					// on inscrit le mode dans les préférences					SetSerialPreference();										}//mresult									// on update la barre d'outils de la fenêtre listing				SetPort(w);				DessineBarreControlListing();			}// commutateur								/* l'icône zoom out		*/							rect1.left+=18;			rect1.right+=18;			if (PtInRect(mouse,&rect1)){				InvertRect(&rect1);				if (G.HauteurST>64){					b1=true;					do{						b2=PtInRect(mouse,&rect1);												if (b2 !=b1) {							InvertRect(&rect1);							b1=b2;							}						if (b2){								G.HauteurST-=10;							G.HauteurST= (((G.HauteurST-4)/5)*5)+4;							if (G.HauteurST<64) G.HauteurST=64;							InvalRect(&port_rect);							BeginUpdate(w);							DrawListingWindow();							EndUpdate(w);							WaitTicks(4);						}					}while (Button());				}// pas inf ou = taille mini 						else do{}while (Button());				InvalRect(&rect1);			}// zoom out					/* l'icône zoom in		*/							rect1.left+=18;			rect1.right+=18;			if (PtInRect(mouse,&rect1)){				InvertRect(&rect1);				if (G.HauteurST<100){					b1=true;					do{						b2=PtInRect(mouse,&rect1);											if (b2 !=b1) {							InvertRect(&rect1);							b1=b2;							}						if (b2){								G.HauteurST+=10;							G.HauteurST= (((G.HauteurST-4)/5)*5)+4;							if (G.HauteurST>100) G.HauteurST=100;							InvalRect(&port_rect);							BeginUpdate(w);							DrawListingWindow();							EndUpdate(w);							WaitTicks(4);						}											}while (Button());				} // pas = ou sup max						else do{}while (Button());				InvalRect(&rect1);			}// zoom in		/* l'icône affiche ¶		*/							rect1.left+=18;			rect1.right+=18;			if (PtInRect(mouse,&rect1)){				InvertRect(&rect1);				// on actionne le menu				menu=GetMenu(2014);				InsertMenu(menu,-1);								if (G.affiche_CR_Flag) {					CheckItem (menu,1,false);					CheckItem (menu,2,true);				} else {					CheckItem (menu,1,true);					CheckItem (menu,2,false);				}								pt.h=rect1.left+8;				pt.v=rect1.top+8;				LocalToGlobal(&pt);				mresult=PopUpMenuSelect(menu,pt.v,pt.h,G.affiche_CR_Flag+1);				DeleteMenu(2014);				ReleaseResource((Handle)menu);													if (mresult){						G.affiche_CR_Flag=LoWord(mresult)-1;						SetPort((GrafPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}								InvalRect(&rect1);			}// affiche ¶}// cette routine permet de dragger un st dans saisie par exemplepascal void DotheDragInListing(Point mouse){	mouse=mouse;}// cette routine ouvre un te dans le sous-titre en courspascal void OpenTheTEListing(Point mouse){short							CharSize,value,Xstart,Ystart;short							VIncrement;short							LargeurTC,largeurTCIn,NormalFace;Str255							string;Rect								rect;RGBColor						blanc,noir;SousTitreRecordPtr		ST_Ptr;TextStyle						newStyle;short							a;//on limite la taille du sous-titre		if (G.HauteurST>100 )	G.HauteurST=100;		noir.red=0;		noir.green=0;		noir.blue=0;		blanc.red=-1;		blanc.green=-1;		blanc.blue=-1;		// on détermine le sous-titre et ses coordoneés	value=(mouse.v-4)/G.HauteurST+GetCtlValue(G.ListingVScroll);	ST_Ptr=C_ConversionNumeroSTPointeur((long)value);	Ystart=((mouse.v-4)/G.HauteurST)*G.HauteurST+3,	Xstart=3;		// on calcule différent parramètre en fct de la hauteur du sous-titre etc...		CharSize=((G.HauteurST-4)*3)/20;		VIncrement=(G.HauteurST-4)/5-1;		if (G.HauteurST>80)	NormalFace=condense;										else	NormalFace=0;		TextSize(CharSize);		TextFont(geneva);		PenNormal();		TextFace(NormalFace);				GetIndString(&string,132,2);		largeurTCIn=StringWidth(&string);		LargeurTC=StringWidth("\p00:00:00:00");			/* click dans le tc in  ?*/				SetRect(&rect,Xstart+5+largeurTCIn,Ystart+VIncrement*2+4,Xstart+7+LargeurTC+2+largeurTCIn,Ystart+VIncrement*3+4);		if (PtInRect(mouse,&rect)){			RGBForeColor(&noir);			RGBBackColor(&blanc);			EraseRect(&rect);			FrameRect(&rect);			InsetRect(&rect,1,1);			G.ListingTE=TEStylNew(&rect,&rect);			G.ListingTEStNum=ST_Ptr->st_AbsNUMST;			G.ListingTEStItem=TimecodeIn_SousTitre;						C_ConversionTCstASCII(ST_Ptr->st_TimeCodeIn,&string);			TESetText(&string[1],(long)string[0],G.ListingTE);			TESetSelect(0,32766,G.ListingTE);						/* on place le mode cr only */			(**G.ListingTE).crOnly=true;			TEAutoView(true,G.ListingTE);			TEFromScrap();			TEActivate(G.ListingTE);			TEUpdate(&rect,G.ListingTE);		}			/* click dans le tc out  ?*/				SetRect(&rect,Xstart+5+largeurTCIn,Ystart+VIncrement*3+5,Xstart+7+LargeurTC+2+largeurTCIn,Ystart+VIncrement*4+5);		if (PtInRect(mouse,&rect)){			RGBForeColor(&noir);			RGBBackColor(&blanc);			EraseRect(&rect);			FrameRect(&rect);			InsetRect(&rect,1,1);			G.ListingTE=TEStylNew(&rect,&rect);			G.ListingTEStNum=ST_Ptr->st_AbsNUMST;			G.ListingTEStItem=TimecodeOut_SousTitre;						C_ConversionTCstASCII(ST_Ptr->st_TimeCodeOut,&string);			TESetText(&string[1],(long)string[0],G.ListingTE);			/* on place le curseur à la fin */			TESetSelect(0,32766,G.ListingTE);						/* on place le mode cr only */			(**G.ListingTE).crOnly=true;			TEAutoView(true,G.ListingTE);			TEFromScrap();			TEActivate(G.ListingTE);			TEUpdate(&rect,G.ListingTE);		}	/* click dans la chaîne commentaîre  ?*/				SetRect(&rect,Xstart+141,Ystart+2,Xstart+417+ajout_largeur_ST_Listing,Ystart+VIncrement+3);		InsetRect(&rect,-1,-1);		if (PtInRect(mouse,&rect)){			RGBForeColor(&noir);			RGBBackColor(&blanc);			EraseRect(&rect);			FrameRect(&rect);			InsetRect(&rect,1,1);			G.ListingTE=TEStylNew(&rect,&rect);			G.ListingTEStNum=ST_Ptr->st_AbsNUMST;			G.ListingTEStItem=Commentaire_SousTitre;						if (ST_Ptr->st_CommentaireLenth)					TESetText(ST_Ptr->st_CommentairePtr,ST_Ptr->st_CommentaireLenth,G.ListingTE);			/* on place le curseur à la fin */			TESetSelect(32766,32766,G.ListingTE);						/* on place le mode cr only */			(**G.ListingTE).crOnly=true;			TEAutoView(true,G.ListingTE);			TEFromScrap();			TEActivate(G.ListingTE);			TEUpdate(&rect,G.ListingTE);		}	/* click dans le texte ?*/		SetRect(&rect,Xstart+141,Ystart+VIncrement+6,Xstart+417+ajout_largeur_ST_Listing,Ystart+VIncrement*5+3);		InsetRect(&rect,-1,-1);		if (PtInRect(mouse,&rect)){			RGBForeColor(&noir);			RGBBackColor(&blanc);			EraseRect(&rect);			FrameRect(&rect);			InsetRect(&rect,1,1);			G.ListingTE=TEStylNew(&rect,&rect);			G.ListingTEStNum=ST_Ptr->st_AbsNUMST;			G.ListingTEStItem=Texte_SousTitre;						(**G.ListingTE).crOnly=true;			TEAutoView(true,G.ListingTE);			TEFromScrap();// on place les vrai coordonnées du te			(**G.ListingTE).destRect=rect;			(**G.ListingTE).viewRect=rect;						TRANSFERTTEXTE_MEMOIRE_STYLETE(G.ListingTE,ST_Ptr,&rect,-1);			a=C_get_STJustification(ST_Ptr);			TESetJust(a,G.ListingTE);// on sélectionne tous le texte et on place la taille 14			TESetSelect(0,32767,G.ListingTE);			newStyle.tsSize=CharSize;			TESetStyle(doSize,&newStyle,true,G.ListingTE);			//on place le curseur à la fin du texte// on active le TE		/* on place le curseur à la fin */			TESetSelect(32760,32760,G.ListingTE);			TEActivate(G.ListingTE);			TEUpdate(&rect,G.ListingTE);					}}void FlashTracking(void){Rect	rect,rect1,port_rect;WindowPtr	w=(WindowPtr)&G.ListingWindow;		/* on détermine dans quel bouton on a frappé */		port_rect=w->portRect;		port_rect.right-=16;		port_rect.bottom-=16;				TextFont(geneva);	// pour une version internationnale		TextSize(9);				/* bouton tracking		*/			rect=w->portRect;		rect.top=rect.bottom-14;		rect.right=119; // 1 relief		rect1=rect;		InvertRect(&rect);		WaitTicks(4);		InvertRect(&rect);		WaitTicks(4);		InvertRect(&rect);		WaitTicks(4);		InvertRect(&rect);		InvalRect(&rect);		BeginUpdate(w);		DrawListingWindow();		EndUpdate(w);}/* 	-----------------------------------------------	Gestion des ordres dans la palette télécommande	-----------------------------------------------  */	pascal void DoMouseDownPaletteTelecommande(EventRecord	*event){		DialogPtr					dialog=G.TELECOMMANDEWindow,D=(DialogPtr)&G.DialogSaisie;	short						itemhit,itemtype,IconId;	Handle						item,saveShuttle,saveVar;	Rect							rect;	CIconHandle				iconhandle,icon;	Boolean						result=false,outboucle;	Point						pt;	GrafPtr					oldport;	SousTitreRecordPtr	ST_Ptr,ST1;	long							TC;	WindowPtr				Li=(GrafPtr)&G.ListingWindow;	Str255					buffer;		GetPort(&oldport);	SetPort(dialog);		TC=G.General_TCCourant;	ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);			// on sauvegarde le handle de 2 icônes	GetDItem(dialog,10,&itemtype,&saveShuttle,&rect);	GetDItem(dialog,11,&itemtype,&saveVar,&rect);		pt=event->where;	GlobalToLocal(&pt);	WaitTicks(4); //for test		itemhit=1+FindDItem(dialog,pt);	if (itemhit !=-1) result=true;			/* dans le cas où BB est intégré dans une regie de montage,		on peut utiliser le fil n°1 (output handchake ) pour commander un relais. 		Lorsqu'il est activé ce relais basculerais le control du béta sur le mac	*/	// on active le fil dts pour relais automatique  (si mode auto)	if (G.LecteurTimeCode_Type==2) 	   if (G.Mode_Commutateur==0)   {		if (itemhit >=1 && itemhit<=7 ||			itemhit >=12 && itemhit <=13){				Control(G.ModemOutRefNum,17,nil); 				WaitTicks(2);	// on laisse au relais le temps de coller avant d'envoyer l'ordre au vtr 2 ticks 1/30 sec ≈ 33 ms								SetPort((GrafPtr)&G.ListingWindow);								// on update le l'icône commutateur dans listing				rect.left=496;				rect.top=Li->portRect.bottom-14; 								rect.right=rect.left+14;				rect.bottom=rect.top+14;							// on affiche l'icône commuté				icon=GetCIcon(281);							if (icon) {					PlotCIcon(&rect,icon);							DisposeCIcon(icon);					}				} //item hit...				SetPort(dialog);		} // mode commutateur		if (itemhit==1){			if (gvarmode==0){				gvarmode=1; // shuttle				GetDItem(dialog,10,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,10);				iconhandle=GetCIcon((IconId/4)*4+2);				SetDItem(dialog,10,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,10,(IconId/4)*4+2);				GetDItem(dialog,11,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,11);				iconhandle=GetCIcon((IconId/4)*4);				SetDItem(dialog,11,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,11,(IconId/4)*4);				C_Unhilite_icon_button(dialog,10);					C_Unhilite_icon_button(dialog,11);										}						DoDrawShuttleButton();					/*  il faut invalider le cache du conversion num pointeur			et les caches du dernier sous-titre dessiné */		G.General_DernierNumConvertiPtr=nil;				G.Sous_titre_dessined=nil;			G.Sous_titreInOffscreen=nil;			G.TravailAFaire_Affichage=0; 		UpdateGeneralValue();				}				if (itemhit==10) {			gvarmode=1; // shuttle				GetDItem(dialog,10,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,10);				iconhandle=GetCIcon((IconId/4)*4+2);				SetDItem(dialog,10,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,10,(IconId/4)*4+2);				GetDItem(dialog,11,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,11);				iconhandle=GetCIcon((IconId/4)*4);				SetDItem(dialog,11,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,11,(IconId/4)*4);					C_Unhilite_icon_button(dialog,11);					if (G.LecteurTimeCode_Type==2)TxRS422('SHTL',0,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==1)TxVITCReader('SHTL',0 ,G.ModemOutRefNum);				C_Hilite_icon_button(dialog,10);			}						if (itemhit==11) {			gvarmode=2; // var									GetDItem(dialog,11,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,11);				iconhandle=GetCIcon((IconId/4)*4+2);				SetDItem(dialog,11,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,11,(IconId/4)*4+2);				GetDItem(dialog,10,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,10);				iconhandle=GetCIcon((IconId/4)*4);				SetDItem(dialog,10,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,10,(IconId/4)*4);				if (G.LecteurTimeCode_Type==2)TxRS422('SHTL',0,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==1)TxVITCReader('SHTL',0 ,G.ModemOutRefNum);				C_Unhilite_icon_button(dialog,10);					C_Hilite_icon_button(dialog,11);				}				if ( itemhit<7 && itemhit >1) {									GetDItem(dialog,10,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,10);				iconhandle=GetCIcon((IconId/4)*4);				SetDItem(dialog,10,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,10,(IconId/4)*4);								GetDItem(dialog,11,&itemtype,&item,&rect);				DisposeCIcon((CIconHandle)item);				IconId=C_findIconResourceDitl(dialog,11);				iconhandle=GetCIcon((IconId/4)*4);				SetDItem(dialog,11,itemtype,(Handle)iconhandle,&rect);				SetDitlIconId(dialog,11,(IconId/4)*4);							C_Unhilite_icon_button(dialog,10);				C_Unhilite_icon_button(dialog,11);					gvarmode=0; // var		}						C_Hilite_icon_button(dialog,itemhit);			switch(itemhit) {						case 2:				if (G.LecteurTimeCode_Type==1) TxVITCReader('FREW',0x5F,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==2) TxRS422('FREW',0x5F,G.ModemOutRefNum);			break;						case 3:				if (G.LecteurTimeCode_Type==1) TxVITCReader('FFWD',0x5F,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==2) TxRS422('FFWD',0x5F,G.ModemOutRefNum);			break;						case 4:				if (G.LecteurTimeCode_Type==1) TxVITCReader('SHTL',-64,G.ModemOutRefNum);	// play -1				if (G.LecteurTimeCode_Type==2) TxRS422('VAR ',-64,G.ModemOutRefNum);	// play -1			break;									case 5:				if (G.LecteurTimeCode_Type==1) TxVITCReader('STOP',0x5F,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==2) {						TxRS422('STOP',0x5F,G.ModemOutRefNum);						TxRS422('SBOF',0x5F,G.ModemOutRefNum);				}			break;						case 6:				if (G.LecteurTimeCode_Type==1) TxVITCReader('PLAY',0x5F,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==2) TxRS422('PLAY',0x5F,G.ModemOutRefNum);			break;						case 7:				if (G.LecteurTimeCode_Type==1) TxVITCReader('EJEC',0x5F,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==2) TxRS422('EJEC',0x5F,G.ModemOutRefNum);			break;				// ----						case 8:	// Mark in					/* on prépare l'undo */					DoMakeUndo(TimecodeIn_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);												if (G.saisieTE && G.saisieTEStItem==TimecodeIn_SousTitre)								TransfertSaisieMemoire();									ST_Ptr->st_TimeCodeIn=TC;					DrawSt_enCourDansListing();						SetPort(D);					InvalRect(&D->portRect);/*	On vérifie le sous-titre		et on signale les erreurs	*/					VerifieTimeCodes(ST_Ptr);					SignalErreurSousTitre(ST_Ptr);					SetPort(dialog);									break;		// ----						case 9:	// Mark out									/* on prépare l'undo */					DoMakeUndo(TimecodeOut_SousTitrebcd,0,							ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeOut);												if (G.saisieTE && G.saisieTEStItem==TimecodeOut_SousTitre)								TransfertSaisieMemoire();													ST_Ptr->st_TimeCodeOut=TC;					DrawSt_enCourDansListing();						SetPort(D);					InvalRect(&D->portRect);					VerifieTimeCodes(ST_Ptr);					SignalErreurSousTitre(ST_Ptr);					SetPort(dialog);				break;			case 12:				TxRS422('SEAR',ST_Ptr->st_TimeCodeIn,G.ModemOutRefNum);			break;						case 13:				TxRS422('SEAR',ST_Ptr->st_TimeCodeOut,G.ModemOutRefNum);			break;						case 14: // st precedent					TransfertSaisieMemoire();					do{							ST1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;					/* on regarde si le st précedent exite							si non, on s'arrête					*/							if (ST1) {							G.General_SousTitreEncour=ST1->st_AbsNUMST;								UpdateSaisie();												CentreListingWindow();							ST_Ptr=ST1;							VerifieTimeCodes(ST_Ptr);							SignalErreurSousTitre(ST_Ptr);						} else	outboucle=true;					} while (Button() && outboucle==false);					GetKaraokeFromST(G.General_SousTitreEncour);			break;										case 15: // st suivant					TransfertSaisieMemoire();					do{						ST1=(SousTitreRecordPtr)ST_Ptr->st_NextST;					/* on regarde si le st suivant exite							si non, on en rajoute 1 					*/							if (ST1) {							G.General_SousTitreEncour=ST1->st_AbsNUMST;								UpdateSaisie();												CentreListingWindow();							ST_Ptr=ST1;							VerifieTimeCodes(ST_Ptr);							SignalErreurSousTitre(ST_Ptr);						} else{							outboucle=true;							C_Hilite_icon_button(D,3);							C_InsertSt(ST_Ptr,32);							WaitTicks(20);							C_Unhilite_icon_button(D,3);							UpdateSaisie();												CentreListingWindow();						}					} while (Button() && outboucle==false);					GetKaraokeFromST(G.General_SousTitreEncour);			break;											} // switch						//on effectue le suivi des boutons				// si ≠ cancel ou opk on track le mouse up				// sinon on attend le mouse up et on agit en conscéquence			if (itemhit >1 && itemhit <=15) {					TrackCurseur(dialog,itemhit);				}						WaitTicks(1);		// si mode lecteur VITC on relache le boutton poussoir			if (G.LecteurTimeCode_Type==1) TxVITCReader('NULL',00,G.ModemOutRefNum);	// on désactive le fil "dts" pour relais automatique (seulement si mode momentané)	if (G.LecteurTimeCode_Type==2) 	if (G.Mode_Commutateur==0)   {			if (itemhit >=1 && itemhit<=7 ||			itemhit >=12 && itemhit <=13) {				SetPort((GrafPtr)&G.ListingWindow);								// on update le l'icône commutateur dans listing				rect.left=496;				rect.top=Li->portRect.bottom-14; 				rect.right=rect.left+14;				rect.bottom=rect.top+14;							 	icon=GetCIcon(282);				if (icon) {					PlotCIcon(&rect,icon);							DisposeCIcon(icon);					}									WaitTicks(2);					Control(G.ModemOutRefNum,18,nil); 				WaitTicks(2);									// on affiche l'icône pleine seulement si mode rs 422				icon=GetCIcon(280);								if (icon) {					PlotCIcon(&rect,icon);							DisposeCIcon(icon);					}									SetPort(dialog);		}	// item hit	}//mode commutateur	// on regarde s'il faut resynchroniser le st en cours		ST_Ptr=C_ConversionTimeCodePointeur(G.General_TCCourant);					if (ST_Ptr) // seulement si pointeur valide			  if(G.Base_Adresse) 				if (G.Sous_titre_dessined!=ST_Ptr) {						/*  	Le sous-titre dans la carte d'affichage n'est plus le st courant on redessine 							directement dans carte le bon sous-titre.					*/										/* 		on raz la carte d'affichage								on dessine le sous-titre					*/							C_ClearVx();								G.Sous_titre_dessined=ST_Ptr;							if (ValidST(ST_Ptr)==0)								CC_Draw_SousTitre(ST_Ptr,G.X_Offset,G.Y_Offset,														G.Base_Adresse,G.Row_Bytes,&G.ScreenRenderedRect);							/* on invalide le sous-titre in offscreen */														G.Sous_titreInOffscreen=nil;				} 				SetPort(oldport);}		/* gestion des clicks dans la palette chenille	*/	pascal void DoMouseDownPaletteChenille(EventRecord	*event){	DialogPtr					dialog=G.ChenilleWindow;short					itemhit;Point						pt;long							a;GrafPtr					oldport;	GetPort(&oldport);	SetPort(dialog);		pt=event->where;	GlobalToLocal(&pt);		itemhit=1+FindDItem(dialog,pt);	if (itemhit >=5 && itemhit <=6)		switch(itemhit) {				case 5: // increment					a=C_IncDecValueSpecial(dialog,itemhit,3,1,50,1);					G.Echelle_Bandeau=a;					G.Bandeau_LastTC=G.General_TCCourant;					DessineLaChenille(G.General_TCCourant);				break;								case 6: // décrément					a=C_IncDecValueSpecial(dialog,itemhit,3,1,50,-1);					G.Echelle_Bandeau=a;					G.Bandeau_LastTC=G.General_TCCourant;					DessineLaChenille(G.General_TCCourant);				break;		} // switch				SetPort(oldport);} // mouse down chenille/* gestion des clicks dans la palette chenille	*/	pascal void BlankingDialogEvent(EventRecord	*event){	DialogPtr				dialog=gBlankingVerticalWindow,dummyDialog;short					itemHit,part,type,Dodraw;Point					pt;long					a;GrafPtr					oldport;RGBColor				newColor;Handle 					hndl;Rect 					rect;SPtr					P;SousTitreRecordPtr		ST_Ptr;	GetPort(&oldport);	SetPort(gDialogReglageSimu);	TextFont(geneva);	TextSize(9);	pt=event->where;	GlobalToLocal(&pt);	Dodraw=0;	if (DialogSelect(event,&dummyDialog,&itemHit)){		GetDItem(gBlankingVerticalWindow,itemHit,&type,&hndl,&rect);		if (itemHit==9) {				if (!gMaxSpeed) {					gMaxSpeed=true;					SetCtlValue((ControlHandle)hndl,true);					}				}	}			SetPort(oldport);} // BlankingDialogEventvoid DoKeyEvent(EventRecord *event){unsigned char key;	WindowPtr window;short part;	part= FindWindow(event->where,&window);	if (!DoFonctionKey(event)){ // gestion des touches de fonctions		window=(WindowPtr)FrontNonFloatingWindow();			key = event->message & charCodeMask;		if ( event->modifiers & cmdKey ) {			/* Command key down */			if ( event->what == keyDown ) {				Adjust_BB_Menu();						/* enable/disable/check menu items properly */				DoMenuCommand(MenuKey(key));			}			}  else {			// s'il n'y a pas de te ouvert , on gère la barre d'espace pour faire pause de la machine	//#############		if  (G.saisieTE==nil) {			if (!G.ListingTE)  {				if (!G.BlockNoteTE)  {				if ((event->message&0xff)==0x20) { // barre d'espace					// on envoie un still 0					if (G.LecteurTimeCode_Type==2)TxRS422('SHTL',0,G.ModemOutRefNum);					if (G.LecteurTimeCode_Type==1)TxVITCReader('SHTL',0 ,G.ModemOutRefNum);				}			}				    } 		}							//	if (window==G.TELECOMMANDEWindow) 			DoKeyDownPaletteTelecommande(event);	//	if (window==G.ChenilleWindow) 				DoKeyDownPaletteChenille(event);		if (window==(WindowPtr)gDialogPrefAffichage) 	DoPreferenceKeyDownAffichageDlog(window,event);		if (window==(WindowPtr)&G.ListingWindow) 		DoKeyDownListing (event);		if (window==(WindowPtr)&G.DialogSaisie) 		DoKeyDownDialogSaisie (event);		if (window==(WindowPtr)G.BlockNoteWindow) 		DoKeyDownDialogBlockNote (event);		}	}}void DoKeyDownListing (EventRecord *event){SousTitreRecordPtr 	ST_Ptr;unsigned short 		c;WindowPtr		W=(WindowPtr)&G.ListingWindow;Boolean 			keyProcessed=false;long				TC=G.General_TCCourant;GrafPtr			oldport;		GetPort(&oldport);		SetPort(W);		// le sous-titre en cours		ST_Ptr=C_ConversionNumeroSTPointeur(G.General_SousTitreEncour);//   on regarde si le TE est ouvert et que l'ordre n'a pas été processé			if (G.ListingTE ) {				// on filtre en fonction du type de te		c=event->message&0xff;				// te numérique ?				if ( G.ListingTEStItem==TimecodeIn_SousTitre||			G.ListingTEStItem==TimecodeOut_SousTitre||			 G.ListingTEStItem==Duree_SousTitre){			// fermeture te ?				if ( c==3 || c==0x0d )  {				FermeLEsTE();				G.ChangeSinceLastSave=true;				keyProcessed=true;			} else {				// caractère valable ?				if (	( c>='0' && c<='9') ||					c=='+' || 					c=='-' ||					c==' ' ||					c==',' ||					c==';' ||					c=='.' ||					c<32 )     { 						DoMakeUndo(G.ListingTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.ListingTE);						TEKey(c,G.ListingTE);						G.ChangeSinceLastSave=true;						keyProcessed=true;					}			}// a t-on appuyé sur la touche supression, si oui on regarde si nous sommes au dernier caractère ?					if (c==0x7f)				if ( (**G.ListingTE).teLength!=(**G.ListingTE).selStart ){ 					DoMakeUndo(G.ListingTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.ListingTE);					TEKey(0x1d,G.ListingTE);					TEKey(8,G.ListingTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;					}			if (!keyProcessed) SysBeep(1);					} else { // c'est un te texte			// fermeture te ?				if ( c==3 )  {				FermeLEsTE();				G.ChangeSinceLastSave=true;				keyProcessed=true;				}// a t-on appuyer sur la touche supression, si oui on regarde si nous sommes au dernier caractère ?					if (c==0x7f)				if ( (**G.ListingTE).teLength!=(**G.ListingTE).selStart ){ 					DoMakeUndo(G.ListingTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.ListingTE);					TEKey(0x1d,G.ListingTE);					TEKey(8,G.ListingTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;					}			  if (!keyProcessed) { 					DoMakeUndo(G.ListingTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.ListingTE);					TEKey(c,G.ListingTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;				}				} // te texte	} else {// if te existe && !keyProcessed ?			// on regarde si c'est une touche en code étendu (insère page up etc...)					c=(event->message&0xff00)>>8;						switch (c){				case	0x73:	// premier st					SetCtlValue(G.ListingVScroll,1);					DrawListingWindow();					ShowControl(G.ListingVScroll);					keyProcessed=true;				break;								case	0x77:	// dernier st					SetCtlValue(G.ListingVScroll,G.General_NombreST);					DrawListingWindow();					ShowControl(G.ListingVScroll);					keyProcessed=true;				break;								case	0x74:	// page up					ControlActionProc(G.ListingVScroll,inPageUp);					keyProcessed=true;				break;								case	0x79:	// page down					ControlActionProc(G.ListingVScroll,inPageDown);					keyProcessed=true;				break;			}		// switch			c=event->message&0xff;			if(!keyProcessed)				switch (c){				case	30:	// précedent						ControlActionProc(G.ListingVScroll,inUpButton);						keyProcessed=true;				break;								case	31:	// suivant						ControlActionProc(G.ListingVScroll,inDownButton);						keyProcessed=true;				break;			}		// switch							// pas de listing TE ...		}					SetPort(oldport);}void DoKeyDownDialogBlockNote (EventRecord *event){		DoDialogBlockNoteEvent(event);}void DoKeyDownDialogSaisie (EventRecord *event){SousTitreRecordPtr 	ST_Ptr;unsigned short 		c;DialogPtr			D=(WindowPtr)&G.DialogSaisie;Boolean 			keyProcessed=false,saisieTEwasopen=false;long				TC=G.General_TCCourant,oldstnum,a;GrafPtr			oldport;Rect				rect;short			itemtype,LastTeItem;Handle			item;		GetPort(&oldport);		SetPort(D);				saisieTEwasopen=(G.saisieTE!=nil);		LastTeItem=G.saisieTEStItem; // on conserve au cas où il faut réouvrir un te				// le sous-titre en cours		ST_Ptr=C_ConversionNumeroSTPointeur(G.General_SousTitreEncour);// on regarde si c'est une touche en code étendu (insère page up etc...)				c=(event->message&0xff00)>>8;				switch (c){				case	0x73:	// premier st						FermeLEsTE();						G.General_SousTitreEncour=1;						SetCtlValue(G.ListingVScroll,1);						CentreListingWindow();						UpdateSaisie();						keyProcessed=true;						GetKaraokeFromST(G.General_SousTitreEncour);						gModeSaisieTCState=0;				break;								case	0x77:	// dernier st						FermeLEsTE();						G.General_SousTitreEncour=G.General_NombreST;						SetCtlValue(G.ListingVScroll,G.General_NombreST);						CentreListingWindow();						UpdateSaisie();						keyProcessed=true;						GetKaraokeFromST(G.General_SousTitreEncour);						gModeSaisieTCState=0;				break;								case	0x74:	// précedent						FermeLEsTE();						oldstnum=G.General_SousTitreEncour;						G.General_SousTitreEncour--;						if (G.General_SousTitreEncour<1)G.General_SousTitreEncour=1;						CentreListingWindowByNumSTSimpleUpdate(G.General_SousTitreEncour,oldstnum);							UpdateSaisie();						keyProcessed=true;						GetKaraokeFromST(G.General_SousTitreEncour);						gModeSaisieTCState=0;				break;								case	0x79:	// suivant						FermeLEsTE();						oldstnum=G.General_SousTitreEncour;						G.General_SousTitreEncour++;						if (G.General_SousTitreEncour>G.General_NombreST){ // si fin de liste on insert un st							C_InsertSt(ST_Ptr,32);							UpdateSaisie();							CentreListingWindow();							} else {								CentreListingWindowByNumSTSimpleUpdate(G.General_SousTitreEncour,oldstnum);									UpdateSaisie();								}						keyProcessed=true;						GetKaraokeFromST(G.General_SousTitreEncour);						gModeSaisieTCState=0;				break;			}		// switch									//   on regarde si le TE est ouvert et que l'ordre n'a pas été processé			if (G.saisieTE &&!keyProcessed ) {		TextFont(G.General_FontNumber);		// on filtre en fonction du type de te		c=event->message&0xff;		// on ferme le te ?				if ( G.saisieTEStItem==TimecodeIn_SousTitre||			G.saisieTEStItem==TimecodeOut_SousTitre||			 G.saisieTEStItem==Duree_SousTitre	 ){			// caractère valable ?			if (	( c>='0' && c<='9') ||				c=='+' || 				c=='-' ||				c==' ' ||				c==0x08 ||				c==',' ||				c==';' ||				c=='.' ||				c==0x1c ||				c==0x1d )     { 					DoMakeUndo(G.saisieTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.saisieTE);					TEKey(c,G.saisieTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;					Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères				}						// fermeture te ?				if ( c==3 || c==0x0d )  {				TransfertSaisieMemoire(); 				G.ChangeSinceLastSave=true;				keyProcessed=true;				Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères				LastTeItem=0;				}// a t-on appuyer sur la touche supression, si oui on regarde si nous sommes au dernier caractère ?					if (c==0x7f)				if ( (**G.saisieTE).teLength!=(**G.saisieTE).selStart ){ 					DoMakeUndo(G.saisieTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.saisieTE);					TEKey(0x1d,G.saisieTE);					TEKey(8,G.saisieTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;					Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères					}							if (!keyProcessed) SysBeep(1);					} else { // c'est un te texte			// fermeture te ?				if ( c==3 )  {				TransfertSaisieMemoire(); 				G.ChangeSinceLastSave=true;				keyProcessed=true;				Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères				LastTeItem=0;			/*  on raz le processeur d'affichage */			if (G.Sous_titre_dessined->st_AbsNUMST==G.saisieTEStNum) {				G.Sous_titre_dessined=nil	;				}					if (G.Sous_titreInOffscreen->st_AbsNUMST==G.saisieTEStNum) {				G.Sous_titre_dessined=nil	;				}				}// a t-on appuyer sur la touche supression, si oui on regarde si nous sommes au dernier caractère ?					if (c==0x7f)			if ( (**G.saisieTE).teLength!=(**G.saisieTE).selStart ){ 					DoMakeUndo(G.saisieTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.saisieTE);					TEKey(0x1d,G.saisieTE);					TEKey(8,G.saisieTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;					Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères					}			  if (!keyProcessed) { 					DoMakeUndo(G.saisieTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.saisieTE);					TEKey(c,G.saisieTE);					G.ChangeSinceLastSave=true;					keyProcessed=true;					Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractères				}				} // te texte	} // if te existe && !keyProcessed			/* 	s'il n'y a pas de te ouvert et que mode saisie TC nous pouvons assigner quelques touches du clavier 	à des fonctions particulières			 E ou e ou alt E ou alt+shift E pour enchaîné	D ou d => mark in	F ou f => mark out	 alt + D ou d => changement de plan à l'entrée		alt + D ou d => changement de plan à la sortie	ALT + G OU g	=> chg de plan à l'entrée et à la sortie	space = next st*/					if ( (!keyProcessed )&& (G.SaisieModePreferenciel==1) ){			c=(event->message&0xff);							switch(c) {					case 4:					case '∂':	// chg entré					case '∆':					case 'D':	// mark in					case 'd':											// pour le tc in on regarde si , tcout exsite et pas de st_suivant															if ( gModeSaisieTC==1&& gModeSaisieTCState==2 ){ // on a fait tcin et tc out dans l'ordre 					if (	ST_Ptr->st_NextST==nil 		&&		// pas de sous-titre suivant						ST_Ptr->st_TimeCodeOut!=-1  ){	// tc out existe						// on passe au sous-titre suivant							FermeLEsTE();							G.General_SousTitreEncour++;						if (G.General_SousTitreEncour>G.General_NombreST){								C_InsertSt(ST_Ptr,32);								UpdateSaisie();								CentreListingWindow();							} else {								SetCtlValue(G.ListingVScroll,G.General_SousTitreEncour);								CentreListingWindow();								UpdateSaisie();							}														G.ChangeSinceLastSave=true;							keyProcessed=true;							GetKaraokeFromST(G.General_SousTitreEncour);							ST_Ptr=C_ConversionNumeroSTPointeur(G.General_SousTitreEncour);						}											}// if gModeSaisieTC 						// on effectue le Undo						gModeSaisieTCState=1; // on vient de faire tc in			 			DoMakeUndo(TimecodeIn_SousTitrebcd,0,ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeIn);						ST_Ptr->st_TimeCodeIn=TC;						SelectReferencedWindow((WindowReference)D);						UpdateSaisie();						DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour);							DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour-1);							G.ChangeSinceLastSave=true;						keyProcessed=true;												if (event->modifiers&controlKey){ // si alt on fait commentaire												DoCommentaire(1);						}					break;										case 6:					case 'f':	// mark out					case 'F':					case 'ƒ':	// chg sortie					case '·':											// on effectue le Undo			 			DoMakeUndo(TimecodeOut_SousTitrebcd,0,ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeOut);						ST_Ptr->st_TimeCodeOut=TC;						SelectReferencedWindow((WindowReference)D);						DoUpdate(D);						UpdateSaisie();						DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour);							DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour+1);								G.ChangeSinceLastSave=true;						keyProcessed=true;													if (event->modifiers&controlKey){ // si alt on fait commentaire												DoCommentaire(2);						}									if ( gModeSaisieTC==2 ){ // mode passage suivant  auto après tc out					if (	ST_Ptr->st_NextST==nil   ){	// pas de st suivant						// on passe au sous-titre suivant							FermeLEsTE();							G.General_SousTitreEncour++;						if (G.General_SousTitreEncour>G.General_NombreST){								C_InsertSt(ST_Ptr,32);								UpdateSaisie();								CentreListingWindow();							} else {								SetCtlValue(G.ListingVScroll,G.General_SousTitreEncour);								CentreListingWindow();								UpdateSaisie();							}														G.ChangeSinceLastSave=true;							keyProcessed=true;							GetKaraokeFromST(G.General_SousTitreEncour);							ST_Ptr=C_ConversionNumeroSTPointeur(G.General_SousTitreEncour);						} // pas de st suivant					} else { // pas mode passage auto après tc out							if (gModeSaisieTCState==1 ) // si on vient de faire tcin									gModeSaisieTCState=2; // on indique que l'on vient de faire tcout						}					break;										case 'E':	// enchainé					case 'e':					case 'ê':					case 'Ê':						Do_Enchaine(ST_Ptr,TC);						G.ChangeSinceLastSave=true;						keyProcessed=true;						gModeSaisieTCState=1; // on indique que l'on vient de faire équivalent tcin					break;										/*					case '∂':	// chg entré					case '∆':						DoCommentaire(1);						G.ChangeSinceLastSave=true;						keyProcessed=true;					break;										case 'ƒ':	// chg sortie					case '·':						DoCommentaire(2);						G.ChangeSinceLastSave=true;						keyProcessed=true;					break;						*/					case	' ' :	// ST suivant					case	'3 ' :	// ST suivant						FermeLEsTE();						G.General_SousTitreEncour++;						if (G.General_SousTitreEncour>G.General_NombreST){							C_InsertSt(ST_Ptr,32);							UpdateSaisie();							CentreListingWindow();						} else {							SetCtlValue(G.ListingVScroll,G.General_SousTitreEncour);							CentreListingWindow();							UpdateSaisie();							}						G.ChangeSinceLastSave=true;						keyProcessed=true;						GetKaraokeFromST(G.General_SousTitreEncour);						gModeSaisieTCState=0;					break;										case 'P':	// chg plan sortie - 4 images					case 'p':					case 'π':					case '∏':					case 16:						// on effectue le Undo			 			DoMakeUndo(TimecodeOut_SousTitrebcd,0,ST_Ptr->st_AbsNUMST,ST_Ptr->st_TimeCodeOut);						ST_Ptr->st_TimeCodeOut=C_SoustractionTimeCode(TC,4);						SelectReferencedWindow((WindowReference)D);						DoUpdate(D);						UpdateSaisie();						DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour);							DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour+1);								G.ChangeSinceLastSave=true;						keyProcessed=true;													if (event->modifiers&controlKey){ // si alt on fait commentaire												DoCommentaire(2);						}					break;		} // switch raccourci clavier	} // if mode saisie tc	/* On regarde s'il faut réouvrir la case texte,	*/			if ( 			(!G.saisieTE) &&			(saisieTEwasopen) &&			(LastTeItem==Texte_SousTitre) 					 )DoOpenSaisieTE(Texte_SousTitre);		//on vérifie les time code			if (keyProcessed) UpdateGeneralValue();					VerifieTimeCodes(ST_Ptr);		SetPort(oldport);}void DoCommentaire(short commentaire) {Str255	st0;		// on récupère le texte		FermeLEsTE();		GetIndString(&st0,128,commentaire);		// on ouvre le te en commentaire		DoOpenSaisieTE(Commentaire_SousTitre);		TESetSelect(0,32766, G.saisieTE);		DoMakeUndo(G.saisieTEStItem,TickCount(),G.General_SousTitreEncour,(long)G.saisieTE);		TEDelete(G.saisieTE);				// on place le commentaire		TEStylInsert(&st0[1], (long)st0[0],nil,G.saisieTE);		// on place le commentaire dans le st		TransfertSaisieMemoire();		DrawSt_enCourDansListing();			G.ChangeSinceLastSave=true;}// docommentaire// cette routine simule un click de souris dans la fenêtre saisievoid SimulClickInSaisie(short itemNum){GrafPtr		oldport;EventRecord 	event;DialogPtr		D=(DialogPtr)&G.DialogSaisie;Rect			rect;short		type;Handle		hndl;		GetPort(&oldport);		SetPort(D);				GetDItem(D,itemNum,&type,&hndl,&rect);		SelectReferencedWindow((WindowReference)D);		event.where.v=rect.top+2;		event.where.h=rect.left+2;		event.what=mouseDown;		LocalToGlobal(&event.where);// on appelle la routine MouseDownSaisie		DoDialogSaisieEvent(&event);		SetPort(oldport);}//SimulClickInSaisie