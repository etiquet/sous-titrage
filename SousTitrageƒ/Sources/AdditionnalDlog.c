#include "BB.Globals_C.h"#include <Gestalt.h>pascal	Boolean myStandartfilterproc(DialogPtr theDialog ,EventRecord *event,short *itemhit);pascal	sliderstructHandle GetNewSlider(short minvalue,short maxvalue,short value,short increment,Rect *rect);pascal void DrawSlider(sliderstructHandle slider);	pascal short DoSliderFollow(sliderstructHandle slider);pascal long C_IncDecValueProc(DialogPtr Dialog,short itemNumber,				short updatItem,void(*DrawFonction(DialogPtr dlog,short updatItem,long value)),				long minvalue,long maxvalue,long increment);long	gStartSecond;pascal long My_IncDecValue(DialogPtr Dialog,short itemNumber,short textitemnumber,long minvalue,long maxvalue,long increment);void UpdateByTe(DialogPtr dlog,short item);/* *=====================================================================**Diverses routines utilisées pour la gestion des boutons dans un dialog **=====================================================================**///#pragma segment Dialogspascal void C_Hilite_icon_button(DialogPtr Dialog,short itemNumber){	short					IconId;	Rect					Rectangle;	short					the_itemtype;	Handle					the_Handle;	Handle					iconhandle;	if (itemNumber< 0) return;	GetDItem(Dialog,itemNumber,&the_itemtype,&the_Handle,&Rectangle);		  	if ((the_itemtype&0x6f)== iconItem){	IconId=C_findIconResourceDitl(Dialog,itemNumber);	iconhandle=(Handle)GetCIcon(IconId+1);	if(iconhandle){		PlotCIcon(&Rectangle,(CIconHandle)iconhandle);			DisposeCIcon((CIconHandle)iconhandle);		}	}		if ((the_itemtype&0x6f)== picItem){	IconId=C_findIconResourceDitl(Dialog,itemNumber);	iconhandle=GetResource('PICT',IconId+1);	if(iconhandle){		DrawPicture((PicHandle)iconhandle,&Rectangle);		ReleaseResource((Handle)iconhandle);		}	}}				pascal void C_Unhilite_icon_button(DialogPtr Dialog,short itemNumber){	Rect					Rectangle;	short					the_itemtype;	Handle					the_Handle;			if (itemNumber< 0) return;		GetDItem(Dialog,itemNumber,&the_itemtype,&the_Handle,&Rectangle);		if ((the_itemtype&0x6f)== iconItem){	PlotCIcon(&Rectangle,(CIconHandle) the_Handle);		}		if ((the_itemtype&0x6f)== picItem){	DrawPicture((PicHandle)the_Handle,&Rectangle);	}	}		pascal long My_IncDecValue(DialogPtr Dialog,short itemNumber,short textitemnumber,long minvalue,long maxvalue,long increment){	long		result;	Str255		string;	Handle		the_Handle;	short		the_itemtype;	Rect		Rectangle;	long		start=TickCount();	C_Hilite_icon_button(Dialog,itemNumber);	GetDItem(Dialog,textitemnumber,&the_itemtype,&the_Handle,&Rectangle);	GetIText(the_Handle,&string);	StringToNum(&string,&result);	while	(Button()==true){		if ((TickCount()-start)< 60) WaitTicks(8);		else	WaitTicks(2);			result=result+increment;	if(result>maxvalue) result=maxvalue;	if(result<minvalue) result=minvalue;	NumToString(result,&string);	SetIText(the_Handle,&string);	UpdateByTe(Dialog,textitemnumber);	}	C_Unhilite_icon_button(Dialog,itemNumber);	return(result);}	void UpdateByTe(DialogPtr dlog,short item){long		result;Str255		string;Handle		the_Handle;short		the_itemtype;Rect			Rectangle;RGBColor		c,c1;	GetForeColor(&c);	GetDItem(dlog,item,&the_itemtype,&the_Handle,&Rectangle);	GetIText(the_Handle,&string);	InsetRect(&Rectangle,1,1);		TETextBox ((char*)string+1,(long)string[0],&Rectangle,teCenter);		c1.red=0x8080;	c1.green=0x8080;	c1.blue=0x8080;		RGBForeColor(&c1);	InsetRect(&Rectangle,-1,-1);	FrameRect(&Rectangle);		RGBForeColor(&c);}pascal long C_IncDecValue(DialogPtr Dialog,short itemNumber,short textitemnumber,long minvalue,long maxvalue,long increment){	long		result;	Str255		string;	Handle		the_Handle;	short		the_itemtype;	Rect		Rectangle;	long		start=TickCount();	C_Hilite_icon_button(Dialog,itemNumber);	GetDItem(Dialog,textitemnumber,&the_itemtype,&the_Handle,&Rectangle);	GetIText(the_Handle,&string);	StringToNum(&string,&result);	while	(Button()==true){		if ((TickCount()-start)< 60) WaitTicks(8);		else	WaitTicks(2);			result=result+increment;	if(result>maxvalue) result=maxvalue;	if(result<minvalue) result=minvalue;	NumToString(result,&string);	SetIText(the_Handle,&string);	}	C_Unhilite_icon_button(Dialog,itemNumber);	return(result);}	pascal long C_IncDecValueSpecial(DialogPtr Dialog,short itemNumber,short textitemnumber,long minvalue,long maxvalue,long increment){	long		result;	Str255		string;	Handle		the_Handle;	short		the_itemtype;	Rect		Rectangle;	long		start=TickCount();		C_Hilite_icon_button(Dialog,itemNumber);	GetDItem(Dialog,textitemnumber,&the_itemtype,&the_Handle,&Rectangle);	GetIText(the_Handle,&string);	StringToNum(&string,&result);	while	(Button()==true){		if ((TickCount()-start)< 60) WaitTicks(8);		else	WaitTicks(2);		result=result+increment;	if(result>maxvalue) result=maxvalue;	if(result<minvalue) result=minvalue;	NumToString(result,&string);	SetIText(the_Handle,&string);	EraseRect(&Rectangle);	MoveTo(Rectangle.left,Rectangle.bottom-3);	TextMode(srcCopy);	DrawString(&string);					}	C_Unhilite_icon_button(Dialog,itemNumber);	return(result);}	pascal Boolean TrackCurseur(DialogPtr dialog,short itemnumber){	short	itemtype;	Handle	item;	Rect	rect;	Boolean Inrect;	Point	pt;		if (itemnumber< 0) return false;	GetDItem(dialog,itemnumber,&itemtype,&item,&rect);	while (StillDown()==true){					GetMouse(&pt);				Inrect=PtInRect(pt,&rect);				if (Inrect== true) {					C_Hilite_icon_button(dialog,itemnumber);				} else {					C_Unhilite_icon_button(dialog,itemnumber);				}	}				GetMouse(&pt);		Inrect=PtInRect(pt,&rect);		C_Unhilite_icon_button(dialog,itemnumber);					return Inrect;	}		pascal short C_findIconResourceDitl(DialogPtr Dialog,short itemNumber){	Handle				LaListeH;	DitlelementPtr		LaListe;	Ditl_MasterlistPtr	LaListe1;	long				a;		short				i;		LaListeH=((DialogPeek)Dialog)->items;	HLock(LaListeH);	LaListe=(DitlelementPtr)*LaListeH;	LaListe1=(Ditl_MasterlistPtr)*LaListeH;	//	 	i=LaListe1->dml_NumberOfItem+1;//début de la liste	a=2;	a=a+(long)LaListe;	LaListe=(DitlelementPtr)a;	   	if (itemNumber<=i) {// Boucle de rcherche 	for (i=1; i<itemNumber; i++) {	  	a=(long)LaListe->deLenth;// on aligne  modulo 2	 	if ((a-(a/2)*2)!=0) a=a+1;  	a=a+14+(long)LaListe;	LaListe=(DitlelementPtr)a;	 	} // boucle  	} // if		HUnlock(LaListeH);	return(LaListe->deIdNumber);}		pascal void WaitTicks(long Wait){	EventRecord 	theEvent;	long			trucks;			Boolean			result;		trucks=TickCount();	while ((TickCount()-trucks)<Wait)	result=EventAvail(everyEvent,&theEvent);}void DrawPopUpDial(DialogPtr dialog,short item,MenuHandle menu,short MenuItem){short font;short size;short itemtype;Rect rect;Handle hndl;Str255 string;	// on dessine le pop up	SetPort(dialog);	font=dialog->txFont;	size=dialog->txSize;	GetDItem(dialog,item,&itemtype,&hndl,&rect);	InsetRect(&rect,-1,-1);	FrameRect(&rect);		InsetRect(&rect,1,1);		MoveTo(rect.left+1,rect.bottom+1);	LineTo(rect.right+1,rect.bottom+1);	LineTo(rect.right+1,rect.top-1);		//0n affiche le texte du pop-up menu	TextFont(0);	TextSize(12);	PenNormal();	GetDItem(dialog,item,&itemtype,&hndl,&rect);	GetItem(menu,MenuItem,&string);	rect.right=rect.right-16;	rect.left=rect.left+8;	TextBox(&string[1],(long)string[0],&rect,teJustLeft);	// on dessine le triangle du pop up		GetDItem(dialog,item,&itemtype,&hndl,&rect);	PenSize(2,2);	MoveTo(rect.right+1-(rect.bottom-rect.top-2)/3,rect.top+(rect.bottom-rect.top-2)/3);	Line(-(rect.bottom-rect.top-2),0);	Line((rect.bottom-rect.top-2)/2,(rect.bottom-rect.top-2)/2);	LineTo(rect.right+1-(rect.bottom-rect.top-2)/3,rect.top+(rect.bottom-rect.top-2)/3);	PenNormal();	TextFont(font);	TextSize(size);}	/* cette routine ajoute une chaine à la suite d'une autre */pascal void AppendString(char *source,char *dest){long	l;	l=(long)*((Ptr)source)+*((Ptr)dest);	if (l>255) l=255-(long)*((Ptr)dest);		else l=(long)*((Ptr)source);	BlockMove((Ptr)source+1,(Ptr)dest+1+(long)*((Ptr)dest),l);	*((Ptr)dest)=l+(long)*((Ptr)dest);}pascal void MakeReliefRectangle(rect) 	Rect *rect;{	RGBColor	saveBackColor,color;				EraseRect(rect);				// on dessine le contour blanc				GetForeColor(&saveBackColor);					color.red=0xffff;				color.green=0xffff;				color.blue=0xffff;				RGBForeColor(&color);				MoveTo((*rect).left,(*rect).bottom-1);				LineTo((*rect).right-1,(*rect).bottom-1);				LineTo((*rect).right-1,(*rect).top);				RGBForeColor(&saveBackColor);			// on dessine le contour gris				GetForeColor(&saveBackColor);					color.red=0x4000;				color.green=0x4000;				color.blue=0x4000;				RGBForeColor(&color);				MoveTo((*rect).left,(*rect).bottom);				LineTo((*rect).left,(*rect).top);				LineTo((*rect).right,(*rect).top);				RGBForeColor(&saveBackColor);				} //MakeReliefRectanglepascal void MakeReliefRectangle1(rect) 	Rect *rect;{	RGBColor	saveBackColor,color;								// on dessine le contour blanc				GetForeColor(&saveBackColor);					color.red=0xffff;				color.green=0xffff;				color.blue=0xffff;				RGBForeColor(&color);				MoveTo((*rect).left,(*rect).bottom-1);				LineTo((*rect).right-1,(*rect).bottom-1);				LineTo((*rect).right-1,(*rect).top);				RGBForeColor(&saveBackColor);			// on dessine le contour gris				GetForeColor(&saveBackColor);					color.red=0x6000;				color.green=0x6000;				color.blue=0x6000;				RGBForeColor(&color);				MoveTo((*rect).left,(*rect).bottom-1);				LineTo((*rect).left,(*rect).top);				LineTo((*rect).right-1,(*rect).top);				RGBForeColor(&saveBackColor);				} //MakeReliefRectangle1pascal void MakeReliefRectangle2(Rect *rect) {	RGBColor	saveBackColor,color;								// on dessine le contour blanc				GetForeColor(&saveBackColor);					color.red=0x4000;				color.green=0x4000;				color.blue=0x4000;				RGBForeColor(&color);				MoveTo((*rect).left,(*rect).bottom-1);				LineTo((*rect).right-1,(*rect).bottom-1);				LineTo((*rect).right-1,(*rect).top);				RGBForeColor(&saveBackColor);			// on dessine le contour gris				GetForeColor(&saveBackColor);					color.red=0xefff;				color.green=0xefff;				color.blue=0xefff;				RGBForeColor(&color);				MoveTo((*rect).left,(*rect).bottom-1);				LineTo((*rect).left,(*rect).top);				LineTo((*rect).right-1,(*rect).top);				RGBForeColor(&saveBackColor);				} //MakeReliefRectangle2pascal short SetDitlIconId(DialogPtr Dialog,short itemNumber,short newId){	Handle				LaListeH;	DitlelementPtr		LaListe;	Ditl_MasterlistPtr	LaListe1;	long				a;		short				i;		LaListeH=((DialogPeek)Dialog)->items;	HLock(LaListeH);	LaListe=(DitlelementPtr)*LaListeH;	LaListe1=(Ditl_MasterlistPtr)*LaListeH;	//	 	i=LaListe1->dml_NumberOfItem;//début de la liste	a=2;	a=a+(long)LaListe;	LaListe=(DitlelementPtr)a;	   	if (itemNumber<=i) {// Boucle de rcherche 	for (i=1; i<itemNumber; i++) {	  	a=(long)LaListe->deLenth;// on aligne  modulo 2	 	if ((a-(a/2)*2)!=0) a=a+1;  	a=a+14+(long)LaListe;	LaListe=(DitlelementPtr)a;	 	} // boucle  	} // if		i=LaListe->deIdNumber;	LaListe->deIdNumber=newId;		HUnlock(LaListeH);	return(i);}		/* 	Cette routine permet de dessinner, un dialog	en forçant le texte en srcOr, et dessine les icônes correctement*/pascal void MyDrawDialog(DialogPtr D){PixPatHandle		the_pixpat;short				itemtype,i,IconId,font,a,depth;Handle				item,iconhandle;Rect				rect;Handle				LaListeH,h;DitlelementPtr		LaListe;Ditl_MasterlistPtr	LaListe1;Str255				string;RgnHandle			rgn;RGBColor			savecolor,noir,blanc;		SetPort(D);		depth=GiveMinDepth(&D->portRect);			noir.red=0;		noir.green=0;		noir.blue=0;		blanc.red=-1;		blanc.green=-1;		blanc.blue=-1;		if (depth>=4) {			MakeReliefRectangle(&D->portRect);			the_pixpat=GetPixPat(140);			if (the_pixpat!=nil){				InsetRect(&D->portRect,2,2);				FillCRect(&D->portRect,the_pixpat);				InsetRect(&D->portRect,-2,-2);				DisposePixPat(the_pixpat);				}		}		LaListeH=((DialogPeek)D)->items;		HLock(LaListeH);		LaListe=(DitlelementPtr)*LaListeH;		LaListe1=(Ditl_MasterlistPtr)*LaListeH;				for (i=1;i<=(LaListe1->dml_NumberOfItem+1);i++) {			GetDItem(D,i,&itemtype,&item,&rect);						switch (itemtype&0x7f) {						case iconItem:				IconId=C_findIconResourceDitl(D,i);			  iconhandle=(Handle)GetCIcon(IconId);			  if(iconhandle){				  PlotCIcon(&rect,(CIconHandle)iconhandle);					  DisposeCIcon((CIconHandle)iconhandle);				  }							break;			case picItem:				IconId=C_findIconResourceDitl(D,i);				iconhandle=GetResource('PICT',IconId);				if(iconhandle){					DrawPicture((PicHandle)iconhandle,&rect);					ReleaseResource((Handle)iconhandle);				}			break;			case statText:				GetIText(item,&string);				IconId=D->txFace;				font=D->txFont;				GetForeColor(&savecolor);				RGBForeColor(&noir);				TextFont(0);				TextFace(0);				if (D->txSize) MoveTo(rect.left+1,rect.top+D->txSize+1);					else MoveTo(rect.left+1,rect.top+12+1);				/* on recherche le ^0"*/				if ((string[1]=='^') && (string[2]>=0x30 &&string[2]<=0x32)) {							a=(short)string[2]&0x03;						switch(a){							case 0:								h=(Handle)LMGetDAStrings(0);							break;							case 1:								h=(Handle)LMGetDAStrings(1);							break;							case 2:								h=(Handle)LMGetDAStrings(2);							break;							case 3:								h=(Handle)LMGetDAStrings(3);							break;						}							HLock(h);							if (depth>=4)	DrawString(*h);							if (D->txSize) MoveTo(rect.left,rect.top+D->txSize);								else MoveTo(rect.left,rect.top+12);							RGBForeColor(&blanc);							DrawString(*h);							HUnlock(h);					} else	{							if (depth>=4) DrawString(&string);							if (D->txSize) MoveTo(rect.left,rect.top+D->txSize);								else MoveTo(rect.left,rect.top+12);							RGBForeColor(&blanc);							DrawString(&string);					}				D->txFace=IconId;				D->txFont=font;				RGBForeColor(&savecolor);			break;				case editText:				rgn=NewRgn();				InsetRect(&rect,-3,-3);				RectRgn(rgn,&rect);				UpdateDialog(D,rgn);				DisposeRgn(rgn);			break;				} // switch		}// for 		DrawControls(D);		GetDItem(D,1,&itemtype,&item,&rect);		InsetRect(&rect,-4,-4);		PenSize(3,3);		FrameRoundRect(&rect,16,16);}/* 	Cette routine renvoie la profondeur la plus petite pour le rectangle.	Elle assume que le port courant correspond au port pour dessiner	*/short	GiveMinDepth(Rect *localrect){GDHandle		NextDevice=NULL;Rect			GlobalRect;short			depth=32,newdepth;OSErr			err;CGrafPtr		port;Rect			intersect;	long			result;		GlobalRect=*localrect;		err=Gestalt(gestaltQuickdrawFeatures,&result);	// on regarde si color quickdraw présent		if (err || ((result & (1L << gestaltHasColor)) == 0)) {			return	1;		}		// on conertie les coordonnées en globales		LocalToGlobal((Point*)&GlobalRect.bottom);		LocalToGlobal((Point*)&GlobalRect.top);	// is the current port a color grafport? if not,// pretend we're a 1-bit device (because we are)		GetPort((GrafPtr*) &port);		if ((port->portVersion & 0xC000) != 0xC000) {			// not a color grafport. Only do 1-bit			return 1;			}	 	NextDevice =GetDeviceList();	do{		// regarde si offscreendevice ?		if ((TestDeviceAttribute(NextDevice,screenDevice) == 0)||			(TestDeviceAttribute(NextDevice,screenActive) == 0)) {} 		else {		// un vrai ecran			newdepth = (*(*NextDevice)->gdPMap)->pixelSize;			if (SectRect(&(**NextDevice).gdRect,&GlobalRect,&intersect)) {					if (newdepth<result) depth=newdepth;			}		}// reel device		NextDevice =GetNextDevice(NextDevice);	 } while (NextDevice);	return depth;}pascal Boolean myStandartfilterproc(DialogPtr theDialog ,EventRecord *event,short *itemhit){	short		the_itemType,part,dh,dv;	WindowPtr	window=nil;	Point		The_point;	unsigned char		key;	GrafPtr		oldport;	Boolean		result=false,extend=false;	Handle	item;	Rect		rect;	Str255		st0;	TEHandle	te;			GetIndString(&st0,130,7);		GetPort(&oldport);		SetPort((GrafPtr)theDialog);		switch (event->what ) {		case 0:			break;				case mouseDown:			part = FindWindow(event->where, &window);			switch ( part ) {				case inContent:					SystemClick	(event,window);  //let the system handle it					break;		//									}								break;					case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;			// on filtre les caractères non numériques			if ( (event->modifiers & optionKey)&&(key<32)) {	/* option key down */				if ( (event->modifiers & (shiftKey))) {	/* shift key down */// on bouge la fenêtre par 20							switch	(key){					case 30:						dv=-20;						dh=0;					break;					case 31:						dv=20;						dh=0;					break;					case 28:						dv=0;						dh=-20;					break;					case 29:						dv=0;						dh=20;					break;					}				} else {// on bouge la fenêtre par 1								switch	(key){					case 30:						dv=-1;						dh=0;					break;					case 31:						dv=1;						dh=0;					break;					case 28:						dv=0;						dh=-1;					break;					case 29:						dv=0;						dh=1;					break;						}				}		/*				on déplace la fenêtre		*/ 					The_point.v=window->portRect.top+dv;				The_point.h=window->portRect.left+dh; 				LocalToGlobal(&The_point);				MoveWindow((WindowPtr)theDialog,The_point.h,The_point.v,false);					result=true;								} else {			/* pas option key down */			if ( (event->modifiers & cmdKey)) {							te = ((DialogPeek)theDialog)->textH;					switch(key) {							case 'x':							case 'X':								if (((**te).selStart-(**te).selEnd !=0)){ 									SystemEdit(3); 									ZeroScrap(); 									TECut(te);									TEToScrap(); 									}									break;							case 'c':							case 'C':								if (((**te).selStart-(**te).selEnd !=0)){ 									SystemEdit(3); 									ZeroScrap();									TECopy(te);								 	TEToScrap(); 								}																break;							case 'v':							case 'V':									TEFromScrap();									TEPaste(te);								break;															case 'a':							case 'A':									TESetSelect(0,32767,te);							break;					} // switch					}	//if cmd key down 			switch(key) {				case 3: // ok bouton				case 13: // ok bouton					*itemhit=1;					result=true;					GetDItem((DialogRef)theDialog,1,&the_itemType,&item,&rect);					HiliteControl((ControlHandle)item,true);					WaitTicks(10);					break;									case 27:	// esc					*itemhit=2;					result=true;					GetDItem(theDialog,2,&the_itemType,&item,&rect);					HiliteControl((ControlHandle)item,true);					WaitTicks(10);					break;											} //switch			} //else			break;				case updateEvt:			if (event->message ==(long)theDialog)	{				BeginUpdate(theDialog);				DrawDialog(theDialog);				EndUpdate(theDialog);			} else	DoUpdate((WindowPtr)event->message);					break;				}//	switch		SetPort(oldport);		return (result);} // myStandartfilterprocpascal Boolean Filter_WithCountDown(DialogPtr theDialog,EventRecord *event,short *itemhit){	short		the_itemType,part,dh,dv;	WindowPtr	window=nil;	Point		The_point;	unsigned char		key;	GrafPtr		oldport;	Boolean		result=false,extend=false;	Handle	item;	Rect		rect;	Str255		st0;	TEHandle	te;		long		a,b;				GetPort(&oldport);		SetPort((GrafPtr)theDialog);				if (gStartSecond==-2)	gStartSecond=LMGetTime()+11;				a=gStartSecond-LMGetTime();		if (a<0) {					GetDialogItem((DialogRef)theDialog,1,&the_itemType,&item,&rect);					HiliteControl((ControlHandle)item,true);					WaitTicks(10);					*itemhit=1;					result=true;					}		GetDItem(theDialog,6,&the_itemType,&item,&rect);		GetIText(item,&st0);					StringToNum(&st0,&b);		if (b!=a){			NumToString(a,&st0);			SetIText(item,&st0);						}				GetIndString(&st0,130,7);		switch (event->what ) {		case 0:			break;				case mouseDown:			part = FindWindow(event->where,&window);			switch ( part ) {				case inContent:					SystemClick	(event,window);  //let the system handle it					break;		//									}								break;					case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;			// on filtre les caractères non numériques			if ( (event->modifiers & optionKey)&&(key<32)) {	/* option key down */				if ( (event->modifiers & (shiftKey))) {	/* shift key down */// on bouge la fenêtre par 20							switch	(key){					case 30:						dv=-20;						dh=0;					break;					case 31:						dv=20;						dh=0;					break;					case 28:						dv=0;						dh=-20;					break;					case 29:						dv=0;						dh=20;					break;					}				} else {// on bouge la fenêtre par 1								switch	(key){					case 30:						dv=-1;						dh=0;					break;					case 31:						dv=1;						dh=0;					break;					case 28:						dv=0;						dh=-1;					break;					case 29:						dv=0;						dh=1;					break;						}				}		/*				on déplace la fenêtre		*/ 					The_point.v=window->portRect.top+dv;				The_point.h=window->portRect.left+dh; 				LocalToGlobal(&The_point);				MoveWindow((WindowPtr)theDialog,The_point.h,The_point.v,false);					result=true;								} else {			/* pas option key down */			if ( (event->modifiers & cmdKey)) {							te = ((DialogPeek)theDialog)->textH;					switch(key) {							case 'x':							case 'X':								if (((**te).selStart-(**te).selEnd !=0)){ 									SystemEdit(3); 									ZeroScrap(); 									TECut(te);									TEToScrap(); 									}									break;							case 'c':							case 'C':								if (((**te).selStart-(**te).selEnd !=0)){ 									SystemEdit(3); 									ZeroScrap();									TECopy(te);								 	TEToScrap(); 								}																break;							case 'v':							case 'V':									TEFromScrap();									TEPaste(te);								break;															case 'a':							case 'A':									TESetSelect(0,32767,te);							break;					} // switch					}	//if cmd key down 			switch(key) {				case 3: // ok bouton				case 13: // ok bouton					*itemhit=1;					result=true;					GetDItem(theDialog,1,&the_itemType,&item,&rect);					HiliteControl((ControlHandle)item,true);					WaitTicks(10);					break;									case 27:	// esc					*itemhit=2;					result=true;					GetDItem(theDialog,2,&the_itemType,&item,&rect);					HiliteControl((ControlHandle)item,true);					WaitTicks(10);					break;											} //switch			} //else			break;				case updateEvt:			if (event->message !=(long)theDialog)	{				DoUpdate((WindowPtr)event->message);				}		break;				}//	switch		SetPort(oldport);		return (result);} // FilterWithCountDown/* Fonction pour les slider */pascal sliderstructHandle GetNewSlider(short minvalue,			short maxvalue,short value,short increment,Rect *rect){			sliderstructHandle slider;					slider=(sliderstructHandle)NewHandle(sizeof(sliderstruct));		if (slider){		(**slider).min=minvalue;		(**slider).max=maxvalue;		(**slider).value=value;		(**slider).increment=increment;		(**slider).bounds=*rect;		}		return	slider;}pascal void DrawSlider(sliderstructHandle slider){CIconHandle	icon;Rect	rect;RGBColor	saveBackColor,color;	long	a,b;Str255	string;			rect.left=(**slider).bounds.left;		rect.right=(**slider).bounds.right;		rect.top=((**slider).bounds.top+(**slider).bounds.bottom)/2-1;		rect.bottom=rect.top+2;		rect.top-=8;		rect.bottom+=8;					EraseRect(&(**slider).bounds);				rect.top+=8;		rect.bottom-=8;					// on dessine le contour blanc				GetForeColor(&saveBackColor);					color.red=0xffff;				color.green=0xffff;				color.blue=0xffff;				RGBForeColor(&color);				MoveTo(rect.left,rect.bottom);				LineTo(rect.right,rect.bottom);				LineTo(rect.right,rect.top);				RGBForeColor(&saveBackColor);			// on dessine le contour gris				GetForeColor(&saveBackColor);					color.red=0x0000;				color.green=0x0000;				color.blue=0x0000;				RGBForeColor(&color);				MoveTo(rect.left,rect.bottom);				LineTo(rect.left,rect.top);				LineTo(rect.right,rect.top);				RGBForeColor(&saveBackColor);				// on calcule la position du slider			a=(long)(**slider).bounds.right-(**slider).bounds.left-15;			a=a*((**slider).value-(**slider).min);			a=a/((long)(**slider).max-(**slider).min);			b=(**slider).max-(**slider).min;// on effectue l'incrément					a=(a/b)*b;		// on dessine le curseur			rect.left=(**slider).bounds.left+a+5;			rect.right=rect.left+10;			rect.top=((**slider).bounds.top+(**slider).bounds.bottom)/2-7;			rect.bottom=rect.top+13;						icon=GetCIcon(155);			if (icon) {				PlotCIcon(&rect,icon);				DisposeCIcon(icon);			}			 NumToString((long)(**slider).value,&string);			 MoveTo((**slider).bounds.right+8,(**slider).bounds.top+12);			 TextMode(srcCopy);			 if (string[0]==1) {						 	string[0]=2;						 	string[2]=string[1];						 	string[1]=48;			 }						 DrawString(&string);}pascal short DoSliderFollow(sliderstructHandle slider){Point		pt;RgnHandle	rgn;GrafPtr		port;long a,b,c;		Rect rect;	CIconHandle	icon;RGBColor	saveBackColor,color;	Str255	string;			rgn=NewRgn();			GetPort(&port);						CopyRgn(port->clipRgn,rgn);			GetMouse(&pt);	// on calcule la nouvelle valeur			a=pt.h;			if (a<(**slider).bounds.left+5) a=(long)(**slider).bounds.left+5;			if (a>(**slider).bounds.right-10) a=(long)(**slider).bounds.right-10;							a=a-(long)(**slider).bounds.left+5;			a=a*((long)(**slider).max-(**slider).min);			a=a/((long)(**slider).bounds.right-(**slider).bounds.left-15);			b=a+(**slider).min;// on efface l'ancien 			if (b!=(**slider).value) {				a=(long)(**slider).bounds.right-(**slider).bounds.left-15;				a=a*((**slider).value-(**slider).min);				a=a/((long)(**slider).max-(**slider).min);				c=(**slider).max-(**slider).min;	// on effectue l'incrément						a=(a/c)*c;		// on dessine le curseur			rect.left=(**slider).bounds.left+a+5;			rect.right=rect.left+10;			rect.top=((**slider).bounds.top+(**slider).bounds.bottom)/2-7;			rect.bottom=rect.top+13;				RectRgn(port->clipRgn,&rect);				rect.left=(**slider).bounds.left;				rect.right=(**slider).bounds.right;				rect.top=((**slider).bounds.top+(**slider).bounds.bottom)/2-1;				rect.bottom=rect.top+2;				rect.top-=8;				rect.bottom+=8;							EraseRect(&(**slider).bounds);						rect.top+=8;				rect.bottom-=8;					// on dessine le contour blanc				GetForeColor(&saveBackColor);					color.red=0xffff;				color.green=0xffff;				color.blue=0xffff;				RGBForeColor(&color);				MoveTo(rect.left,rect.bottom);				LineTo(rect.right,rect.bottom);				LineTo(rect.right,rect.top);				RGBForeColor(&saveBackColor);			// on dessine le contour gris				GetForeColor(&saveBackColor);					color.red=0x0000;				color.green=0x0000;				color.blue=0x0000;				RGBForeColor(&color);				MoveTo(rect.left,rect.bottom);				LineTo(rect.left,rect.top);				LineTo(rect.right,rect.top);				RGBForeColor(&saveBackColor);						CopyRgn(rgn,port->clipRgn);				DisposeRgn(rgn);			}			(**slider).value=b;// on calcule la position du slider			a=(long)(**slider).bounds.right-(**slider).bounds.left-15;			a=a*((**slider).value-(**slider).min);			a=a/((long)(**slider).max-(**slider).min);			b=(**slider).max-(**slider).min;// on effectue l'incrément					a=(a/b)*b;		// on dessine le curseur			rect.left=(**slider).bounds.left+a+5;			rect.right=rect.left+10;			rect.top=((**slider).bounds.top+(**slider).bounds.bottom)/2-7;			rect.bottom=rect.top+13;						icon=GetCIcon(155);			if (icon) {				PlotCIcon(&rect,icon);				DisposeCIcon(icon);			}			 NumToString((long)(**slider).value,&string);			 MoveTo((**slider).bounds.right+8,(**slider).bounds.top+12);			 TextMode(srcCopy);			 if (string[0]==1) {						 	string[0]=2;						 	string[2]=string[1];						 	string[1]=48;			 }						 DrawString(&string);			return b;}pascal	void FrameRectTwoLine(Rect *rect,Boolean Enfonce){	RGBColor	saveBackColor,color;									PenSize(1,1);								if (Enfonce) { //relief  enfoncé				 // on dessine le contour gris clair clair					 GetForeColor(&saveBackColor);						 color.red=0xEfff;					 color.green=0xEfff;					 color.blue=0xEfff;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);	 				 // on dessine le contour gris sombre sombre					 GetForeColor(&saveBackColor);						 color.red=0x4000;					 color.green=0x4000;					 color.blue=0x4000;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).left,(*rect).top);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);									 PenNormal();					 					 InsetRect(rect,1,1);					 				 // on dessine le contour gris clair					 GetForeColor(&saveBackColor);						 color.red=0xCfff;					 color.green=0xCfff;					 color.blue=0xCfff;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);	 				 // on dessine le contour gris sombre					 GetForeColor(&saveBackColor);						 color.red=0x6000;					 color.green=0x6000;					 color.blue=0x6000;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).left,(*rect).top);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);									 PenNormal();					 				} else {								 // on dessine le contour gris clair								// on dessine le contour gris sombre sombre					 GetForeColor(&saveBackColor);						 color.red=0x4000;					 color.green=0x4000;					 color.blue=0x4000;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);	 				 // on dessine le contour gris clair clair					 GetForeColor(&saveBackColor);						 color.red=0xEF00;					 color.green=0xEF00;					 color.blue=0xEF00;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).left,(*rect).top);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);									 PenNormal();					 					 InsetRect(rect,1,1);					 					// gris sombre 										 GetForeColor(&saveBackColor);						 color.red=0x6000;					 color.green=0x6000;					 color.blue=0x6000;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);	 				 // on dessine le contour gris clair				 					 GetForeColor(&saveBackColor);						 color.red=0xCfff;					 color.green=0xCfff;					 color.blue=0xCfff;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).left,(*rect).top);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);									 PenNormal();				}				} //FrameRectTwoLinepascal	void FrameRectOneLine(Rect *rect,Boolean Enfonce){	RGBColor	saveBackColor,color;									PenSize(1,1);								if (Enfonce) { //relief  enfoncé					 				 // on dessine le contour gris clair					 GetForeColor(&saveBackColor);						 color.red=0xffff;					 color.green=0xffff;					 color.blue=0xffff;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);	 				 // on dessine le contour gris sombre					 GetForeColor(&saveBackColor);						 color.red=0x4000;					 color.green=0x4000;					 color.blue=0x4000;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).left,(*rect).top);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);									 PenNormal();					 				} else {								 // on dessine le contour gris clair									// gris sombre										 GetForeColor(&saveBackColor);						 color.red=0x4000;					 color.green=0x4000;					 color.blue=0x4000;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).bottom-1);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);	 				 // on dessine le contour gris clair				 					 GetForeColor(&saveBackColor);						 color.red=0xffff;					 color.green=0xffff;					 color.blue=0xffff;					 RGBForeColor(&color);					 MoveTo((*rect).left,(*rect).bottom-1);					 LineTo((*rect).left,(*rect).top);					 LineTo((*rect).right-1,(*rect).top);					 RGBForeColor(&saveBackColor);									 PenNormal();				}				} //SpecialFrameRect1