#include "BB.Globals_C.h"#include <stdlib.h>// les globals  	extern MyQDGlobals QD;	extern AppGlobals G;// en attendant	short gvarmode;/* prototypes */void			DessineBarreControlListing(void);void			DessineLaChenille(long TCCentre);void			AfficheTexteST_Listing(SousTitreRecordPtr ST_Ptr,Rect *rect,short CharSize,short AfficheCR);pascal void	DoGrowWindow(WindowPtr w,Rect *MaxNewSize,Point where);pascal void	DrawBlockNoteValue(void);pascal void	CentreListingWindowTRACKING(void);pascal void	CentreListingWindowByNumST(long stnum);void UpdateProchainSousTitre(Boolean partiel);pascal void DrawSaisieValuePartiel(void);void TxVITCReader(long 	code,long message ,short refnum);extern long	 gVitesseVTR;pascal long TestSiDansST(SousTitreRecordPtr ST_Ptr:__A0,unsigned long TC:__D0):__D0;void DoSerialIdle(void);void DoSaisieIdle(void); void FlashTrackingSaisie(void);pascal void  DessineTrackingValiderSaisie(void);extern Boolean gMethodeLectureRS422;extern Boolean		gDone,gRefreshInfoW,gMaxSpeed,doTrackingInListing,doTrackingOutListing,doTrackingInSaisie,doTrackingOutSaisie;extern DialogPtr 	gDialogProchainSousTitre,gMonitor,gtestDecodageWindow;extern RGBColor	gKeyColor;extern Ptr		gDecodeBlanckingVerticalBuffer,gDecodageVerticalST;extern short		 gResultatlectureBlancking,gWatchdog;extern Boolean		gNouveauMessage;extern long		glastCheckSum,gCheckSum;/* Ce fichier contient les routines pour dessiner les fenêtres du logiciel */pascal void DrawListingWindow(void){CGrafPtr		oldport,portdessin;	Rect		rect,rect1,rect_port;RgnHandle	rgn;short		value,maxvisible,Ystart,i;WindowPtr	w=(WindowPtr)&G.ListingWindow;SousTitreRecordPtr	ST_Ptr;RGBColor	color,txcolor,backColor,ForeColor,white,black;Point		pt1,pt2;PixPatHandle	the_pixpat;GDHandle	gdhad;		if (G.HauteurST<ListingHauteurCarreST 	) 		G.HauteurST=ListingHauteurCarreST;		if (G.HauteurST>(ListingHauteurCarreST*2) 	) 	G.HauteurST=ListingHauteurCarreST*2;		black.red=0;		black.green=0;		black.blue=0;		white.red=0xffff;		white.green=0xffff;		white.blue=0xffff;				GetGWorld(&oldport,&gdhad);		SetPort(w);				RectRgn(w->clipRgn,&w->portRect);		rect_port=w->portRect;		rgn=NewRgn();				GetBackColor(&backColor);		GetForeColor(&ForeColor);		if (G.OffscreenListing) {			SetGWorld(G.OffscreenListing,nil);					LockPixels(GetGWorldPixMap(G.OffscreenListing));			portdessin=(CGrafPtr)G.OffscreenListing;		} else portdessin=(CGrafPtr)&G.ListingWindow;				RGBBackColor(&backColor);		RGBForeColor(&ForeColor);				// si lock pixel = false on dessine directement dans l'écran				RectRgn(portdessin->clipRgn,&portdessin->portRect);		if (G.OffscreenListing) EraseRect(&portdessin->portRect);/* il faut calculer le start point d'affichage du texte; on cherche la coordonnée y dans le controle vertical			*/				value=GetCtlValue(G.ListingVScroll);		ST_Ptr=C_ConversionNumeroSTPointeur((long)value);				/* on calcule combien de st vont ètre affiché dans la fenètre; on recupère la taille de la fenètre */		rect=rect_port;				maxvisible=(rect.bottom-rect.top-18)/G.HauteurST;		G.ListingMaxDisplay=maxvisible; // on le stocke dans les globales		PenNormal();		color.red=0xBFFF;		color.green=0xBFFF;		color.blue=0xBFFF;				txcolor.red=0;		txcolor.green=0;		txcolor.blue=0;		RGBForeColor(&color);								TextMode(srcOr);	// on devrai demander la taille etc ...		TextFont(geneva);	// pour une version internationnale		TextSize(9);		RGBForeColor(&color);/* On dessine la barre d'information */		DessineBarreControlListing();		/* on dessine la liste de sous-titre */		rect=rect_port;				rect.right-=15;		rect.bottom-=15;			// on rempli la fenêtre par la pattern		the_pixpat=GetPixPat(G.Listing_PatNum);				if (the_pixpat!=nil){			FillCRect(&rect,the_pixpat);			DisposePixPat(the_pixpat);			}			// on fait le relief		FrameRectTwoLine(&rect,true);			// on limite la zone de dessin				InsetRect(&rect,2,2);						RectRgn(portdessin->clipRgn,&rect);			pt1.h=rect.left;		pt1.v=rect.top;		pt2.h=rect.right;		pt2.v=rect.bottom;				// on dessine la liste		rect1=rect;		rect1.right-=40;		Ystart=4;		i=0;		do{ 			if (ST_Ptr)DrawOneSousTitre(ST_Ptr,4,Ystart,pt1,pt2);			Ystart+=G.HauteurST;			ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_NextST; 			i++;		} while (ST_Ptr!= nil && i<=maxvisible);				if (G.OffscreenListing) {			  SetGWorld(oldport,gdhad);			  	  // copy bits			  rect=rect_port;			  rect.right-=15;			  			  CopyRgn(w->clipRgn,rgn);			  RectRgn(w->clipRgn,&w->portRect);			  			  RGBBackColor(&white);			  RGBForeColor(&black);			  			  CopyBits(&( ((GrafPtr)G.OffscreenListing)->portBits),&( ((GrafPtr)w)->portBits ),&rect,&rect,srcCopy,w->visRgn);	  			  RGBBackColor(&backColor);			  RGBForeColor(&ForeColor);	  	  // on dessine le grow region si fenêtre active			  UnlockPixels(GetGWorldPixMap(G.OffscreenListing));			  }			  		rect=w->portRect;		rect.left=rect.right-15;		RectRgn(w->clipRgn,&rect);		DrawControls(w);		DrawGrowIcon(w);		// on rend la region originale		//CopyRgn(rgn,w->clipRgn);		RectRgn(w->clipRgn,&w->portRect);		DisposeRgn(rgn);		SetGWorld(oldport,gdhad);}// fonction pour updater le gworld de listingpascal void update_listingGworld(void){	WindowPtr	w;	Rect		rect;	GrafPtr	oldport;				w=(WindowPtr)&G.ListingWindow;			GetPort(&oldport);			SetPort(w);						rect.top=0;			rect.left=0;			rect.bottom=w->portRect.bottom-w->portRect.top;			rect.right=w->portRect.right-w->portRect.left;				if (G.OffscreenListing)			if (GiveMinDepth(&w->portRect)==1) UpdateGWorld(&G.OffscreenListing,8,&rect,nil,nil,0);					else UpdateGWorld(&G.OffscreenListing,0,&rect,nil,nil,0);			 			SetPort(oldport);}/* Cette routine ajuste la taille du CONTROL de la fenêtre listing *//*pascal void Adjust_ListingScrollBar(void) {WindowPtr	window=(WindowPtr)&G.ListingWindow;	MoveControl(G.ListingVScroll, window->portRect.right - kScrollbarAdjust,0);	SizeControl(G.ListingVScroll, kScrollbarWidth, (window->portRect.bottom - 				window->portRect.top) - 15);			}*/pascal void DoActivateListingWindow (Boolean becomingActive){	WindowPtr	window=(WindowPtr)&G.ListingWindow;	Rect		growRect,rect;	GrafPtr		oldport;		GetPort(&oldport);	SetPort(window);	RectRgn(window->clipRgn,&window->portRect);		if ( becomingActive ) {						/* the controls must be redrawn on activation: */			(*G.ListingVScroll)->contrlVis = kControlVisible;			InvalRect(&(*G.ListingVScroll)->contrlRect);			/* the growbox needs to be redrawn on activation: */			growRect = window->portRect;			/* adjust for the scrollbars */			growRect.top = growRect.bottom - kScrollbarAdjust;			growRect.left = growRect.right - kScrollbarAdjust;			InvalRect(&growRect);		}	else {					/* the controls must be hidden on deactivation: */			HideControl(G.ListingVScroll);			(*G.ListingVScroll)->contrlVis = kControlInvisible;			/* the growbox should be changed immediately on deactivation: */			SetRect(&rect,window->portRect.right-13,window->portRect.bottom-14,							window->portRect.right,window->portRect.bottom);			EraseRect(&rect);						/* on dessine le grow icon*/			//rgn=NewRgn();			//CopyRgn(window->clipRgn,rgn);			rect=window->portRect;			rect.left=rect.right-14;			//RectRgn(window->clipRgn,&rect);			DrawGrowIcon(window);				// on rend la region originale			//CopyRgn(rgn,window->clipRgn);			//DisposeRgn(rgn);		}	SetPort(oldport);	} /*DoActivate*/pascal void AfficheTrackingStatus(void){WindowPtr	w=(WindowPtr)&G.ListingWindow;RGBColor	color;short		a,b;Str255		st0;Rect		rect,rect1;		PenNormal();		color.red=0xCFFF;		color.green=0xCFFF;		color.blue=0xCFFF;		RGBForeColor(&color);								TextMode(srcOr);	// on devrai demander la taille etc ...		TextFont(geneva);	// pour une version internationnale		TextSize(9);/* On dessine la barre d'information */				rect=w->portRect;		rect.top=rect.bottom-14;		rect.right=119; // 1 relief		rect1=rect;		PaintRect(&rect1);		FrameRectTwoLine(&rect1,false);		// on place le texte tracking		color.red=0;		color.green=0;		color.blue=0;		RGBForeColor(&color);		GetIndString(&st0,132,13);		MoveTo(rect.left+5,rect.bottom-4);		DrawString(&st0);				// on place le mode tracking en cours				a=0;		b=G.Preference_Tracking;		b&=0x03;		if (b==3 ) a=2;		else if (G.Preference_Tracking&1) a=1;		GetIndString(&st0,132,14+a);		DrawString(&st0);}pascal void DoGrowWindow(WindowPtr w,Rect *MaxNewSize,Point where){long a;		GrafPtr	oldport;	GetPort(&oldport);	SetPort(w);		a=GrowWindow(w,where,MaxNewSize);	if (a){		SizeWindow(w,LoWord(a),HiWord(a),true);		InvalRect(&w->portRect);		}	SetPort(oldport);}pascal void DoListingIdle (void){GrafPtr		oldport;	Rect		rect,rect1;WindowPtr	w=(WindowPtr)&G.ListingWindow;RGBColor	color,txcolor,oldcolor,oldFcolor;long		a;			GetPort(&oldport);		SetPort(w);		rect=w->portRect;	//	LocalToGlobal((Point*)&rect);		//LocalToGlobal((Point*)&rect+(Point*)4);		RectRgn(w->clipRgn,&rect);		PenNormal();		GetBackColor(&oldcolor);		GetForeColor(&oldFcolor);				color.red=0xBFFF;		color.green=0xBFFF;		color.blue=0xBFFF;		RGBBackColor(&color);				txcolor.red=0;		txcolor.green=0x8FFF;		txcolor.blue=0;		RGBForeColor(&color);								TextMode(srcCopy);	// on devrai demander la taille etc ...		TextFont(geneva);	// pour une version internationnale		TextSize(9);		RGBForeColor(&color);		/* On dessine le time code courant */				rect=w->portRect;		rect.top=rect.bottom-14;		rect.left=317;		rect.right=457; // 1 relief		rect1=rect;				MoveTo(rect.left,rect.bottom-3);		// on place le texte "time code courant"		RGBForeColor(&txcolor);				// on regarde si l'on est dans un sous-titre				if( G.DrawState&0xff) {			color.red=0;			color.green=0;			color.blue=0;			RGBBackColor(&color);			color.red=-1;			color.green=-1;			color.blue=-1;			RGBForeColor(&color);		}				// on regarde si watchdog <50  (on est sûr de ne pas rater le moment a zero)		if(gWatchdog<50) {			color.red=40000;			color.green=0;			color.blue=0;			RGBForeColor(&color);		}										// on dessine le time code courant		TextFace(bold);		C_ConversionTCstASCII(G.General_TCCourant,(Ptr)&G.bufferTimecodeCourant);		DrawString((Ptr)&G.bufferTimecodeCourant);				PenNormal();		TextFace(0);		RGBBackColor(&oldcolor);		RGBForeColor(&oldFcolor);		// on place l'icône de sauvegarde			rect1=rect;			rect1.left=457;			rect1.left+=3;			rect1.bottom-=0;			rect1.top=rect1.bottom-14;			rect1.right=rect1.left+14;				if(!(G.ChangeSinceLastSave&0x8000)) {			if (G.ChangeSinceLastSave&0x7fff) {				PlotCIcon(&rect1,G.IconSauvegardeOn);			} else {						PlotCIcon(&rect1,G.IconSauvegardeOff);			}					// on place le bit b15 à 1 pour dire que l'icône a été dessiné			G.ChangeSinceLastSave=G.ChangeSinceLastSave|0x8000; 		}// on gère l'affichage de l'icône de réception série		rect1.left+=18;		rect1.right+=18;				if (G.SerialError>=22) PlotCIcon(&rect1,G.IconHandle1);				if(G.SerialError >0) {			G.SerialError--;			if (G.SerialError==0) PlotCIcon(&rect1,G.IconHandle2);		}		// on regarde les tracking		if(doTrackingInListing){			doTrackingInListing=0;			CentreListingWindowTRACKING();		}		if(doTrackingOutListing){			doTrackingOutListing=0;			a=G.General_SousTitreDisplayed;			G.General_SousTitreDisplayed=0;			DrawSt_enCourDansListing_ByPointeur(a);					}			SetPort(oldport);}pascal void DrawOneSousTitre(SousTitreRecordPtr ST_Ptr,							short Xstart,short Ystart,							Point P1,Point P2){Rect							rect;short						value;long							absnum;long							a,b,c;Str255						string;RGBColor					color,saveColor,Save_BackRgbColor,textcolor,rouge,noir,currentBack,blanc;Boolean						flag;		SousTitreRecordPtr	st1;Ptr							P;Byte							car;short						CharSize,mincolor;short						VIncrement;short						LargeurTC,largeurTCIn,NormalFace;WindowPtr				w=(WindowPtr)&G.ListingWindow;GrafPtr					oldport;//on limite la taille du sous-titre		if (G.HauteurST>100 )	G.HauteurST=100;// on calcule différent parramètre en fct de la hauteur du sous-titre		CharSize=((G.HauteurST-4)*3)/20;		VIncrement=(G.HauteurST-4)/5-1;		if (G.HauteurST>80)	NormalFace=condense;										else	NormalFace=0;		TextSize(CharSize);		TextFont(geneva);		// on efface l'espace pour le sous-titre// si c'est un sous-titre trové par le tc 			absnum=ST_Ptr->st_AbsNUMST;		GetBackColor(&Save_BackRgbColor);		GetForeColor(&saveColor);		currentBack=Save_BackRgbColor;		currentBack.red=0xB5DD;		currentBack.green=0xB5DD;		currentBack.blue=0xB5DD;				textcolor.red=0;		textcolor.green=0;		textcolor.blue=0;		rouge.red=0xffff;		rouge.green=0;		rouge.blue=0;				noir.red=0;		noir.green=0;		noir.blue=0;				blanc.red=0;		blanc.green=0;		blanc.blue=0;						RGBForeColor(&currentBack);		GetPort(&oldport);		SetPort(w);		mincolor=GiveMinDepth(&w->portRect);				SetPort(oldport);			if(absnum!=(long)G.General_SousTitreEncour){					currentBack.blue=0x8000;					currentBack.green=0x8000;					currentBack.red=0x8000;					RGBBackColor(&currentBack);					RGBForeColor(&currentBack);					}										if(absnum==(long)G.General_SousTitreDisplayed) {					currentBack.blue=43402;					currentBack.green=41725;					currentBack.red=11186;					RGBBackColor(&currentBack);					RGBForeColor(&currentBack);										textcolor.red=0xffff;					textcolor.green=0xffff;					textcolor.blue=0xffff;					}					SetRect(&rect,Xstart,Ystart,Xstart+417+6+ajout_largeur_ST_Listing,Ystart+G.HauteurST-2);		PaintRect(&rect);				if (mincolor==1) 			if(absnum!=(long)G.General_SousTitreEncour){						RGBForeColor(&noir);						PenSize(2,2);						FrameRect(&rect);						PenNormal();					}				RGBForeColor(&saveColor);// on dessine le relief				flag=true;		if(absnum==(long)G.General_SousTitreEncour) flag=false;		FrameRectTwoLine(&rect,flag);				PenNormal();		TextFace(NormalFace);		if(absnum==(long)G.General_SousTitreEncour){				Xstart--;				Ystart--;				}				// on affiche la position horizontale		if (mincolor!=1) TextMode(srcOr);		a=(long)ST_Ptr->st_XOffset;		if (a) {					color.green=0;			color.red=0;			color.blue=0;			RGBForeColor(&color);							MoveTo(Xstart+476-45+ajout_largeur_ST_Listing,Ystart+VIncrement+1);			NumToString(a,&string);			DrawString("\pX: ");			DrawString(&string);			if (mincolor !=1){				color.green=0xffff;				color.red=0xffff;				color.blue=0xffff;				RGBForeColor(&color);				MoveTo(Xstart+476-46+ajout_largeur_ST_Listing,Ystart+VIncrement);				NumToString(a,&string);				DrawString("\pX: ");				DrawString(&string);				}			RGBForeColor(&textcolor);			}// on affiche la position verticale du sous-titre		a=(long)ST_Ptr->st_YOffset;		if (a) {			MoveTo(Xstart+525-45+ajout_largeur_ST_Listing,Ystart+VIncrement*1+1);					color.green=0;			color.red=0;			color.blue=0;			RGBForeColor(&color);						NumToString(a,&string);			DrawString("\pY: ");			DrawString(&string);						if (mincolor !=1){				color.green=0xffff;				color.red=0xffff;				color.blue=0xffff;				RGBForeColor(&color);								MoveTo(Xstart+525-46+ajout_largeur_ST_Listing,Ystart+VIncrement);				NumToString(a,&string);				DrawString("\pY: ");				DrawString(&string);				}			RGBForeColor(&textcolor);			}// on affiche le type de cache// on n'affiche le cache que s'il est différent de pas de cache		a=(long)ST_Ptr->st_MasKType;				if (a>0 && a<4){			MoveTo(Xstart+476-45+ajout_largeur_ST_Listing,Ystart+VIncrement*2+1);			color.green=0;			color.red=0;			color.blue=0;			RGBForeColor(&color);						// on affiche le texte "cache"			GetIndString(&string,132,8);			DrawString(&string);			// on affiche le type de cache			MoveTo(Xstart+476-45+ajout_largeur_ST_Listing,Ystart+VIncrement*3+1);			GetIndString(&string,131,(short)a+1);			DrawString(&string);					if (mincolor !=1){				 color.green=0xffff;				 color.red=0xffff;				 color.blue=0xffff;				 RGBForeColor(&color);				 				 				 // on affiche le texte "cache"				 MoveTo(Xstart+476-46+ajout_largeur_ST_Listing,Ystart+VIncrement*2);				 GetIndString(&string,132,8);				 DrawString(&string);	 				 // on affiche le type de cache				 MoveTo(Xstart+476-46+ajout_largeur_ST_Listing,Ystart+VIncrement*3);				 GetIndString(&string,131,(short)a+1);				 DrawString(&string);				}			RGBForeColor(&textcolor);			}// affichage 'st n°		RGBForeColor(&textcolor);		MoveTo(Xstart+7,Ystart+VIncrement);		GetIndString(&string,132,1);		DrawString(&string);		// si le sous-titre à été trouvé par une fonction, on inverse le mode d'ecriture.		if (mincolor !=1){			 color.blue=0xA000;			 color.green=0;		 	color.red=0;			 RGBForeColor(&color);		 }		 TextFace(bold);		 		 if (absnum==(long)G.General_SousTitretrouve)			TextMode(notSrcOr);				C_ConvertiNumST_String(ST_Ptr->st_NumeroST,&string);		DrawString(&string);		TextMode(srcOr);		RGBForeColor(&textcolor);		TextFace(NormalFace);// affichage TC début  --------------------------------------		MoveTo(Xstart+7,Ystart+VIncrement*3+2);		GetIndString(&string,132,2);		DrawString(&string);		largeurTCIn=StringWidth(&string);		LargeurTC=StringWidth("\p00:00:00:00");// on regarde s'il y a une erreur sur le tc in		/* tc >= tc out */		if (ST_Ptr->st_TimeCodeIn >=ST_Ptr->st_TimeCodeOut ) {						RGBForeColor(&rouge);						if (mincolor==1) TextMode(bold);						}				/* on regarde l'interval avec le sous-titre précédent */		st1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;		a=ST_Ptr->st_TimeCodeIn;		if (st1){			b=st1->st_TimeCodeOut;			if (b!=-1 && a!=-1) {			c= 	C_ConversionTimeCodeTrames(a)-				C_ConversionTimeCodeTrames(b);				if (c<G.Preference_Interval) {						RGBForeColor(&rouge);						if (mincolor==1) TextMode(bold);						}				}		}				C_ConversionTCstASCII(ST_Ptr->st_TimeCodeIn,&string);		DrawString(&string);		RGBForeColor(&textcolor); // on rend la couleur initiale	// on dessine la zone en gris			if (G.General_Preference_DessinGris) {			SetRect(&rect,Xstart+5+largeurTCIn,Ystart+VIncrement*2+4,Xstart+7+LargeurTC+2+largeurTCIn,Ystart+VIncrement*3+4);			PenPat(&QD.gray);			FrameRect(&rect);			PenNormal();			TextFace(NormalFace);		}		TextMode(0);		if (mincolor !=1) TextMode(srcOr);		// affichage TC fin --------------------------------------		MoveTo(Xstart+7,Ystart+VIncrement*4+2);		GetIndString(&string,132,3);		DrawString(&string);		MoveTo(Xstart+7+largeurTCIn,Ystart+VIncrement*4+3);		// on regarde s'il y a une erreur sur le tc out		/* tc >= tc out */		if (ST_Ptr->st_TimeCodeIn >=ST_Ptr->st_TimeCodeOut ){						RGBForeColor(&rouge);						if (mincolor==1) TextMode(bold);						}				/* on regarde l'interval avec le sous-titre suivant */		st1=(SousTitreRecordPtr)ST_Ptr->st_NextST;		b=ST_Ptr->st_TimeCodeOut;		if (st1){			a=st1->st_TimeCodeIn;			if (b!=-1 && a!=-1) {				// on utilise cette méthode car elle garde le signe				c= 	C_ConversionTimeCodeTrames(a)-					C_ConversionTimeCodeTrames(b);				// si erreur on affiche le tc out en rouge				if (c<G.Preference_Interval) {						RGBForeColor(&rouge);						if (mincolor==1) TextMode(bold);					}			   }		}				C_ConversionTCstASCII(ST_Ptr->st_TimeCodeOut,&string);		DrawString(&string);		RGBForeColor(&textcolor);		TextMode(0);	// on dessine la zone en gris		if (G.General_Preference_DessinGris) {			SetRect(&rect,Xstart+5+largeurTCIn,Ystart+VIncrement*3+5,Xstart+7+LargeurTC+2+largeurTCIn,Ystart+VIncrement*4+5);			PenPat(&QD.gray);			FrameRect(&rect);			PenNormal();			TextFace(NormalFace);		}	// on affiche la lisibilité  --------------------------------------		if (mincolor !=1) TextMode(srcOr);		MoveTo(Xstart+7,Ystart+VIncrement*5+4);				GetIndString(&string,132,4);		DrawString(&string);		// on le calcule		a=ST_Ptr->st_TimeCodeOut;		b=ST_Ptr->st_TimeCodeIn;		TextMode(srcOr);		// on affiche seulement si c'est possible				if (b!=-1 && a!=-1) {			c=	C_ConversionTimeCodeTrames(a)-				C_ConversionTimeCodeTrames(b);			c=(c*(long)G.Preference_LisiValue)/st_FramePerSeconds;						// si total caractères >lisibilité =>  couleur=rouge			if (GiveTotalChar(ST_Ptr)>c) {					RGBForeColor(&rouge);					if (mincolor==1) TextMode(bold);					}				NumToString(c,&string);				if (c<999)					DrawString(&string);				else	DrawString("\p++++");				RGBForeColor(&textcolor);		}				TextMode(0);		if (mincolor !=1) TextMode(srcOr);// on affiche l'interval avec le sous-titre précedent		MoveTo(Xstart+7,Ystart+VIncrement*2);		GetIndString(&string,132,5);		DrawString(&string);				// on le calcule// on affiche l'intervalle si et seulement si c'est possible		PenNormal();		a=ST_Ptr->st_TimeCodeIn;		st1=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;		if (st1) {			b=	st1->st_TimeCodeOut;			c= 	C_ConversionTimeCodeTrames(a)-				C_ConversionTimeCodeTrames(b);							// on affiche seulement si c'est possible			if (b!=-1 && a!=-1) {			// si interval < max caractères couleur=rouge				if (c<G.Preference_Interval) RGBForeColor(&rouge);			// on affiche le texte				if (c<0){ // si  interval <0 on affiche <0					GetIndString(&string,132,23);					DrawString(&string);				} else {					if (c<(59*25)) { // si < minutes et >=0						c=C_ConversionTramesTimeCode(c);						C_ConversionTCstASCII(c,&string);						string[6]=5;						DrawString(&string[6]);						} else { // si > 1 min on affiche >min							GetIndString(&string,132,19);							DrawString(&string);						}					}//	if (c<0)			}// (b!=-1 && a!=-1) 		}		// on affiche le texte du sous-titre				SetRect(&rect,Xstart+141,Ystart+VIncrement+6,Xstart+417+ajout_largeur_ST_Listing,Ystart+VIncrement*5+3);			RGBBackColor(&currentBack);			AfficheTexteST_Listing(ST_Ptr,&rect,CharSize,G.affiche_CR_Flag);		// on dessine le contour							if (G.General_Preference_DessinGris) {				InsetRect(&rect,-1,-1);				PenPat(&QD.gray);				FrameRect(&rect);				PenNormal();				TextFace(NormalFace);				}		if (mincolor !=1) TextMode(srcOr);// on regarde s'il faut indiquer que le sous-titre n'est pas calé en bas de cadre// on teste s'il y a des CR en fin de ligne.		b=0;		P=(Ptr)ST_Ptr+ST_Ptr->st_TexteLenth-1;		P=P+sizeof(SousTitreRecord);			if (ST_Ptr->st_TexteLenth) {			a=ST_Ptr->st_TexteLenth;			do {				car=*((Ptr)P);				if (car ==0xd ) b++;				P--;				a--;				} while(a>0 && car<32);			}			// on affiche le nombre de cr		if (b) {			if (mincolor!=1) TextMode(srcOr);			color.blue=0;			color.green=0;			color.red=0x0;			RGBForeColor(&color);						MoveTo(Xstart+476-45+ajout_largeur_ST_Listing,Ystart+VIncrement*4+1);			GetIndString(&string,132,9);			DrawString(&string);			MoveTo(Xstart+476-45+ajout_largeur_ST_Listing,Ystart+VIncrement*5+1);			NumToString(b,&string);			DrawString(&string);			GetIndString(&string,132,10);			DrawString(&string);						if (mincolor !=1){				color.blue=0xffff;				color.green=0xffff;				color.red=0xffff;				RGBForeColor(&color);				MoveTo(Xstart+476-46+ajout_largeur_ST_Listing,Ystart+VIncrement*4);				GetIndString(&string,132,9);				DrawString(&string);				MoveTo(Xstart+476-46+ajout_largeur_ST_Listing,Ystart+VIncrement*5);				NumToString(b,&string);				DrawString(&string);				GetIndString(&string,132,10);				DrawString(&string);				}			RGBForeColor(&textcolor);		}		// on dessine le commentaire		SetRect(&rect,Xstart+141,Ystart+2,Xstart+417+ajout_largeur_ST_Listing,Ystart+VIncrement+3);		a=ST_Ptr->st_CommentaireLenth;		color.blue=0x9fff;		color.green=0;		color.red=0;		RGBForeColor(&color);		if (a) TextBox(ST_Ptr->st_CommentairePtr,a,&rect,teJustCenter);		RGBForeColor(&textcolor);// on dessine le contour						if (G.General_Preference_DessinGris) {			 InsetRect(&rect,-1,-1);			 PenPat(&QD.gray);			 FrameRect(&rect);			 PenNormal();			 TextFace(NormalFace);			 }// on rend les couleurs de la fenêtre		TextFace(0);		RGBBackColor(&Save_BackRgbColor);		RGBForeColor(&saveColor);		// si le sous-titre trouvé est sortie de l'écran on reset le flag 		value=GetCtlValue(G.ListingVScroll);		if (G.General_SousTitretrouve<value || 			G.General_SousTitretrouve>(value+G.ListingMaxDisplay) ){			G.General_SousTitretrouve=nil;		}} // DrawOneSousTitre/* Cette Routine affiche le texte dans une case de listing	et elle affiche les CR avec le caractères ¶ */void AfficheTexteST_Listing(SousTitreRecordPtr ST_Ptr,Rect *rect,short CharSize,short AfficheCR){TEHandle	te;Handle		theText,STScrp;long			a;Rect			r;char			buff[32],c;short		i,totaltext;TextStyle	newStyle;		r=*rect;		OffsetRect(&r,4000,4000); // pour ètre sûr de ne pas dessiner le sous-titre		te=TEStylNew(&r,&r); // on prépare le système "offscreen"		if (te) {			a=(long)ST_Ptr->st_Justification;				// la justification du sous-titre				TESetJust(C_get_STJustification(ST_Ptr),te);					if (AfficheCR) {			if (ST_Ptr->st_TexteLenth){				// on  place le texte sans modif					TRANSFERTTEXTE_MEMOIRE_STYLETE(te,ST_Ptr,rect,-1);								// maintenant on recherche les CR et on place le caractères "¶" en gras Couleur=Bleu					buff[0]='¶';					theText=(**te).hText;					newStyle.tsFace=0;					newStyle.tsColor.red=0;					newStyle.tsColor.green=0;					newStyle.tsColor.blue=-1;					totaltext=ST_Ptr->st_TexteLenth;										for (i=0;i<totaltext;i++){						c= *(*theText+i);						if (c==0x0D){							totaltext++;							TESetSelect(i,i,te);							TEInsert((Ptr)&buff,1,te);							TESetSelect(i,i+1,te);							TESetStyle( doFace+doColor,&newStyle,true,te);							i++;							}					}										// on préfère placer à la main la taille, car on ne fait 1 update que à la fin					if (CharSize!=-1) {						TESetSelect(0,32767,te);						newStyle.tsSize=CharSize;						TESetStyle(doSize,&newStyle,false,te);						TESetSelect(32767,32767,te);					} // (newsize!=-1) 										// on place les bonnes valeurs du rectangle d'affichage et on redessine				 	(**te).destRect=*rect;					(**te).viewRect=*rect;					TECalText(te);					TEUpdate(rect,te); 	// on update le texte					PenNormal();				}			} else {							// on  place le texte sans modif				TRANSFERTTEXTE_MEMOIRE_STYLETE(te,ST_Ptr,rect,-1);								// on préfère placer à la main la taille, car on ne fait 1 update que à la fin				if (CharSize!=-1) {					TESetSelect(0,32767,te);					newStyle.tsSize=CharSize;					TESetStyle(doSize,&newStyle,false,te);					TESetSelect(32767,32767,te);				} // (newsize!=-1) 								// on replace les bonnes valeurs				(**te).destRect=*rect;				(**te).viewRect=*rect;				TECalText(te);				TEUpdate(rect,te); 	// on update le texte				PenNormal();			}			TEDispose(te);		} //if (te)} //AfficheTexteST_Listing// Cette routine dessine dans listing, le sous-titre présent dans saisie// (si il est visible)pascal void DrawSt_enCourDansListing(void){	DrawSt_enCourDansListing_ByPointeur((long)G.General_SousTitreEncour);			}// cette routine dessine le st désigné par l'abs num "num" dans la fenêtre listingpascal void DrawSt_enCourDansListing_ByPointeur(unsigned long num){CGrafPtr	oldport;unsigned short	value,a;RgnHandle	rgn;SousTitreRecordPtr ST_Ptr;WindowPtr w=(WindowPtr)&G.ListingWindow;Rect	rect,rect1;Point 	pt1;PixPatHandle	the_pixpat;RGBColor	color,savecolor,savebcolor,black,white;GDHandle					gdhad;	pt1.v=0; pt1.h=0;		/* on filtre les valeurs impossibles */	if (num==0  || num > G.General_NombreST) return ;			GetGWorld(&oldport,&gdhad);		SetPort(w);	rgn=NewRgn();	PenNormal();		black.red=0;	black.green=0;	black.blue=0;		white.red=-1;	white.green=-1;	white.blue=-1;		color.red=0;	color.green=0;	color.blue=0;	RGBForeColor(&color);					TextMode(srcOr);	// on devrai demander la taille etc ...	TextFont(geneva);	// pour une version internationnale	TextSize(9);		value=GetCtlValue(G.ListingVScroll);			if ( num>=value 		 && ( num<= (value+G.ListingMaxDisplay)) ){		ST_Ptr=C_ConversionNumeroSTPointeur((long)num);			// on calcule le rectangle où l'on va dessiner le sous-titre			a=num;		a=a-value;				a=a*G.HauteurST+4;		// on sauvegarde la cliprgn		CopyRgn(w->clipRgn,rgn);				rect=w->portRect;		rect.top=a;		rect.right-=17;		rect.left=417+6;		rect.bottom=a+G.HauteurST;				// on limite la zone de dessin pour le bas de la fenètre		if (rect.bottom>(w->portRect.bottom-17) )								rect.bottom=w->portRect.bottom-17;										RectRgn(w->clipRgn,&rect);			// on rempli la partie droite par la pattern			rect1=w->portRect;				rect1.right-=15;		rect1.bottom-=15;		rect.left=3;		if (rect.bottom>w->portRect.bottom) rect.bottom=w->portRect.bottom;		RectRgn(w->clipRgn,&rect1);		// si offscreen on dessine dans offscreen		 if (G.OffscreenListing) {			 SetGWorld(G.OffscreenListing,nil);					 LockPixels(GetGWorldPixMap(G.OffscreenListing));			 RectRgn(G.OffscreenListing->clipRgn,&G.OffscreenListing->portRect);					// on rempli la fenêtre par la pattern			the_pixpat=GetPixPat(G.Listing_PatNum);					if (the_pixpat!=nil){				FillCRect(&G.OffscreenListing->portRect,the_pixpat);				DisposePixPat(the_pixpat);				}							} else { // si pas offscreen				the_pixpat=GetPixPat(G.Listing_PatNum);				if (the_pixpat!=nil){					FillCRect(&rect1,the_pixpat);					DisposePixPat(the_pixpat);				}			}		DrawOneSousTitre(ST_Ptr,4,a,pt1,pt1);				/* si buffer offscreen on fait copy bits*/		if (G.OffscreenListing) {		// on calcule la zone visible de copy bits				//CopybitRgn=NewRgn();				//CopyRgn(w->clipRgn,CopybitRgn);				//SectRgn(w->visRgn,CopybitRgn,CopybitRgn);								SetGWorld(oldport,gdhad);					GetForeColor(&savecolor);				GetBackColor(&savebcolor);				RGBForeColor(&black);				RGBBackColor(&white);				CopyBits(&( ((GrafPtr)G.OffscreenListing)->portBits),&( ((GrafPtr)w)->portBits ),&rect,&rect,srcCopy,w->visRgn);				UnlockPixels(GetGWorldPixMap(G.OffscreenListing));				RGBForeColor(&savecolor);				RGBBackColor(&savebcolor);				//DisposeRgn(CopybitRgn);				}			}			// on rend la rgn originale			//RectRgn(w->clipRgn,&w->portRect);			CopyRgn(rgn,w->clipRgn);			DisposeRgn(rgn);			SetGWorld(oldport,gdhad);	}/* routine gérant le controle de la fenêtre listing */pascal void ControlActionProc(ControlHandle control,short partcode){short						value,a,stnum,i,b;Rect							rect,rect1,rect2,rect3,wrect,FlotportRect,TempRect,FlotportRect1;WindowPtr				w=(WindowPtr)&G.ListingWindow;WindowPtr				Flot=(WindowPtr)G.TELECOMMANDEWindow;WindowPtr				Flot1=(WindowPtr)G.ChenilleWindow;RGBColor					white,black,oldback,oldfore,color;SousTitreRecordPtr	ST_Ptr;CGrafPtr					oldport;PixPatHandle			the_pixpat;GDHandle					gdhad;Point						P1;RgnHandle					scrollRgn,tempRgn;Boolean						doit,floaat=false;		GetGWorld(&oldport,&gdhad);				SetPort(w);		wrect=w->portRect;		GetBackColor(&oldback);		GetForeColor(&oldfore);				tempRgn=NewRgn();		scrollRgn=NewRgn();				black.red=0;		black.green=0;		black.blue=0;		white.red=0xffff;		white.green=0xffff;		white.blue=0xffff;				// on calcule les coordonnées de la flot en coordonnées locale de listing		FlotportRect.left=0;		FlotportRect.right=0;		FlotportRect.top=0;		FlotportRect.bottom=0;// la fenêtre téécommande existe t-elle ?				if(  ((WindowPeek)Flot)->visible ) {			SetPort(Flot);			FlotportRect=Flot->portRect;			LocalToGlobal((Point*)&FlotportRect);			LocalToGlobal((Point*)&FlotportRect+4);			SetPort(w);			GlobalToLocal((Point*)&FlotportRect);			GlobalToLocal((Point*)&FlotportRect+4);						floaat=floaat|SectRect(&FlotportRect,&wrect,&TempRect);		}			// la fenêtre chenille existe t-elle ?				if(  ((WindowPeek)Flot1)->visible ) {			SetPort(Flot1);			FlotportRect1=Flot1->portRect;			LocalToGlobal((Point*)&FlotportRect1);			LocalToGlobal((Point*)&FlotportRect1+/*(Point*)*/4);			SetPort(w);			GlobalToLocal((Point*)&FlotportRect1);			GlobalToLocal((Point*)&FlotportRect1+4);						floaat=floaat|SectRect(&FlotportRect1,&wrect,&TempRect);		}					if (!G.OffscreenListing)floaat=true;			switch(partcode){		// ces routines permettent d'effectuer de scroll dans la fenêtre listing		case	inUpButton:		case	inDownButton:	 		a=1;			if (partcode==inUpButton) a=-a;				 		value=GetCtlValue(control);			value+=a;						/* si nous sommes dans les frontières de la liste des sous-titres			on effectue le scrolling */			doit=false;			if (value>0 &&( value<=(GetCtlMax(control)-G.ListingMaxDisplay+1))  )  doit=true;				else	if (a<0  && value>0) doit=true;						if (doit){				SetCtlValue(control,value);				ShowControl(control);							/*				Pour un aspect visuel doux on dessine le sous-titre qui apparaîtra en haut ou en bas 			dans le scroll de la liste, dans un buffer offscreen pour optimiser le temps de rendu.				S'il n'est pas possible d'utiliser un buffer offscreen, faute de mémoire,			on dessine le st a la fin du scrolling.		*/										/*		on détermine le sous-titre qui faut dessiner dans le offscreen 		*/						if (partcode==inUpButton) stnum=value;				if (partcode==inDownButton) stnum=value+G.ListingMaxDisplay-1;			/* on le dessine dans le offscreen s'il existe */						if (G.OffscreenListing) {					SetGWorld(G.OffscreenListing,nil);							LockPixels(GetGWorldPixMap(G.OffscreenListing));					RectRgn(G.OffscreenListing->clipRgn,&G.OffscreenListing->portRect);										// on rempli la fenêtre par la pattern					the_pixpat=GetPixPat(G.Listing_PatNum);							if (the_pixpat!=nil){						FillCRect(&G.OffscreenListing->portRect,the_pixpat);						DisposePixPat(the_pixpat);					}					P1.h=0;							P1.v=0;							ST_Ptr=C_ConversionNumeroSTPointeur((long)stnum);					if ( ((long)stnum) <= G.General_NombreST)						if (ST_Ptr)DrawOneSousTitre(ST_Ptr,4,4,P1,P1);										//on dessine le  STsuivant si down button car un sous-titre peut être en partie visible										if (partcode==inDownButton) {						ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_NextST;						if (ST_Ptr) DrawOneSousTitre(ST_Ptr,4,G.HauteurST+4,P1,P1);					}					SetGWorld((CGrafPtr)w,gdhad);				}			/* 			on scroll le sous-titre 			initialisation du scroll					rect = source, rect1 = dest pour scroll (dans listing)		rect2 source offscreen,rect3 destination dans listing		On calcule les coordonnées des différents rectangles 					*/								RGBBackColor(&white);				RGBForeColor(&black);								rect1=wrect;				// on limite la zone de dessin								rect1.left=+4;				rect1.top+=4;				rect1.right-=17;				rect1.bottom-=18;								rect=rect1;				rect3=rect1;				rect2.top=4;				rect2.left=4;				rect2.bottom=G.HauteurST;				if (partcode==inDownButton) rect2.bottom+=G.HauteurST;				rect2.right=wrect.right-17;					/*			on affine les rectangle en fonction du sens de scrolling	*/		/* 	note: il y un problème si  une fenêtre flotante est placée devant			on regarde si la palette est devant la fenêtre listing			si elle l'est, on scroll sans valeur intermediaire	*/								a=G.HauteurST;				if (!floaat) a=a/2;												if (partcode==inUpButton) { // vers le bas					rect2.bottom+=4;					rect2.top=rect2.bottom-a;					rect3.bottom=rect3.top+a;				} else {								// vers le haut					/* 						Pour faire un scroll vers lehaut , il nous faut faire attention:						-  le dernier sous-titre visible peut être coupé						- 	ne pas effacer le bas de la page					*/			/* on calcule la hauteur visible du dernier sous-titre */					b=G.ListingMaxDisplay*G.HauteurST;					b=rect.bottom-b; 					rect2.top=b;					rect2.bottom=b+a;					rect3.bottom=rect.bottom;					rect3.top=rect3.bottom-a;				}						// on fait l'effet de scroll (2 )			 			if (!floaat){						for(i=0;i<2;i++){												SetRectRgn(scrollRgn,0,0,0,0);						color.blue=0x8000;						color.green=0x8000;						color.red=0x8000;						RGBBackColor(&color);						if (partcode!=inUpButton)  	ScrollRect(&rect,0,-a,scrollRgn);												else				ScrollRect(&rect,0,a,scrollRgn);												InvalRgn(scrollRgn);					 		/*on accole le offscreen s'il existe*/						RGBBackColor(&white);						if (G.OffscreenListing) 							if (partcode==inUpButton) {								CopyBits(&( ((GrafPtr)G.OffscreenListing)->portBits),&( ((GrafPtr)w)->portBits ),&rect2,&rect3,srcCopy,w->visRgn);								rect2.top-=a;								rect2.bottom-=a;						   } else {								CopyBits(&( ((GrafPtr)G.OffscreenListing)->portBits),&( ((GrafPtr)w)->portBits ),&rect2,&rect3,srcCopy,w->visRgn);								rect2.top+=a;								rect2.bottom+=a;							}					} // FOR								} // floaat								else{												SetRectRgn(scrollRgn,0,0,0,0);						color.blue=0x8000;						color.green=0x8000;						color.red=0x8000;						RGBBackColor(&color);												if (partcode!=inUpButton)  	ScrollRect(&rect,0,-a,scrollRgn);												else				ScrollRect(&rect,0,a,scrollRgn);												InvalRgn(scrollRgn);					 						RGBBackColor(&white);		/*on accole le offscreen s'il existe*/						if (G.OffscreenListing) 							if (partcode==inUpButton) {								CopyBits(&( ((GrafPtr)G.OffscreenListing)->portBits),&( ((GrafPtr)w)->portBits ),&rect2,&rect3,srcCopy,w->visRgn);								rect2.top-=a;								rect2.bottom-=a;						   } else {								CopyBits(&( ((GrafPtr)G.OffscreenListing)->portBits),&( ((GrafPtr)w)->portBits ),&rect2,&rect3,srcCopy,w->visRgn);								rect2.top+=a;								rect2.bottom+=a;							}																} // else floaat											// on rafraichie la fenêtre listing			if (floaat){					RectRgn(scrollRgn,&rect);				InvalRgn(scrollRgn);				}					   	DoUpdate(w);			if (G.OffscreenListing) {				UnlockPixels(GetGWorldPixMap(G.OffscreenListing));			}	else {				 DrawListingWindow();			}		}	//doit		break;			 		 case inPageUp:			 value=GetCtlValue(control);			 a=value-G.ListingMaxDisplay;			 SetCtlValue(control,a);			 ShowControl(control);			 DrawListingWindow();			break;				 case inPageDown:			 value=GetCtlValue(control);			 a=value+G.ListingMaxDisplay;			 SetCtlValue(control,a);			 ShowControl(control);			 DrawListingWindow();		 break;				 	 }// switch	 	 		DisposeRgn(scrollRgn);		DisposeRgn(tempRgn);		RGBBackColor(&oldback);		RGBForeColor(&oldfore);			SetGWorld(oldport,gdhad);					}/* routine pour le dessin de la fenêtre saisie */pascal void UpdateSaisie(void){CGrafPtr	oldport;GDHandle	gdh;WindowPtr	w=(WindowPtr)&G.DialogSaisie;RGBColor	oldback,oldfore,noir,blanc,bblack;PixPatHandle	the_pixpat;	GetGWorld(&oldport,&gdh);	SetPort(w);		TextFont(geneva);	TextFace(bold);	TextSize(10);			noir.red=0;	noir.green=0;	noir.blue=0;			blanc.red=-1;	blanc.green=-1;	blanc.blue=-1;		GetBackColor(&oldback);	GetForeColor(&oldfore);/* si c'est possible on utilise le offscreen buffer		*/	if (G.OffscreenSaisie) {			UpdateGWorld(&G.OffscreenSaisie,0,&w->portRect,nil,nil,0);			SetGWorld(G.OffscreenSaisie,nil);				RectRgn(G.OffscreenSaisie->clipRgn,&G.OffscreenSaisie->portRect);			LockPixels(GetGWorldPixMap(G.OffscreenSaisie));			the_pixpat=GetPixPat(G.Saisie_PatNum);					if (the_pixpat!=nil){				FillCRect(&w->portRect,the_pixpat);				DisposePixPat(the_pixpat);			} 	} else {		the_pixpat=GetPixPat(G.Saisie_PatNum);		if (the_pixpat!=nil){			FillCRect(&w->portRect,the_pixpat);			DisposePixPat(the_pixpat);		} 		}				/* on update le contenu de la fenêtre */			TextFont(geneva);		TextFace(bold);		TextSize(10);				bblack.red=256;		bblack.green=11*256;		bblack.blue=71*256;		RGBForeColor(&bblack);			Draw_Icon_Text_Ditl((DialogPtr)&G.DialogSaisie);		DrawSaisieValue();/* si offscreen on recopie le dessin */		SetGWorld((CGrafPtr)w,gdh);	if (G.OffscreenSaisie) {			RGBBackColor(&blanc);			RGBForeColor(&noir);			CopyBits(&( ((GrafPtr)G.OffscreenSaisie)->portBits),&( ((GrafPtr)w)->portBits ),&G.OffscreenSaisie->portRect,&w->portRect,srcCopy,w->visRgn);			UnlockPixels(GetGWorldPixMap(G.OffscreenSaisie));			RGBBackColor(&oldback);			RGBForeColor(&oldfore);		}	SetGWorld(oldport,gdh);			RGBBackColor(&blanc);			RGBForeColor(&noir);} //update dialog saisiepascal void  Draw_Line_Number_Saisie(void){GrafPtr					w,oldport;DialogPtr					dialog=(DialogPtr)&G.DialogSaisie;PixPatHandle				the_pixpat;short						itemtype;Handle						item;Rect							rect,rect1;SousTitreRecordPtr	ST_Ptr;Str255						string,st0;RGBColor					color,oldcolor,bleu,rouge,black,lightGray;long						a,b,c,totalC;		black.red=0;		black.green=0;		black.blue=0;				bleu.red=0;		bleu.green=0;		bleu.blue=0xCfff;				rouge.red=0xffff;		rouge.green=0;		rouge.blue=0;		color.red=0;		color.blue=0xafff;		color.green=0;				lightGray.red=60947;		lightGray.green=60947;		lightGray.blue=60947;				ST_Ptr=C_ConversionNumeroSTPointeur((long) G.General_SousTitreEncour);		GetPort(&oldport);/* 	On déternine si l'on est dans listing port ou offscreen listing 	sinon on force le port pour dialog saisie*/		if(oldport != (GrafPtr)G.OffscreenSaisie) SetPort((GrafPtr)dialog);		GetPort(&w);		GetForeColor(&oldcolor);		RGBForeColor(&color);/* on efface les chiffres par un raccord de pattern */		GetDItem(dialog,30,&itemtype,&item,&rect); // nb de caractère sur la ligne		rect1.top=rect.top;		rect1.left=rect.left;				GetDItem(dialog,31,&itemtype,&item,&rect); // nb de caractère sur la ligne				rect1.bottom=rect.bottom;		rect1.right=rect.right;				RectRgn(w->clipRgn,&rect1);			// on efface le port du rectangle	 (seul moyen d'ètre raccord en ppat)				the_pixpat=GetPixPat(G.Saisie_PatNum);				if (the_pixpat!=nil){			FillCRect(&w->portRect,the_pixpat);			DisposePixPat(the_pixpat);		}							TextMode(srcOr);				                                                                                                                  						TextFont(geneva);		TextSize(10);		TextFace(bold);				/* on affiche le nombre total de caractères*/			GetDItem(dialog,31,&itemtype,&item,&rect); // nb de caractère sur la ligne			MoveTo(rect.left,rect.top+10);			totalC=GiveTotalChar(ST_Ptr);	// donne -1 si start// end			NumToString((long)totalC,&string);			if (totalC!=-1) DrawString(&string);					if ( (G.saisieTEStItem== Texte_SousTitre) && (G.saisieTE!=nil) ) { 			/* on affiche la ligne en cours dans le sous-titre */			GetDItem(dialog,30,&itemtype,&item,&rect); // nb de caractère sur la ligne			MoveTo(rect.left,rect.top+10);			a=GiveCurrentLine(ST_Ptr);	// donne -1 si start// end			NumToString((long)a,&string);			if (a!=-1) DrawString(&string);						/* on affiche le nombre total de caractères sur la ligne en cours*/			GetDItem(dialog,34,&itemtype,&item,&rect); // nb de caractère sur la ligne			MoveTo(rect.left,rect.top+10);			a=GiveCurrentLinetotalChar(ST_Ptr);	// donne -1 si start// end			NumToString((long)a,&string);			if (a!=-1) DrawString(&string);		}			/* ---------------- Affichage de la lisibilitée ---------------- */		PenNormal();		GetDItem(dialog,19,&itemtype,&item,&rect);		TextSize(12);		TextFace(bold);			RGBForeColor(&bleu);		MoveTo(rect.left+1,rect.top+9);		a=ST_Ptr->st_TimeCodeIn;		b=ST_Ptr->st_TimeCodeOut;			// on affiche seulement si c'est possible		if (b!=-1 && a!=-1) {			c=C_SoustractionTimeCode(b,a);			c=C_ConversionTimeCodeTrames(c);			c=(c*(long)G.Preference_LisiValue)/st_FramePerSeconds;				// si lisibilité < max caractères couleur=rouge			if (totalC>c) RGBForeColor(&rouge);				NumToString(c,&string);			if (c<999)				DrawString(&string);			else	DrawString("\p++++");				RGBForeColor(&black);		}				// on gère la zone "de dialogue"// si mode tracking on affiche tracking // si te ouvert on affiche "validation" + emboss/* on rend la couleur de face et le clip rect */			RGBForeColor(&oldcolor);		RectRgn(dialog->clipRgn,&w->portRect);		RGBForeColor(&oldcolor);		//on dessine le bouton tracking ou valider dans saisie		DessineTrackingValiderSaisie();		SetPort(oldport);}// affiche number saisiepascal void  DessineTrackingValiderSaisie(void){GrafPtr					w,oldport;DialogPtr					dialog=(DialogPtr)&G.DialogSaisie;PixPatHandle				the_pixpat;short						itemtype;Handle						item;Rect							rect,rect1;SousTitreRecordPtr	ST_Ptr;Str255						string,st0;RGBColor					color,oldcolor,bleu,rouge,black,lightGray;long						a,b,c,totalC;		black.red=0;		black.green=0;		black.blue=0;				bleu.red=0;		bleu.green=0;		bleu.blue=0xCfff;				rouge.red=0xffff;		rouge.green=0;		rouge.blue=0;		color.red=0;		color.blue=0xafff;		color.green=0;						lightGray.red=60947;		lightGray.green=60947;		lightGray.blue=60947;				ST_Ptr=C_ConversionNumeroSTPointeur((long) G.General_SousTitreEncour);		GetPort(&oldport);/* 	On déternine si l'on est dans listing port ou offscreen listing 	sinon on force le port pour dialog saisie*/		if(oldport != (GrafPtr)G.OffscreenSaisie) SetPort((GrafPtr)dialog);		GetPort(&w);		GetForeColor(&oldcolor);		RGBForeColor(&color);		PenNormal();		RectRgn(w->clipRgn,&w->portRect);		TextFace(0);				GetDItem(dialog,46,&itemtype,&item,&rect);		TextSize(9);	if (G.saisieTE){			RGBForeColor(&lightGray);			PaintRect(&rect);			InsetRect(&rect,1,1);			RGBForeColor(&bleu);			GetIndString(&st0,129,57);						MoveTo(rect.left+3,rect.top+10);			DrawString(&st0);			FrameRectOneLine(&rect,false);	} else if (G.Preference_Tracking&2){			RGBForeColor(&lightGray);			PaintRect(&rect);			RGBForeColor(&rouge);			MoveTo(rect.left+3,rect.top+10);			GetIndString(&st0,129,58);			DrawString(&st0);			RGBForeColor(&lightGray);			FrameRect(&rect);	} else {	 // on ne fait rien	}	RGBForeColor(&oldcolor);	SetPort(oldport);}// DessineTrackingValiderSaisie/* Cette routine revoie le nombre total de caractère pour le sous-titre*/	pascal short GiveTotalChar(SousTitreRecordPtr st){short		result=0,i,max;unsigned char	b;Ptr			P;TEHandle		te=G.saisieTE;	if (te != nil){ // il ya une te on regarde dedans			P=(Ptr)*((**te).hText);		max=(**te).teLength;		for (i=0;i<max;i++) {			 b=(*P);			 if (b>32 && (b!=0xca)) result++;			 P++;		}		} else { // pas de te on regarde dans le st record		 P=(Ptr)st+sizeof(SousTitreRecord);		 max=(short)st->st_TexteLenth;				 for(i=0;i<max;i++){			 b=(*P);			 if (b>32 && (b!=0xca)) result++;			 P++;			 }		 	} // else 	return result;}/* Cette routine renvoie le n° de la ligne en cours dans le te text de saisie */pascal short 	GiveCurrentLine(SousTitreRecordPtr st){short		start=1,end=1,nbcr=0,max,i;TEHandle		te=G.saisieTE;Ptr			P;		/* si pas de te on revoie -1*/	if (te ==nil) return -1;		/* on compte le nombre de cr jusqu'au selstart */		P=(Ptr)*((**te).hText);	max=(**te).selStart;	if (max>(**te).teLength) max=(**te).teLength;	for (i=0;i<max;i++) {		if ((*P)==0xd) {		start++;		}		P=P+1;	}		P=(Ptr)*((**te).hText);	max=(**te).selEnd;	if (max>(**te).teLength) max=(**te).teLength;	for (i=0;i<max;i++) {		if ((*P)==0xd) end++;		P=P+1;	}	/* si la selection n'est pas  toute sur la même ligne on retourne -1*/	if (end !=start) SysBeep(10);		return end;}/* Cette routine revoie le nombre total de caractère sur la ligne active pour le sous-titre*/	pascal short GiveCurrentLinetotalChar(SousTitreRecordPtr st){short		result=0;short		max,charstart,i,start;TEHandle	te=G.saisieTE;Ptr			P,P1;unsigned char	b;		/* si pas de te on revoie -1*/	if (te ==nil) return -1;		P=(Ptr)*((**te).hText);	start=(**te).selStart;	max=(**te).teLength;	if (start>max) start=max;	P1=P;		/* on se place sur le premier caractère de la ligne courante*/		charstart=0;	for (i=0;i<start;i++) {		b=(*P);		if (b==0xd) {			P1=P+1;			charstart=i+1;			}		P=P+1;	} 		/* P1 position du dernier cr */	/* on compte le nombre de caractère jusqu'au prochain cr ou à la fin du texte*/		i=charstart;	do{		b=(*P1);		if (b>0xd) result++;		P1=P1+1;		i++;	}while (i<max && (b != 0xd) );		return result;}/* on affiche le nombre total de caractères du sous-titre *//*				GetDItem(dialog,31,&itemtype,&item,&rect); // nb de caractère sur la ligne		MoveTo(rect.left,rect.top+10);		a=GiveTotalChar(ST_Ptr);		NumToString((long)a,&string);		DrawString(&string);		*/		/* cette routine dessine les valeurs de la fenêtre saisie */pascal void DrawSaisieValue(void){		Rect		rect,rect_port;RgnHandle	rgn,rgn2,oldclip;short		itemtype,totalC;CGrafPtr	w,oldport;DialogPtr	D=(DialogPtr)&G.DialogSaisie;SousTitreRecordPtr	ST_Ptr;RGBColor	white,black,bleu,lightGray,Fcolor,Bcolor;Str255		string;PixPatHandle	the_pixpat;Handle		item;TEHandle	te;		black.red=1;		black.green=11;		black.blue=71;		white.red=0xffff;		white.green=0xffff;		white.blue=0xffff;				bleu.red=0;		bleu.green=0;		bleu.blue=0xffff;				lightGray.red=60947;		lightGray.green=60947;		lightGray.blue=60947;				GetPort((GrafPtr*)&w);		GetPort((GrafPtr*)&oldport);/* 	On déternine si l'on est dans listing port ou offscreen listing 	sinon on force le port pour dialog saisie*/	if (G.OffscreenSaisie)		if(oldport != G.OffscreenSaisie)				if	(oldport != (CGrafPtr)D){						SetPort((GrafPtr)D);						oldport=(CGrafPtr)D;						}								SetPort(D);							if (GiveMinDepth(&D->portRect)==1) {					RGBForeColor(&black);					RGBBackColor(&white);														bleu.red=0;					bleu.green=0;					bleu.blue=0;										lightGray.red=-1;					lightGray.green=-1;					lightGray.blue=-1;				}								SetPort((GrafPtr)oldport);								TextFont(geneva);		TextFace(0);		TextSize(11);		PenNormal();												GetForeColor(&Fcolor);		GetBackColor(&Bcolor);		rect_port=w->portRect;		ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);/* on affiche les boutons de justification */ 		Update_JustifButton	();		/* 		On efface les rectangle de de num sous-titre+interval+lisibilité 	on détermine la zone de remplissage par des régions*/		rgn=NewRgn();		rgn2=NewRgn();		oldclip=NewRgn();		//GetClip(oldclip); // on sauvegarde le clip de la fenêtre				the_pixpat=GetPixPat(G.Saisie_PatNum);				if (the_pixpat!=nil){			GetDItem(D,17,&itemtype,&item,&rect);			RectRgn(rgn2,&rect);			/*CopyRgn(oldclip,rgn2);*/						GetDItem(D,18,&itemtype,&item,&rect);			RectRgn(rgn,&rect);			UnionRgn(rgn,rgn2,rgn2),			GetDItem(D,19,&itemtype,&item,&rect);			RectRgn(rgn,&rect);			UnionRgn(rgn,rgn2,rgn2),			FillCRgn(rgn2,the_pixpat);			DisposePixPat(the_pixpat);		}		RectRgn(w->clipRgn,&w->portRect);		//SetClip(oldclip); // on rend le clip/* on dessine le n° du sous-titre en cour */				RGBForeColor(&bleu);		TextFace(bold);		TextSize(14);		GetDItem(D,17,&itemtype,&item,&rect);		MoveTo(rect.left,rect.top+14);		C_ConvertiNumST_String(ST_Ptr->st_NumeroST,&string);		DrawString(&string);		TextFace(0);		RGBForeColor(&black);				totalC=GiveTotalChar(ST_Ptr);/* ---------------- Affichage du time code in ---------------- */		GetDItem(D,14,&itemtype,&item,&rect);		TextSize(14);		/* s'il y a un TE tc in on rafraichie le te */ 		if (G.saisieTE && G.saisieTEStItem==TimecodeIn_SousTitre) {			// on force la main au te pour edssiner dans le offscrenn si nécessaire			(**G.saisieTE).inPort=(GrafPtr)w;			RGBForeColor(&black);			RGBBackColor(&white);				EraseRect(&rect);			TEUpdate(&rect,G.saisieTE);			if (FrontNonFloatingWindow()!=(WindowReference)D) PenPat(&QD.dkGray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);			RGBForeColor(&Fcolor);			RGBBackColor(&Bcolor);			(**G.saisieTE).inPort=(GrafPtr)D;		} else {			/*pas de te on dessine le tc à la main */			InsetRect(&rect,-1,-1);			RGBForeColor(&lightGray);			PaintRect(&rect);			InsetRect(&rect,1,1);			RGBForeColor(&black);			C_ConversionTCstASCII(ST_Ptr->st_TimeCodeIn,&string);			MoveTo(rect.left+1,rect.top+14);			DrawString(&string);			PenPat(&QD.gray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);		}/* ---------------- Affichage du time code Out ---------------- */		PenNormal();		GetDItem(D,15,&itemtype,&item,&rect);		TextSize(14);		/* s'il y a un TE tc in on rafraichie le te */ 		if (G.saisieTE && G.saisieTEStItem==TimecodeOut_SousTitre) {			(**G.saisieTE).inPort=(GrafPtr)w;			RGBForeColor(&black);			RGBBackColor(&white);				EraseRect(&rect);			TEUpdate(&rect,G.saisieTE);			if (FrontNonFloatingWindow()!=(WindowReference)D) PenPat(&QD.dkGray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);			RGBForeColor(&Fcolor);			RGBBackColor(&Bcolor);			(**G.saisieTE).inPort=(GrafPtr)D;		} else {			/*pas de te on dessine le tc à la main */			InsetRect(&rect,-1,-1);			RGBForeColor(&lightGray);			PaintRect(&rect);			InsetRect(&rect,1,1);			RGBForeColor(&black);			C_ConversionTCstASCII(ST_Ptr->st_TimeCodeOut,&string);			MoveTo(rect.left+1,rect.top+14);			DrawString(&string);			PenPat(&QD.gray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);		}/* on affiche le texte du sous-titre */		PenNormal();		GetDItem(D,12,&itemtype,&item,&rect);		TextSize(14);		/* s'il y a un TE texte on rafraichie le te */ 		if (G.saisieTE && G.saisieTEStItem==Texte_SousTitre) {			(**G.saisieTE).inPort=(GrafPtr)w;			RGBForeColor(&black);			RGBBackColor(&white);				EraseRect(&rect);			TEUpdate(&rect,G.saisieTE);			if (FrontNonFloatingWindow()!=(WindowReference)D) PenPat(&QD.dkGray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);			RGBForeColor(&Fcolor);			RGBBackColor(&Bcolor);			(**G.saisieTE).inPort=(GrafPtr)D;			} else {			/*pas de te on dessine le texte à l'aide d'un te */			InsetRect(&rect,-1,-1);			RGBForeColor(&lightGray);			PaintRect(&rect);			InsetRect(&rect,1,1);			RGBForeColor(&black);			RGBBackColor(&lightGray);			te=TEStylNew(&rect,&rect);	// la justification du sous-titre							TESetJust(C_get_STJustification(ST_Ptr),te);		// on y place le texte				TRANSFERTTEXTE_MEMOIRE_STYLETE(te,ST_Ptr,&rect,14);			TEDispose(te);			PenPat(&QD.gray); 			InsetRect(&rect,-1,-1);			FrameRect(&rect);		}		/* on affiche le commentaire du sous-titre */		PenNormal();		GetDItem(D,13,&itemtype,&item,&rect);		TextSize(9);		TextFont(geneva);		/* s'il y a un TE texte on rafraichie le te */ 		if (G.saisieTE && G.saisieTEStItem==Commentaire_SousTitre) {			(**G.saisieTE).inPort=(GrafPtr)w;			RGBForeColor(&black);			RGBBackColor(&white);				EraseRect(&rect);			TEUpdate(&rect,G.saisieTE);			if (FrontNonFloatingWindow()!=(WindowReference)D) PenPat(&QD.dkGray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);			RGBForeColor(&Fcolor);			RGBBackColor(&Bcolor);			(**G.saisieTE).inPort=(GrafPtr)D;			} else {			/* pas de te on dessine le texte à l'aide d'un text box */			InsetRect(&rect,-1,-1);			RGBForeColor(&lightGray);			PaintRect(&rect);			InsetRect(&rect,1,1);			RGBForeColor(&black);			if (ST_Ptr->st_CommentairePtr && ST_Ptr->st_CommentaireLenth) 				TextBox(ST_Ptr->st_CommentairePtr,						ST_Ptr->st_CommentaireLenth,						&rect,teJustCenter);						PenPat(&QD.gray); 			InsetRect(&rect,-1,-1);			FrameRect(&rect);		}		PenNormal();		RGBBackColor(&white);/* on dessine le rectange autour du bouton fermeture */				GetDItem(D,45,&itemtype,&item,&rect);		FrameRectOneLine(&rect,true);		/* on affiche le nombre de caractère par ligne */		Draw_Line_Number_Saisie();/* on affiche la durée et la lisibilité */		CalculDuree();	/* on rend le port	préalable */	SetPort((GrafPtr)oldport);				// même chose que précédemment// mais on ne dessine que les time-codes		 } //pascal void DrawSaisieValue(void) pascal void DrawSaisieValuePartiel(void){		Rect		rect,rect_port;RgnHandle	rgn,rgn2,oldclip;short		itemtype,totalC;CGrafPtr	w,oldport;DialogPtr	D=(DialogPtr)&G.DialogSaisie;SousTitreRecordPtr	ST_Ptr;RGBColor	white,black,bleu,lightGray,Fcolor,Bcolor;Str255		string;PixPatHandle	the_pixpat;Handle		item;TEHandle	te;		black.red=1;		black.green=11;		black.blue=71;		white.red=0xffff;		white.green=0xffff;		white.blue=0xffff;				bleu.red=0;		bleu.green=0;		bleu.blue=0xffff;				lightGray.red=60947;		lightGray.green=60947;		lightGray.blue=60947;		GetPort((GrafPtr*)&w);		GetPort((GrafPtr*)&oldport);/* 	On déternine si l'on est dans listing port ou offscreen listing 	sinon on force le port pour dialog saisie*/		SetPort((GrafPtr)D);			if (GiveMinDepth(&D->portRect)==1) {					RGBForeColor(&black);					RGBBackColor(&white);														bleu.red=0;					bleu.green=0;					bleu.blue=0;										lightGray.red=-1;					lightGray.green=-1;					lightGray.blue=-1;				}														TextFont(geneva);		TextFace(0);		TextSize(11);		PenNormal();												GetForeColor(&Fcolor);		GetBackColor(&Bcolor);				rect_port=w->portRect;		ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);/* 		On efface les rectangle de de num sous-titre+interval+lisibilité 	on détermine la zone de remplissage par des régions*/		rgn=NewRgn();		rgn2=NewRgn();		oldclip=NewRgn();		//GetClip(oldclip); // on sauvegarde le clip de la fenêtre				the_pixpat=GetPixPat(G.Saisie_PatNum);				if (the_pixpat!=nil){			GetDItem(D,17,&itemtype,&item,&rect);			RectRgn(rgn2,&rect);			GetDItem(D,18,&itemtype,&item,&rect);			RectRgn(rgn,&rect);			UnionRgn(rgn,rgn2,rgn2),			GetDItem(D,19,&itemtype,&item,&rect);			RectRgn(rgn,&rect);			UnionRgn(rgn,rgn2,rgn2),			FillCRgn(rgn2,the_pixpat);			DisposePixPat(the_pixpat);		}		//SetClip(oldclip); // on rend le clip/* on dessine le n° du sous-titre en cour */				RGBForeColor(&bleu);		TextFace(bold);		TextSize(14);		GetDItem(D,17,&itemtype,&item,&rect);		MoveTo(rect.left,rect.top+14);		C_ConvertiNumST_String(ST_Ptr->st_NumeroST,&string);		DrawString(&string);		TextFace(0);		RGBForeColor(&black);				totalC=GiveTotalChar(ST_Ptr);		/* ---------------- Affichage du time code in ---------------- */		GetDItem(D,14,&itemtype,&item,&rect);		TextSize(14);		/*pas de te on dessine le tc à la main */		InsetRect(&rect,-1,-1);		RGBForeColor(&lightGray);		PaintRect(&rect);		InsetRect(&rect,1,1);		RGBForeColor(&black);		C_ConversionTCstASCII(ST_Ptr->st_TimeCodeIn,&string);		MoveTo(rect.left+1,rect.top+14);		DrawString(&string);		PenPat(&QD.gray); // si fenêtre != premier plan 		InsetRect(&rect,-1,-1);		FrameRect(&rect);/* ---------------- Affichage du time code Out ---------------- */		PenNormal();		GetDItem(D,15,&itemtype,&item,&rect);		TextSize(14);		/*pas de te on dessine le tc à la main */		InsetRect(&rect,-1,-1);		RGBForeColor(&lightGray);		PaintRect(&rect);		InsetRect(&rect,1,1);		RGBForeColor(&black);		C_ConversionTCstASCII(ST_Ptr->st_TimeCodeOut,&string);		MoveTo(rect.left+1,rect.top+14);		DrawString(&string);		PenPat(&QD.gray); // si fenêtre != premier plan 		InsetRect(&rect,-1,-1);		FrameRect(&rect);		PenNormal();/* on affiche le nombre de caractère par ligne */		Draw_Line_Number_Saisie();/* on affiche la durée et la lisibilité */		CalculDuree();	/* on rend le port	préalable */		SetPort((GrafPtr)oldport);		 } //pascal void DrawSaisieValuePartiel(void)/* Cette routine dessine les boutons de justification */pascal void Update_JustifButton(void){short ciconid,just,itemtype;CIconHandle	icon;DialogPtr	w=(DialogPtr)&G.DialogSaisie;Rect	rect;Handle	item;SousTitreRecordPtr	ST_Ptr;		ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);		just=C_get_STJustification(ST_Ptr); 	if (just==teJustLeft){		ciconid=244+2;	} else {		ciconid=244;	}		icon=GetCIcon(ciconid);		GetDItem(w,37,&itemtype,&item,&rect);		if (icon) PlotCIcon(&rect,icon);		/* justification centrée */	if (just==teJustCenter){		ciconid=248+2;	} else {		ciconid=248;	}		icon=GetCIcon(ciconid);		GetDItem(w,38,&itemtype,&item,&rect);		if (icon) PlotCIcon(&rect,icon);/* just right */		if (just==teJustRight){		ciconid=252+2;	} else {		ciconid=252;	}		icon=GetCIcon(ciconid);		GetDItem(w,39,&itemtype,&item,&rect);		if (icon) PlotCIcon(&rect,icon);} //Update_JustifButton						/* cette routine dessine les temps dans la fenètre saisie */pascal void CalculDuree(void){Rect		rect,rect_port;RgnHandle	rgn,rgn2;short		itemtype,totalC;GrafPtr	oldport;CGrafPtr	w;DialogPtr	D=(DialogPtr)&G.DialogSaisie;SousTitreRecordPtr	ST_Ptr;RGBColor	white,black,bleu,lightGray,rouge;Str255		string;PixPatHandle	the_pixpat;Handle		item;long		a,b,c;		black.red=0;		black.green=0;		black.blue=0;		white.red=0xffff;		white.green=0xffff;		white.blue=0xffff;				bleu.red=0;		bleu.green=0;		bleu.blue=0xCfff;				rouge.red=0xffff;		rouge.green=0;		rouge.blue=0;						lightGray.red=60947;		lightGray.green=60947;		lightGray.blue=60947;				GetPort(&oldport);		if(oldport != (GrafPtr)G.OffscreenSaisie) SetPort((GrafPtr)D);							GetPort((GrafPtr*)&w);				TextFace(0);		TextFont(geneva);		TextSize(9);		PenNormal();				if (GiveMinDepth(&D->portRect)==1) {					RGBForeColor(&black);					RGBBackColor(&white);														bleu.red=0;					bleu.green=0;					bleu.blue=0;										lightGray.red=-1;					lightGray.green=-1;					lightGray.blue=-1;				}				SetPort((GrafPtr)w);				rect_port=w->portRect;		ST_Ptr=C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour);/* 		On efface les rectangle de de num sous-titre+interval+lisibilité 	on détermine la zone de remplissage par des régions*/		rgn=NewRgn();		rgn2=NewRgn();		the_pixpat=GetPixPat(G.Saisie_PatNum);				if (the_pixpat!=nil){			GetDItem(D,16,&itemtype,&item,&rect);			RectRgn(rgn2,&rect);						GetDItem(D,18,&itemtype,&item,&rect);			RectRgn(rgn,&rect);			UnionRgn(rgn,rgn2,rgn2),			GetDItem(D,19,&itemtype,&item,&rect);			RectRgn(rgn,&rect);			UnionRgn(rgn,rgn2,rgn2),			FillCRgn(rgn2,the_pixpat);			DisposePixPat(the_pixpat);		}			/* on dessine le n° du sous-titre en cour */		RectRgn(w->clipRgn,&w->portRect);		RGBForeColor(&black);				totalC=GiveTotalChar(ST_Ptr);		/* on calcule la durée du sous-titre */						C_ConversionTCstASCII(ST_Ptr->st_TimeCodeIn,&string);		GetDItem(D,16,&itemtype,&item,&rect);		TextFont(geneva);		TextSize(9);		a=ST_Ptr->st_TimeCodeIn;		b=ST_Ptr->st_TimeCodeOut;		c=C_SoustractionTimeCode(b,a);		/* s'il y a un TE tc in on rafraichie le te */ 		if (G.saisieTE && G.saisieTEStItem==Duree_SousTitre) {			// on force la main au te pour dessiner dans le offscreen si necessaire			(**G.saisieTE).inPort=(GrafPtr)w;			TEUpdate(&rect,G.saisieTE);			if (FrontNonFloatingWindow()!=(WindowReference)D) PenPat(&QD.dkGray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);			(**G.saisieTE).inPort=(GrafPtr)D;	// on rend le port		} else {			/*pas de te on dessine le tc à la main */			InsetRect(&rect,-1,-1);			RGBForeColor(&lightGray);			PaintRect(&rect);			InsetRect(&rect,1,1);			RGBForeColor(&black);						C_ConversionTCstASCII(c,&string);			// on limite l'affichage à minutes,seconde,trames									string[3]=8;			MoveTo(rect.left+1,rect.top+9);			DrawString(&string[3]);			PenPat(&QD.gray); // si fenêtre != premier plan 			InsetRect(&rect,-1,-1);			FrameRect(&rect);		}/* ---------------- Affichage de la lisibilitée ---------------- */		PenNormal();		GetDItem(D,19,&itemtype,&item,&rect);		TextSize(12);		TextFace(bold);		RGBForeColor(&bleu);		MoveTo(rect.left+1,rect.top+11);				// on affiche seulement si c'est possible		if (b!=-1 && a!=-1) {			c= 	C_ConversionTimeCodeTrames(b)-				C_ConversionTimeCodeTrames(a);								c=(c*(long)G.Preference_LisiValue)/st_FramePerSeconds;				// si lisibilité < max caractères couleur=rouge					if (totalC>c) RGBForeColor(&rouge);				NumToString(c,&string);						if (c<999)				DrawString(&string);			else	DrawString("\p++++");			RGBForeColor(&black);		}		/* ---------------- Affichage de l'intervalle ---------------- */		PenNormal();		GetDItem(D,18,&itemtype,&item,&rect);				RGBForeColor(&bleu);		MoveTo(rect.left+1,rect.top+11);		b=ST_Ptr->st_TimeCodeIn;		ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;		if (ST_Ptr) {			a=ST_Ptr->st_TimeCodeOut;			c= 	C_ConversionTimeCodeTrames(b)-				C_ConversionTimeCodeTrames(a);			// on affiche seulement si c'est possible			if (b!=-1 && a!=-1) {			// si interval < max caractères couleur=rouge				if (c<G.Preference_Interval) RGBForeColor(&rouge);								// on affiche le texte				if (c<0){ // si  interval <0 on affiche <0					TextSize(9);					GetIndString(&string,132,23);					DrawString(&string);				} else {					if (c<59*25) { // si < minutes et >=0						TextSize(10);						c=C_ConversionTramesTimeCode(c);						C_ConversionTCstASCII(c,&string);						string[6]=5;						DrawString(&string[6]);						} else { // si > 1 min on affiche >min							TextSize(9);							GetIndString(&string,132,19);							DrawString(&string);						}					}//	if (c<0)			}// (b!=-1 && a!=-1) 		}					RGBForeColor(&black);				RGBBackColor(&white);				TextFace(0);				SetPort(oldport);}				/*	Cette routine centre la fenêtre listing sur le sous titre courant*/pascal void CentreListingWindow(void){	 CentreListingWindowByNumST((long)G.General_SousTitreEncour);}/*	Cette routine centre la fenêtre listing sur le sous titre courant*/pascal void CentreListingWindowTRACKING(void){	 CentreListingWindowByNumST((long)G.General_SousTitreDisplayed);}pascal void CentreListingWindowByNumST(long stnum){long	value,max,visible=0; // s'i y a un te ouvert on le ferme		if (G.ListingTE) {			SetPort((WindowPtr)&G.ListingWindow);			TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);			TEDispose(G.ListingTE);			G.ListingTE=nil;			InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);		}	// on regarde si le sous-titre est visible	max=GetCtlMax(G.ListingVScroll);		value=stnum-G.ListingMaxDisplay/2+1;	if (value<1) value=1;	if (value<(G.ListingMaxDisplay-1)) value=1;	if (value>(max-(G.ListingMaxDisplay/2)) ) value=max-(G.ListingMaxDisplay/2);	SetCtlValue(G.ListingVScroll,value);	DrawListingWindow();}pascal void CentreListingWindowByNumSTSimpleUpdate(long stnum,long oldstnum){long	value,max,hauteur,a,b; Rect		rect; Boolean	visible=true;// s'i y a un te ouvert on le ferme		if (G.ListingTE) {			SetPort((WindowPtr)&G.ListingWindow);			TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);			TEDispose(G.ListingTE);			G.ListingTE=nil;			InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);		}	// on regarde si le sous-titre est visible	max=GetCtlMax(G.ListingVScroll);	value=GetCtlValue(G.ListingVScroll);	rect=((GrafPtr)&G.ListingWindow)->portRect;	if (  	stnum<value	|| 		stnum>(G.ListingMaxDisplay+value-1)		) visible=false;			// on vérifie qu'il est visible entièrement, si non on force le centrage		if (visible){		a=(stnum-value+1);		a=a*G.HauteurST;		b= (rect.bottom-rect.top )-18;		if (a>b) visible=false;		}			if (!visible){ // st pas visible		// on optimise en fonctions du nombre de sous-titre visibles		value=(stnum/G.ListingMaxDisplay)*G.ListingMaxDisplay;									// si nous sommes dans les premiers sous-titres on ne centre pas		if (value<(G.ListingMaxDisplay))  value=1;				// on vérifie que le sous-titre est visible		{			a=(stnum-value+1)*G.HauteurST; b=(rect.bottom-rect.top)-18;			if (a>b) value=stnum; 	// il n'est pas visible entièrement						if ( value>(max-G.ListingMaxDisplay )  ) 	value=max-(G.ListingMaxDisplay-1); // au dessus de laliste			if ( stnum<value) value=stnum;	// en dessous du sous-titre, il n'était pas visible			if ( stnum>(value+G.ListingMaxDisplay) ) value=stnum;	// au dessus du sous-titre, il n'était pas visible			if (value<1)  value=1;	// erreur on ne peut pas ètre en dessous de 1		}		SetCtlValue(G.ListingVScroll,value);		DrawListingWindow();			} else { // st visible correctement		DrawSt_enCourDansListing_ByPointeur(stnum);		DrawSt_enCourDansListing_ByPointeur(oldstnum);	}	}pascal void DoUpdatePaletteTelecommande(void){DialogPtr					D=G.TELECOMMANDEWindow;PixPatHandle			the_pixpat;short						itemtype,i,IconId;Handle						item;Rect							rect;Handle						LaListeH;DitlelementPtr			LaListe;Ditl_MasterlistPtr	LaListe1;		SetPort(D);		the_pixpat=GetPixPat(129);				if (the_pixpat!=nil){			FillCRect(&D->portRect,the_pixpat);			DisposePixPat(the_pixpat);			}			LaListeH=((DialogPeek)D)->items;		HLock(LaListeH);		LaListe=(DitlelementPtr)*LaListeH;		LaListe1=(Ditl_MasterlistPtr)*LaListeH;				for (i=1;i<=(LaListe1->dml_NumberOfItem+1);i++) {			GetDItem(D,i,&itemtype,&item,&rect);			if ((itemtype&0x7f) == iconItem ) {				IconId=C_findIconResourceDitl(D,i);				item=(Handle)GetCIcon(IconId);				PlotCIcon(&rect,(CIconHandle) item);				}		}		GetDItem(D,1,&itemtype,&item,&rect);		InsetRect(&rect,-2,-2);		EraseRect(&rect);		FrameRectTwoLine(&rect,true);		DessineShuttleButton();}pascal void DoUpdatePaletteChenille(void){DialogPtr					D=G.ChenilleWindow;PixPatHandle			the_pixpat;short						itemtype,i,IconId;Handle						item;Str255						st0;Rect							rect,rect1;Handle						LaListeH;DitlelementPtr			LaListe;Ditl_MasterlistPtr	LaListe1;RGBColor					color,Fcolor;long				a,b,c,d,e,f;			the_pixpat=GetPixPat(129);				TextFont(geneva);		TextSize(9);				color.red=0;		color.blue=0;		color.green=0x4CCC;				if (the_pixpat!=nil){			FillCRect(&D->portRect,the_pixpat);			DisposePixPat(the_pixpat);			}				GetDItem(D,1,&itemtype,&item,&rect);		InsetRect(&rect,-2,-2);		EraseRect(&rect);		FrameRectTwoLine(&rect,true);				GetDItem(D,2,&itemtype,&item,&rect);		InsetRect(&rect,-2,-2);		EraseRect(&rect);		FrameRectTwoLine(&rect,true);		GetDItem(D,11,&itemtype,&item,&rect);		EraseRect(&rect);		MakeReliefRectangle1(&rect);				GetDItem(D,10,&itemtype,&item,&rect);		MakeReliefRectangle2(&rect);				NumToString((long)G.Echelle_Bandeau,&st0);		GetDItem(D,3,&itemtype,&item,&rect);		SetIText(item,&st0);				LaListeH=((DialogPeek)D)->items;		HLock(LaListeH);		LaListe=(DitlelementPtr)*LaListeH;		LaListe1=(Ditl_MasterlistPtr)*LaListeH;				TextMode(srcOr);		TextFace(0);		color.red=0;		color.green=0;		color.blue=0;		RGBForeColor(&color);		for (i=1;i<=(LaListe1->dml_NumberOfItem+1);i++) {			GetDItem(D,i,&itemtype,&item,&rect);			if ((itemtype&0x7f) == iconItem ) {				IconId=C_findIconResourceDitl(D,i);				item=(Handle)GetCIcon(IconId);				PlotCIcon(&rect,(CIconHandle) item);				}			if ((itemtype&0x7f) == statText ) {				GetIText(item,&st0);				MoveTo(rect.left,rect.bottom-3);				DrawString(&st0);			}					}		// le bar graph				color.red=24000;		color.green=24000;		color.blue=48000;		RGBForeColor(&color);				a=C_ConversionTimeCodeTrames(G.General_PremierTC);		b=C_ConversionTimeCodeTrames(G.General_DernierTC);		c=C_ConversionTimeCodeTrames(G.General_TCCourant);				GetDItem(G.ChenilleWindow,2,&itemtype,&item,&rect);		rect1=rect;		d=(long)rect.right-(long)rect.left ;		f=(b-a);		if (f)  			if (  (G.General_PremierTC !=-1) &&(G.General_DernierTC !=-1) ) {				e=( d*(c-a) )/f;				if (e<0) e=0;				if (e>d) e=d;							G.last_BarGraph=e;				rect1.left++;				rect1.top++;				rect1.bottom--;				rect1.right=rect.left+G.last_BarGraph;				PaintRect(&rect1);				rect1.left=rect1.right+1;				rect1.right=rect.right;				EraseRect(&rect1);		} // f		/* on dessine la chenille */		G.Bandeau_LastTC=G.General_TCCourant;		DessineLaChenille(G.General_TCCourant);	// on dessine le tc courant			GetForeColor(&Fcolor);		RGBForeColor(&color);				GetDItem(D,9,&itemtype,&item,&rect);		TextMode(srcCopy);		TextFace(bold);		InsetRect(&rect,-2,-2);		EraseRect(&rect);		MakeReliefRectangle1(&rect);		InsetRect(&rect,2,2);		MoveTo(rect.left,rect.bottom-3);		DrawString((Ptr)&G.bufferTimecodeCourant);		TextMode(srcOr);		TextFace(0);		RGBForeColor(&Fcolor);		color.red=0;		color.green=0;		color.blue=0;		RGBForeColor(&color);} // update chenillepascal void DoChenilleIdle (void){GrafPtr		oldport;	Rect				rect,rect1;WindowPtr	w=(WindowPtr)G.ChenilleWindow;RGBColor		color,oldcolor,oldFcolor;short			itemtype;Handle			item;long				a,b,c,d,e,f;			GetPort(&oldport);		SetPort(w);		GetBackColor(&oldcolor);		GetForeColor(&oldFcolor);			/* on dessine le tc courant */			color.red=0;		color.blue=0;		color.green=0x4CCC;				RGBForeColor(&color);				GetDItem(G.ChenilleWindow,9,&itemtype,&item,&rect);		TextMode(srcCopy);		TextFace(bold);		MoveTo(rect.left,rect.bottom-3);		DrawString((Ptr)&G.bufferTimecodeCourant);		TextMode(srcOr);		TextFace(0);		// le bar graph				color.red=24000;		color.green=24000;		color.blue=48000;		RGBForeColor(&color);		a=C_ConversionTimeCodeTrames(G.General_PremierTC);		b=C_ConversionTimeCodeTrames(G.General_DernierTC);		c=C_ConversionTimeCodeTrames(G.General_TCCourant);				GetDItem(G.ChenilleWindow,2,&itemtype,&item,&rect);		rect1=rect;		d=(long)rect.right-(long)rect.left ;		f=b-a;		if (f)  			if (  (G.General_PremierTC !=-1) &&(G.General_DernierTC !=-1) ) {			e=( d*(c-a) )/f;			if (e<0) e=0;			if (e>d) e=d;				if (G.last_BarGraph !=e) {				G.last_BarGraph=e;				rect1.left++;				rect1.top++;				rect1.bottom--;				rect1.right=rect.left+G.last_BarGraph;			//	SpecialFrameRect(&rect1,false);				PaintRect(&rect1);				rect1.left=rect1.right+1;				rect1.right=rect.right;				EraseRect(&rect1);	        	}		} // f			/* on s'occupe de la chenille */		a=C_ConversionTimeCodeTrames(G.Bandeau_LastTC); 		c=C_ConversionTimeCodeTrames(G.General_TCCourant);		b=c-a; //différence		if( b<0 )b=-b; 		if (b >= ( unsigned long) G.Echelle_Bandeau ){			G.Bandeau_LastTC=G.General_TCCourant;			DessineLaChenille(G.General_TCCourant);		}		/* on rend les couleurs et le port */				RGBBackColor(&oldcolor);		RGBForeColor(&oldFcolor);		SetPort(oldport);}// chenille idle// cette routine dessine la chenille void DessineLaChenille(long TCCentre){Rect				rect,rect1,rect2,rect3,rect4;WindowPtr	w=(WindowPtr)G.ChenilleWindow;RGBColor		color,oldFcolor;short			itemtype;Handle			item;long				a,b,c,d,e;	SousTitreRecordPtr			ST_PtrGauche,ST_PtrDroit,ST_Ptr;RgnHandle		NewClip,oldClip;		if (G.Echelle_Bandeau<1) G.Echelle_Bandeau=1;		if (G.Echelle_Bandeau>50) G.Echelle_Bandeau=50;		GetForeColor(&oldFcolor);		color.red=18000;		color.green=32000;		color.blue=18000;		RGBForeColor(&color);		NewClip=NewRgn();		oldClip=NewRgn();				// on sauvegarde le clip		GetClip(oldClip);		//on détermine le tc du bord gauche 		GetDItem(G.ChenilleWindow,1,&itemtype,&item,&rect);		GetDItem(G.ChenilleWindow,10,&itemtype,&item,&rect3);		RectRgn(NewClip,&rect);				// on clip la zone de dessin		SetClip(NewClip);				a=(long) ((rect.right-rect.left)*G.Echelle_Bandeau )/2;		//a=C_ConversionTimeCodeTrames(G.TCCentre);		b=C_ConversionTramesTimeCode(a);		// c tc bord gauche				c=C_SoustractionTimeCode(TCCentre,b);// d tc bord droit				d=C_AdditionTimeCode(b,TCCentre);// on détermine le ptr du tc de gauche et du tc de droite		ST_Ptr=ST_PtrGauche=C_ConversionTimeCodePointeur(c);		ST_PtrDroit=C_ConversionTimeCodePointeur(d);		rect2=rect1=rect;		a=C_ConversionTimeCodeTrames(TCCentre);		b=(long) (rect.right-rect.left);		e=(rect.right+rect.left)/2;		rect2.left=rect.left;				// on dessine les st		if(ST_Ptr) {			do {				if (ST_Ptr->st_TimeCodeIn !=1 && ST_Ptr->st_TimeCodeOut!=-1 ){					c=C_ConversionTimeCodeTrames(ST_Ptr->st_TimeCodeIn);					d=C_ConversionTimeCodeTrames(ST_Ptr->st_TimeCodeOut);					rect1.left=e +(c-a)/G.Echelle_Bandeau;					rect1.right=e+(d-a)/G.Echelle_Bandeau;					rect2.right=rect1.left;					EraseRect(&rect2);						PaintRect(&rect1);					if (SectRect(&rect2,&rect3,&rect4)) 		MakeReliefRectangle2(&rect3);					if (SectRect(&rect1,&rect3,&rect4)) 		MakeReliefRectangle2(&rect3);					rect2.left=rect1.right+1;					// si rect intersect on dessine le repère				 } // (ST_Ptr->st_TimeCodeIn !=1 && ST_Ptr->st_TimeCodeOut )				 ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_NextST;		 }while (ST_Ptr  &&  ST_Ptr<=ST_PtrDroit );			// on efface à droite du dernier sous-titre 		 			rect2.right=rect.right;					rect2.left=rect1.right;					EraseRect(&rect2);						if (SectRect(&rect2,&rect3,&rect4)) MakeReliefRectangle2(&rect3);		} // if(ST_Ptr)// on rend la clip rgn		SetClip(oldClip);		RGBForeColor(&oldFcolor);}pascal void DoDrawShuttleButton(void){	DialogPtr	dialog=G.TELECOMMANDEWindow;	short 	itemtype;	Rect	rect,r,r1,r2;	Handle 	item;	long				a,olda=0;		short				dH;	Point				mousexy,oldmouse;	CIconHandle		iconhandle;	GrafPtr	oldport;	GetPort(&oldport);	SetPort(dialog);	GetDItem(dialog,1,&itemtype,&item,&rect);	r=rect;	r1=rect;	r2=rect;// on calcule la position de la reglette	au centre	r.left=(rect.right-rect.left-15)/2+rect.left;	r.right=r.left+15;	iconhandle=GetCIcon(1205);	PlotCIcon(&r,(CIconHandle)iconhandle);			GetMouse(&mousexy);	oldmouse.h=0;		dH=8;		if ((mousexy.h>=r.left) && (mousexy.h<=r.right)) {		// limite d'action		dH=mousexy.h-r.left; // pos relatif du click		oldmouse.h=0;	}		do {			GetMouse(&mousexy);				// limite d'action						r.left=mousexy.h-dH;				if (r.left<(rect.left+2)) r.left=rect.left+2;		if ((r.left+15)>(rect.right-2)) r.left=rect.right-17;								// si position différente // dernière fois			if (r.left != oldmouse.h) {				r.right=r.left+15;						// on dessine le curseur			PlotCIcon(&r,(CIconHandle)iconhandle);			// on efface le reste du rectangle 			r2.left=rect.left;			r2.right=r.left;			EraseRect(&r2);				r2.left=r.right;			r2.right=rect.right-1;			EraseRect(&r2);				PlotCIcon(&r,(CIconHandle)iconhandle);			oldmouse.h=r.left;									// on calcule la vitesse						a=(long)((rect.right+rect.left)/2); // position médiane			a=(long)(oldmouse.h+8)-a; //différentiel de position //au centre curseur			a=(a*1024)/(long)(rect.right-rect.left);						// on effectue un changement de pente			if (a<-35) {				a=a-35;				a=a/4;				}						if (a>35) {				a=a+35;				a=a/4;				}						if (gvarmode==1) {							if (G.LecteurTimeCode_Type==1) TxVITCReader('SHTL',a&0xFFFF,G.ModemOutRefNum);				if (G.LecteurTimeCode_Type==2) TxRS422('SHTL',a&0xFFFF,G.ModemOutRefNum);				}			if (gvarmode==2) {				// on limite les valeurs pour le var				a=(a*9)/4; // moin rapide que shuttle				if (a<-64) a=-64;				if (a>0) {					a=a*3/2;					if (a>80) a=80;					}									if (a!=olda)						if (G.LecteurTimeCode_Type==1) TxVITCReader('SHTL',a&0xFFFF,G.ModemOutRefNum);					if (G.LecteurTimeCode_Type==2) TxRS422('VAR ',a&0xFFFF,G.ModemOutRefNum);					olda=a;				}				DoListingIdle();				if (G.LecteurTimeCode_Type==2) WaitTicks(2); //for test				DoSerialIdle();			} //(r.left != oldmouse.h)	// on rafraichi le tc	// on demande le tc	DoListingIdle();	DoSerialIdle();	} while (WaitMouseUp()==true);						if (G.LecteurTimeCode_Type==1) TxVITCReader('SHTL',0,G.ModemOutRefNum);	if (G.LecteurTimeCode_Type==2) TxRS422('SHTL',0,G.ModemOutRefNum);	EraseRect(&rect);				DisposeCIcon((CIconHandle)iconhandle);// on calcule la position de la reglette	au centre	r.left=(rect.right-rect.left-15)/2+rect.left;	r.right=r.left+15;	iconhandle=GetCIcon(1204);	PlotCIcon(&r,(CIconHandle)iconhandle);		DisposeCIcon((CIconHandle)iconhandle);	SetPort(oldport);	// on réactive l'interrogation automatique du tc player} // DoDrawShuttleButton/* Routine pour dessiner la reglette */pascal void	DessineShuttleButton(void){	DialogPtr	dialog=G.TELECOMMANDEWindow;	short 	itemtype;	Rect	rect,r;	Handle 	item;	CIconHandle			iconhandle;	GetDItem(dialog,1,&itemtype,&item,&rect);	r=rect;// on calcule la position de la reglette	au centre	r.left=(rect.right-rect.left-15)/2+rect.left;	r.right=r.left+15;	iconhandle=GetCIcon(1204);	PlotCIcon(&r,(CIconHandle)iconhandle);		DisposeCIcon((CIconHandle)iconhandle);}void 	DessineBarreControlListing(void){Rect							rect,rect1,rect2;short						a,s,mincolor,b;WindowPtr				w=(WindowPtr)&G.ListingWindow;RGBColor					color,txcolor,white,black;Str255						st0;CIconHandle				icon;		GrafPtr					oldport;								PenNormal();					white.red=-1;			 white.green=-1;			 white.blue=-1;			 			 black.red=0;			 black.green=0;			 black.blue=0;				GetPort(&oldport);		SetPort(w);		mincolor=GiveMinDepth(&w->portRect);		if (mincolor!=1) {				 color.red=0xBFFF;			 color.green=0xBFFF;			 color.blue=0xBFFF;			 			 			 } else {			 color.red=-1;			 color.green=-1;			 color.blue=-1;			RGBForeColor(&black);			RGBBackColor(&white);				 }		SetPort(oldport);			 txcolor.red=0;			txcolor.green=0;			txcolor.blue=0;		RGBForeColor(&color);								TextMode(srcOr);	// on devrai demander la taille etc ...		TextFont(geneva);	// pour une version internationnale		TextSize(9);/* On dessine la barre d'information */				rect=w->portRect;		rect.top=rect.bottom-14;		rect.right=119; // 1 relief		rect1=rect;		if (mincolor!=1) PaintRect(&rect1);		else EraseRect(&rect1);				FrameRectTwoLine(&rect1,false);		// on place le texte tracking		RGBForeColor(&txcolor);		GetIndString(&st0,132,13);		MoveTo(rect.left+5,rect.bottom-4);		DrawString(&st0);				// on place le mode tracking en cours				a=0;		b=G.Preference_Tracking;		b&=0x03;		if (b==3 ) a=2;		else if (G.Preference_Tracking&1) a=1;		GetIndString(&st0,132,14+a);		DrawString(&st0);		//		MoveTo(rect.right,rect.top);		LineTo(rect.right,rect.bottom);		MoveTo(rect.right+1,rect.top);		LineTo(rect.right+1,rect.bottom);						//		RGBForeColor(&color);				rect.left=rect.right+2;		rect.right=257; // 1 relief		rect1=rect;		if (mincolor!=1) PaintRect(&rect1);		else EraseRect(&rect1);				FrameRectOneLine(&rect1,true);		// on place le texte total sous-titre		RGBForeColor(&txcolor);		GetIndString(&st0,132,17);		MoveTo(rect.left+5,rect.bottom-3);		DrawString(&st0);				// on place le nombre de sous-titre				NumToString(G.General_NombreST,&st0);		DrawString(&st0);		RGBForeColor(&color);		//				rect.left=rect.right;		rect.right=457; // 1 relief		rect1=rect;		if (mincolor!=1) PaintRect(&rect1);		else EraseRect(&rect1);		FrameRectOneLine(&rect1,true);		// on place le texte "time code courant"		RGBForeColor(&txcolor);		GetIndString(&st0,132,18);		MoveTo(rect.left+5,rect.bottom-3);		DrawString(&st0);		// si mode tc interne on affiche un bouton		if (G.LecteurTimeCode_Type==0){			GetIndString(&st0,132,20);			MoveTo(rect.left+140,rect.bottom-4);			DrawString(&st0);				rect2.left=rect.left+136;			rect2.right=rect2.left+StringWidth(&st0)+8;			rect2.top=rect.top+1;			rect2.bottom=rect.bottom-1;			FrameRoundRect(&rect2,4,4);		} else {							// si offset lecture TC on l'indique				if (G.OffsetLectureTCPlay || G.OffsetLectureTCStop ){									txcolor.red=0xBFFF;					txcolor.green=0;					txcolor.blue=0;					RGBForeColor(&txcolor); // on place le texte en rouge					GetIndString(&st0,132,24); // /!\ offset TC					MoveTo(rect.left+140,rect.bottom-4);					DrawString(&st0);						}		}				// on efface le dernier espace		RGBForeColor(&color);		rect.left=rect.right;		rect.right=w->portRect.right-15; // 1 relief		rect1=rect;		if (mincolor!=1) PaintRect(&rect1);		else EraseRect(&rect1);// on dessine les icônes à droite de la fenêtre		/*	l'icône de sauvegarde		*/				rect1.left=460;		rect1.bottom=w->portRect.bottom;		rect1.top=rect1.bottom-14;		rect1.right=rect1.left+14;		if (G.ChangeSinceLastSave&0x7fff) {			PlotCIcon(&rect1,G.IconSauvegardeOn);		} else {					PlotCIcon(&rect1,G.IconSauvegardeOff);		}				// on place le bit b15 à 1 pour dire que l'icône a été dessiné		G.ChangeSinceLastSave=G.ChangeSinceLastSave|0x8000; 						/* l'icône reception série		*/			rect1.left+=18;			rect1.right+=18;			if (G.SerialError>0) PlotCIcon(&rect1,G.IconHandle1);			else PlotCIcon(&rect1,G.IconHandle2);				/* l'icône commutateur		*/							rect1.left+=18;			rect1.right+=18;		// on affiche l'icône pleine seulement si mode rs 422		if (G.LecteurTimeCode_Type==2){		s=G.Mode_Commutateur;		//if (s<0 || s>2) DebugStr("\p ooops.");		icon=GetCIcon(280+G.Mode_Commutateur);			} else icon=GetCIcon(283);					if (icon) {				PlotCIcon(&rect1,icon);					DisposeCIcon(icon);				}				/* l'icône zoom out		*/							rect1.left+=18;			rect1.right+=18;			icon=GetCIcon(276);			if (icon)PlotCIcon(&rect1,icon);		/* l'icône zoom in		*/							rect1.left+=18;			rect1.right+=18;			icon=GetCIcon(272);			if (icon) PlotCIcon(&rect1,icon);										/* l'icône affiche ¶		*/							rect1.left+=18;			rect1.right+=18;			icon=GetCIcon(284);			if (icon) PlotCIcon(&rect1,icon);									/* 	La ligne	*/					rect=w->portRect;		color.green=0;		color.red=0;		color.blue=0;0;		RGBForeColor(&color);		MoveTo(rect.left,rect.bottom-15);		LineTo(rect.right-16,rect.bottom-15);} // dessine barre de control listingpascal void DrawBlockNoteValue(void){short			type,i;Handle			itemH;Rect				rect;Str255			st0;PixPatHandle		the_pixpat;DialogPtr			D=(DialogPtr)G.BlockNoteWindow;RgnHandle			rgn,rgn1;GrafPtr			oldport;RGBColor			oldF,color;long 				c;		GetPort(&oldport);		SetPort(D);		GetForeColor(&oldF);		// on rempli par une pixpat (sauf	 les région de texte et n°40)		the_pixpat=GetPixPat(129);		TextFont(geneva);		TextSize(9);						if (the_pixpat!=nil){			rgn=NewRgn();			rgn1=NewRgn();			RectRgn(rgn,&D->portRect);			// les premiers textes			for (i=1;i<=10;i++){				GetDItem(D,i,&type,&itemH,&rect);				RectRgn(rgn1,&rect);				DiffRgn(rgn,rgn1,rgn);				}			// la zone infos				GetDItem(D,39,&type,&itemH,&rect); RectRgn(rgn1,&rect); DiffRgn(rgn,rgn1,rgn);			// la zone texte			GetDItem(D,21,&type,&itemH,&rect); RectRgn(rgn1,&rect); DiffRgn(rgn,rgn1,rgn);			//on rempli par la pattern			FillCRgn(rgn,the_pixpat);			DisposePixPat(the_pixpat);			//on efface le reste			RectRgn(rgn1,&D->portRect);			DiffRgn(rgn1,rgn,rgn);			//on dispose les structures			EraseRgn(rgn);			DisposeRgn(rgn);			DisposeRgn(rgn1);		}//if (the_pixpat!=nil		else EraseRect(&D->portRect); // si pas de pixpat on efface seulement		// on dessine les textes et les icônes		color.red=0;		color.green=0;		color.blue=28000;		RGBForeColor(&color);		Draw_Icon_Text_Ditl((DialogPtr)G.BlockNoteWindow);		RGBForeColor(&oldF);// on entoure quelques zones				GetDItem(D,21,&type,&itemH,&rect);		InsetRect(&rect,-2,-2);		FrameRectOneLine(&rect,true);				GetDItem(D,39,&type,&itemH,&rect);		InsetRect(&rect,1,1);		PenPat(&QD.gray);		FrameRect(&rect);		PenNormal();		// maintenant on rafraichi les time-code		for(i=9;i>=0;i--){			GetDItem(D,i+1,&type,&itemH,&rect);			C_ConversionTCstASCII(G.BlockNote_tc[i],&st0);			TextBox(&st0[1],(long)st0[0],&rect,teJustLeft);			InsetRect(&rect,-1,-1);			PenPat(&QD.gray);			FrameRect(&rect);			PenNormal();			InsetRect(&rect,-1,-1);			FrameRectOneLine(&rect,true);		}// on dessine le commentaire		GetDItem(D,21,&type,&itemH,&rect);		TextBox(&G.BlockNote_texte[1],(long)G.BlockNote_texte[0],&rect,teJustLeft);		InsetRect(&rect,-1,-1);		PenPat(&QD.gray);		FrameRect(&rect);		PenNormal();	// on dessine la durée du film		GetDItem(D,33,&type,&itemH,&rect);		if (G.BlockNote_tc[8]!=-1 && G.BlockNote_tc[0]!=-1){			c=C_SoustractionTimeCode(G.BlockNote_tc[8],G.BlockNote_tc[0]);			C_ConversionTCstASCII(c,&st0);			TextBox(&st0[1],(long)st0[0],&rect,teJustLeft);			}			// 1er tc du film		GetDItem(D,34,&type,&itemH,&rect);		C_ConversionTCstASCII(G.General_PremierTC,&st0);		TextBox(&st0[1],(long)st0[0],&rect,teJustLeft);//  le dernier sous-titre du film		GetDItem(D,35,&type,&itemH,&rect);		C_ConversionTCstASCII(G.General_DernierTC,&st0);		TextBox(&st0[1],(long)st0[0],&rect,teJustLeft);// on dessine la dernière police d'affichage utilisée		GetDItem(D,40,&type,&itemH,&rect);		TextBox(&G.LastFontUsed[1],(long)G.LastFontUsed[0],&rect,teJustLeft);		GetPort(&oldport);} // DrawBlockNoteValuevoid FlashTrackingSaisie(void){short			type,i;Handle			itemH;Rect				rect;Str255			st0;PixPatHandle		the_pixpat;DialogPtr			D=(DialogPtr)&G.DialogSaisie;RgnHandle			rgn,rgn1;GrafPtr			oldport;RGBColor			oldF,color;long 				c;RGBColor			oldcolor,bleu,rouge,black,lightGray;		black.red=0;		black.green=0;		black.blue=0;				bleu.red=0;		bleu.green=0;		bleu.blue=0xCfff;				rouge.red=0xffff;		rouge.green=0;		rouge.blue=0;		color.red=0;		color.blue=0xafff;		color.green=0;						lightGray.red=60947;		lightGray.green=60947;		lightGray.blue=60947;		GetPort(&oldport);		SetPort(D);		GetForeColor(&oldF);				GetDItem(D,46,&type,&itemH,&rect);		TextSize(9);						if (!G.saisieTE){			InvertRect(&rect);			WaitTicks(4); 			InvertRect(&rect);			WaitTicks(4); 			RGBForeColor(&lightGray);			PaintRect(&rect);			RGBForeColor(&rouge);			MoveTo(rect.left+3,rect.top+10);			GetIndString(&st0,129,58);			DrawString(&st0);			RGBForeColor(&lightGray);			FrameRect(&rect);			InvertRect(&rect);			WaitTicks(4); 			InvertRect(&rect);			WaitTicks(4); 			InvalRect(&rect);			UpdateSaisie();	}		SetPort(oldport);} // FlashTrackingSaisie// cette routine dessine les stat texte,pict et icon d'un dialogpascal void Draw_Icon_Text_Ditl(DialogPtr dialog){	short			itemtype,i;	Handle			item;	Rect				rect;	Handle			LaListeH;	DitlelementPtr		LaListe;	Ditl_MasterlistPtr	LaListe1;	Str255			st0;	short			oldtextmode;	//SetPort(dialog); on ne fait pas setport car problème si offscreen dessin	oldtextmode=((GrafPtr)dialog)->txMode;	// on sauveagrde le mode	TextMode(srcOr);					// on force scrOr	// la liste des items		LaListeH=((DialogPeek)dialog)->items;	HLock(LaListeH);	LaListe=(DitlelementPtr)*LaListeH;	LaListe1=(Ditl_MasterlistPtr)*LaListeH;		for (i=0;i<=LaListe1->dml_NumberOfItem;i++) {		GetDItem(dialog,i+1,&itemtype,&item,&rect);		if ((itemtype&0x7f) == iconItem && item!=nil){			 PlotCIcon(&rect,(CIconHandle) item);			 }		if ((itemtype&0x7f) == statText && item!=nil){			GetDialogItemText(item,&st0);			MoveTo(rect.left,rect.bottom-3);				DrawString(&st0);		 }		 if ((itemtype&0x7f) == picItem && item!=nil){			DrawPicture((PicHandle)item,&rect);		 }		 	 	} // for i...		TextMode(oldtextmode); // on rend le mode	HUnlock(LaListeH);}//Draw_Icon_Text_Ditlvoid MyUpdateDialog(DialogPtr dialog);void MyUpdateDialog(DialogPtr dialog){		Draw_Icon_Text_Ditl(dialog);		UpdateControls(dialog,dialog->visRgn);		/*		 // s'il ya des TE on les redessines		 if ( (itemtype == editText )&& item!=nil) {			TEUpdate((PicHandle)item,&rect);		 }			 	*/	 }/* Cette routine ajuste la taille du CONTROL de la fenêtre listing */pascal void Adjust_ListingScrollBar(void) {WindowPtr	window=(WindowPtr)&G.ListingWindow;	MoveControl(G.ListingVScroll, window->portRect.right - kScrollbarAdjust,0);	SizeControl(G.ListingVScroll, kScrollbarWidth, (window->portRect.bottom - 				window->portRect.top) - 15);			}void UpdateInfoWindow(void){GrafPtr	oldport;RGBColor	color;PixPatHandle the_pixpat;DialogPtr 	D=G.ServiceWindow;Handle	itemH;short	type;Rect		rect;RgnHandle rgn,rgn1;	GetPort(&oldport);	SetPort(D);	TextFont(geneva);	TextSize(9);	TextFace(0);	TextMode(srcCopy);	the_pixpat=GetPixPat(129);	color.red=0; color.green= 0; color.blue=0;	RGBForeColor(&color);			if (  (the_pixpat!=nil) && (GiveMinDepth(&D->portRect)>1)  ) {		// on calcule la rgn pour la pattern			rgn=NewRgn();			rgn1=NewRgn();			RectRgn(rgn,&D->portRect);			GetDItem(D,20,&type,&itemH,&rect);			EraseRect(&rect);			InsetRect(&rect,-1,-1);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			FillCRgn(rgn,the_pixpat);			DisposeRgn(rgn);			DisposeRgn(rgn1);									InsetRect(&rect,1,1);			FrameRectOneLine(&rect,true);						} else { // si pas de pixpat ou Ecran n&B  on efface seulement			EraseRect(&D->portRect); // si pas de pixpat on efface seulement			GetDItem(D,20,&type,&itemH,&rect);			PenPat(&QD.gray);			FrameRect(&rect);			PenNormal();		}		if (the_pixpat!=nil) 	DisposePixPat(the_pixpat);	// on entoure le petit rectangle	GetDItem(D,19,&type,&itemH,&rect);	PenPat(&QD.gray);	FrameRect(&rect);		// on entoure le petit rectangle	GetDItem(D,23,&type,&itemH,&rect);	PenPat(&QD.gray);	FrameRect(&rect);		PenNormal();						color.red=0; color.green= 0; color.blue=42000;	RGBForeColor(&color);	Draw_Icon_Text_Ditl(G.ServiceWindow);	DrawInfowWindValue();}//UpdateInfoWindowvoid	DrawInfowWindValue(void){GrafPtr	oldport;RGBColor	color;Str255	st0;long		c;DialogPtr	D=G.ServiceWindow;	Handle	itemH;short	type;Rect		rect;	GetPort(&oldport);	SetPort(D);	PenNormal();	TextFont(geneva);	TextSize(9);	TextFace(0);	TextMode(srcCopy);	// on dessine les valeurs// performances	color.red=0; color.green= 32000; color.blue=0;	RGBForeColor(&color);	NumToString(G.EventLoop_Speed,&st0);	GetDItem(D,1,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		st0[st0[0]+1]=' ';	st0[st0[0]+2]=' ';	st0[0]+=2;	DrawString(&st0);	NumToString(G.Serial_Main_rate,&st0);	GetDItem(D,2,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		st0[st0[0]+1]=' ';	st0[st0[0]+2]=' ';	st0[0]+=2;	DrawString(&st0);		NumToString(G.Serial_Vitc_rate,&st0);	GetDItem(D,3,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		st0[st0[0]+1]=' ';	st0[st0[0]+2]=' ';	st0[0]+=2;	DrawString(&st0);		NumToString(G.Serial_Sony_rate,&st0);	GetDItem(D,4,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		st0[st0[0]+1]=' ';	st0[st0[0]+2]=' ';	st0[0]+=2;	DrawString(&st0);		//vitesse du VTR		GetDItem(D,22,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);	DrawString("                      ");	NumToString(gVitesseVTR*100/6,&st0);	MoveTo(rect.left,rect.bottom-3);	st0[st0[0]+1]='%';	st0[st0[0]+2]=' ';	st0[0]+=2;	DrawString(&st0);		// technique de lecture timecode	GetDItem(D,25,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);	if (gMethodeLectureRS422) DrawString("\pMainLoop ");	else  DrawString("\pInterrupt ");	// time code divers et variés	TextFace(bold);	C_ConversionTCstASCII(G.General_PseudoTimeCode,&st0);	GetDItem(D,5,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		C_ConversionTCstASCII(G.Vitc_Readen,&st0);	GetDItem(D,6,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		C_ConversionTCstASCII(G.PlayerStruct.vtr_LTC,&st0);	GetDItem(D,7,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		C_ConversionTCstASCII(G.PlayerStruct.vtr_VITC,&st0);	GetDItem(D,8,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		c=C_SoustractionTimeCode(G.PlayerStruct.vtr_LTC,G.PlayerStruct.vtr_VITC);	C_ConversionTCstASCII(c,&st0);	GetDItem(D,9,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);	SetPort(oldport);}void	DrawInfowWindValuePartiel(void){GrafPtr	oldport;RGBColor	color;Str255	st0;long		c;DialogPtr	D=G.ServiceWindow;	Handle	itemH;short	type;Rect		rect;	GetPort(&oldport);	SetPort(D);		PenNormal();	TextFont(geneva);	TextSize(9);	TextFace(bold);	TextMode(srcCopy);// on dessine les valeurs// performances	color.red=0; color.green= 32000; color.blue=0;	RGBForeColor(&color);// time code divers et variés	C_ConversionTCstASCII(G.General_PseudoTimeCode,&st0);	GetDItem(D,5,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		C_ConversionTCstASCII(G.Vitc_Readen,&st0);	GetDItem(D,6,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		C_ConversionTCstASCII(G.PlayerStruct.vtr_LTC,&st0);	GetDItem(D,7,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		C_ConversionTCstASCII(G.PlayerStruct.vtr_VITC,&st0);	GetDItem(D,8,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);		c=C_SoustractionTimeCode(G.PlayerStruct.vtr_LTC,G.PlayerStruct.vtr_VITC);	C_ConversionTCstASCII(c,&st0);	GetDItem(D,9,&type,&itemH,&rect);	MoveTo(rect.left,rect.bottom-3);		DrawString(&st0);	SetPort(oldport);}void UpdateProchainSousTitre(Boolean partiel){GrafPtr	oldport;RGBColor	color;DialogPtr 	D=gDialogProchainSousTitre;Handle	itemH;short	type;Rect		rect;RgnHandle rgn,rgn1;long	start,end;SousTitreRecordPtr	ST_Ptr;Boolean	dodraw=false,transparent=(gMonitor!=nil);long a;Str255	st0;short cmode=srcCopy;	GetPort(&oldport);		SetPort(D);	TextFont(helvetica);	TextSize(30);	TextFace(bold);	TextMode(cmode);	PenMode(cmode);		color.red=-1; color.green=-1; color.blue=-1; 	RGBForeColor(&color);		color.red=0; color.green=0; color.blue=0; 		if (transparent) RGBBackColor(&gKeyColor);	else 		  RGBBackColor(&color);			if(!partiel) EraseRect(&D->portRect);	// on calcule le time code du prochain sous-titre	ST_Ptr=G.General_SousTitreCourantPtr;		if (ST_Ptr) {		a=TestSiDansST(ST_Ptr,G.General_TCCourant);		if (a!=-1){			if (a>=0){							ST_Ptr=(SousTitreRecordPtr)ST_Ptr->st_NextST;				if (ST_Ptr){					start=ST_Ptr->st_TimeCodeIn;					end=ST_Ptr->st_TimeCodeOut;					dodraw=true;				}						} else {				start=ST_Ptr->st_TimeCodeIn;				end=ST_Ptr->st_TimeCodeOut;				dodraw=true;							}		}// (a!=-1)	}				if (dodraw){		C_ConversionTCstASCII(start,&st0);		GetDItem(D,1,&type,&itemH,&rect);		MoveTo(rect.left+3,rect.top+30);		DrawString(&st0);				C_ConversionTCstASCII(end,&st0);		GetDItem(D,2,&type,&itemH,&rect);		MoveTo(rect.left+3,rect.top+30);		DrawString(&st0);	} else {		GetDItem(D,1,&type,&itemH,&rect);		EraseRect(&rect);			GetDItem(D,2,&type,&itemH,&rect);		EraseRect(&rect);	}		SetPort(oldport);}//UpdateProchainSousTitrevoid DoSaisieIdle(void){SousTitreRecordPtr ST_Ptr;		// on regarde les tracking		if(doTrackingInSaisie){			doTrackingInSaisie=0;						// on ne fait le tracking que si le te est ferme			if (!G.saisieTE){					TransfertSaisieMemoire();							/* on recherche le st correspondant au tc courant */					ST_Ptr=C_ConversionTimeCodePointeur(G.General_TCCourant);					G.General_SousTitreEncour=ST_Ptr->st_AbsNUMST;					UpdateSaisie();										//CentreListingWindow();					VerifieTimeCodes(ST_Ptr);					SignalErreurSousTitre(ST_Ptr);					} //!G.saisieTE					}  //doTrackingInSaisie	} //DoSaisieIdle