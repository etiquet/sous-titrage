#include "BB.Globals_C.h"#include "CreateFastFont.h"#include "PPCDispatch.h"// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;	pascal void Terminate(void);pascal Boolean RPIdleWText(Handle theRpd,long value,Str255 string,pascal void(*UpdateFct)(WindowPtr window),Boolean Multifinder );extern pascal Ptr	 GIVEDISPLAYFONT_CHARINFO(FontRenderRecordPtr theFontrecord:__A0,short car:__D0,short style:__D1):__A0;CharHeaderPtr C_GiveDisplayFont_CharInfo(FontRenderRecordPtr theFont,short thechar,short theStyle);pascal void  Create_FastFont(FontRenderRecordPtr FontRender,short DestinationSize ,Ptr RenderEffect   );		pascal short A_DRAW_A_CHAR(FontRenderRecordPtr  FontRender,short  TheChar,short TheStyle,							long  FaceColor, long BorderColor, long ShadowColor, long bgdColor,							 char  flags, short Xpos,short Ypos, char* DisplayRamPtr, long RowBytes);inline asm void saveregisteronstack(void);inline asm void restoreregisterfromstack(void);/*		Cette routine effectue le rendu d'une police d'affichage colorée	à partir d'une font déjà calculée, pour une grande rapiditée d'affichage  */short  C_fastFont_Calcul_char(	FontRenderRecordPtr FontRender,	CharHeaderPtr chptr, 	CharHeaderPtr rend_chptr ,	short charnum ,	short StyleType,	unsigned long *FontCurrentPtr,	Ptr FontBitmapPtr);				pascal void Create_FastFont(FontRenderRecordPtr FontRender,short DestinationSize ,Ptr RenderEffect   ){long		total,contig,FontBitmapSize,mem,TotalChar,CharCounter,style,charnum,Date,estTime,StartDate;Str255	st0,st1;Handle	mymemH,renderH,RPD;Ptr		mymemPtr,FontBitmapPtr;DialogPtr	dlog;short 	Itemchoisi,StyleType,err;	unsigned long FontCurrentPtr,PreviousFontCharPtr,FontCharPtr,FontStylePtr,a,Row_Bytes;CharHeaderPtr	chptr,prchptr,tmpPtr;DateTimeRec	datrec;Rect			myrect;Boolean		flag,docharloop;						// on regarde si parametre "font render" valide									if (! FontRender->Render_handle) {	// il n'y a pas de "font" en memoire			// alert			AlertUser(31);			return ;				} else {			HUnlock(FontRender->Render_handle);				}// on regarde s'il y a déjà un handle aloué (dejà un calcul précédent)		if (FontRender->RenderColor_handle) {				// oui on le dispose			HUnlock(FontRender->RenderColor_handle);			DisposeHandle(FontRender->RenderColor_handle);			FontRender->RenderColor_handle=nil;		}/* on demande une zone mémoire pour pouvoir dessiner un caractère dans un plan	on reserve un espace mémoire =4 fois la taille de la lettre 			pour permettre le rendu d'un plan*/		mem=(FontRender->FontSize)*(FontRender->FontSize)*32 +10240;		mymemH=NewHandle(mem);		HLock(mymemH); 		mymemPtr=*mymemH; 	//handle => pointeur/*on effectue un calcul préalable de l'espace mémoire nécessaire pour contenirla police	d'affichage. on récupère la taille du handle display font on ouvre un dialog pour indiquer que nous recherchons de la mémoire*/		dlog=GetNewDialog(176,nil,(WindowPtr)-1);		DrawDialog(dlog);						mem= GetHandleSize(FontRender->Render_handle);		// on regarde s'il y a un probleme				if (mem<=0) {			// on dispose la memoire			AlertUser(31);			if (mymemH)	DisposeHandle(mymemH);			return ;					} 		//on demande un handle de 4 fois la taille 		FontBitmapSize=mem*4;		renderH=NewHandle(FontBitmapSize);						// on ferme le dialog demande de mémoire		DisposeDialog(dlog);						// probleme de mémoire ?		if (renderH) { 						// il n'y a pas assez de mémoire	// non on indique la mémoire dispo et on demande son choix à l'utilisateur						PurgeSpace(&total,&contig); 		NumToString(contig/1024-32,&st1);		NumToString(FontBitmapSize/1024,&st0);		ParamText(&st0,&st1,nil,nil);		Itemchoisi=Alert(194,nil);		if (Itemchoisi == 1){	// on quitte la routine			if (mymemH)	DisposeHandle(mymemH);			return ;		}		// l'utilisateur a demandé que l'on essaye le rendu (à ses risques et perils)		renderH=NewHandle(contig-32*1024);						} //if (renderH<=0)// on place le handle dans la structure		FontRender->RenderColor_handle=renderH;		FontBitmapPtr=*renderH;		FontRender->interligne=1;// on initialise le  Font record de la police		FontRender->First_Char=33;		FontRender->last_Char=255;/* ---; on reserve de la place pour le header du font bitmaps;; rappel  :     	ptr style 1		<-  début du font bitmaps	);				  / / / / 									) header font bitmap;				ptr style n									) ;;				headerCharN°1	<- début 1 er style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn;				    / / / /;				headerCharN°1	<- début n ème style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn; (il faut réserver un  long ptr pour chaque style) ; il faudra changer le nom face number par style number (nombre de style dans le bitmap); initialisation du Displayfont header en tête ; réservation de la place nombre de style à rendre* taille du "styleHeader" ; réservation de la place*/	HLock(FontRender->Render_handle);		// on vérouille le handle source	FontCurrentPtr=sizeof(MasterPlaneInfo)*FontRender->Face_Number;	FontRender->max_descent=0;	FontRender->max_Ascent=0;	// on calcule le nombre total de caractères		TotalChar=(FontRender->last_Char-FontRender->First_Char)*FontRender->Face_Number;	CharCounter=0; 	//reset du compteur	// on ouvre une réglette de progression		GetIndString(&st0,129,55); // "CALCUL D'UNE POLICE D'AFFICHAGE"	RPD=RPInitReglette(&st0,&FontRender->FontName,1,TotalChar,true);	// LE NOM DE LA POLICE"	GetDateTime(&StartDate);			// la boucle de rendu	//  c'est parti pour la grande boucle			for (style=0; style<FontRender->Face_Number;style++){	// on calcule le pointeur (relatif // au debut de la zone mémoire )		FontCurrentPtr=((FontCurrentPtr+3)/4)*4;		FontStylePtr=FontCurrentPtr;		PreviousFontCharPtr=0;				// on le place dans la table en début		((MasterPlanePtr)FontBitmapPtr)->styleoffset[style].offset=(Ptr)FontStylePtr;				// on détermine quel style il faut calculer (normal, italique, gras)		// car si nb de style =3 (0,1,2) pas de difficultée		// si nb de style =2 (0,1) il faut déterminer de quel style il s'agit,  gras ou italique ?				docharloop=true;		StyleType=style;			/*	switch(style) {		case 0:			StyleType=0;		break;				case 1: // style italique ou gras ?			if ( FontRender->FontStyle&1) {				 StyleType=1; 				 break;			 } else {			 	if (! FontRender->FontStyle&2)  docharloop=false;				StyleType=2;				break;				}		break;				case 2: // style gras ?			if (! FontRender->FontStyle&1)  docharloop=false;			StyleType=1;		break;				} //switch(style)		*/		if (docharloop) { // on fait la boucle de calcule des caractères	 	 	// boucle de calcul caratères				for (charnum=FontRender->First_Char; charnum<=FontRender->last_Char;charnum++){			// initialisation des pointeurs "Display font" boucle caractères			FontCharPtr=FontCurrentPtr;			FontCurrentPtr=FontCharPtr+sizeof(CharHeader);						// on update les pointeurs de cet en tête						a=(unsigned long)FontBitmapPtr+FontCharPtr;			chptr=(CharHeaderPtr)a; //						chptr->CH_PreviousChar=(char*)PreviousFontCharPtr;			chptr->CH_NextChar=0;			chptr->CH_CharNumber=charnum;			chptr->CH_Spare=0xdada;						// raz le rectangle du caractère			chptr->CH_Rect.top=-1;			chptr->CH_Rect.left=-1;			chptr->CH_Rect.bottom=0;			chptr->CH_Rect.right=0;			//  on update le "CH_NextChar" du char précédent (s'il existe)				if (	PreviousFontCharPtr){											// on calcule le pointeur absolu du char precedent							a=(unsigned long)FontBitmapPtr+PreviousFontCharPtr; //(CharHeaderPtr)				prchptr=(CharHeaderPtr)a;				prchptr->CH_NextChar=(char*)FontCharPtr;	// le ptr courant			}					// l'actuel char devient le précédent   au prochain passage			PreviousFontCharPtr=FontCharPtr;															//  ----- on dessine le caractère dans un buffer -------------						//tmpPtr=(CharHeaderPtr)GIVEDISPLAYFONT_CHARINFO(FontRender,charnum,StyleType);		tmpPtr=C_GiveDisplayFont_CharInfo(FontRender,charnum,StyleType);				flag=false;				if (tmpPtr ) {					// on calcule le row bytes de ce caractère			Row_Bytes=(tmpPtr->CH_Rect.right+4)*4;						// on recopie les dimensions du caractère.			myrect=tmpPtr->CH_Rect;			chptr->CH_Rect=tmpPtr->CH_Rect;							}		// 	on test si rectangle coherent pour une police & char <> 0xca									if ( (myrect.bottom-myrect.top)>0 &  (myrect.bottom-myrect.top)<500 ) {			if ( (myrect.right-myrect.left)>0 &  (myrect.right-myrect.left)<500 ) {			 	if (charnum!=0xca) flag=true;			}		}					// si pas de pointeur de caractères <=> problème -> on ne fait rien					if (! tmpPtr ) 	flag=false; ;					if (charnum ==0xca) flag=false;		if (charnum ==0xff) flag=false;		// ------ 										if (flag){				//on effectue le calcul du ffont du char				err= C_fastFont_Calcul_char( FontRender,chptr, tmpPtr ,charnum , StyleType,&FontCurrentPtr,FontBitmapPtr);				if (err) {						AlertUser(6);						goto onsortdela; 								}				//FontCurrentPtr+=16; // pour que le ptr suivant soit valide (optionel)						}	else {				FontCurrentPtr+=16; // pour que le ptr suivant soit valide (optionel)								chptr->CH_Spare=0;				chptr->CH_Rect.top=0;						chptr->CH_Rect.left=0;						chptr->CH_Rect.bottom=0;						chptr->CH_Rect.right=0;								}	// if (flag)						// -----------------------------	// on indique l'état de progression						CharCounter++;										// on rafraichie la réglette					// on essaye d'estimer de temps restant					GetDateTime(&Date);					Date-=StartDate; 	//le temps ecoulé EN SECONDE										if (Date>5){	// on ne le fait pas pendant les 5 première secondes												estTime=((TotalChar-CharCounter)*Date)/CharCounter;						SecondsToDate((unsigned long )estTime, &datrec); // on transforme les secondes en minute,secondes												st0[0]=0;						// les minutes						NumToString(datrec.minute,&st1); 						if (st1[0]==1) {st0[0]++;  st0[st0[0]]='0';} // on ajoute un leading zero						BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);						st0[0]+=st1[0];						// les secondes						NumToString(datrec.second,&st1); 						st0[0]++;  st0[st0[0]]=':';						if (st1[0]==1) {st0[0]++;  st0[st0[0]]='0';} // on ajoute un leading zero						BlockMove(&st1[1],&st0[st0[0]+1],st1[0]);						st0[0]+=st1[0];											} else st0[0]=nil;				if ( RPIdleWText(RPD,CharCounter,st0,nil/*&DoUpdate*/,true) ) // on rafraichi la reglette de progression						if (CautionAlert (295,nil)==1){  // l'utilisateur demande l'arrêt, on demande confirmation								HUnlock(FontRender->RenderColor_handle);// il souhaite arrêter								DisposeHandle((Handle)FontRender->RenderColor_handle); // on dispose le handle								FontRender->RenderColor_handle=nil;								RPDispose(RPD);								return ;							} //vraiment arrêter						} // for (charnum=0)			    } // if (dothechar)		} // for (style=0; style<FontRender->Face_Number,style++)onsortdela:	// on dispose l'indicateur de progression	RPDispose(RPD);	// on taille le handle à la taille voulue	HUnlock(FontRender->Render_handle);			HUnlock (FontRender-> RenderColor_handle);	SetHandleSize (FontRender-> RenderColor_handle,FontCurrentPtr);	if (mymemH) DisposeHandle(mymemH);		} //Create_FastFont	inline asm void saveregisteronstack( void ){					move.l 	(sp)+,a0			//on recupère l'adresse de retour					movem.l 	d1-d7/a1-a4,-(sp)	//sauvegarde des registres					jmp (a0)				}				inline asm void restoreregisterfromstack( void ){										move.l 	(sp)+,a0			//on recupère l'adresse de retour					movem.l 	(sp)+,d1-d7/a1-a4	//sauvegarde des registres					jmp (a0)				}			short  C_fastFont_Calcul_char(	FontRenderRecordPtr FontRender,	CharHeaderPtr chptr, 	CharHeaderPtr rend_chptr ,	short charnum ,	short StyleType,	unsigned long *FontCurrentPtr,	Ptr	FontBitmapPtr){unsigned long 	Row_Bytes,a,b;PlaneInfoPtr	planeinfo;short		item,i;Ptr			mem=nil;Ptr			P,P1,P2;long*			pl;Str255		st0;short		tmp;								Row_Bytes=(rend_chptr->CH_Rect.right+1)*4; 	// le row byte du caractère sur 32 bits    														//!!!! pourquoi   CH_Rect.right+ 1?????							/*	on recupère le "base line" maximum  */				a=(unsigned long)rend_chptr+sizeof(CharHeader);		// on calcule l'adresse du plane info 1 du caractère				planeinfo=(PlaneInfo*)a;								tmp=planeinfo->pi_Baseline; 				//!!! note: la base line est une valeur négative								if (FontRender->Plane_Number==2){ //si 2 plans					a+=sizeof(PlaneInfo);					planeinfo=(PlaneInfo*)a;					if (tmp>planeinfo->pi_Baseline) 		tmp=planeinfo->pi_Baseline;				}								if (FontRender->Plane_Number==3){ //si 3 plans					a+=sizeof(PlaneInfo);					planeinfo=(PlaneInfo*)a;					if (tmp>planeinfo->pi_Baseline) 		tmp=planeinfo->pi_Baseline;				}								chptr->CH_Spare=tmp;					// on utilise le  spare pour placer la base ligne				tmp=-tmp;								// base line*-1 => ascent				if(tmp>2){	// erreur  ?					// on calcule les caractèristiques génerale de la police					if (tmp>FontRender->max_Ascent)	FontRender->max_Ascent=tmp;					tmp=rend_chptr->CH_Rect.bottom-tmp;					if (tmp>FontRender->max_descent)	FontRender->max_descent=tmp;						}																	b=rend_chptr->CH_Rect.bottom-chptr->CH_Rect.top;					if (b>FontRender->interligne)	FontRender->interligne=b;	// maintenant on effectue le calcul de la lettre ----------------	// on regarde si l'on va dépasser la  mémoire 	// l'espace pris par le caractère à calculer				a= (rend_chptr->CH_Rect.right+1);				a=a*(rend_chptr->CH_Rect.bottom+1);				a=a*4; 						//  assez de mémoire ?	/* on demande son avis à l'utilisateur */								if ( GetHandleSize(FontRender->RenderColor_handle) <  (  ((unsigned long) *FontCurrentPtr) +a ) ) {					item=StopAlert(293,nil); 															switch (item){						case 1: // ne pas garder							DisposeHandle(FontRender->RenderColor_handle);							FontRender->RenderColor_handle=nil;														return -1;						break;												case 2: //garder							SetHandleSize(FontRender->RenderColor_handle, (long) *FontCurrentPtr+16);														return nil;						break;					} // switch 				}								a= (rend_chptr->CH_Rect.right+1);				a=a*(rend_chptr->CH_Rect.bottom+1);				a=a*4; // l'espace pris par le caractère à calculer				a=((a+31)/32)*32;												mem=NewPtrClear(a);														if (mem) {						b=-chptr->CH_Spare;												PPCDispatch_Call_C_Draw_A_Char(FontRender,charnum,StyleType,									G.RGB_FaceColor, G.RGB_BorderColor,									G.RGB_ShadowColor,0x00000000,									0,0,b,(char *)mem,Row_Bytes);																																	// pour le debug on ecrit dans la carte d'affichage									/*									A_DRAW_A_CHAR(FontRender,charnum,StyleType,									G.RGB_FaceColor, G.RGB_BorderColor,									G.RGB_ShadowColor,0x00000000,									100,100,b,(char *)G.Base_Adresse,G.Row_Bytes);																		*/									a=(unsigned long )*FontCurrentPtr+(unsigned long )FontBitmapPtr;						/*						// recopie dans la vx						P=(char*)mem;						P1=G.Base_Adresse;						for(i=0;i<(rend_chptr->CH_Rect.bottom+1);i++){							BlockMove(P,P1,Row_Bytes);							P+=Row_Bytes;							P1+=G.Row_Bytes;						}*/												a= (rend_chptr->CH_Rect.right+1);						a=a*(rend_chptr->CH_Rect.bottom+1);						a=a*4; // l'espace pris par le caractère calculé										b=(unsigned long )*FontCurrentPtr+(unsigned long )FontBitmapPtr;						P=(char*)mem;						P1=(char*)b;						BlockMove(P,P1,a);																													if (a>16)  	*FontCurrentPtr+=a;		 else 	*FontCurrentPtr+=16;														DisposePtr(mem);												} //if (mem)						else 		{							*FontCurrentPtr+=16;							return -1;						}								return nil;} //C_fastFont_Calcul_char