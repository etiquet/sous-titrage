#include "BB.Globals_C.h"#include <Devices.h>#include <StdArg.h>#include <stdio.h>#include <Controls.h>// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;#define thisDialogID 230/* Symbolic Dialog Item Numbers */static enum {	CTRL1 = 1,	CTRL2,	CTRL3,	EDIT4,	ICON5,	ICON6,	EDIT7,	ICON8,	ICON9,	EDIT10,	ICON11,	ICON12,	EDIT13,	ICON14,	ICON15,	EDIT16,	ICON17,	ICON18,	EDIT19,	ICON20,	ICON21,	EDIT22,	ICON23,	ICON24,	CTRL25,	EDIT26,	ICON27,	ICON28,	USER29,	USER30,	USER31,	CTRL32,	STXT33_Kerning,	STXT34_Larg,	STXT35_Interligne,	STXT36_X,	STXT37_Ligne,	STXT38_Largeur,	STXT39_Hauteur,	STXT40_Safe,	STXT41_Face,	STXT42_Coordonn,	STXT43_R,	USER44,	USER45,	USER46,	USER47,	USER48,	STXT49_R,	STXT50_Couleur,	LASTITEM	} DialogItemNumber;#define OK_ITEM 	?? /* Can't determine which item dismisses dialog affirmatively */#define CANCEL_ITEM 	?? /* Define this to be item that cancels dialog *//* Useful constants */#ifndef ENTERkey#define ENTERkey	0x3#endif#ifndef DELETEkey#define DELETEkey	0x8#endif#ifndef NIL#define NIL ((void *)0)#endif#ifndef TRUE#define TRUE 1#endif#ifndef FALSE#define FALSE 0#endif#ifndef FRONT_WINDOW#define FRONT_WINDOW  ((WindowPtr) (-1L))#endiftypedef struct ColorST {long face;long border;long shadow;long mask;}ColorST,*ColorSTPtr;static ColorST ST_color;/* Prototypes */DialogPtr  OpenPreferenceAffichageDlog(void);void     	ClosePreferenceAffichageDlog(DialogPtr dlog);void     	DoPreferenceAffichageDlogDialogUpdate(DialogPtr dlog);void      	DoPreferenceAffichageDlogDialogActivate(DialogPtr dlog, int activ);void 		DoPreferenceMouseDownAffichageDlog(DialogPtr w, EventRecord *evt);void 		DoPreferenceKeyDownAffichageDlog(DialogPtr w, EventRecord *evt);static int 	DoPreferenceAffichageDlogDialogItem(DialogPtr dlog, short itemHit); void 	DoPreferenceKeyDownAffichageDlog(DialogPtr w, EventRecord *evt);static short  DoTeJob(DialogPtr dlog, short item);static 	ValidValue(DialogPtr dlog,short item);static pascal  Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit);static Boolean CheckUserItems(Point where, short *itemHit);static int     AnyBadValues(DialogPtr dlog);static void    CenterWindow(WindowPtr w, short top);static long    strlen(char *);static char   *strcpy(char *dst, char *src);static char   *PascalToC(unsigned char *pstr);static unsigned char   *CToPascal(char *cstr);static void    PutDlgString(DialogPtr dlog, int item, unsigned char *str, int sel);static void    PutDlgWord(DialogPtr dlog, int item, int val, int sel);static void    PutDlgLong(DialogPtr dlog, int item, long val, int sel);static void    PutDlgChkRadio(DialogPtr dlog, int item, int val);static int     GetDlgString(DialogPtr dlog, int item, unsigned char *str);static int     GetDlgWord(DialogPtr dlog, int item, short *val);static int     GetDlgLong(DialogPtr dlog, int item, long *val);static int     GetDlgChkRadio(DialogPtr dlog, int item);static int     TextSelected(DialogPtr dlog);static OSType  CanPaste(int n, ...);static void    FrameDefault(DialogPtr dlog, int item, int frame);static void    GetDlgPanel(DialogPtr dlog, int item, Rect *panel);pascal short C_MakeTheBbdfMenu(long signature,MenuHandle menu,Handle *Le_handle);void MyUpdateDialog(DialogPtr dialog);pascal long My_IncDecValue(DialogPtr Dialog,short itemNumber,short textitemnumber,long minvalue,long maxvalue,long increment);void UpdateByTe(DialogPtr dlog,short item);void gereEventLoop(EventRecord* event,short GotEvent);short TabRot(short next);static 	PrefAff_Set(DialogPtr dlog,short item);static 	PrefAff_Get(DialogPtr dlog,short item);void RedessineSTenCours_BroadCast(void);DialogPtr	gDialogPrefAffichage;pascal void C_DoFileOpen(FSSpecPtr fss);void C_ClearVx (void);pascal void Test_Draw_String(void);int       SelectCoulStBroadcast(ColorSTPtr color);pascal void PutPrefAffInGeneralPref(void);short  Get_FontFssByName(Str255 Fontname, FSSpecPtr  fss);static short  UpdateDisplayFontHandle(long gLastPopUpItemChoice, FontRenderRecordPtr fontRecord);static Point where;static int modifiers;static Handle	bbdfmenu;static short	PopUpnbitem;static short	gNeedtovalid;static short	gLastPopUpItemChoice;static short 	gUpdateFontData=false;void	ForceUpdatePrefAffich(void); void	ForceUpdatePrefAffich(void){GrafPtr	oldport;	GetPort(&oldport);	if (gDialogPrefAffichage){		SetPort(gDialogPrefAffichage);						/* If it's not already */		InvalRect(&gDialogPrefAffichage->portRect);	}	SetPort(oldport);}  /* *	For non-modal dialogs, after a key up/down event in dialog window, w, call this *	to entertain the key. */void DoPreferenceKeyDownAffichageDlog(DialogPtr w, EventRecord *evt)	{		short itemHit;				SetPort(w);						/* If it's not already */				modifiers = evt->modifiers;		/* Stuff our local globals */		where = evt->where;		GlobalToLocal(&where);			 	if (CheckUserItems(where,&itemHit) || DialogSelect(evt,&w,&itemHit)){	 	}} /* *	For non-modal dialogs, after a mouse down event in dialog window, w, call this *	to entertain the click. */ void DoPreferenceMouseDownAffichageDlog(DialogPtr w, EventRecord *evt)	{		short 	a,itemHit;		GrafPtr	oldport;		Point		pt;		ControlHandle ctrl;	 	GetPort(&oldport);			SetPort(w);						/* If it's not already */								modifiers = evt->modifiers;		/* Stuff our local globals */		where = evt->where;		GlobalToLocal(&where);						a=FindDialogItem(w,where);		a++;		if (a>0 && a!=3){ // tout suaf le pop-up menu			if (FindControl (where,w,&ctrl)) { // un control ?				if (TrackControl(ctrl,where,nil) ) // oui on le trac					DoPreferenceAffichageDlogDialogItem(w,a);			 		} else 	 			 			DoPreferenceAffichageDlogDialogItem(w,a);		//non pas control	 	}		 		 	if (a>0 && a==3){ //le pop-up menu	 		DialogSelect(evt, &w,&itemHit);	 		DoPreferenceAffichageDlogDialogItem(w,a);		//non pas control	 	}	 		 	SetPort(oldport);	}/* * Mouse down event: * Check if it's in some user item, and convert to itemHit if appropriate. */static Boolean CheckUserItems(Point where, short *itemHit)	{		return(FALSE);	}/* * Redraw the contents of this dialog due to update event. * If you have not installed UserItem draw routines, you should redraw * them explicitly here; otherwise, UpdtDialog() will call your routines. */void DoPreferenceAffichageDlogDialogUpdate(DialogPtr dlog)	{GrafPtr oldPort;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;short type; Handle hndl; Rect box,rect;RGBColor  c,c1;long	a;		GetPort(&oldPort); SetPort(dlog);		TextFont(geneva);	// pour une version internationnale		TextSize(9);// on récupère les valeurs pour la fenètre		PrefAff_Set(dlog,nil);		BeginUpdate(dlog);// on entoure la fenêtre d'une ppat		pixpat=GetPixPat(129);						if (pixpat!=nil){			rgn=NewRgn();			rgn1=NewRgn();			RectRgn(rgn,&dlog->portRect);			GetDItem(dlog,44,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDItem(dlog,45,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			GetDItem(dlog,46,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);					GetDItem(dlog,47,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);								GetDItem(dlog,48,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);						FillCRgn(rgn,pixpat);			DisposePixPat(pixpat);			DisposeRgn(rgn);			DisposeRgn(rgn1);		}		GetDItem(dlog,44,&type,&hndl,&box);		MakeReliefRectangle1(&box);		GetDItem(dlog,45,&type,&hndl,&box);		MakeReliefRectangle1(&box);				GetDItem(dlog,46,&type,&hndl,&box);		MakeReliefRectangle1(&box);				GetDItem(dlog,47,&type,&hndl,&box);		MakeReliefRectangle1(&box);				GetDItem(dlog,48,&type,&hndl,&box);		MakeReliefRectangle1(&box);// on assombri les dessous des textes de descriptions		GetForeColor(&c); // on backup la couleur ...		c1.red=0x9080;		c1.green=0x9080;		c1.blue=0xc0c0;		RGBForeColor(&c1); 		GetDItem(dlog,49,&type,&hndl,&box);		PaintRect(&box);		GetDItem(dlog,42,&type,&hndl,&box);		PaintRect(&box);		GetDItem(dlog,43,&type,&hndl,&box);		PaintRect(&box);		GetDItem(dlog,50,&type,&hndl,&box);		PaintRect(&box);		GetDItem(dlog,40,&type,&hndl,&box);		PaintRect(&box);		RGBForeColor(&c); // on backup la couleur ...// on rafraichi les controls et les ditl				MyUpdateDialog(dlog);// on dessine les pseudo te				 UpdateByTe(dlog,4);		 UpdateByTe(dlog,7);		 UpdateByTe(dlog,10);		 UpdateByTe(dlog,13);		 UpdateByTe(dlog,16);		 UpdateByTe(dlog,19);		 UpdateByTe(dlog,22);		 UpdateByTe(dlog,26);		 		 // si le check box auto n'est pas activé on dimmed certains item		GetForeColor(&c); // on backup la couleur ...		GetBackColor(&c1); // on backup la couleur ...			 if (	!GetDlgChkRadio(dlog,25) ){				RGBForeColor(&c1); 				PenPat(&QD.gray);				PenMode(patBic);		 		GetDItem(dlog,26,&type,&hndl,&box);		 		box.right+=18;		 		box.bottom+=4;		 		box.top-=3;		 		PaintRect(&box);		 		PenNormal();		 }// on dessine les couleurs		GetDItem(dlog,29,&type,&hndl,&box);		InsetRect(&box,1,1); // couleur de la face		a=((G.RGB_FaceColor&0xFF0000)>>16);		c1.red=a+a<<8;		a=((G.RGB_FaceColor&0xFF00)>>8);		c1.green=a+a<<8;		a=((G.RGB_FaceColor&0xFF));		c1.blue=a+a<<8;		RGBForeColor(&c1); 		PaintRect(&box); // la couleur de la face ...				InsetRect(&box,-2,-2); // le tour noir 		c1.red=0;		c1.green=0;		c1.blue=0;		RGBForeColor(&c1); 		FrameRect(&box);		InsetRect(&box,-3,-3); // le tour noir 		FrameRect(&box);		InsetRect(&box,2,2); // le tour noir 		PenSize(2,2);				a=255-((G.RGB_FaceColor&0xFF000000)>>24);		c1.red=a+a<<8;		c1.green=a+a<<8;		c1.blue=a+a<<8;			RGBForeColor(&c1); 		FrameRect(&box);		PenSize(1,1);	//bordure		GetDItem(dlog,30,&type,&hndl,&box);		InsetRect(&box,1,1); // le tour noir 		a=((G.RGB_BorderColor&0xFF0000)>>16);		c1.red=a+a<<8;		a=((G.RGB_BorderColor&0xFF00)>>8);		c1.green=a+a<<8;		a=((G.RGB_BorderColor&0xFF));		c1.blue=a+a<<8;		RGBForeColor(&c1); 		PaintRect(&box); // la couleur de la face ...				InsetRect(&box,-2,-2); // le tour noir 		c1.red=0;		c1.green=0;		c1.blue=0;		RGBForeColor(&c1); 		FrameRect(&box);		InsetRect(&box,-3,-3); // le tour noir 		FrameRect(&box);		InsetRect(&box,2,2); // le tour noir 		PenSize(2,2);				// le tour en transparence		a=255-((G.RGB_BorderColor&0xFF000000)>>24);		c1.red=a+a<<8;		c1.green=a+a<<8;		c1.blue=a+a<<8;			RGBForeColor(&c1); 		FrameRect(&box);		PenSize(1,1);//cache		GetDItem(dlog,31,&type,&hndl,&box);		InsetRect(&box,1,1); // le tour noir 		a=((G.RGB_OutlineBoxColor&0xFF0000)>>16);		c1.red=a+a<<8;		a=((G.RGB_OutlineBoxColor&0xFF00)>>8);		c1.green=a+a<<8;		a=((G.RGB_OutlineBoxColor&0xFF));		c1.blue=a+a<<8;		RGBForeColor(&c1); 		PaintRect(&box); // la couleur de la face ...		InsetRect(&box,-2,-2); // le tour noir 		c1.red=0;		c1.green=0;		c1.blue=0;		RGBForeColor(&c1); 		FrameRect(&box);		InsetRect(&box,-3,-3); // le tour noir 		FrameRect(&box);		InsetRect(&box,2,2); // le tour noir 		PenSize(2,2);				a=255-((G.RGB_OutlineBoxColor&0xFF000000)>>24);		c1.red=a+a<<8;		c1.green=a+a<<8;		c1.blue=a+a<<8;			RGBForeColor(&c1); 		FrameRect(&box);		PenSize(1,1);		RGBForeColor(&c); // on rend la couleur		//		UpdtDialog(dlog,dlog->visRgn);		EndUpdate(dlog);		SetPort(oldPort);	}/* * Activate event: Activate or deactivate this dialog and any items in it */void DoPreferenceAffichageDlogDialogActivate(DialogPtr dlog, int activ)	{		SetPort(dlog);	}/* * Build this dialog's window on desktop, and install initial item values. * Return the dlog opened, or NIL if error (no resource, no memory). */DialogPtr OpenPreferenceAffichageDlog()	{		short type; Handle hndl; PopupPrivateDataHandle H2; MenuHandle aMenu; Rect box; GrafPtr oldPort;		DialogPtr dlog; unsigned char *p,str[256];  TEHandle te;		GetPort(&oldPort);		//dlog = GetNewDialog(thisDialogID,NIL,FRONT_WINDOW);						GetNewWindowReference((DialogPtr*)&dlog,thisDialogID,(WindowReference)-1,(ActivateHandlerUPP)nil); // palette flottante ....		if (dlog == NIL) { SysBeep(1); return(NIL); }	/* Poor man's error message */		CenterWindow(dlog,0);		SetPort(dlog);		TextFont(geneva);	// pour une version internationnale		TextSize(9);		te=((DialogPeek)dlog)->textH   ;				if (te){			(**te).txSize=9;			(**te).txFont=geneva;			 TEDeactivate (te);  // on désactive le te		}		/* Fill in dialog's values here */		//on initialise le menu police d'affichage			//	aMenu = GetMenu(2011);		GetDItem(dlog,3,&type,&hndl,&box);		PopUpnbitem=0;		H2=(PopupPrivateDataHandle)(**((ControlHandle)hndl)).contrlData; // le menu du control ...		aMenu=(**H2).mHandle;		if (aMenu){			//DetachResource((Handle)aMenu); // a voir			PopUpnbitem=C_MakeTheBbdfMenu('Bbdf',aMenu,&bbdfmenu);		}		gLastPopUpItemChoice=1;		SetControlMaximum((ControlHandle)hndl,PopUpnbitem+1); //on affecte le nb d'item du pop-up menu				//on des hilite le control de vallidation		GetDItem(dlog,CTRL32,&type,&hndl,&box);		HiliteControl((ControlHandle)hndl,255);				gUpdateFontData=false;		// on récupère les valeurs		PrefAff_Set(dlog,nil);		ShowWindow(dlog);		return(dlog);	}/* * Clean up any allocated stuff, and return dialog to primordial mists */void ClosePreferenceAffichageDlog(DialogPtr dlog)	{		if (dlog) {			DisposeDialog(dlog);	/* Call CloseDialog if you provide storage to GetNewDialog */		}	}/* * Deal with user clicking on an item in this dialog, either modal or non-modal. * The local point is in where; modifiers in modifiers. * Returns whether or not the dialog should be closed (keepGoing). */static int DoPreferenceAffichageDlogDialogItem(DialogPtr dlog, short itemHit)	{		short type,okay=FALSE,keepGoing=TRUE,val,flag;		Handle hndl; Rect box; Point pt;short a;		PopupPrivateDataHandle H2;		unsigned char *p,str[256];		FSSpecPtr fss;		long	L;		if (itemHit<1 || itemHit>=LASTITEM)			return(keepGoing);				/* Only legal items, please */		GetDItem(dlog,itemHit,&type,&hndl,&box);		switch(type) {			case ctrlItem+btnCtrl:				break;			case ctrlItem+chkCtrl:				break;			case ctrlItem+radCtrl:				break;			case ctrlItem+resCtrl:				switch(itemHit) {					case CTRL1:  //button couleur 						if (G.VE_BoardID==0x2a2) ConfigureVX_UpStreamKeyer();// on passe en upstream key							flag=false;							ST_color.face=G.RGB_FaceColor;							ST_color.border=G.RGB_BorderColor;							ST_color.shadow=G.RGB_ShadowColor;  //non utilisé							ST_color.mask=G.RGB_OutlineBoxColor;																		if (SelectCoulStBroadcast(&ST_color)){															//on regarde s'il faut recalculer la police									if( 										 (G.RGB_FaceColor != ST_color.face) ||										 (G.RGB_BorderColor != ST_color.border)										) flag=true;																G.RGB_FaceColor=ST_color.face;									G.RGB_BorderColor=ST_color.border;									G.RGB_ShadowColor=ST_color.shadow;//non utilisé									G.RGB_OutlineBoxColor=ST_color.mask;									// on créer la nouvelle fast font																						if (flag) Create_FastFont(&G.Display_Font,32,nil);							}						/*on force un rafraichissement de la carte							if( G.Base_Adresse ){								G.DrawState=0x8000;								do{}while(G.DrawState&0x8000); //si il y a une fondu								G.ScreenRenderedRect.left=0;								G.ScreenRenderedRect.right=768;								G.ScreenRenderedRect.top=0;								G.ScreenRenderedRect.bottom=576;								C_ClearVx(); // on efface le buffer d'affichage								PutPrefAffInGeneralPref();								//on redessine les sous-titre dans la carte et dans le offscreen								RedessineSTenCours_BroadCast();															}*/						if (G.VE_BoardID==0x2a2)							if (G.VE_Mode) ConfigureVX_DownStreamKeyer();		// on rend le mode préalable						 	ForceUpdatePrefAffich();												break;					case CTRL2: //button ouvrir 							C_DoFileOpen(nil);					break;					case CTRL3: // menu police d'affichage																a=GetControlValue((ControlHandle)hndl); //note:  l'item 1 ne sert pas						if (a!=gLastPopUpItemChoice)  // pas la même valeur qu'avant						if (a>1){							// on demande à l'utilisateur , s'il souhaite réellement ouvri la police ...							// on recupère le handle du menu ...							H2=(PopupPrivateDataHandle)(**((ControlHandle)hndl)).contrlData; // le menu du control ...							GetMenuItemText((**H2).mHandle, a, &str);							if (GiveUser_Choice((Str255*)&str )==1){								HLock(bbdfmenu);								L=(long)*bbdfmenu;								L+=(a-2)*sizeof(FSSpec);								fss=(FSSpecPtr)L;								C_DoFileOpen((FSSpecPtr)fss );								HUnlock(bbdfmenu);							}														// on recupère les valeurs							//							ForceUpdatePrefAffich();						}												break;					case CTRL25:							a= GetDlgChkRadio(dlog,itemHit);							if (a) PutDlgChkRadio(dlog,itemHit,0);							else PutDlgChkRadio(dlog,itemHit,1);							PrefAff_Get(dlog,itemHit);							// il faut forcer l'update des items 26,27,28							GetDItem(dlog,26,&type,&hndl,&box);							// on définie la zone à la main		 					box.right+=18;		 					box.bottom+=4;		 					box.top-=3;							SetPort(dlog);							InvalRect(&box);						break;					case CTRL32:						// Bouton Redessiner ST							gNeedtovalid=false;							RedessineSTenCours_BroadCast();													// on met à jour les valeurs kern,largeur espace,internligne dans la font ...						if (gUpdateFontData){							UpdateDisplayFontHandle( gLastPopUpItemChoice,&G.Display_Font);							gUpdateFontData=0;						}												break;					}				break;			case statText:				switch(itemHit) {					case STXT33_Kerning:						break;					case STXT34_Larg:						break;					case STXT35_Interligne:						break;					case STXT36_X:						break;					case STXT37_Ligne:						break;					case STXT38_Largeur:						break;					case STXT39_Hauteur:						break;					case STXT40_Safe:						break;					case STXT41_Face:						break;					case STXT42_Coordonn:		/* NOT Enabled */						break;					case STXT43_R:		/* NOT Enabled */						break;					case STXT49_R:		/* NOT Enabled */						break;					case STXT50_Couleur:		/* NOT Enabled */						break;					}				break;			case editText:				switch(itemHit) {					case EDIT4:					case EDIT7:					case EDIT10:					case EDIT13:					case EDIT16:					case EDIT19:					case EDIT22:					case EDIT26:										flag=0;										if (itemHit==26) {						flag=GetDlgChkRadio(dlog,25); //seulement si kern check actif					} else flag=1;					 						 if (flag)					 	do{					 			itemHit= DoTeJob(dlog, itemHit); // pour gérer les te dans un flot non modal dialog					 			ValidValue(dlog,itemHit);					 			PrefAff_Get(dlog,itemHit);								gNeedtovalid=true;								if (itemHit<13) gUpdateFontData=true;  // modification de la police...														 }while (itemHit); // pour gérer le tab entre les items ...						break;					}				break;			case iconItem:				switch(itemHit) {					case ICON5:						a=My_IncDecValue(dlog,itemHit,4,-12,12,1); //kerning						ValidValue(dlog,4);						PrefAff_Get(dlog,4);						gUpdateFontData=true;						break;					case ICON6:						a=My_IncDecValue(dlog,itemHit,4,-12,12,-1);						ValidValue(dlog,4);						PrefAff_Get(dlog,4);						gUpdateFontData=true;						break;					case ICON8:						a=My_IncDecValue(dlog,itemHit,7,0,50,1);//espace						ValidValue(dlog,7);						PrefAff_Get(dlog,7);						gUpdateFontData=true;						break;					case ICON9:						a=My_IncDecValue(dlog,itemHit,7,0,50,-1);						ValidValue(dlog,7);						PrefAff_Get(dlog,7);						gUpdateFontData=true;						break;					case ICON11:						a=My_IncDecValue(dlog,itemHit,10,-12,50,1);//internligne						ValidValue(dlog,10);						PrefAff_Get(dlog,10);						gUpdateFontData=true;						break;					case ICON12:						a=My_IncDecValue(dlog,itemHit,10,-12,50,-1);						ValidValue(dlog,10);						PrefAff_Get(dlog,10);						gUpdateFontData=true;						break;					case ICON14:						a=My_IncDecValue(dlog,itemHit,13,-768/2,768/2,1);						ValidValue(dlog,13);						PrefAff_Get(dlog,13);						break;					case ICON15:						a=My_IncDecValue(dlog,itemHit,13,-768/2,768/2,-1);											ValidValue(dlog,13);						PrefAff_Get(dlog,13);						break;					case ICON17:						a=My_IncDecValue(dlog,itemHit,16,30,570,1);											ValidValue(dlog,16);						PrefAff_Get(dlog,16);						break;					case ICON18:						a=My_IncDecValue(dlog,itemHit,16,30,570,-1);											ValidValue(dlog,16);						PrefAff_Get(dlog,16);						break;					case ICON20:						a=My_IncDecValue(dlog,itemHit,19,-5,+20,1);											ValidValue(dlog,19);						PrefAff_Get(dlog,19);						break;					case ICON21:						a=My_IncDecValue(dlog,itemHit,19,-5,+20,-1);											ValidValue(dlog,19);						PrefAff_Get(dlog,19);						break;					case ICON23:						a=My_IncDecValue(dlog,itemHit,22,-5,+20,1);											ValidValue(dlog,22);						PrefAff_Get(dlog,22);						break;					case ICON24:						a=My_IncDecValue(dlog,itemHit,22,-5,+20,-1);											ValidValue(dlog,22);						PrefAff_Get(dlog,22);						break;					case ICON27:						if ( GetDlgChkRadio(dlog,25) ){ //seulement si kern check actif							a=My_IncDecValue(dlog,itemHit,26,20,95,1);												ValidValue(dlog,26);							PrefAff_Get(dlog,26);						}						break;					case ICON28:						if ( GetDlgChkRadio(dlog,25) ){//seulement si kern check actif							a=My_IncDecValue(dlog,itemHit,26,20,95,-1);												ValidValue(dlog,26);							PrefAff_Get(dlog,26);						}						break;					}					gNeedtovalid=true;                                                                                      										break;			case picItem:				break;			case userItem:				switch(itemHit) {					case USER29:						break;					case USER30:						break;					case USER31:						break;					case USER44:						break;					case USER45:						break;					case USER46:						break;					case USER47:						break;					case USER48:						break;					}				break;			}		// on affecte le bouton valider		GetDItem(dlog,CTRL32,&type,&hndl,&box);				if (gNeedtovalid) 	HiliteControl((ControlHandle)hndl,0);		else  			HiliteControl((ControlHandle)hndl,255);				if (okay) keepGoing = AnyBadValues(dlog);		return(keepGoing);	}/* * Pull values out of dialog items and deliver TRUE if any of them are * illegal or inconsistent; otherwise deliver FALSE.  If any values are bad, * you should inform your user about the problem here before delivering TRUE. * If any items are missing values, this is the place to assign any defaults. */static int AnyBadValues(DialogPtr dlog)	{		unsigned char str[256]; short val,len;		if (GetDlgString(dlog,EDIT4,str)) {			/* Got a string (can also call GetDlgWord(), etc. here) */			}		else {			/* Field was empty */			}		if (GetDlgString(dlog,EDIT7,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT10,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT13,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT16,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT19,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT22,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT26,str)) {			}		else {			}		return(FALSE);	}/*••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*//* *  The following are various utility routines for general dialog management. *  Typically, you'll want to keep them in a library that is available to all *  your dialog modules; however, they are included here (and declared static) *  as a private library so that you can quickly compile this file for testing. */#define _PrivateLibraries_#ifdef  _PrivateLibraries_/* *	Center a given window, w, horizontally in the main screen, top pixels from *	the top, or centered vertically if top is 0.  The window should be invisible. */static void CenterWindow(WindowPtr w, short top)	{		Rect scr; Point p;		short rsize,size,margin,xoff,yoff;		scr = qd.screenBits.bounds;		SetPort(w);		p.h = w->portRect.left; p.v = w->portRect.top;		LocalToGlobal(&p);		size = scr.right - scr.left;		rsize = w->portRect.right - w->portRect.left;		margin = size - rsize;		if (margin > 0) {			margin >>= 1;			p.h = scr.left + margin;			}		size = scr.bottom - scr.top;		rsize = w->portRect.bottom - w->portRect.top;		margin = size - rsize;		if (margin > 0) {			margin >>= 1;			p.v = scr.top + margin;			}		MoveWindow(w,p.h,top?top:p.v,FALSE);	}/* Local C string length routine */static long strlen(register char *str)	{		register char *p;		p = str;		while (*p++) ;		return((long)(--p - str));	}/* Convert in place a Pascal string to C string, and deliver its address */static char *PascalToC(unsigned char *str)	{		register unsigned char *p,*q,*end;		end = str + *str;		q = (p=str) + 1;		while (p < end) *p++ = *q++;		*p = '\0';		return((char *)str);	}/* *	Convert in place a C string to Pascal string, and deliver its address. *	The C string should not be greater than 255 chars in length, or the *	resulting Pascal string will be truncated to 255 chars. */static unsigned char *CToPascal(char *str)	{		register char *p,*q;		register long len;		len = strlen(str);		if (len > 255) len = 255;		p = str + len;		q = p-1;		while (p != str) *p-- = *q--;		*str = len;		return((unsigned char *)str);	}/* Dialog Item Stuffers *//* *	Install a given Pascal string, str, into the given static or edit text item *	in the dialog, dlog.  If the item is an edit text item, leave the installed *	text selected or not according to the value of sel (TRUE or FALSE). */static void PutDlgString(DialogPtr dlog, int item, unsigned char *str, int sel)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		SetIText(hndl,str);		if (type == editText)			SelIText(dlog,item,sel?0:32767,32767);		InvalRect(&box);	}/* *	Install a given decimal long value into the static or edit text item of the *	given dialog, dlog.  If the item is an edit text item, leave the installed *	text for the number selected or not according to sel (TRUE or FALSE). */static void PutDlgLong(DialogPtr dlog, int item, long val, int sel)	{		unsigned char str[32];		NumToString(val,str);		PutDlgString(dlog,item,str,sel);	}/* *	Same as above, only for an int (word) decimal number. */static void PutDlgWord(DialogPtr dlog, int item, int val, int sel)	{		PutDlgLong(dlog,item,(long)val,sel);	}/* *	Set the given check box or radio button item of the given dialog, dlog, to *	on or off, according to val. */static void PutDlgChkRadio(DialogPtr dlog, int item, int val)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		SetCtlValue((ControlHandle)hndl,val!=0);	}/* *	Deliver the value of the checkbox or radio button item of the given dialog. */static int GetDlgChkRadio(DialogPtr dlog, int item)	{		short type; Handle hndl; Rect box;				GetDItem(dlog,item,&type,&hndl,&box);		return(GetCtlValue((ControlHandle)hndl) != 0);	}/* Dialog Item Unstuffers *//* *	Retrieve the value of an edit text item in a given dialog, placing the *	resulting Pascal string in the buffer, str, which is assumed large enough *	to hold the text (256 bytes max).  If item is the number of a static text *	item, the empty string is delivered.  Delivers TRUE or FALSE according to *	whether or not the text so delivered was empty.   */static int GetDlgString(DialogPtr dlog, int item, unsigned char *str)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		if (type == editText) GetIText(hndl,str);		 else                 *str = 0;		return(*str != 0);	}/* *	Retrieve the value of an edit text item in a given dialog, converting the *	Pascal string to a long and setting *val to it.  Delivers TRUE or FALSE *	according to whether or not the text so delivered was empty.  If FALSE, *	*val is set to 0; if TRUE, *val is set to whatever StringToNum() says the *	value is, even if the text contains non-numerical characters. */static int GetDlgLong(DialogPtr dlog, int item, long *val)	{		int ans; unsigned char str[256];		*val = 0;		ans = GetDlgString(dlog,item,str);		if (ans)			StringToNum(str,val);		return(ans);		}/* Same as above, only delivers the value of a word */static int GetDlgWord(DialogPtr dlog, int item, short *val)	{		int ans; long num;		*val = 0;		ans = GetDlgLong(dlog,item,&num);		if (ans)			*val = num;		return(ans);	}/* *	Deliver the number of the current editText item in given dialog if any text *	is selected in it, or 0 if none selected. */static int TextSelected(DialogPtr dlog)	{		register TEHandle textH; int item = 0;				textH = ((DialogPeek)dlog)->textH;		if (*textH)			if ( (*textH)->selStart != (*textH)->selEnd )				item = ((DialogPeek)dlog)->editField+1;		return(item);	}/* *  If any of the variable argument scrap types are available for pasting from *  the scrap, deliver the first one.  Otherwise, deliver 0.  For example, *	 *      if (whichType = CanPaste(3,'TEXT','PICT','STUF')) ... * *  There can be any number of types in the list, as long as the preceding count, n, *  is correct. */static  OSType CanPaste(int n, ...)	{		register OSType nextType,ans = 0L;		long err,offset;		va_list nextArg;				va_start(nextArg,n);		nextType = va_arg(nextArg, OSType);				while (n-- > 0) {			err = GetScrap(NIL, nextType, &offset);			if (err >= -1) {				ans = nextType;				break;				}			nextType = va_arg(nextArg, OSType);			}				va_end(nextArg);		return(ans);	}/* *	Frame or unframe a default dialog item (presumed a button) in given dialog. *	Note that you don't need to use an extra user item to do this unless you *	are doing some sort of non-standard default highlighting (not recommended). */static void FrameDefault(DialogPtr dlog, int item, int frame)	{		short type; Handle hndl; Rect box;		GrafPtr oldPort; PenState oldPen;				GetPort(&oldPort); SetPort(dlog);		GetPenState(&oldPen);				GetDItem(dlog,item,&type,&hndl,&box);		InsetRect(&box,-4,-4);				PenSize(3,3);		if (frame) PenPat(&qd.black);		/* Paint frame */		 else      PenPat(&qd.white);		/* Erase frame */		FrameRoundRect(&box,16,16);				SetPenState(&oldPen);		SetPort(oldPort);	}/* *	Get rectangle, *panel, for a given item (usually a user or picture item) *	and then hide the item so that it doesn't interfere with mouse clicking. *	This lets you stop worrying about the item order any user or pict items that *	obscure other items in the item list, which can affect how the DialogMgr *	returns itemHits. */static void GetDlgPanel(DialogPtr dlog, int item, Rect *panel)	{		short type; Handle hndl;				GetDItem(dlog,item,&type,&hndl,panel);		HideDItem(dlog,item);	}#endif// cette routine est appelée quand on à cliquer dans un TE// elle ne rend la main que quand on a cliquer à l'extérieur du te// ou bien que l'on a cliqué sur enter ou return static short  DoTeJob(DialogPtr dlog, short item){// on commence par indiquer qu'il se passe quelque chose sur ce TE.long		result;Str255		string;Handle		the_Handle;short		the_itemtype,finish,itemHit,a,GotEvent,tab;Rect			Rectangle,r1;RGBColor		c,c1;EventRecord	theEvent;DialogPtr		theDialog;Point			Mouse;TEHandle 		te;WindowPtr	w;	GetForeColor(&c);	GetDItem(dlog,item,&the_itemtype,&the_Handle,&Rectangle);	GetDlgString(dlog, item,&string);	r1=Rectangle;		EraseRect(&r1);	InsetRect(&r1,-2,-2);	c1.blue=0xcccc;	c1.green=0;	c1.red=0;	PenSize(2,2);	RGBForeColor(&c1);	FrameRect(&r1);	PenSize(1,1);	RGBForeColor(&c);// boucle de traitement	finish=false;		GetDItem(dlog,item,&the_itemtype,&the_Handle,&Rectangle);	Rectangle.top+=1;	// pour que le te soit bien positionné	te=TENew(&Rectangle,& Rectangle);	if (!te) return 0;		TESetAlignment(teCenter, te);	TESetText(&string[1], string[0], te);	TEUpdate (&Rectangle,te);  // on update le te	TEActivate (te);  // on active le tedo {	 GotEvent=WaitNextEvent(-1,&theEvent, 0, nil);			Mouse=theEvent.where;		GlobalToLocal(&Mouse);		 		TEIdle(te); // on fait le idle pour le dialog		//return ou enter		if (theEvent.what==keyDown){		 // key pressed			if (				(theEvent.message&0xff)==0x0d	||				(theEvent.message&0xff)==0x03	||				(theEvent.message&0xff)=='\t'  			) finish=true;			else TEKey(theEvent.message&0xff, te);			// il faut ensuite modifier l'event pour que cet event ne soit pas traité			theEvent.message=0;		}				a= FindDialogItem(dlog, Mouse)+1;				// clicl à l'exterieur de la zone ...		if (theEvent.what==mouseDown) {		// key pressed			if (a!=item) finish=true;			else TEClick(Mouse,false, te);		}						// on regarde s'il faut passer l'event au reste du programme		FindWindow(theEvent.where,&w);		if (w==dlog) {// pour nous ?			if (theEvent.what==updateEvt){						BeginUpdate(dlog);						TEUpdate (&Rectangle,te);  // on update le te						PenSize(2,2);						RGBForeColor(&c1);						FrameRect(&r1);						PenSize(1,1);						RGBForeColor(&c);				   	EndUpdate(dlog);				   }			gereEventLoop(&theEvent,0); // non juste les idles		} else 			gereEventLoop(&theEvent,GotEvent); // non alors je ne sais pas		SetPort(dlog); // il vaut mieux préciser }while(finish==false);		if (te) TEDeactivate (te);  // on désactive le te// on rend le tour du te	GetDItem(dlog,item,&the_itemtype,&the_Handle,&Rectangle);	InsetRect(&Rectangle,-3,-3);	EraseRect(&Rectangle);	a=(**te).teLength;	if (a>255) a=255;	string[0]=a;		// on recopie la chaine du te	BlockMove((char*)*((**te).hText),(char*)&string[1],a);	SetIText(the_Handle,&string);	if (te) TEDispose(te);  // on désactive le te//on redessine le te		UpdateByTe(dlog,item);// on transfert la valeur			// si on a reçu un caractère tab on change de te// si on a fait un tab dans ce cas 	if ( (theEvent.message&0xff)=='\t' ){		tab=TabRot(item);	} else tab=0;				RGBForeColor(&c);		return tab;}short TabRot(short next){	if (next==4) return 7;	if (next==7) return 10;	if (next==10) return 13;	if (next==13) return 16;	if (next==16) return 19;	if (next==19) return 22;	if (next==22) return 26;	return 4;}// cette fonction récupère les valeurs depuis la mémoirestatic 	PrefAff_Set(DialogPtr dlog,short item){short type,start,end;Handle hndl; Rect box; Point pt;short i;PopupPrivateDataHandle H2;unsigned char str[256];FSSpecPtr fss;			start=1 ;	end= 26;	// si on nous demande un item en particulier...		if (item>=1 && item<=26){		start=item;		end=item;	}		for (i=start;i<=end;i++){	GetDItem(dlog,i,&type,&hndl,&box);	switch (i){		case 3: // pop-menu			//voir le nom de la police en cours			// ajouter un element au menu "---"		break;			case 4: // kerning			PutDlgWord(dlog,i,G.Display_Font.NormalKerning, 0);		break;				case 7: // largeur espace			PutDlgWord(dlog,i,G.Display_Font.spaceWidth, 0);		break;						case 10: // interligne			PutDlgWord(dlog,i,G.Display_interligne, 0);		break;						case 13: // xpos			PutDlgWord(dlog,i,G.X_Offset, 0);		break;				case 16: // base line			 PutDlgWord(dlog,i,G.Y_Offset, 0);		break;					case 19: // largeur cache			 PutDlgWord(dlog,i,G.Boxing_Size, 0);		break;					case 22: // hauteur cache			 PutDlgWord(dlog,i,G.Boxing_SizeV, 0);		break;					case 25: // G.Preference_KernCheck;			PutDlgChkRadio(dlog,i,G.Preference_KernCheck);		break;				case 26: // safe area			 PutDlgWord(dlog,i,G.safearea, 0);		break;			} // switch	} // for 	return 0;}// cette fonction transfert les valeurs vers la mémoirestatic 	PrefAff_Get(DialogPtr dlog,short item){short type,start,end,cont;Handle hndl; Rect box; Point pt;short i,j;PopupPrivateDataHandle H2;unsigned char str[256];FSSpecPtr fss;long	L;	start=1 ;	end= 26;	// si on nous demande un item en particulier...		if (item>=1 && item<=26){		start=item;		end=item;	}		for (i=start;i<=end;i++){	GetDItem(dlog,i,&type,&hndl,&box);	switch (i){		case 3: // pop-menu			//voir le nom de la police en cours					// problèmatique restante comment gérer s'il l'on à ouvert la typo par le bouton ouvrir ...			/*			if (G.Display_Font.Render_handle  && G.Display_Font.Render_handle ){ // typo chargée ??					// on détermine la police en cours					H2=(PopupPrivateDataHandle)(**((ControlHandle)hndl)).contrlData; // le menu du control ...										j=1;					do{						j++;						GetItem((**H2).mHandle,j+1,&str);						cont=EqualString(&str,&(G.Display_Font.FontName),false,false);					}while (j<=PopUpnbitem && !cont);					// on a trouvé la police, on affecte le n°					if (cont)  SetControlValue((ControlHandle)hndl,j);								} else {				SetControlValue((ControlHandle)hndl, 1);				} */		break;			case 4: // kerning			GetDlgWord(dlog,i,&G.Display_Font.NormalKerning);		break;				case 7: // largeur espace			GetDlgWord(dlog,i,&G.Display_Font.spaceWidth);		break;						case 10: // interligne			GetDlgWord(dlog,i,&G.Display_interligne);		break;						case 13: // xpos			GetDlgWord(dlog,i,&G.X_Offset);		break;				case 16: // base line			 GetDlgWord(dlog,i,&G.Y_Offset);		break;					case 19: // largeur cache			 GetDlgWord(dlog,i,&G.Boxing_Size);		break;					case 22: // hauteur cache			 GetDlgWord(dlog,i,&G.Boxing_SizeV);		break;					case 25: // G.Preference_KernCheck;			G.Preference_KernCheck=GetDlgChkRadio(dlog,i);		break;				case 26: // safe area			 GetDlgWord(dlog,i,&G.safearea);		break;			} // switch	} // for 		return 0;}// cette fonction transfert les valeurs vers la mémoirestatic 	ValidValue(DialogPtr dlog,short item){short type,start,end,cont;Handle hndl; Rect box; Point pt;short i;PopupPrivateDataHandle H2;unsigned char str[256];FSSpecPtr fss;long	L;short value;	start=1 ;	end= 26;	// si on nous demande un item en particulier...		if (item>=1 && item<=26){		start=item;		end=item;	}		for (i=start;i<=end;i++){	GetDItem(dlog,i,&type,&hndl,&box);	switch (i){		case 3: // pop-menu		break;			case 4: // kerning			GetDlgWord(dlog,i,&value);			if (value<(-10) ) {					PutDlgWord(dlog,i,-12, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 10 ) {					PutDlgWord(dlog,i,12, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}							break;				case 7: // largeur espace			GetDlgWord(dlog,i,&value);			if (value<(0) ) {					PutDlgWord(dlog,i,0, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 50) {					PutDlgWord(dlog,i,50, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}					break;						case 10: // interligne			GetDlgWord(dlog,i,&value);			if (value<(-5) ) {					PutDlgWord(dlog,i,-12, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 50) {					PutDlgWord(dlog,i,50, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			break;						case 13: // xpos			GetDlgWord(dlog,i,&value);			if (value<(-768/2) ) {					PutDlgWord(dlog,i,-768/2, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 768/2) {					PutDlgWord(dlog,i,768/2, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}						break;				case 16: // base line			GetDlgWord(dlog,i,&value);			if (value<(30) ) {					PutDlgWord(dlog,i,30, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 570) {					PutDlgWord(dlog,i,570, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}					break;					case 19: // largeur cache			GetDlgWord(dlog,i,&value);			if (value<(-5) ) {					PutDlgWord(dlog,i,-5, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 20){					PutDlgWord(dlog,i,20, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}						break;					case 22: // hauteur cache			GetDlgWord(dlog,i,&value);			if (value<(-5) ) {					PutDlgWord(dlog,i,-5, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value> 20){					PutDlgWord(dlog,i,20, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}						break;					case 25: // G.Preference_KernCheck;		break;				case 26: // safe area			GetDlgWord(dlog,i,&value);			if (value<(30) ) {					PutDlgWord(dlog,i,30, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			if (value>80){					PutDlgWord(dlog,i,80, 0);					UpdateByTe(dlog,i);					SysBeep(1);				}			break;			} // switch	} // for 	return 0;}void   	PrefAffichage_AjouteAuMenu( FontRenderRecordPtr  Display_Font,FSSpecPtr  fss);// cette routine ajoute et selectionne la police chargé au menu courant// note nous faisons deja un test pour voir si le nom de cette police n'est pas déja dans la listevoid   	PrefAffichage_AjouteAuMenu( FontRenderRecordPtr  Display_Font,FSSpecPtr  fss){short i,exist=0;FSSpecPtr  fss1;Handle 	hndl; Rect 		box;short	type;long L;PopupPrivateDataHandle H2; MenuHandle menu;		GetDItem(gDialogPrefAffichage,CTRL3,&type,&hndl,&box);		// on commence par tester si le fichier est dans la liste en mémoire		i=1;		do{				L=(long)*bbdfmenu;				L+=(i-1)*sizeof(FSSpec);				fss1=(FSSpecPtr)L;								// maintenant on compare les fss				// note il ne peux y en avoir qu'un ....								if (  fss1->vRefNum == fss->vRefNum  )					if (fss1->parID ==	fss->parID )					 if (CompareString(fss1->name,fss->name,nil)==0      ) 	exist=i;				i++;					} while ( (i<=PopUpnbitem) && (!exist) );	// nom nouveau ?	if (exist) {			/*(**(ControlHandle)hndl).contrlValue=exist+1;			Draw1Control((ControlHandle)hndl);*/			SetControlValue((ControlHandle)hndl,exist+1);			gLastPopUpItemChoice=exist+1;		} else {	//nouveau, donc on l'ajoute à la liste		HUnlock(bbdfmenu);		SetHandleSize(bbdfmenu,(PopUpnbitem+2)*sizeof(FSSpec)); //on taille le handle		if (!MemError() ){			PopUpnbitem++;			// on copie le handle			HLock(bbdfmenu);			L=(long)*bbdfmenu;			L+=(PopUpnbitem-1)*sizeof(FSSpec);			fss1=(FSSpecPtr)L;			BlockMove((Ptr)fss,(Ptr)fss1,sizeof(FSSpec)); /* on recopie le fss*/				//on ajoute un élément au menu			H2=(PopupPrivateDataHandle)(**((ControlHandle)hndl)).contrlData; // le menu du control ...			menu=(**H2).mHandle;			InsertMenuItem(menu,fss->name,PopUpnbitem+2);			HUnlock(bbdfmenu);			gLastPopUpItemChoice=PopUpnbitem+1;			SetControlMaximum((ControlHandle)hndl,PopUpnbitem+1); //on affecte le nb d'item du pop-up menu			SetControlValue((ControlHandle)hndl,PopUpnbitem+1);		/*	(**(ControlHandle)hndl).contrlValue=PopUpnbitem+1;			Draw1Control((ControlHandle)hndl);*/		}	}}// cette fonction permet de déterminer si une police est dans la listeshort  Get_FontFssByName(Str255 Fontname, FSSpecPtr  fss){short		i,exist;FSSpecPtr		fss1;long			L;GrafPtr		oldport;	Handle 		hndl; Rect 			box;short		type;			GetPort(&oldport);		SetPort(gDialogPrefAffichage);				i=1;		exist=0;		// on teste si le fichier est dans la liste en mémoire		do{				L=(long)*bbdfmenu;				L+=(i-1)*sizeof(FSSpec);				fss1=(FSSpecPtr)L;				// maintenant on compare les fss				// note il ne peux y en avoir qu'un ....				 if (CompareString(fss1->name,Fontname,nil)==0 ){				 	 	exist=i;				 	 	if (fss) BlockMove(fss1,fss,sizeof(FSSpec)); // on copie le fss				 	 }				i++;					} while ( (i<=PopUpnbitem) && (!exist) );				if (exist) { // oui on actualise le menu			GetDItem(gDialogPrefAffichage,CTRL3,&type,&hndl,&box);			SetControlValue((ControlHandle)hndl,exist+1);			gLastPopUpItemChoice=exist+1;		}						SetPort(oldport);	return exist;}// cette routine permet de modifier le handle de la police en coursstatic short  UpdateDisplayFontHandle(long gLastPopUpItemChoice, FontRenderRecordPtr fontRecord){FSSpecPtr	    fss;OSErr		err;short		MainFRefNum,theVolume;ParamBlockRec	pb;long			count,L;FontRenderRecord	fr;// on récupère le fss		L=(long)*bbdfmenu;		L+=(gLastPopUpItemChoice-2)*sizeof(FSSpec);		fss=(FSSpecPtr)L;// on ouvre le fichier		err=FSpOpenDF(fss,fsRdWrPerm,&MainFRefNum);			if (err) { 				SysBeep(1); 				return -1; 				}						GetVRefNum(MainFRefNum,&theVolume);// on lit le header		count=sizeof(FontRenderRecord);		err=FSRead(MainFRefNum,&count,(char*)&fr);//  on modifie le font record		fr.ExtraInterligne=G.Display_interligne;		fr.NormalKerning=G.Display_Font.NormalKerning;		fr.spaceWidth=G.Display_Font.spaceWidth;				// note: si cette police possède une table de kerning		// la valeur doit être au moins égale à 0x159				if (fr.VersNumber< 159)				fr.VersNumber=159; // pour indiquer la version de la typo				count=sizeof(FontRenderRecord);				//on ecrit le header		err = SetFPos(MainFRefNum, fsFromStart, 0);		err = FSWrite(MainFRefNum,&count,(char*)&fr);		// on flush le fichier		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioResult=0;		pb.ioParam.ioRefNum=MainFRefNum;		PBFlushFile((ParmBlkPtr)&pb,false);		// on ferme le fichier		FSClose(MainFRefNum);// on flush le volume		pb.ioParam.ioVRefNum=theVolume;		pb.ioParam.ioCompletion=(IOCompletionUPP)nil;		pb.ioParam.ioNamePtr=(StringPtr)nil;		pb.ioParam.ioResult=0;		PBFlushVol((ParmBlkPtr)&pb,false);		return 0;}