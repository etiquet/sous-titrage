	PRINT	PUSH,OFF			 	INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a';	INCLUDE	'types.a' 	INCLUDE	'QuickEqu.a' 	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'	 	INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'PrEqu.a'	PRINT	POP					IMPORT	QD:MyQDGlobals		IMPORT	G:AppGlobals		; cette routine permet de tester la validitée des import de reférence entre routine MPW_asm et Metrowerk_C* ================================================* PROCEDURE A_Draw_A_Char(); * ================================================*** Cette routine dessine un caractère dans la ram de la VX**	entrée: 	FontRenderPTr 	(long)*				Char n°		 	(word)	*				style			(word)*				Facecolor		(long)*				bordercolor		(long)*				Shadowcolor		(long)*				Bgdcolor		(long)*				flags			(word)	; blend / opaque bgd; si blend regarde la couleur*										  en dessous du caractère *				x pos*				y pos*				basescreenptr*				Row_Bytes				ds.l	1		; rowbyte**	sortie:		Resultat		(word)	; 0= ok, ≠0 erreur**A_Draw_A_Char	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordLargeurChar		ds.w	1ParamBegin	EQU	*			; start parameters after this pointFontRenderPTr	ds.l	1Char			ds.w	1style			ds.w	1Faceclr			ds.l	1borderclr		ds.l	1Shadowclr		ds.l	1Bgdlr			ds.l	1flags			ds.w	1Xpos			ds.w	1Ypos			ds.w	1DisplayRamPtr			ds.l	1		; vidéo ramRow_Bytes				ds.l	1		; rowbyteParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkcharPtr					ds.l	1			; ptr du charBasePtr					ds.l	1			; base PtrplaneNumber				ds.l	1			; nombre de plan pour le charRectangleChar			ds		rect		; rectangle entourant le caractèreMinLeft					ds.w	1		; miminum leftMinTop					ds.w	1		; miminum topsparePtr				ds.l	1		; 4 ème plan du char (futur...)shadowPtr				ds.l	1borderPtr				ds.l	1FacePtr					ds.l	1DisplayRamRectangle		ds		rect		; ?spareRectangle			ds		rectshadowRectangle			ds		rectborderRectangle			ds		rectFaceRectangle			ds		rectwidth					ds.w	1		; largeur de la VXheight					ds.w	1		; hauteur de la VXX					ds.w		1Y					ds.w		1LocalSize	EQU 	*			; size of all the local variables			ENDR			machine MC68030			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord ;HSLColor		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,draw_Shuttle_Frame			movem.l d1-d7/a1-a4,-(sp)	; sauvegarde des registres			move.w	#758,width(a6)			; largeur écran			move.w	#576,height(a6)			; hauteur écran; -----------------  on recupère les infos du caractère -------------------------------								move.l	FontRenderPTr(a6),a0				move.w	style(a6),d1						;				move.w	Char(a6),d0				import	GiveDisplayFont_CharInfo				jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan				tst.w	d0				bne  	Exit			; il y a une erreur; a0 = ptr du char info; a1 = abs ptr du font display bitmap; d1 = nombre de plan pour le caractère				move.l	a0,charPtr(a6)				move.l	a1,BasePtr(a6)				move.w	d1,planeNumber(a6); on regarde si c'est un caractère affichable				cmp.w	#$ca,Char(a6)				bne.s	@1@1								move.w	right+CH_Rect(a0),d0				sub.w	left+CH_Rect(a0),d0				move.w	d0,LargeurChar(a6)								bmi		Exit						; pas un caractère affichable; calcul position verticale dans la VX 					move.w	Ypos(a6),d0  				add.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0					; rapport de la base line								mulu	2+Row_Bytes(a6),d0			; row_byte sur .l donc pd faible => 2+				add.l	DisplayRamPtr(a6),d0		; base VX				move.l	d0,a4				; détermination des pointeurs				move.l	charPtr(a6),a3								move.l	CharHeaderSize+pi_PlaneBase(a3),a0				adda.l	BasePtr(a6),a0		; ptr de la face												move.l	PlaneInfoSize+CharHeaderSize+pi_PlaneBase(a3),a1						adda.l	BasePtr(a6),a1				; ptr de la bordure				suba.l	a2,a2			; ptr de l'ombre ShadowPtr(a6)							clr.w	d2							; compteur vertical* ------- vertical loopvertical_loop				clr.w	d3							; compteur horizontal* ------- horizontal loophorizontal_loop; --------- détermination de la couleur du fond 						cmp.w	#0,Flags(a6)					; black bgd				beq.s	BlackBgd										cmp.w	#1,Flags(a6)					; box color				beq.s	BoxBgd;				cmp.w	#2,Flags(a6)					; blend bgd;				beq.s	BlendBgd;  lecture pixels				BlendBgd				move.w		Xpos(a6),d1				add.w		d3,d1				move.l		(a4,d1.w*4),D0		; on écrit la valeur dans la ram				move.l	#$ff,d4							; fond opaque				bra.s	DoFaceColor		; --------- si black on met un noir absoluBlackBgd				move.l	#$00000000,d0				move.l	#$ff,d4							; fond transparent				bra.s	DoFaceColor; --------- si box color on met la couleur de la boiteBoxBgd				move.l	G.RGB_OutlineBoxColor,d0		; couleur du fond de l'outline box				move.l	#$ff,d4							; fond opaque; note on ne peut plus utiliser d4 et d0 car ils sont utilisé pour le BGD color et Bng factor; problème : il faut déterminer quand on peut prendre la valeur d'un pixel ou non; c.a.d. est ce que le pt à lire est dans le carré du plan ( pas très clair ...)DoFaceColor				movem.l	d0-d2,-(sp)			; sauvegarde des registres		  d0-d2				move.l	d2,d1				; Y				move.l	d3,d0				; X; dans le rectangle de la face ?				move.l	charPtr(a6),a3								cmp.w	left+CharHeaderSize+pi_Rect(a3),d3				blt.s	PasDansFace				cmp.w	right+CharHeaderSize+pi_Rect(a3),d3				bgt.s	PasDansFace				cmp.w	top+CharHeaderSize+pi_Rect(a3),d2				blt.s	PasDansFace				cmp.w	bottom+CharHeaderSize+pi_Rect(a3),d2				bgt.s	PasDansFace; oui dans rectangle, on lit la valeur 								sub.w	left+CharHeaderSize+pi_Rect(a3),d0					sub.w	top+CharHeaderSize+pi_Rect(a3),d1	; origin 0,0				move.w	right+CharHeaderSize+pi_Rect(a3),d2				sub.w	left+CharHeaderSize+pi_Rect(a3),d2	; rowbyte				addq.W	#1,d2				mulu	d2,d1						; y Pos				and.l	#$ffff,d0				add.l	d0,d1				moveq	#0,d7				move.b	(a0,d1.l),d7				; Facteur pour face				movem.l	(sp)+,d0-d2; note on ne peut plus utiliser d4,d0,d7								bra.s	DoBorderColor; -------------				; non pas dans la facePasDansFace		clr.w	d7			; pas de face				movem.l	(sp)+,d0-d2; ------------- on récupère la valeur de la bordure				DoBorderColor						movem.l	d0-d2,-(sp)			; sauvegarde des registres		  d0-d2				cmpa.l	#$0000000,a1		; il y a -til une bordure ?;				beq.s	PasDansBorder		; non, pas de bordure				move.l	d2,d1				; Y				move.l	d3,d0				; X; dans le rectangle de la bordure ?								cmp.w	left+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d0				blt.s	PasDansBorder				cmp.w	right+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d0				bgt.s	PasDansBorder				cmp.w	top+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d1				blt.s	PasDansBorder				cmp.w	bottom+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d1				bgt.s	PasDansBorder; oui dans rectangle, on lit la valeur 								sub.w	left+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d0					sub.w	top+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d1	; origin 0,0				move.w	right+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d2				sub.w	left+CharHeaderSize+PlaneInfoSize+pi_Rect(a3),d2	; rowbyte				addq.W	#1,d2				mulu	d2,d1						; y Pos				and.l	#$ffff,d0				add.l	d0,d1				moveq	#0,d6				move.b	(a1,d1.l),d6				; Facteur pour border				movem.l	(sp)+,d0-d2				; note on ne peut plus utiliser d4,d0,d7,d6								bra.s	DoShadowColor; -------------				; non pas dans la bordurePasDansBorder		clr.w	d6			; pas de face				movem.l	(sp)+,d0-d2; ------------- on récupère la valeur de la shadow			DoShadowColor					movem.l	d0-d2,-(sp)			; sauvegarde des registres		  d0-d2				cmpa.l	#$0000000,a2		; il y a -til une ombre ?				beq.s	PasDansShadow		; non, pas de ombre				move.l	d2,d1				; Y				move.l	d3,d0				; X; dans le rectangle de la Shadow ?				cmp.w	left+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d3				blt.s	PasDansShadow				cmp.w	right+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d3				bgt.s	PasDansShadow				cmp.w	top+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2				blt.s	PasDansShadow				cmp.w	bottom+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2				bgt.s	PasDansShadow; oui dans rectangle, on lit la valeur 				sub.w	left+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d0					sub.w	top+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d1	; origin 0,0				move.w	right+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2				sub.w	left+CharHeaderSize+PlaneInfoSize*2+pi_Rect(a3),d2	; rowbyte				addq.W	#1,d2				mulu	d2,d1						; y Pos				and.l	#$ffff,d0				add.l	d0,d1				moveq	#0,d5				move.b	(a2,d1.l),d5				; Facteur pour shadow				movem.l	(sp)+,d0-d2				; note on ne peut plus utiliser d4,d0,d7,d6,d5								bra.s	DoMultiplyColor; -------------				; non pas dans l'ombrePasDansShadow	clr.w	d5			; pas de face				movem.l	(sp)+,d0-d2DoMultiplyColor				movem.l		d1-d7/a0-a7,-(sp)				; sauvegarde x,y en cour			; on récupère les couleurs face,border,shadow;				move.l		G.RGB_FaceColor,d3	;				move.l		G.RGB_BorderColor,d2;				move.l		G.RGB_ShadowColor,d1								move.l		Faceclr(a6),d3							move.l		borderclr(a6),d2					move.l		Shadowclr(a6),d1	; d0= bgdcolor, d1= shadowbgd, d2= bordercolor, d3= face color; d4= bgdfactor , d5= shadow factor , d6= border factor, d7= face factor   				import		ColorMultiplicateur  				jsr			ColorMultiplicateur		; résultat dans d0								movem.l		(sp)+,d1-d7/a0-a7				; on récupére les registres				; on écrit le résultat dans la ram				move.w		Xpos(a6),d1				add.w		d3,d1				move.l		d0,(a4,d1.w*4)			; on écrit la valeur dans la ram; fin boucle X				addq.w		#1,d3				cmp.w		right+CH_Rect(a3),d3				bls			horizontal_loop								add.l		Row_Bytes(a6),a4				; fin boucle Y				addq.w		#1,d2				cmp.w		bottom+CH_Rect(a3),d2				bls			vertical_loopExit			movem.l (sp)+,d1-d7/a1-a4	; sauvegarde des registres								UNLK	A6				MOVEA.L	(SP)+,A0		; save the caller's address				ADDA.L	#ParamSize,SP		; strip the caller's parameters				JMP	(A0)									DbgInfo.new	A_Draw_A_Char			; this name will appear in the debugger				align 4					ENDP								end