#include "BB.Globals_C.h"#include <Devices.h>#include <StdArg.h>#include <stdio.h>#include <TextUtils.h>// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;#define thisDialogID 231/* Symbolic Dialog Item Numbers */static enum {	BUT1_OK = 1,	BUT2_Cancel,	EDIT3,	ICON4,	ICON5,	EDIT6,	ICON7,	ICON8,	EDIT9,	ICON10,	ICON11,	USER12,	USER13,	USER14,	STXT15_Face,	STXT16_Bordure,	STXT17_Cache,	STXT18_Couleur,	STXT19_Valeurs,	STXT20_Opacit,	USER21,	USER22,	USER23,	STXT24_H,	STXT25_R,	STXT26_H,	STXT27_R,	STXT28_H,	STXT29_R,	USER30,	Test31,	LASTITEM	} DialogItemNumber;#define OK_ITEM 	BUT1_OK#define CANCEL_ITEM 	BUT2_Cancel/* Useful constants */#ifndef ENTERkey#define ENTERkey	0x3#endif#ifndef DELETEkey#define DELETEkey	0x8#endif#ifndef NIL#define NIL ((void *)0)#endif#ifndef TRUE#define TRUE 1#endif#ifndef FALSE#define FALSE 0#endif#ifndef FRONT_WINDOW#define FRONT_WINDOW  ((WindowPtr) (-1L))#endiftypedef struct ColorST {long face;long border;long shadow;long mask;}ColorST,*ColorSTPtr;/* Prototypes */int       SelectCoulStBroadcast(ColorSTPtr color);DialogPtr OpenThisDialog(ColorSTPtr color);void      CloseThisDialog(DialogPtr dlog);void      DoDialogUpdate(DialogPtr dlog);void      DoDialogActivate(DialogPtr dlog, int activ);void      DoDialogContent(DialogPtr dlog, EventRecord *evt);int       DoDialogItem(DialogPtr dlog, short itemHit);pascal  Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit);Boolean CheckUserItems(Point where, short *itemHit);int     AnyBadValues(DialogPtr dlog);static void	DrawTransParenceREct(DialogPtr dlog,short item, short value);static void DrawColorRect_String(DialogPtr dlog,short itemcolor,short hslitem, short rvbitem);void MyUpdateDialog(DialogPtr dialog);pascal long My_IncDecValue(DialogPtr Dialog,short itemNumber,short textitemnumber,long minvalue,long maxvalue,long increment);void    CenterWindow(WindowPtr w, short top);static long    strlen(char *);static char   *strcpy(char *dst, char *src);static char   *PascalToC(unsigned char *pstr);static unsigned char   *CToPascal(char *cstr);static void    PutDlgString(DialogPtr dlog, int item, unsigned char *str, int sel);static void    PutDlgWord(DialogPtr dlog, int item, int val, int sel);static void    PutDlgLong(DialogPtr dlog, int item, long val, int sel);static void    PutDlgChkRadio(DialogPtr dlog, int item, int val);static int     GetDlgString(DialogPtr dlog, int item, unsigned char *str);static int     GetDlgWord(DialogPtr dlog, int item, short *val);static int     GetDlgLong(DialogPtr dlog, int item, long *val);static int     GetDlgChkRadio(DialogPtr dlog, int item);static int     TextSelected(DialogPtr dlog);static OSType  CanPaste(int n, ...);void    FrameDefault(DialogPtr dlog, int item, int frame);static void    GetDlgPanel(DialogPtr dlog, int item, Rect *panel);void C_TestDrawChar(long face, long border,long shadow, long mask);static void ConvertRGBColor_ARGB(DialogPtr dlog,ColorSTPtr clrst);static void UpdateByTe(DialogPtr dlog,short item);static Point where;static int modifiers;static short	gFontMustBeRecalculed;static	RGBColor	gFaceColor,gBorderColor,gMasqueColor;static void  ConcatStr(Str255* src,Str255* dst);/* *	Display this modal dialog.  Return TRUE if OK, FALSE if CANCEL or error. *	If the dialog displays values from outside this module, you should either *	import them from globals, or change the argument list of this routine to *	bring them in and pass them to OpenThisDialog(), DoDialogItem(), etc. */int SelectCoulStBroadcast(ColorSTPtr color)	{		short itemHit,okay=FALSE,keepGoing=TRUE;		DialogPtr dlog=NIL; GrafPtr oldPort;		ModalFilterUPP MyFilterUPP;		long	a,b,g,r;				GetPort(&oldPort);		/* On PowerPC, need a RoutineDescriptor from heap; on 68K, no allocation */				MyFilterUPP = NewModalFilterProc(MyFilter);		if (MyFilterUPP == NIL) goto cleanUp;				gFontMustBeRecalculed=false;				/* Build dialog window and install its item values */				dlog = OpenThisDialog(color);		if (dlog == NIL) goto cleanUp;		/* Entertain filtered user events until dialog is dismissed */				while (keepGoing) {			ModalDialog(MyFilterUPP,&itemHit);			keepGoing = DoDialogItem(dlog,itemHit);			}				/*		 *	Do final processing of item values, such as exporting them to caller.		 *	DoDialogItem() has already called AnyBadValues().		 */				okay = (itemHit == OK_ITEM);		if (okay) {		/* Or whatever is equivalent */			// on palce les valeurs de transparence			ConvertRGBColor_ARGB(dlog,color);			}		/* That's all, folks! */cleanUp:				if (dlog) CloseThisDialog(dlog);		if (MyFilterUPP) DisposeRoutineDescriptor(MyFilterUPP);		SetPort(oldPort);		SetDAFont(0);		return(okay);	}/* *	We have to have a filter function, at the very least so that we can outline *	any default button, entertain keyboard editing commands, cmd-period canceling, etc. *	Note that you do not need to have a special user item covering the default button *	in your dialog item list. */static pascal Boolean MyFilter(DialogPtr dlog, EventRecord *evt, short *itemHit)	{		Boolean ans=FALSE,doHilite=FALSE; WindowPtr w,window;		short type,ch,part; Handle hndl; Rect box;		static long then; static Point clickPt;		long 	a; Str255 str;				w = (WindowPtr)(evt->message);				switch(evt->what) {			case updateEvt:				if (w == dlog) {					/* Update our dialog contents */					DoDialogUpdate(dlog);					ans = TRUE; *itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoUpdate(w) routine here if you					 *	don't want unsightly holes in background windows caused					 *	by nested alerts, balloon help, or screen savers (see					 *	Tech Note #304).					 */					}				break;			case activateEvt:				if (w == dlog) {					DoDialogActivate(dlog,(evt->modifiers & activeFlag)!=0);					*itemHit = 0;					}				 else {					/*					 *	Call your main event loop DoActivate(w) routine here if					 *	you want to deactivate the former frontmost window, in order					 *	to unhighlight any selection, scroll bars, etc.					 */					}				break;			case mouseDown:							where = evt->where;		/* Make info available to DoDialog() */				part = FindWindow(evt->where, &window);				if ( part==inDrag)               /* pass screenBits.bounds to get all gDevices */						if	(window==(WindowPtr)FrontNonFloatingWindow()) {							 DragWindow(window, evt->where,&QD.screenBits.bounds);							*itemHit = 0;						 } 						case mouseUp:				where = evt->where;		/* Make info available to DoDialog() */				GlobalToLocal(&where);				modifiers = evt->modifiers;				ans = CheckUserItems(where,itemHit);				break;			case keyDown:				if ((ch=(unsigned char)evt->message)==3) {					*itemHit = OK_ITEM /* Default Item Number here */;					doHilite = ans = TRUE;					}				 else if (evt->modifiers & cmdKey) {					ch = (unsigned char)evt->message;					switch(ch) {						case 'x':						case 'X':							if (TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DlgCut(dlog); TEToScrap(); }							 else {								/* Cut from anything else cuttable, like a list */								}							break;						case 'c':						case 'C':							if (TextSelected(dlog))								{ SystemEdit(3); ZeroScrap(); DlgCopy(dlog); TEToScrap(); }							 else {								/* Copy from anything else copyable, like a list */								}							break;						case 'v':						case 'V':							if (CanPaste(1,'TEXT'))								{ TEFromScrap(); DlgPaste(dlog); }							 else {							 	/* Deal with any other pasteable scraps here */								}							break;						case 'a':						case 'A':							if (((DialogPeek)dlog)->editField >= 0) {								/* Dialog has text edit item: select all */								SelIText(dlog,((DialogPeek)dlog)->editField+1,0,32767);								}							 else {								}							*itemHit = 0;							break;						case '.':							*itemHit = CANCEL_ITEM;							doHilite = TRUE;							break;						}					ans = TRUE;		/* Other cmd-chars ignored */					} else {										// on intecepte les caractères retour chariot et tap pour les TE ....					if ( (ch==0x0d) || ch=='\t' ) {						// on vérife la valeur du te						// on détermine quel item est touché ...								GetDlgString(dlog,*itemHit,&str); 							StringToNum(&str,&a);							if (a<0) {							 	a=0;							 	SysBeep(1);								NumToString(a,&str);								PutDlgString(dlog,*itemHit, &str,1); 							  }							if (a>100) { 								a=100; 								SysBeep(1);							 	NumToString(a,&str);								PutDlgString(dlog,*itemHit, &str,1); 							 }							// on dessine la transparence du rectangle														DrawTransParenceREct(dlog,(24-*itemHit/3),a);						}					}				break;			}		if (doHilite) {			GetDItem(dlog,*itemHit,&type,&hndl,&box);			/* Reality check */			if (type == (btnCtrl+ctrlItem)) {				long soon = TickCount() + 7;		/* Or whatever feels right */				HiliteControl((ControlHandle)hndl,1);				while (TickCount() < soon) ;		/* Leave hilited for a bit */				}			}		return(ans);	}/* * Mouse down event: * Check if it's in some user item, and convert to itemHit if appropriate. */static Boolean CheckUserItems(Point where, short *itemHit)	{		return(FALSE);	}/* * Redraw the contents of this dialog due to update event. * If you have not installed UserItem draw routines, you should redraw * them explicitly here; otherwise, UpdtDialog() will call your routines. */static void DoDialogUpdate(DialogPtr dlog)	{GrafPtr oldPort;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;short type; Handle hndl; Rect box,rect;long a;short s;Str255 str;		GetPort(&oldPort); 		SetPort(dlog);		BeginUpdate(dlog);// on entoure la fenêtre d'une ppat		pixpat=GetPixPat(129);						if (pixpat!=nil){			rgn=NewRgn();			rgn1=NewRgn();			RectRgn(rgn,&dlog->portRect);			GetDItem(dlog,30,&type,&hndl,&rect);			RectRgn(rgn1,&rect);			DiffRgn(rgn,rgn1,rgn);			FillCRgn(rgn,pixpat);			DisposePixPat(pixpat);			DisposeRgn(rgn);			DisposeRgn(rgn1);		}		GetDItem(dlog,30,&type,&hndl,&box);		MakeReliefRectangle1(&box);		PenNormal();				//	on dessine les pseudo bouton de couleur							DrawColorRect_String(dlog,12,24,25);		DrawColorRect_String(dlog,13,26,27);		DrawColorRect_String(dlog,14,28,29);				// on dessine les rectangles de transparence		GetDlgWord(dlog,3,&s); 		DrawTransParenceREct(dlog,23,s);		GetDlgWord(dlog,6,&s); 		DrawTransParenceREct(dlog,22,s);		GetDlgWord(dlog,9,&s); 		DrawTransParenceREct(dlog,21,s);				//UpdtDialog(dlog,dlog->visRgn);// on rafraichi les controls et les ditl				MyUpdateDialog(dlog);// on dessine les pseudo te				 UpdateByTe(dlog,3);		 UpdateByTe(dlog,6);		 UpdateByTe(dlog,9);		FrameDefault( dlog,1, 1);		EndUpdate(dlog);		SetPort(oldPort);}//static void	DrawTransParenceREct(DialogPtr dlog,short item, short value){GrafPtr oldPort;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;short type,i,h; Handle hndl; Rect box,rect;long a,b;Str255 str;		RGBColor	c,c1;		GetPort(&oldPort); 		SetPort(dlog);		GetDItem(dlog,item,&type,&hndl,&box);		InsetRect(&box,-1,-1);		FrameRect(&box);		InsetRect(&box,1,1);		EraseRect(&box);		GetForeColor(&c1);		b=255-(value*255)/100;				c.red=(b<<8)+b;		c.green=(b<<8)+b;		c.blue=(b<<8)+b;				RGBForeColor(&c);		TextSize(12);		TextFace(bold);		MoveTo(box.left+2,box.top+12);		DrawChar('A');				TextSize(9);		TextFace(0);		RGBForeColor(&c1);		SetPort(oldPort);}pascal	void FrameRectTwoLine(Rect *rect,Boolean Enfonce);// routine static void PaintColorRect(DialogPtr dlog,short itemcolor,short hilite);static void PaintColorRect(DialogPtr dlog,short itemcolor,short hilite){GrafPtr oldPort;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;short type; Handle hndl; Rect box,rect;long a;Str255 str,str1,str2;		RGBColor	c,c1,c2,c3;HSLColor	hsl; 				GetPort(&oldPort);		SetPort(dlog);		GetForeColor(&c1);		GetDItem(dlog,itemcolor,&type,&hndl,&box);		MakeReliefRectangle1(&box);		InsetRect(&box,-2,-2);		FrameRectTwoLine(&box,hilite);		GetDItem(dlog,itemcolor,&type,&hndl,&box);		InsetRect(&box,1,1);				// on recupère la couleur en fonction de l'item		switch(itemcolor){			case 12:			c=gFaceColor;			break;			case 13:			c=gBorderColor;			break;			case 14:			c=gMasqueColor;			break;					}		RGBForeColor(&c);				if (hilite){			c.red=c.red/2;			c.green=c.green/2;			c.blue=c.blue/2;		}				box.left++;		box.top++;		PaintRect(&box);				RGBForeColor(&c1);		SetPort(oldPort);}static void DrawColorRect_String(DialogPtr dlog,short itemcolor,short hslitem, short rvbitem){GrafPtr oldPort;PixPatHandle	pixpat;		RgnHandle	rgn,rgn1;short type; Handle hndl; Rect box,rect;long a;Str255 str,str1,str2;		RGBColor	c,c1,c2,c3;HSLColor	hsl; 				GetPort(&oldPort);		SetPort(dlog);		GetForeColor(&c1);		PaintColorRect(dlog,itemcolor,0);						switch(itemcolor){			case 12:			c=gFaceColor;			break;			case 13:			c=gBorderColor;			break;			case 14:			c=gMasqueColor;			break;					}				TextMode(srcCopy);		TextFace(0);		PenNormal();				c2.red=0;		c2.green=0;		c2.blue=-1;						RGBForeColor(&c2);// on effectue le calcul des chaines// RGB		a=c.red&0xff00;		a=a>>8;		NumToString(a,&str1);		str[0]=0;		str[0]++;  str[str[0]]='R'; 		str[0]++;  str[str[0]]=':'; 		ConcatStr((Str255*)&str1,(Str255*)&str);		str[0]++;  str[str[0]]=','; 		str[0]++;  str[str[0]]=' '; 				str[0]++;  str[str[0]]='V'; 				str[0]++;  str[str[0]]=':'; 				a=c.green&0xff00;		a=a>>8;		NumToString(a,&str1);		ConcatStr((Str255*)&str1,(Str255*)&str);		str[0]++;  str[str[0]]=','; 		str[0]++;  str[str[0]]=' '; 				str[0]++;  str[str[0]]='B'; 				str[0]++;  str[str[0]]=':'; 				a=c.blue&0xff00;		a=a>>8;		NumToString(a,&str1);		ConcatStr((Str255*)&str1,(Str255*)&str);		// on dessine le texte		GetDItem(dlog,rvbitem,&type,&hndl,&box);		EraseRect(&box);		MoveTo(box.left+9, box.top+9);		DrawString(&str);//HSL		RGB2HSL (&c, &hsl);		a=(hsl.hue*360)/65535;		NumToString(a,&str1);		str[0]=0;		str[0]++;  str[str[0]]='H'; 		str[0]++;  str[str[0]]=':'; 		ConcatStr((Str255*)&str1,(Str255*)&str);		str[0]++;  str[str[0]]='°'; 		str[0]++;  str[str[0]]=','; 		str[0]++;  str[str[0]]=' '; 				str[0]++;  str[str[0]]='S'; 				str[0]++;  str[str[0]]=':'; 				a=(hsl.saturation*100)/65535;		NumToString(a,&str1);		ConcatStr((Str255*)&str1,(Str255*)&str);		str[0]++;  str[str[0]]='%'; 		str[0]++;  str[str[0]]=','; 		str[0]++;  str[str[0]]=' '; 				str[0]++;  str[str[0]]='L'; 				str[0]++;  str[str[0]]=':'; 				a=(hsl.lightness*100)/65535;		NumToString(a,&str1);		ConcatStr((Str255*)&str1,(Str255*)&str);		str[0]++;  str[str[0]]='%'; 				// on dessine le texte		GetDItem(dlog,hslitem,&type,&hndl,&box);		EraseRect(&box);		MoveTo(box.left+9, box.top+9);		DrawString(&str);		RGBForeColor(&c1);		SetPort(oldPort);}	/* * Activate event: Activate or deactivate this dialog and any items in it */static void DoDialogActivate(DialogPtr dlog, int activ)	{		SetPort(dlog);	}/* * Build this dialog's window on desktop, and install initial item values. * Return the dlog opened, or NIL if error (no resource, no memory). */static DialogPtr OpenThisDialog(ColorSTPtr color)	{		short type; Handle hndl; Rect box; GrafPtr oldPort;		DialogPtr dlog; unsigned char *p,str[256];		TEHandle te; long a,r,g,b;				GetPort(&oldPort);		SetDAFont(geneva);		dlog = GetNewDialog(thisDialogID,NIL,FRONT_WINDOW);		if (dlog == NIL) { SysBeep(1); return(NIL); }	/* Poor man's error message */		CenterWindow(dlog,0);		SetPort(dlog);				TextFont(geneva);	// pour une version internationnale		TextSize(9);		te=((DialogPeek)dlog)->textH   ;				if (te){			(**te).txSize=9;			(**te).txFont=geneva;		}		/* Fill in dialog's values here */		// on palce les valeurs de transparence				a=color->face&0xff000000;		a=a>>24;		a=a&0xff;		a=(a*100)/255; // transparence face		PutDlgWord(dlog,EDIT3,a, 0);				a=color->border&0xff000000;		a=a>>24;		a=a&0xff;		a=(a*100)/255; // transparence border			PutDlgWord(dlog,EDIT6,a, 0);				a=color->mask&0xff000000;		a=a>>24;		a=a&0xff;		a=(a*100)/255; // transparence mask		PutDlgWord(dlog,EDIT9,a, 0);				// on palce les valeurs des couleurs				r=color->face&0xff0000;		r=r>>16;		r=(r<<8)+r;		g=color->face&0xff00;		g=g>>8;		g=(g<<8)+g;		b=color->face&0xff;		b=(b<<8)+b;						gFaceColor.red=r;		gFaceColor.green=g;		gFaceColor.blue=b;// --		r=color->border&0xff0000;		r=r>>16;		r=(r<<8)+r;		g=color->border&0xff00;		g=g>>8;		g=(g<<8)+g;		b=color->border&0xff;		b=(b<<8)+b;						gBorderColor.red=r;		gBorderColor.green=g;		gBorderColor.blue=b;		//-				r=color->mask&0xff0000;		r=r>>16;		r=(r<<8)+r;		g=color->mask&0xff00;		a=a>>8;		g=(g<<8)+g;		b=color->mask&0xff;		b=(b<<8)+b;						gMasqueColor.red=r;		gMasqueColor.green=g;		gMasqueColor.blue=b;												// on regarde s'il y a une police d'afficgae en mémoire		// si non on desactive le control "test		GetDItem(dlog,Test31,&type,&hndl,&box);		if(	 (!G.Display_Font.Render_handle)  ||		 (!G.Display_Font.RenderColor_handle)  )			HiliteControl((ControlHandle)hndl,255);				ShowWindow(dlog);		return(dlog);	}/* * Clean up any allocated stuff, and return dialog to primordial mists */static void CloseThisDialog(DialogPtr dlog)	{		if (dlog) {			DisposeDialog(dlog);	/* Call CloseDialog if you provide storage to GetNewDialog */		}}static void ConvertRGBColor_ARGB(DialogPtr dlog,ColorSTPtr color){long	a,r,g,b;Str255 str;		GetDlgString(dlog,EDIT3,&str);		StringToNum(&str,&a);		a=((a*255)/100)&0xff;		a=a<<24;				r=(gFaceColor.red&0xff00)<<8;		g=(gFaceColor.green&0xff00);		b=(gFaceColor.blue&0xff00)>>8;					color->face=a+r+g+b;		//------------------------------------------------------				GetDlgString(dlog,EDIT6,&str);		StringToNum(&str,&a);		a=((a*255)/100)&0xff;		a=a<<24;				r=(gBorderColor.red&0xff00)<<8;		g=(gBorderColor.green&0xff00);		b=(gBorderColor.blue&0xff00)>>8;					color->border=a+r+g+b;//------------------------------------------------------				GetDlgString(dlog,EDIT9,&str);		StringToNum(&str,&a);		a=((a*255)/100)&0xff;		a=a<<24;		r=(gMasqueColor.red&0xff00)<<8;		g=(gMasqueColor.green&0xff00);		b=(gMasqueColor.blue&0xff00)>>8;					color->mask=a+r+g+b;		//------------------------------------------------------		}/* * Deal with user clicking on an item in this dialog, either modal or non-modal. * The local point is in where; modifiers in modifiers. * Returns whether or not the dialog should be closed (keepGoing). */static int DoDialogItem(DialogPtr dlog, short itemHit)	{		short type,okay=FALSE,keepGoing=TRUE,val;		Handle hndl; Rect box; Point pt; long a;		unsigned char *p,str[256];		Str255 prompt;		RGBColor	newColor;		ColorST clrst;		if (itemHit<1 || itemHit>=LASTITEM)			return(keepGoing);				/* Only legal items, please */		GetDItem(dlog,itemHit,&type,&hndl,&box);		switch(type) {			case ctrlItem+btnCtrl:				switch(itemHit) {					case BUT1_OK:						keepGoing = FALSE; okay = TRUE;						break;					case BUT2_Cancel:						keepGoing = FALSE;						break;											case Test31:  // test des paramètres						ConvertRGBColor_ARGB(dlog,&clrst);						C_TestDrawChar(clrst.face,clrst.border,clrst.shadow,clrst.mask);						break;						}				break;							case ctrlItem+chkCtrl:				break;			case ctrlItem+radCtrl:				break;			case ctrlItem+resCtrl:				break;			case statText:				switch(itemHit) {					case STXT15_Face:		/* NOT Enabled */						break;					case STXT16_Bordure:		/* NOT Enabled */						break;					case STXT17_Cache:		/* NOT Enabled */						break;					case STXT18_Couleur:		/* NOT Enabled */						break;					case STXT19_Valeurs:		/* NOT Enabled */						break;					case STXT20_Opacit:		/* NOT Enabled */						break;					case STXT24_H:		/* NOT Enabled */						break;					case STXT25_R:		/* NOT Enabled */						break;					case STXT26_H:		/* NOT Enabled */						break;					case STXT27_R:		/* NOT Enabled */						break;					case STXT28_H:		/* NOT Enabled */						break;					case STXT29_R:		/* NOT Enabled */						break;					}				break;			case editText:				switch(itemHit) {					case EDIT3:						break;					case EDIT6:						break;					case EDIT9:						break;					}				break;			case iconItem:				switch(itemHit) {					case ICON4:						a=My_IncDecValue(dlog,itemHit,3,0,100,1);						gFontMustBeRecalculed=true; // pour recalculer la fast font							DrawTransParenceREct(dlog,23,a);						break;					case ICON5:						a=My_IncDecValue(dlog,itemHit,3,0,100,-1);						gFontMustBeRecalculed=true; // pour recalculer la fast font							DrawTransParenceREct(dlog,23,a);						break;					case ICON7:						a=My_IncDecValue(dlog,itemHit,6,0,100,1);						gFontMustBeRecalculed=true; // pour recalculer la fast font							DrawTransParenceREct(dlog,22,a);						break;					case ICON8:						a=My_IncDecValue(dlog,itemHit,6,0,100,-1);						gFontMustBeRecalculed=true; // pour recalculer la fast font							DrawTransParenceREct(dlog,22,a);					break;					case ICON10:						a=My_IncDecValue(dlog,itemHit,9,0,100,1);						DrawTransParenceREct(dlog,21,a);						break;					case ICON11:						a=My_IncDecValue(dlog,itemHit,9,0,100,-1);						DrawTransParenceREct(dlog,21,a);						break;					}														break;			case picItem:				break;			case userItem:				pt.v=0;  pt.h=0;				GetIndString((unsigned char*)&prompt,129,60);								switch(itemHit) {													case USER12:							PaintColorRect(dlog,itemHit,1);							if ( GetColor(pt,							&prompt,							&gFaceColor,							&newColor) )  gFaceColor=newColor;							DrawColorRect_String(dlog,12,24,25);												break;					case USER13:							PaintColorRect(dlog,itemHit,1);							if ( GetColor(pt,							&prompt,							&gBorderColor,							&newColor) )  gBorderColor=newColor;							DrawColorRect_String(dlog,13,26,27);						break;					case USER14:							PaintColorRect(dlog,itemHit,1);							if ( GetColor(pt,							&prompt,							&gMasqueColor,							&newColor) )  gMasqueColor=newColor;							DrawColorRect_String(dlog,14,28,29);						break;					}				break;			}		if (okay) keepGoing = AnyBadValues(dlog);		return(keepGoing);	}/* * Pull values out of dialog items and deliver TRUE if any of them are * illegal or inconsistent; otherwise deliver FALSE.  If any values are bad, * you should inform your user about the problem here before delivering TRUE. * If any items are missing values, this is the place to assign any defaults. */static int AnyBadValues(DialogPtr dlog)	{		unsigned char str[256]; short val,len;		if (GetDlgString(dlog,EDIT3,str)) {			/* Got a string (can also call GetDlgWord(), etc. here) */			}		else {			/* Field was empty */			}		if (GetDlgString(dlog,EDIT6,str)) {			}		else {			}		if (GetDlgString(dlog,EDIT9,str)) {			}		else {			}		return(FALSE);	}/*••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••*//* *  The following are various utility routines for general dialog management. *  Typically, you'll want to keep them in a library that is available to all *  your dialog modules; however, they are included here (and declared static) *  as a private library so that you can quickly compile this file for testing. */#define _PrivateLibraries_#ifdef  _PrivateLibraries_/* *	Center a given window, w, horizontally in the main screen, top pixels from *	the top, or centered vertically if top is 0.  The window should be invisible. */static void CenterWindow(WindowPtr w, short top)	{		Rect scr; Point p;		short rsize,size,margin,xoff,yoff;		scr = qd.screenBits.bounds;		SetPort(w);		p.h = w->portRect.left; p.v = w->portRect.top;		LocalToGlobal(&p);		size = scr.right - scr.left;		rsize = w->portRect.right - w->portRect.left;		margin = size - rsize;		if (margin > 0) {			margin >>= 1;			p.h = scr.left + margin;			}		size = scr.bottom - scr.top;		rsize = w->portRect.bottom - w->portRect.top;		margin = size - rsize;		if (margin > 0) {			margin >>= 1;			p.v = scr.top + margin;			}		MoveWindow(w,p.h,top?top:p.v,FALSE);	}/* Local C string length routine */static long strlen(register char *str)	{		register char *p;		p = str;		while (*p++) ;		return((long)(--p - str));	}/* Convert in place a Pascal string to C string, and deliver its address */static char *PascalToC(unsigned char *str)	{		register unsigned char *p,*q,*end;		end = str + *str;		q = (p=str) + 1;		while (p < end) *p++ = *q++;		*p = '\0';		return((char *)str);	}/* *	Convert in place a C string to Pascal string, and deliver its address. *	The C string should not be greater than 255 chars in length, or the *	resulting Pascal string will be truncated to 255 chars. */static unsigned char *CToPascal(char *str)	{		register char *p,*q;		register long len;		len = strlen(str);		if (len > 255) len = 255;		p = str + len;		q = p-1;		while (p != str) *p-- = *q--;		*str = len;		return((unsigned char *)str);	}/* Dialog Item Stuffers *//* *	Install a given Pascal string, str, into the given static or edit text item *	in the dialog, dlog.  If the item is an edit text item, leave the installed *	text selected or not according to the value of sel (TRUE or FALSE). */static void PutDlgString(DialogPtr dlog, int item, unsigned char *str, int sel)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		SetIText(hndl,str);		if (type == editText)			SelIText(dlog,item,sel?0:32767,32767);		InvalRect(&box);	}/* *	Install a given decimal long value into the static or edit text item of the *	given dialog, dlog.  If the item is an edit text item, leave the installed *	text for the number selected or not according to sel (TRUE or FALSE). */static void PutDlgLong(DialogPtr dlog, int item, long val, int sel)	{		unsigned char str[32];		NumToString(val,str);		PutDlgString(dlog,item,str,sel);	}/* *	Same as above, only for an int (word) decimal number. */static void PutDlgWord(DialogPtr dlog, int item, int val, int sel)	{		PutDlgLong(dlog,item,(long)val,sel);	}/* *	Set the given check box or radio button item of the given dialog, dlog, to *	on or off, according to val. */static void PutDlgChkRadio(DialogPtr dlog, int item, int val)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		SetCtlValue((ControlHandle)hndl,val!=0);	}/* *	Deliver the value of the checkbox or radio button item of the given dialog. */static int GetDlgChkRadio(DialogPtr dlog, int item)	{		short type; Handle hndl; Rect box;				GetDItem(dlog,item,&type,&hndl,&box);		return(GetCtlValue((ControlHandle)hndl) != 0);	}/* Dialog Item Unstuffers *//* *	Retrieve the value of an edit text item in a given dialog, placing the *	resulting Pascal string in the buffer, str, which is assumed large enough *	to hold the text (256 bytes max).  If item is the number of a static text *	item, the empty string is delivered.  Delivers TRUE or FALSE according to *	whether or not the text so delivered was empty.   */static int GetDlgString(DialogPtr dlog, int item, unsigned char *str)	{		short type; Handle hndl; Rect box;		GetDItem(dlog,item,&type,&hndl,&box);		if (type == editText) GetIText(hndl,str);		 else                 *str = 0;		return(*str != 0);	}/* *	Retrieve the value of an edit text item in a given dialog, converting the *	Pascal string to a long and setting *val to it.  Delivers TRUE or FALSE *	according to whether or not the text so delivered was empty.  If FALSE, *	*val is set to 0; if TRUE, *val is set to whatever StringToNum() says the *	value is, even if the text contains non-numerical characters. */static int GetDlgLong(DialogPtr dlog, int item, long *val)	{		int ans; unsigned char str[256];		*val = 0;		ans = GetDlgString(dlog,item,str);		if (ans)			StringToNum(str,val);		return(ans);		}/* Same as above, only delivers the value of a word */static int GetDlgWord(DialogPtr dlog, int item, short *val)	{		int ans; long num;		*val = 0;		ans = GetDlgLong(dlog,item,&num);		if (ans)			*val = num;		return(ans);	}/* *	Deliver the number of the current editText item in given dialog if any text *	is selected in it, or 0 if none selected. */static int TextSelected(DialogPtr dlog)	{		register TEHandle textH; int item = 0;				textH = ((DialogPeek)dlog)->textH;		if (*textH)			if ( (*textH)->selStart != (*textH)->selEnd )				item = ((DialogPeek)dlog)->editField+1;		return(item);	}/* *  If any of the variable argument scrap types are available for pasting from *  the scrap, deliver the first one.  Otherwise, deliver 0.  For example, *	 *      if (whichType = CanPaste(3,'TEXT','PICT','STUF')) ... * *  There can be any number of types in the list, as long as the preceding count, n, *  is correct. */static OSType CanPaste(int n, ...)	{		register OSType nextType,ans = 0L;		long err,offset;		va_list nextArg;				va_start(nextArg,n);		nextType = va_arg(nextArg, OSType);				while (n-- > 0) {			err = GetScrap(NIL, nextType, &offset);			if (err >= -1) {				ans = nextType;				break;				}			nextType = va_arg(nextArg, OSType);			}				va_end(nextArg);		return(ans);	}/* *	Get rectangle, *panel, for a given item (usually a user or picture item) *	and then hide the item so that it doesn't interfere with mouse clicking. *	This lets you stop worrying about the item order any user or pict items that *	obscure other items in the item list, which can affect how the DialogMgr *	returns itemHits. */static void GetDlgPanel(DialogPtr dlog, int item, Rect *panel)	{		short type; Handle hndl;				GetDItem(dlog,item,&type,&hndl,panel);		HideDItem(dlog,item);	}#endifstatic void  ConcatStr(Str255* src,Str255* dst){long L;char*  P;char* P1;		L=(long)src; L++; P=(char*)L;	L=(long)dst; L+=*dst[0]+1; P1=(char*)L;	BlockMove(P,P1,*src[0]);	*dst[0]+=*src[0];}static void UpdateByTe(DialogPtr dlog,short item){long		result;Str255		string;Handle		the_Handle;short		the_itemtype;Rect			Rectangle;RGBColor		c,c1;	GetForeColor(&c);	GetDItem(dlog,item,&the_itemtype,&the_Handle,&Rectangle);	GetIText(the_Handle,&string);	InsetRect(&Rectangle,1,1);		TETextBox ((char*)string+1,(long)string[0],&Rectangle,teCenter);		c1.red=0x8080;	c1.green=0x8080;	c1.blue=0x8080;		RGBForeColor(&c1);	InsetRect(&Rectangle,-1,-1);	FrameRect(&Rectangle);		RGBForeColor(&c);}