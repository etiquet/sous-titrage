#include "CreateFastFont.h"#include "DrawSousTitre.h"#include 	"GiveFontInfo.h"//#include "PPCDispatch.h"// cette routine permet de dessiner un caractère anti-aliasé#ifdef 	powerc   // pour la compilation en  code resource PPCProcInfoType __procinfo =  kPascalStackBased     		 | RESULT_SIZE(SIZE_CODE(sizeof(short))) 		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(FontRenderRecordPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(long))) 		 | STACK_ROUTINE_PARAMETER(8, SIZE_CODE(sizeof(long))) 		 | STACK_ROUTINE_PARAMETER(9, SIZE_CODE(sizeof(short))) 		 | STACK_ROUTINE_PARAMETER(10, SIZE_CODE(sizeof(short))) 		 | STACK_ROUTINE_PARAMETER(11, SIZE_CODE(sizeof(char*))) 		 | STACK_ROUTINE_PARAMETER(12, SIZE_CODE(sizeof(long)))	 ;#endif //#ifdef 	powerc// cette routine effectue l'affichage d'une type à partir d'une display font// cette routine est assez lente, sa velocité ne permet pas l'affichage en temps reel d'un sous-titre ...// il faut passer pas fastDraw_a_char pour le suivi temps reel.// elle est utilisée principalement pour le calcul d'un police d'affichage rapide....// elle ne permet que de calculer des police en plan 32bits ....pascal short C_Draw_A_Char(FontRenderRecordPtr  FontRender,short  TheChar,					short TheStyle, long  Face_Color,long Border_Color,long Shadow_Color,long bgd_Color,					long  drapeau,short  Xpos ,short Ypos ,char* DisplayRamPtr,long RowBytes){char*		FacePtr;char*		BorderPtr;char*		ShadowPtr;char*		P1;char*		P2;char*		P3;long*		baseadresse;long*		P4;long*		P5;CharHeader_CPtr	chptc;unsigned long	LL,b,offsetBaseLine,Pixel;short		nbPlan,x,y,ss;			// nombre de plan pour le caractèrePlaneInfoPtr	plane0,plane1,plane2;			// 3 plane infoCharHeaderPtr	CurrentChar;unsigned short	fact;long			facerb,borderrb,shadowrb;char*		BasePtr;//quelques vérifications d'usage...				if (!FontRender) return -2;				if (  (TheChar<FontRender->First_Char) || (TheChar>FontRender->last_Char) ) return 0;				// on ne traite pas les caractères espace ....				if (TheChar==0xca ||  TheChar==0x20) return (FontRender->spaceWidth); // on demande le header du caractère				CurrentChar=C_GiveDisplayFont_CharInfo(FontRender,TheChar,TheStyle);				if (!CurrentChar) return 0; // erreur ...				if (((CurrentChar->CH_Spare)&0xffff)==0xcaca) ss=1;  // un test de validité de la font				if (((CurrentChar->CH_Spare)&0xffff)==0xcbcb) ss=1;  // un test de validité de la font				// note on place $caca dans le spare au moment du rendu de la police...				if (!ss) return -1;				// n° caractère dans la liste// on calcule les adresse des plane info				chptc=(CharHeader_CPtr)CurrentChar;				plane0=&(chptc->pi[0]);				plane1=&(chptc->pi[1]); // ce pointeur peut-être invalide , attention				plane2=&(chptc->pi[2]); // ce pointeur peut-être invalide , attention										// pour voir s'il y a une différence					LL=(unsigned long)CurrentChar;				LL+=sizeof(CharHeader);				LL+=sizeof(PlaneInfo);				LL+=sizeof(PlaneInfo);								// on vérifie que le rectangle n'est pas nul								if (  (plane0->pi_Rect.right-plane0->pi_Rect.left) <=0) return 0;// la base du plan				BasePtr=(char*)*(FontRender->Render_handle );						//détermination des pointeurs des différents plans dans le fichier source//note on gère entre 1 et  3 plans// mais actuellement les typos calculées, ne possèdent que 2 plans ...				nbPlan=FontRender->Plane_Number;				ShadowPtr=BorderPtr=nil; 								// on calcule les pointeurs des differents plans				LL=(unsigned long)plane0->pi_PlaneBase;				LL+=(unsigned long)BasePtr;				FacePtr=(char*)LL;				facerb=(plane0->pi_Rect.right-plane0->pi_Rect.left);				facerb++;				ss=plane0->pi_Baseline;    // la base line du plan				if (FontRender->Plane_Number>1) { // dans le cas d'une police à 2 plans					LL=(unsigned long)plane1->pi_PlaneBase;					LL+=(unsigned long)BasePtr;					BorderPtr=(char*)LL;					borderrb=(plane1->pi_Rect.right-plane1->pi_Rect.left);					borderrb++;					ss=plane1->pi_Baseline;    // la base line du  plan				}				if (FontRender->Plane_Number>2) {// dans le cas d'une police à 3 plans					LL=(unsigned long)plane2->pi_PlaneBase;					LL+=(unsigned long)BasePtr;					ShadowPtr=(char*)LL;					shadowrb=(plane2->pi_Rect.right-plane2->pi_Rect.left);					shadowrb++;					ss=plane2->pi_Baseline;    // la base line du plan				}// 	calcul du pointeur dans le plan de destination//	base line négative et Ypos positif// 	note ss (sigend short) et non pas autre chose//	contient la base line du plan de nombre le plus elevé// 	attention, car on suppose que le plan le plus élevé est celui qui est le plus haut// ceci est vrai dans le cas de 2 plan , mais incertitude pour le jour ou , il ya 3 plans// il y aura un choix à faire ....				ss+=Ypos;				if (ss<0) ss=0;				LL=ss*RowBytes;				LL+=Xpos*4; // x en 32 bits				LL+=(unsigned long)DisplayRamPtr;				baseadresse=(long*)LL;				// boucle verticale//note: chaque plan a un offset par rapport au rectangle global englobant le caractère// il faut effectuer un changement de coordonnées pour la lecture du pixel// boucle horizontale		for (y=0;y<=CurrentChar->CH_Rect.bottom;y++){		P4=(long*)baseadresse;	for (x=0;x<=CurrentChar->CH_Rect.right;x++){	// on recupère la valeur dans chaque plan de la source /et on effectue le calcul de la couleur du pixel	// note: il faut effectuer un test pour savoir si le pixel est present dans le plan de la source	// le traitement s'effectue dans cet ordre ...			switch(drapeau){// on détermine la couleur du pixel du fond				case	1:	// couleur demandee					Pixel=bgd_Color; //G.RGB_OutlineBoxColor ?					fact=00;				break;								case 2: //blend avec le fond existant					Pixel=*(P4);					fact=0xFF;	// opacitée 100%				break;						default: // noir transparent					Pixel=00;					fact=0xFF;				break;			}						/*			if (ShadowPtr){				if (PtInRect(pt,&plane2->pi_Rect)){				LL=shadowrb*(y-plane2->pi_Rect.top); //y pos				LL+=x-plane2->pi_Rect.left;	//x pos				LL+=(unsigned long)ShadowPtr;				P2=(char*)LL;				fact=*(P2); 			//	Pixel=MultiplyPixel(Pixel,Shadow_Color,fact);				} 			}						*/			if (BorderPtr){			 	 if (Pt_InRect(x,y,&plane1->pi_Rect)){					LL=borderrb*(y-plane1->pi_Rect.top); //y pos					LL+=(x-plane1->pi_Rect.left);	//x pos					LL+=(unsigned long)BorderPtr;					P2=(char*)LL;					fact=*(P2);					fact=fact&0xff;					Pixel=MultiplyPixel(Pixel,Border_Color,fact);					//Pixel=(fact<<24)+(fact<<16)+(fact<<8)+(fact);				} 				}									if (FacePtr){			 	if (Pt_InRect(x,y,&plane0->pi_Rect)){					LL=(y-plane0->pi_Rect.top)*facerb; 					LL+=(x-plane0->pi_Rect.left);		//x pos					LL+=(unsigned long)FacePtr;					P2=(char*)LL;					fact=*(P2);					fact=fact&0xff;					//Pixel=(fact<<24)+(fact<<16)+(fact<<8)+(fact);					Pixel=MultiplyPixel(Pixel,Face_Color,fact);				} 																}		// on ecrit la valeur du pixel			*(P4)=Pixel;			P4++;		} // for X	baseadresse+=(unsigned long)RowBytes/4; // l'addresse de destination dans la ram 	} // for Y	//on retourne la largeur du pixel ....	return (CurrentChar->CH_Rect.right-CurrentChar->CH_Rect.left);} //C_Draw_A_Char// cette routine calcule le produit matriciel de 2 pixels en format AAAAAAAA RRRRRRRR GGGGGGGG BBBBBBBBstatic unsigned long MultiplyPixel(unsigned long bgd,unsigned long fgd,short fact){unsigned long 	a,r,g,b,a2,r2,g2,b2,a3,r3,g3,b3,temp,temp1;unsigned short	m,m_1;		//on calcule les coéfficients		m=fact;		m_1=255-fact;	//multiplicateur inverse		//on récupère les valeurs de multiplication		//background		a2=bgd&0xff000000;		r2=bgd&0xff0000;		g2=bgd&0xff00;		b2=bgd&0xff;		//foreground				a3=fgd&0xff000000;		r3=fgd&0xff0000;		g3=fgd&0xff00;		b3=fgd&0xff;	// alpha		temp=a2>>24;		temp1=a3>>24;		a=temp1*m+temp*m_1;		a=a&0xff00;		a=a<<16;			// rouge		temp=r2>>16;		temp1=r3>>16;		r=temp1*m+temp*m_1;		r=r&0xff00;		r=r<<8;	//vert		temp=g2>>8;		temp1=g3>>8;		g=temp1*m+temp*m_1;		g=g&0xff00;	//bleu		temp=b2;		temp1=b3;		b=temp1*m+temp*m_1;		b=b&0xff00;		b=b>>8;										return a+r+g+b;} //MultiplyPixel// Cette routine test si un point est dans un rectangle// note: extrémitées incluses , ce qui est différents des fonctions normal du macstatic short   Pt_InRect(short x, short y,Rect *rec){	if (x>rec->right) return 0;	if (x<rec->left) return 0;	if (y>rec->bottom) return 0;	if (y<rec->top) return 0;	 	return true;}/*; ---;; rappel  :     	ptr style 1		<-  début du font bitmaps	);				  / / / / 									) header font bitmap;				ptr style n									) ;;				headerCharN°1	<- début 1 er style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn;				    / / / /;				headerCharN°1	<- début n ème style, début 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN°n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn; (il faut réserver un  long ptr pour chaque style) ; il faudra changer le nom face number par style number (nombre de style dans le bitmap); initialisation du Displayfont header en tête */