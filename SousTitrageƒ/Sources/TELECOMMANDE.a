	PRINT	PUSH,OFF				INCLUDE	'ToolEqu.a'	INCLUDE	'Traps.a'	INCLUDE	'PackMacs.a'	INCLUDE	'QuickEqu.a'	INCLUDE	'SysEqu.a'	INCLUDE	'BB.Records.a'	INCLUDE	'StandardFile.a'		INCLUDE	'PackMacs.a'	INCLUDE	'intenv.a'		; so we can get our args, open files, etc.	INCLUDE	'signal.a'		; so we can handle 'Command-.'	INCLUDE	'TimeEqu.a'		; pour utiliser le time manager		PRINT	POP 		IMPORT	qd:MyQDGlobals		IMPORT	G:AppGlobals**   ROUTINES DE TELECOMMANDES DE MAGNETOSCOPES AU PROTOCOLE SONY*	* ===============================================================*  PROCEDURE  TxRS422_Interrupt (ORDRE: long,parram: long,Refnum: short)* ===============================================================**	c'est la même routine que TxRS422 mais sous interruption*	fct à transmettre    *	PLAY,STOP,FFWD,etc…**	donnée: long**  n° de port série     TxRS422_Interrupt 	proc	ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointcommande	ds.l	1		; code de commandeParrametres	ds.l	1		; parramètres à envoyer (adresse ou données en fct de la commande)Refnum		ds.w	1		; n° du port du magnétoscopeParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkDataBuffer		ds.b	64Tx_paramblock	ds.b	64LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII		movem.l d1-d7/a1-a4,-(sp); DISPATCH DES ORDRES		tst.w Refnum(a6)		beq 	 Exit				move.l	commande(a6),d0		case#.l	(d0,if),\		('TIME',TIMECODESENSE),\		('STAT',STATUSSENSE),\		('PLAY',PLAY),\		('STOP',STOP),\		('FFWD',FFWD),\		('FREW',FREW),\		('SHTL',SHTL),\		('JOG ',JOG),\		('VAR ',VAR),\		('EDPR',EDITPRESET),\		('EDON',EDITON),\		('EDOF',EDITOFF),\		('SLEE',SELECTEE),\		('EEON',FULLEEON),\		('EEOF',FULLEEOFF),\		('SEAR',SEARCH),\		('SBON',STANDBYON),\		('SBOF',STANDBYOFF),\		('Pla+',SPEEDPLAYplus),\		('Pla-',SPEEDPLAYmoin),\		('DEV?',DeviceCheck),\		('EJEC',EJECT),\		('Wsta',SendStatus)\		('W tc',SendTC)			; pour émettre un time code		bra		Exit; PLAY 			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$01,2(a0)				move.b	#$02,(a0)							bra		CalculeCheckSum; -------------EJECT 			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$0F,2(a0)				move.b	#$02,(a0)							bra		CalculeCheckSum; -----STOP 			lea		DataBuffer(a6),a0						move.b	#$20,1(a0)				move.b	#$00,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FFWD  			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$10,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FREW  			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$20,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----SHTL  			lea		DataBuffer(a6),a0				move.b	#$13,2(a0)				bra.s	SimpleOuDoublePrecision; -----JOG  			lea		DataBuffer(a6),a0				move.b	#$11,2(a0)				bra.s	SimpleOuDoublePrecision; -----VAR  			lea		DataBuffer(a6),a0				move.b	#$12,2(a0)				bra.s	SimpleOuDoublePrecision; -----				SimpleOuDoublePrecision				; on détermine le sens demandé				move.l	Parrametres(a6),d0				TST.W	D0				bpl.s	Forward			; bit 32= 0 => forward				add.b	#$10,2(a0)		; on ajoute $10 pour indiquer reverseForward							move.l	Parrametres(a6),d0				and.l	#$ffff0000,d0		; simple ou double précision double si b15-b8≠ 0				bne.s	DoublePrecision	 ; simple précision				move.b	#$21,1(a0)				move.L	Parrametres(a6),d0				tst.w	d0				bpl.s	SimplePositif					neg.w	d0SimplePositif	move.b	d0,3(a0)				move.b	#3,(a0)					bra		CalculeCheckSum;DoublePrecision				move.b	#$22,1(a0)				move.L	Parrametres(a6),d0				tst.w	d0				bpl.s	DoublePositif_1					neg.w	d0DoublePositif_1	move.b	d0,3(a0)				swap	d0				move.b	d0,4(a0)				move.b	#4,(a0)					bra		CalculeCheckSum; -----EDITPRESET 		lea		DataBuffer(a6),a0				move.b	#$41,1(a0)				move.b	#$30,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#03,(a0)				bra		CalculeCheckSum; -----EDITON  		lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$65,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----EDITOFF 		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$64,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----SELECTEE  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$63,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FULLEEON  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$61,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FULLEEOFF  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$60,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----SEARCH  		lea		DataBuffer(a6),a0 				move.b	#$24,1(a0)				move.b	#$31,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				ror.l	#4,d0				move.b	d0,4(a0)				ror.l	#4,d0				move.b	d0,5(a0)				ror.l	#4,d0				move.b	d0,6(a0)				move.b	#$06,(a0)				bra		CalculeCheckSum; -----STANDBYON  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$05,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----STANDBYOFF  	lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$04,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----TIMECODESENSE  	lea		DataBuffer(a6),a0				move.b	#$61,1(a0)				move.b	#$0C,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)							move.b	#$03,(a0)				bra		CalculeCheckSum; -----STATUSSENSE  	lea		DataBuffer(a6),a0 				move.b	#$61,1(a0)				move.b	#$20,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#$03,(a0)				bra		CalculeCheckSum; -----SPEEDPLAYplus 	lea		DataBuffer(a6),a0 				move.b	#$21,1(a0)				move.b	#$38,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#$03,(a0)				bra		CalculeCheckSum; -----SPEEDPLAYmoin 	lea		DataBuffer(a6),a0 				move.b	#$21,1(a0)				move.b	#$39,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#$03,(a0)				bra		CalculeCheckSum; -----DeviceCheck		lea		DataBuffer(a6),a0 				move.b	#$00,1(a0)				move.b	#$11,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum				; ------SendTC			lea		DataBuffer(a6),a0 				move.b	#$6,(a0)				move.b	#$74,1(a0)				move.b	#$04,2(a0)								move.l	Parrametres(a6),d0				move.b	d0,3(a0)				lsr.L	#8,d0				move.b	d0,4(a0)				lsr.L	#8,d0				move.b	d0,5(a0)				lsr.L	#8,d0				move.b	d0,6(a0)												bra		CalculeCheckSum; ------SendStatus				lea		DataBuffer(a6),a0 				move.b	#$6,(a0)				move.b	#$7a,1(a0)				move.b	#$20,2(a0)								move.l	Parrametres(a6),a1				move.b	(a1),3(a0)				move.b	1(a1),4(a0)				move.b	2(a1),5(a0)				move.b	3(a1),6(a0)								move.b	4(a1),7(a0)				move.b	5(a1),8(a0)				move.b	6(a1),9(a0)				move.b	7(a1),10(a0)				move.b	8(a1),11(a0)				move.b	9(a1),12(a0)								bra		CalculeCheckSum; -------------------CalculeCheckSum; on calcule le check-sum  de la chaîne à transmettre, puis on envoie le message		lea.l	DataBuffer(a6),a0		moveq	#0,d0		moveq	#0,d1			move.b	(a0),d1		move.l	d1,d7		subq.w	#1,d7	; on soustrait 1 pour le dbraCheckSumLoop		add.b	1(a0,d7.w),d0	; calcule le dbra		dbra.w	d7,CheckSumLoop				move.b	d0,1(a0,d1.w)	; adresse du checksum		add.b	#1,(a0)			; 1 octets en plus; on envoie l'ordre au magnétoscope				lea		Tx_paramblock(a6),a0 		clr.w	22(a0)		move.w	Refnum(a6),ioRefNum(a0)			;  tx				lea		DataBuffer(a6),a1		moveq	#0,d0		move.b	(a1)+,d0		 		move.l	a1,32(a0)	; ioBuffer 		move.l	d0,ioReqCount(a0)	; nombre de données à transmettre		 		move.w	#FsatMark,ioPosMode(a0)	;fsfromStart 		clr.l	ioPosOffset(a0)		; de la position 0		clr.l	ioCompletion(a0)   		_Write 	,async Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.New		TxRS422_Interrupt		ENDP* ===============================================================*  PROCEDURE  TxRS422 (ORDRE: long,parram: long,Refnum: short)* ===============================================================**	c'est la même routine que TxRS422 mais sous interruption*	fct à transmettre    *	PLAY,STOP,FFWD,etc…**	donnée: long**  n° de port série     TxRS422 	proc	ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointcommande	ds.l	1		; code de commandeParrametres	ds.l	1		; parramètres à envoyer (adresse ou données en fct de la commande)Refnum		ds.w	1		; n° du port du magnétoscopeParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkDataBuffer		ds.b	64Tx_paramblock	ds.b	64LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII		movem.l d1-d7/a1-a4,-(sp); DISPATCH DES ORDRES		tst.w Refnum(a6)		beq 	 Exit				move.l	commande(a6),d0		case#.l	(d0,if),\		('TIME',TIMECODESENSE),\		('STAT',STATUSSENSE),\		('PLAY',PLAY),\		('STOP',STOP),\		('FFWD',FFWD),\		('FREW',FREW),\		('SHTL',SHTL),\		('JOG ',JOG),\		('VAR ',VAR),\		('EDPR',EDITPRESET),\		('EDON',EDITON),\		('EDOF',EDITOFF),\		('SLEE',SELECTEE),\		('EEON',FULLEEON),\		('EEOF',FULLEEOFF),\		('SEAR',SEARCH),\		('SBON',STANDBYON),\		('SBOF',STANDBYOFF),\		('Pla+',SPEEDPLAYplus),\		('Pla-',SPEEDPLAYmoin),\		('DEV?',DeviceCheck),\		('EJEC',EJECT),\		('TCOU',PresetOutTC),\		('TCIN',PresetINTC),\		('EDIT',AutoEdit),\		('PRER',Preroll),\		('PRTP',PrerollTimePreset),\		('LLRE',LostLockReset),\		('WSta',SendStatus)\		('W tc',SendTC)			; pour émettre un time code		bra		ExitPrerollTimePreset  					lea		DataBuffer(a6),a0 				move.b	#$44,1(a0)				move.b	#$31,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				ror.l	#8,d0				move.b	d0,4(a0)				ror.l	#8,d0				move.b	d0,5(a0)				ror.l	#8,d0				move.b	d0,6(a0)				move.b	#$06,(a0)				bra		CalculeCheckSum; -----------------				LostLockReset		lea		DataBuffer(a6),a0 			move.b	#$40,1(a0)			move.b	#$2D,2(a0)			move.b	#$02,(a0)					bra		CalculeCheckSum; -------------------	Preroll		lea		DataBuffer(a6),a0 			move.b	#$20,1(a0)			move.b	#$30,2(a0)			move.b	#$02,(a0)					bra		CalculeCheckSum; -------------------AutoEdit	lea		DataBuffer(a6),a0 			move.b	#$20,1(a0)			move.b	#$42,2(a0)			move.b	#$02,(a0)					bra		CalculeCheckSum; -------------------PresetINTC  	lea		DataBuffer(a6),a0 				move.b	#$44,1(a0)				move.b	#$14,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				ror.l	#8,d0				move.b	d0,4(a0)				ror.l	#8,d0				move.b	d0,5(a0)				ror.l	#8,d0				move.b	d0,6(a0)				move.b	#$06,(a0)				bra		CalculeCheckSum; -----------------				PresetOutTC  	lea		DataBuffer(a6),a0 				move.b	#$44,1(a0)				move.b	#$15,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				ror.l	#8,d0				move.b	d0,4(a0)				ror.l	#8,d0				move.b	d0,5(a0)				ror.l	#8,d0				move.b	d0,6(a0)				move.b	#$06,(a0)				bra		CalculeCheckSum; -------------				PLAY 			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$01,2(a0)				move.b	#$02,(a0)							bra		CalculeCheckSum; -------------EJECT 			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$0F,2(a0)				move.b	#$02,(a0)							bra		CalculeCheckSum; -----STOP 			lea		DataBuffer(a6),a0						move.b	#$20,1(a0)				move.b	#$00,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FFWD  			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$10,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FREW  			lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$20,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----SHTL  			lea		DataBuffer(a6),a0				move.b	#$13,2(a0)				bra.s	SimpleOuDoublePrecision; -----JOG  			lea		DataBuffer(a6),a0				move.b	#$11,2(a0)				bra.s	SimpleOuDoublePrecision; -----VAR  			lea		DataBuffer(a6),a0				move.b	#$12,2(a0)				bra.s	SimpleOuDoublePrecision; -----				SimpleOuDoublePrecision				; on détermine le sens demandé				move.l	Parrametres(a6),d0				TST.W	D0				bpl.s	Forward			; bit 32= 0 => forward				add.b	#$10,2(a0)		; on ajoute $10 pour indiquer reverseForward							move.l	Parrametres(a6),d0				and.l	#$ffff0000,d0		; simple ou double précision double si b15-b8≠ 0				bne.s	DoublePrecision	 ; simple précision				move.b	#$21,1(a0)				move.L	Parrametres(a6),d0				tst.w	d0				bpl.s	SimplePositif					neg.w	d0SimplePositif	move.b	d0,3(a0)				move.b	#3,(a0)					bra		CalculeCheckSum;DoublePrecision				move.b	#$22,1(a0)				move.L	Parrametres(a6),d0				tst.w	d0				bpl.s	DoublePositif_1					neg.w	d0DoublePositif_1	move.b	d0,3(a0)				swap	d0				move.b	d0,4(a0)				move.b	#4,(a0)					bra		CalculeCheckSum; -----EDITPRESET 		lea		DataBuffer(a6),a0				move.b	#$41,1(a0)				move.b	#$30,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#03,(a0)				bra		CalculeCheckSum; -----EDITON  		lea		DataBuffer(a6),a0				move.b	#$20,1(a0)				move.b	#$65,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----EDITOFF 		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$64,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----SELECTEE  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$63,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FULLEEON  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$61,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----FULLEEOFF  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$60,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----SEARCH  		lea		DataBuffer(a6),a0 				move.b	#$24,1(a0)				move.b	#$31,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				ror.l	#8,d0				move.b	d0,4(a0)				ror.l	#8,d0				move.b	d0,5(a0)				ror.l	#8,d0				move.b	d0,6(a0)				move.b	#$06,(a0)				bra		CalculeCheckSum; -----STANDBYON  		lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$05,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----STANDBYOFF  	lea		DataBuffer(a6),a0 				move.b	#$20,1(a0)				move.b	#$04,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum; -----TIMECODESENSE  	lea		DataBuffer(a6),a0				move.b	#$61,1(a0)				move.b	#$0C,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)							move.b	#$03,(a0)				bra		CalculeCheckSum; -----STATUSSENSE  	lea		DataBuffer(a6),a0 				move.b	#$61,1(a0)				move.b	#$20,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#$03,(a0)				bra		CalculeCheckSum; -----SPEEDPLAYplus 	lea		DataBuffer(a6),a0 				move.b	#$21,1(a0)				move.b	#$38,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#$03,(a0)				bra		CalculeCheckSum; -----SPEEDPLAYmoin 	lea		DataBuffer(a6),a0 				move.b	#$21,1(a0)				move.b	#$39,2(a0)				move.l	Parrametres(a6),d0				move.b	d0,3(a0)				move.b	#$03,(a0)				bra		CalculeCheckSum; -----DeviceCheck		lea		DataBuffer(a6),a0 				move.b	#$00,1(a0)				move.b	#$11,2(a0)				move.b	#$02,(a0)				bra		CalculeCheckSum				; ------SendTC			lea		DataBuffer(a6),a0 				move.b	#$6,(a0)				move.b	#$74,1(a0)				move.b	#$04,2(a0)								move.l	Parrametres(a6),d0				move.b	d0,3(a0)				lsr.L	#8,d0				move.b	d0,4(a0)				lsr.L	#8,d0				move.b	d0,5(a0)				lsr.L	#8,d0				move.b	d0,6(a0)												bra		CalculeCheckSum; ------SendStatus				lea		DataBuffer(a6),a0 				move.b	#$6,(a0)				move.b	#$7a,1(a0)				move.b	#$20,2(a0)								move.l	Parrametres(a6),a1				move.b	(a1),3(a0)				move.b	1(a1),4(a0)				move.b	2(a1),5(a0)				move.b	3(a1),6(a0)								move.b	4(a1),7(a0)				move.b	5(a1),8(a0)				move.b	6(a1),9(a0)				move.b	7(a1),10(a0)				move.b	8(a1),11(a0)				move.b	9(a1),12(a0)								bra		CalculeCheckSum; -------------------CalculeCheckSum; on calcule le check-sum  de la chaîne à transmettre, puis on envoie le message		lea.l	DataBuffer(a6),a0		moveq	#0,d0		moveq	#0,d1			move.b	(a0),d1		move.l	d1,d7		subq.w	#1,d7	; on soustrait 1 pour le dbraCheckSumLoop		add.b	1(a0,d7.w),d0	; calcule le dbra		dbra.w	d7,CheckSumLoop				move.b	d0,1(a0,d1.w)	; adresse du checksum		add.b	#1,(a0)			; 1 octets en plus; on envoie l'ordre au magnétoscopesendorders				lea		Tx_paramblock(a6),a0 		clr.w	22(a0)		 		move.w	Refnum(a6),ioRefNum(a0)			;  tx				lea		DataBuffer(a6),a1		moveq	#0,d0		move.b	(a1)+,d0		 		move.l	a1,32(a0)	; ioBuffer 		move.l	d0,ioReqCount(a0)	; nombre de données à transmettre		 		move.w	#FsatMark,ioPosMode(a0)	;fsfromStart 		clr.l	ioPosOffset(a0)		; de la position 0		clr.l	ioCompletion(a0)   		_Write 	 		Exit	movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo.New		TxRS422		ENDP* ===============================================================*  PROCEDURE  RxRS422 (ORDRE: D0,VTR: D1, DATA D2 )* ===============================================================** 	Décode les informations reçues d'un vtr, protocole SONY**	format :*	a0= pointeur chaine de données*	d0= vtr id (-8= (printer); -6= (modem); ≠ => futur extensions)* 	a5 = pointe sur les variables global du programme*	retour: d0= err	, si≠0 => err   *RxRS422 	proc	Export			with	VtrStatusRecord,soustitreRecord					move.b	(a0),d0		; on regarde le code de fonction cmd1		and.w	#$f0,d0		case#.w	(d0,if),\		($10,fctReturn),\		($70,SenseReturn)		bra		Error; ---------; code de fonction retour de valeur , status, time-codeSenseReturn				move.b	1(a0),d0	; CMD 2		and.w	#$ff,d0		case#.w	(d0,if),\		(0,CTL_1),\			; tape timer 1		(1,CTL_2),\			; tape timer 2		(4,LTC),\			; ltc time		(5,LTC_UB),\		; ltc user bits		(6,VITC),\			; VITC time code		(7,VITC_UB),\		; VITC user bits		($14,LTC),\			; ltc corigé		($15,LTC_UB),\		; user bit corrigés		($16,VITC_UB),\		; user bit corrigés		($20,STATUS),\		; status		($3E,RecordInhibitSense)			bra		error		; on se fout des autres codes; ---------; retour des focntions		fctReturn				move.b	1(a0),d0	; CMD 2		and.w	#$ff,d0		case#.w	(d0,if),\		($01,ack),\		($12,Nack),\		($11,DeviceType)		bra		Error		; erreur; --------; traitement des codes	CTL_1				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Exit	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_TTM1(a1),a1				move.b	2(a0),3(a1)				move.b	3(a0),2(a1)				move.b	4(a0),1(a1)				move.b	5(a0),0(a1)								bra		Exit; --------CTL_2				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Exit	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)								lea		vtr_TTM2(a1),a1				move.b	2(a0),3(a1)				move.b	3(a0),2(a1)				move.b	4(a0),1(a1)				move.b	5(a0),0(a1)				bra		Exit; --------LTC				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Exit	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_LTC(a1),a1				move.b	2(a0),3(a1)				move.b	3(a0),2(a1)				move.b	4(a0),1(a1)				move.b	5(a0),0(a1)				move.l	(a1),G.LastRecevied422TC	; pour le mode auto Ltc/vitc				bra		Exit; --------LTC_UB				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Exit	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_LTC_UB(a1),a1				move.b	2(a0),3(a1)				move.b	3(a0),2(a1)				move.b	4(a0),1(a1)				move.b	5(a0),0(a1)				move.l	(a1),G.LastRecevied422TC	; pour le mode auto Ltc/vitc				bra		Exit; --------VITC			jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Exit	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_VITC(a1),a1				move.b	2(a0),3(a1)				move.b	3(a0),2(a1)				move.b	4(a0),1(a1)				move.b	5(a0),0(a1)				move.l	(a1),G.LastRecevied422TC	; pour le mode auto Ltc/vitc				bra		ExitVITC_UB				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Exit	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_VITC_UB(a1),a1				move.b	2(a0),3(a1)				move.b	3(a0),2(a1)				move.b	4(a0),1(a1)				move.b	5(a0),0(a1)				bra		Exit; --------STATUS			jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Error	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_status(a1),a1				move.b	2(a0),(a1)				move.b	3(a0),1(a1)				move.b	4(a0),2(a1)				move.b	5(a0),3(a1)				move.b	6(a0),4(a1)				move.b	7(a0),5(a1)				move.b	8(a0),6(a1)				move.b	9(a0),7(a1)				move.b	10(a0),8(a1)				move.b	11(a0),9(a1)								bra		Exit; --------RecordInhibitSense				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Error	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				lea		vtr_recInhibit(a1),a1				move.b	3(a0),(a1)				move.b	4(a0),1(a1)					bra		Exit; --------ack				jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Error	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				bra		Exit; --------Nack			jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Error	; erreur				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				moveq	#0,d0				move.b	3(a0),d0				move.b	d0,vtr_error(a1)				bra		Exit; --------DeviceType		jsr		GetVtrInfoStructurePtr				cmpa.l	#0,a1				beq		Error	; erreur				clr.w	vtr_error(a1)				move.l	Ticks,d0				move.l	d0,vtr_Ticks(a1)				move.b	3(a0),vtr_Type(a1)				move.b	4(a0),1+vtr_Type(a1)						bra		Exit; --------; erreur de réception on place -1 pour indiquer celaerror			move.w	#-1,d0		; pas protocole sony				bra		Exit_2; --------Exit			move.w	#0,d0				; ok protocole sonyExit_2				rts				JMP	(A0); routine donnant l'adresse dans a1 de la structure GetVtrInfoStructurePtr; par défaut pour l'instant		lea		G.PlayerStruct,a1		rts						DbgInfo.New		RxRS422		ENDP* ======================================================================	* readVitcComplete* ======================================================================	; routine appelée quand la lecture des autres caractères à été effectuerreadVitcComplete	 	proc	ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkInputParamBlock	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,VtrStatusRecord,soustitreRecord			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII; a0 contient le ptr du paramblock, do contient le code résultat de l'opération		cmp.w	#-27,d0		beq.s	AbortError		cmp.w	#$ffcd,d0		bne.s	PasAbortErrorAbortError	moveq	#0,d0	move.w	d0,IoResult(a0)	UNLK	A6	MOVEA.L	(SP)+,A0		; save the caller's address	ADDA.L	#ParamSize,SP		; strip the caller's parameters	JMP	(A0)	; oui 	PasAbortError	movem.l	d2/A3-a5,-(sp)	; sauvegarde registre a5	move.l	-4(A0),a5	clr.w	IoResult(a0)	move.l	a0,InputParamBlock(a6)			TST.W	d0	bne		waitHeader	; ON a perdu des données,il faut resynchroniser !!!!!!!!!!!!!	; on a recu les caractères on analyse la reception 	move.l	32(a0),a1		; le buffer rx	moveq	#0,d0	; on regarde si nous sommes toujours en sychro avec le lecteur de vitc		move.b	0(a1),d1	and.b	#$f0,d1	cmp.b	#$70,d1	bne		waitHeader		; perte de synchronisation	SuiteLectureTc		move.b	0(a1),d1	and.b	#$03,d1	rol.l	#4,d0	add.b	d1,d0		tst.b	d1	beq.s 	@2@2		move.b	1(a1),d1	and.b	#$0f,d1	rol.l	#4,d0	add.b	d1,d0		move.b	2(a1),d1	and.b	#$07,d1	rol.l	#4,d0	add.b	d1,d0		move.b	3(a1),d1	and.b	#$0f,d1	rol.l	#4,d0	add.b	d1,d0		move.b	4(a1),d1	and.b	#$07,d1	rol.l	#4,d0	add.b	d1,d0		move.b	5(a1),d1	and.b	#$0f,d1	rol.l	#4,d0	add.b	d1,d0		move.b	6(a1),d1	and.b	#$03,d1	rol.l	#4,d0	add.b	d1,d0		move.b	7(a1),d1	and.b	#$0f,d1	rol.l	#4,d0	add.b	d1,d0	move.b	0(a1),d1		; test du field reçu	and.b	#8,d1	beq.s	Pasfield2		; field 1/2;	or.l	#$80000000,d0 ; field 2pasfield2		move.l	d0,G.Vitc_Readen	move.l	G.General_TCCourant,G.General_LastTCCourant	and.l	#$3f7f7f3f,d0	move.l	d0,G.General_TCCourant		; on place le tc courant dans la case; on s'occupe d'activer le voyant série		tst.w	G.SerialError		; faut-il redessiner le flag		bne.s	@1		move.w	#25,G.SerialError		bra		GotTC@1		move.w	#22,G.SerialError	GotTC	; on remmande une lecture de 9 octets (on est en sync ->pas de problème)			move.l	InputParamBlock(a6),a0 	move.l	32(a0),d0		; le buffer rx 	and.l	#$fffffffe,d0 	move.l	d0,32(a0)		; le buffer rx 	move.l	#8,ioReqCount(a0) 	move.w	#fsatMark,ioPosMode(a0) 	clr.l	ioPosOffset(a0)	lea		readVitcComplete,a1	move.l	a1,ioCompletion(a0)  	_Read	,async	bra		exit			; ---- il y a une erreur de reception on repart à la routine principale				; on  demande lecture d'un octet	waitHeader 		move.l	InputParamBlock(a6),a0 		move.l	32(a0),d0		; le buffer rx 		and.l	#$fffffffe,d0 		move.l	d0,32(a0)		; le buffer rx 		move.l	#1,ioReqCount(a0) 		import 	SERIAL; routine de gestion du port serie 		lea 	SERIAL,a1					; routine de gestion du port serie 		move.l	a1,ioCompletion(a0) 		clr.l	ioPosOffset(a0) 		move.w	#fsatMark,ioPosMode(a0) 	   	_Read	,async	Exit	movem.l	(sp)+,d2/A3-a5		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	readVitcComplete		; this name will appear in the debugger		align 4			ENDP* ======================================================================	* SonyCompleteReceiveMessage * ======================================================================	; routine appelée quand la lecture des autres caractères à été effectuerSonyCompleteReceiveMessage	 	proc	ExportStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkInputParamBlock	ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			WITH	StackFrame,VtrStatusRecord,soustitreRecord			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII; a0 contient le ptr du paramblock, do contient le code résultat de l'opération		cmp.w	#-27,d0		beq.s	AbortError		cmp.w	#$ffcd,d0		bne.s	PasAbortErrorAbortError		moveq	#0,d0		move.w	d0,IoResult(a0)		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)	; oui 	PasAbortError		movem.l	d2/A3-a5,-(sp)	; sauvegarde registre a5				move.l	-4(A0),a5		clr.w	IoResult(a0)		move.l	a0,InputParamBlock(a6)				TST.W	d0		bne		waitHeader	; ON a perdu des données,il faut resynchroniser !!!!!!!!!!!!!	; erreur sur infos reçues				move.l	32(a0),d0		; le buffer rx		and.l	#$fffffffe,d0		move.l	d0,A1		move.b	(a1),d0		and.b	#$f0,d0		cmp.b	#$10,d0		beq 	WaitHeader	;on redemande une lecture du port série	; pas visiblement de problèmes on analyse la reception		move.l	A1,A0		jsr		RxRS422				; maintenant on recopie pour le logiciel le time code 		move.w	G.Player_TC_src,d0		; type de tc demandé 		bne.s	PasModeAutoLtcVitc			; mode Auto Ltc/Vitc				move.l	G.LastRecevied422TC,d0		bra.S	GotTC		PasModeAutoLtcVitc		subq.w	#1,d0		lsl.w	#2,d0			lea.l	G.PlayerStruct,a1 			move.l	vtr_LTC(a1,d0.w),d0GotTC			move.l	G.General_TCCourant,G.General_LastTCCourant		and.l	#$3f7f7f3f,d0		move.l	d0,G.General_TCCourant		; on place le tc courant dans la case; a3 pointe sur la structure du vtr; on reset le chien de garde;		move.l	#15,VtrChienDeGarde(a5)	; ! pb Quelle machine		; on  demande lecture d'un octet	; on utilise le PB déja préparé pour cet effetwaitHeader		lea		G.Main_Rx_PB,a0 		move.l	32(a0),d0		; le buffer rx 		and.l	#$fffffffe,d0 		move.l	d0,32(a0)		; le buffer rx 		move.l	#1,ioReqCount(a0) 		clr.l	ioPosOffset(a0) 		move.w	#fsFromStart,ioPosMode(a0) 	   	_Read	,async	Exit	movem.l	(sp)+,d2/A3-a5		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.New	SonyCompleteReceiveMessage		; this name will appear in the debugger		align 4			ENDP				End* =================================================* PROCEDUREs SPECIALEs POUR LA LECTURE DU PORT SERIEL* PROCEDURE	SERIAL()* =================================================** a0 = paramBlockPtr => on connais l'adresse des variable globales de bbSERIAL		PROC EXPORT			with		VtrStatusRecord,soustitreRecordserialbis				; entrée 1 de la routine 	cmp.w	#-27,d0	beq.s	AbortError_1	cmp.w	#$ffcd,d0	bne.s	PasAbortError_1AbortError_1		moveq	#0,d0	move.w	d0,IoResult(a0)	rts	PasAbortError_1			movem.l	d1-d7/A5,-(sp)	; sauvegarde registre a5	move.l	-4(a0),a5		; le contenu de a5 est placé devant chaque buffer; en cas d'erreur on raz la lecture série		tst.w	d0	bne 	waitHeader2		; ------------------------------------	; Quel mode série ?		ModeLecteurVitc		cmp.w	#1,G.LecteurTimeCode_Type	bne.s	ModeRS422			lea.l	G.Rx_Modem_Buffer,a1	; a1= adresse du buffer (variable globale)	move.b	(a1),d0	and.b	#$f0,d0	cmp.b	#$00,d0	bne 	waitHeader2				; in sync ?; oui in sync		lea		G.Rx_modem_paramblock,a0 	clr.w	22(a0) 	move.w	G.ModemInRefNum,ioRefNum(a0) 		lea.l	G.Rx_Modem_Buffer,a1	; a1= adresse du buffer (variable globale)	move.l	a1,32(a0) 	move.l	#8,ioReqCount(a0) 	move.w	#fsatMark,ioPosMode(a0) 	clr.l	ioPosOffset(a0)	import	readVitcComplete	lea		readVitcComplete,a1	move.l	a1,ioCompletion(a0)  	_Read	,async	bra		Exit; ------------------------------------	ModeRS422		cmp.w	#2,G.LecteurTimeCode_Type	bne 	exit		lea.l	G.Rx_Modem_Buffer,a1		; le buffer rx du lecteur	move.b	(a1),d0	and.b	#$f0,d0	cmp.b	#$10,d0 	beq 	WaitHeader2	;on redemande une lecture du port série	cmp.b	#$70,d0 	beq.s	lecteur_ProtocoleSony_Good 	bra		WaitHeader2	;on redemande une lecture du port série;----lecteur_ProtocoleSony_Good		tst.w	G.SerialError		; faut-il redessiner le flag	bne.s	@1	move.w	#25,G.SerialError	bra		GotTC@1	move.w	#22,G.SerialErrorGotTC	move.b	(a1),d0	and.l	#$f,d0		; nombre de caractère à lire (du mesage du vtr)	addq.l	#2,d0		; cmd1 + cmd 2 + checksum		lea.l	G.Rx_modem_paramblock,a0	clr.w	22(a0)		clr.w	IoResult(a0)	lea.l	G.Rx_Modem_Buffer,a1	lea.l	1(a1),a1				; nombre de caractères à lire 	move.l	a1,32(a0) 	move.l	d0,ioReqCount(a0)	 	move.w	#fsAtMark,ioPosMode(a0)	 	move.l	#0,ioPosOffset(a0)		import	SonyCompleteReceiveMessage	lea		SonyCompleteReceiveMessage,a1	move.l	a1,ioCompletion(a0)  	_Read	,async	bra		Exit;------------------------------------------; on redemande la lecture d'un autre octetswaitHeader2	lea		G.Rx_modem_paramblock,a0	clr.w	22(a0) 	lea.l	G.Rx_Modem_Buffer,a1		move.l	a1,32(a0) 	move.l	#1,ioReqCount(a0) 	move.w	#fsFromStart,ioPosMode(a0)	move.w	G.ModemInRefNum,ioRefNum(a0) 	clr.l	ioPosOffset(a0)	lea.l	SERIAL(pc),a1					; routine de gestion du port serie	move.l	a1,ioCompletion(a0)   	_Read	,async		exit	movem.l	(sp)+,d1-d7/a5		; on rend le contenu préalable de d5		RTS		DbgInfo.New	SERIALINT		; this name will appear in the debugger	align 4		ENDP