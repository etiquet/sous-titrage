#include "BB.Globals_C.h"#include <Devices.h>// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;	//#pragma segment C_UndoRedo	/*	Gestion des Undos :	-------------------	Quand on effectue une capture de tc ou bien une ouverture de texte	on stocke l'ancienne valeur dans une case tampon avec une indication	de temps.	Puis si l'utilisateur demande Undo, on prend le dernier évènement de la liste	on rend cette valeur	à l'endroit où elle a été prise,	et on transfère le contenu actuel dans la mémoire undo 	Doit-on mettre actif le sous-titre concerné lors d'un Undo ?	Ces parramètres sont-ils raz si insert ou delete un sous-titre ?	Combien faut-il garder de undo	Au bout de combien de temps il faut attendre pour faire un nouveau undo sur le texte ?	Undo sur renumérotation ?*/// element de UndoRedotypedef struct UndoRedoElement{short			Undo_Type; 			//type del'undolong				Undo_Ticks; 			//heure de l'undolong				Undo_AbsST;	 	//n° absolu du Sous-titrelong				Undo_Data; 			//timecode ou Handle	Handle			Undo_TexteHandle;Handle			Undo_StyleHandle;long				Undo_spare1;long				Undo_spare2;}UndoRedoElement,*UndoRedoElementPtr,**UndoRedoElementHandle;// structure principaletypedef struct	UndoRedoList{long							TotalElement;UndoRedoElement		Element[];}UndoRedoList,*UndoRedoListPtr,**UndoRedoListHandle;/* globales non exportées */static UndoRedoListHandle 			Undo_Stack;static UndoRedoListHandle 			Redo_Stack;static unsigned long 						Undo_LastTicks;static unsigned long 						Redo_LastTicks;/* prototype *//* routines locales */static pascal void ClearListe(UndoRedoListHandle list);static pascal void MetElementDansListe(UndoRedoListHandle list,short type,long ticks,long lastticks,long AbsNum,long data);static void ManageAlistForInsert(UndoRedoListHandle list,long AbsNum);static void ManageAlistForDelete(UndoRedoListHandle list,long AbsNum);/* routine exportée */pascal void InitUndoRedo(void);pascal void DoMakeUndo(short typeUndo,long ticks,long Abs_num,long Data);pascal void DoMakeRedo(short typeUndo,long ticks,long Abs_num,long Data);pascal void DoUseUndo(void);pascal void DoUseRedo(void);pascal void ManageUndoRedoListeForInsert(long AbsNum);pascal void ManageUndoRedoListeForDelete(long AbsNum);pascal void InitialiseUndoRedo(void);pascal void AdjustMenuUndo(void);/* ------ les routines ------ *//* cette routine est appellée 1 fois lors de l'initialisation du programme */pascal void InitUndoRedo(void){	Undo_Stack=nil;	Redo_Stack=nil;	Undo_LastTicks=0;	Redo_LastTicks=0;	InitialiseUndoRedo();}/* Routines pour placer des données dans une liste undo/redo	note : data peut ètre soit un tc en bcd (long)			soit un TEHandle si texte ou commentaire */pascal void DoMakeUndo(short typeUndo,long ticks,long Abs_num,long Data){		MetElementDansListe(Undo_Stack,typeUndo,ticks,Undo_LastTicks,Abs_num,Data);		Undo_LastTicks=ticks;} //pascal void DoMakeRedo(short typeUndo,long ticks,long Abs_num,long Data){		//MetElementDansListe(Redo_Stack,typeUndo,ticks,Redo_LastTicks,Abs_num,Data);		//Redo_LastTicks=ticks;} ///*			Cette routine place un élément dans la liste*/static pascal void MetElementDansListe(UndoRedoListHandle list,short type,long ticks,							long lastticks,long AbsNum,long the_data){TEHandle						te=(TEHandle)the_data;OSErr						err=0;long							a;short						i,oldSelStart,oldSelEnd;Boolean						dotheJob=false;UndoRedoElementPtr TheUndo;Handle						h;	if (list){ 		/* code valide ?*/		if (type<Texte_SousTitre || type>TimecodeOut_SousTitrebcd) return;		/* on regarde s'il faut placer le undo */		if (ticks==0)  dotheJob=true; // on nous force la main				i=(**list).TotalElement;		// on regarde // au précédent ticks si + de 3 secondes on fait undo		if (i) {				if( (ticks-lastticks ) >= (67*3 ))	dotheJob=true; 				} else dotheJob=true; // on n'a pas de undo dans la liste pour l'instant donc on place le premier				if (dotheJob) {			/* on agrandi le handle (note: on s'arrête à 64 éléments) */			if ((**list).TotalElement<64) {							HUnlock((Handle)list);				/*SetHandleSize((Handle)list,						( ((**list).TotalElement +1)*sizeof(UndoRedoElement))+2);*/				err=MemError();				if (!err) (**list).TotalElement++;								HUnlock((Handle)list);			} else {								/* on est à la valeur limite on décale la liste 					vers le bas pour effacer le 1er élément de la liste */				err=0;				HLock((Handle)list);				BlockMove(		(Ptr)&((**list).Element[1]),								(Ptr)&((**list).Element[0]),								(long)( (**list).TotalElement-1 )*sizeof(UndoRedoElement)						);				HUnlock((Handle)list);				}						/* maintenant si pas d'erreur on place le undo */			if (!err) {				HLock((Handle)list);				i=(**list).TotalElement-1;				TheUndo=(UndoRedoElementPtr)&((**list).Element[i]);									TheUndo->Undo_Type=type; //type del'undo				TheUndo->Undo_Ticks=ticks; //heure de l'undo				TheUndo->Undo_AbsST=AbsNum; //n° absolu du Sous-titre				TheUndo->Undo_Data=nil; //timecode					TheUndo->Undo_TexteHandle=nil; // Handle				TheUndo->Undo_StyleHandle=nil;				TheUndo->Undo_spare1=0;				TheUndo->Undo_spare2=0;				switch (type){					 case Texte_SousTitre:					 case Commentaire_SousTitre:					 case TimecodeIn_SousTitre:					 case TimecodeOut_SousTitre:					 case Duree_SousTitre:								 /* on sélectionne tout le texte */						 oldSelStart=(**te).selStart;						 oldSelEnd=(**te).selEnd;						 TESetSelect(0, 32766, te);						 					 /* on récupère le texte						et on en fait une copie					 */						 h=(Handle)TEGetText(te);						 HandToHand(&h);						 						 TheUndo->Undo_TexteHandle=h;						 TheUndo->Undo_StyleHandle=(Handle)GetStylScrap(te);									 /* on rend la sélection précedente					 */										 TESetSelect(oldSelStart, oldSelEnd, te);					 break;					 			/*ce ne sont pas des TE mais des time code en BCD*/						 case TimecodeIn_SousTitrebcd:					 case TimecodeOut_SousTitrebcd:					 						 TheUndo->Undo_Data=the_data; //timecode BCD		 					 break;				 				} //switch				HUnlock((Handle)list);			} else AlertUser(17); /* erreur de mémoire */		}// dothe job		}//if (list)} //put element dans la liste/*  ------ initialisation et dispose des undo ------ *//* Cette routine est appelée au démarrage et pour un nouveau film */pascal void	InitialiseUndoRedo(void){	/* on regarde s'il y a des listes de undo/redo si oui on dispose tout le contenu */	if (Undo_Stack){ ClearListe(Undo_Stack); DisposeHandle((Handle)Undo_Stack); Undo_Stack=nil; }	if (Redo_Stack){ ClearListe(Redo_Stack); DisposeHandle((Handle)Redo_Stack); Redo_Stack=nil; }		/* Maintenant on demande un handle de mémoire 	(note dans la verion précedente du soft	c'était un pointeur) */	Undo_Stack=(UndoRedoListHandle)NewHandleClear((sizeof(UndoRedoElement)*66)+2);	Redo_Stack=(UndoRedoListHandle)NewHandleClear((sizeof(UndoRedoElement)*66)+2);	} //InitialiseUndoRedo(void)/*		Cette routine "dispose" tous les handles de mémoire dans une liste*/pascal void ClearListe(UndoRedoListHandle list){short i;Handle h;	if (list){		HLock((Handle)list);		for (i=0; i<(**list).TotalElement;i++){			h=(**list).Element[i].Undo_TexteHandle;			if (h) DisposeHandle(h);			h=(**list).Element[i].Undo_StyleHandle;			if (h) DisposeHandle(h);				} // for			HUnlock((Handle) list);	}//(list)}//ClearListe				/* Cette routine ajuste les items annuler et refaire du menu Edition */		pascal void AdjustMenuUndo(void){MenuHandle		menu;Str255				st0;short				i;UndoRedoElementPtr	TheUndo;		/* on détermine s'il y un undo, si oui on affiche le texte */				menu=GetMHandle(130);		if (menu) {			if( (Undo_Stack) && ((**Undo_Stack).TotalElement ) ){				i=(**Undo_Stack).TotalElement;				if (i) {					TheUndo=(UndoRedoElementPtr)&((**Undo_Stack).Element[i-1]);					i=1+TheUndo->Undo_Type;					if (i<1) i=1;					if (i>8) i=8;					GetIndString(&st0,134,i);					SetItem(menu,1,&st0);					EnableItem(menu,1);				} else {					GetIndString(&st0,134,1);					SetItem(menu,1,&st0);					DisableItem(menu,1);				}			} else {				GetIndString(&st0,134,1);				SetItem(menu,1,&st0);				DisableItem(menu,1);			}								/* on détermine s'il y un Redo, si oui on affiche le texte */				if( (Redo_Stack) && ((**Redo_Stack).TotalElement ) ){				i=(**Redo_Stack).TotalElement;				if(i){					TheUndo=(UndoRedoElementPtr)&((**Redo_Stack).Element[i-1]);					i=1+TheUndo->Undo_Type;					if (i<1) i=1;					if (i>8) i=8;					GetIndString(&st0,135,i);					SetItem(menu,2,&st0);					EnableItem(menu,2);						} else {					GetIndString(&st0,135,1);					SetItem(menu,2,&st0);					DisableItem(menu,2);					}							} else {				GetIndString(&st0,135,1);				SetItem(menu,2,&st0);				DisableItem(menu,2);			}								}// if menu} // AdjustMenuUndopascal void ManageUndoRedoListeForInsert(long	AbsNum){	ManageAlistForInsert(Undo_Stack,AbsNum);	ManageAlistForInsert(Redo_Stack,AbsNum);}pascal void ManageUndoRedoListeForDelete(long	AbsNum){	ManageAlistForDelete(Undo_Stack,AbsNum);	ManageAlistForDelete(Redo_Stack,AbsNum);}/* cette routine manage une liste pour un insert 	si un élément à un asbnum> au soustitre insérer on incrémente son n°*/static void ManageAlistForInsert(UndoRedoListHandle list,long AbsNum){short i,total=(**list).TotalElement;UndoRedoElementPtr	TheUndo;	if ( list && (**list).TotalElement){		for (i=0;i<total;i++){				TheUndo=(UndoRedoElementPtr)&((**list).Element[i]);				if( (TheUndo->Undo_AbsST)>AbsNum) TheUndo->Undo_AbsST++;		}	} // for i} //ManageAlistForInsert/* cette routine manage une liste pour un delete 	si un élément à un asbnum > au soustitre effacé on décremente son n°	si un élément à un asbnum = au soustitre effacé on l'efface*/static void ManageAlistForDelete(UndoRedoListHandle list,long AbsNum){long	l;short i,total=(**list).TotalElement;UndoRedoElementPtr	TheUndo;	if ( list && (**list).TotalElement){		for (i=0;i<total;i++){				TheUndo=(UndoRedoElementPtr)&((**list).Element[i]);				if( (TheUndo->Undo_AbsST)>AbsNum) TheUndo->Undo_AbsST--;				if( (TheUndo->Undo_AbsST)==AbsNum){ // on efface l'éléments				/* on déplace la mémoire sauf si c'est le dernier élément */					if (i !=(total-1) ){							// on calcule la taille du déplacement ( (dernierId) - i -1 ) & dernierId=total-1 )						 l=(total-i)-2;						 l=l*sizeof(UndoRedoElement);						 HLock((Handle)list);						 BlockMove(	(Ptr)&((**list).Element[i+1]),									(Ptr)&((**list).Element[i]),l);					 					 	} //(i !=(total-1) )												 /* un élément en moins */						 (**list).TotalElement--; total--;						 /* on ajuste la taille du handle */						 HUnlock((Handle)list);						/* SetHandleSize((Handle)list,								 ( ((**list).TotalElement)*sizeof(UndoRedoElement))+2);*/				}		}	} // for i}//ManageAlistForDelete//pascal void DoUseUndo(void){UndoRedoElementPtr	TheUndo;SousTitreRecordPtr	ST_Ptr;GrafPtr			oldport;Boolean				changeSTCourant;long					total;	/* on regarde s'il y a un élément dans la liste */		if ( (Undo_Stack) && ((**Undo_Stack).TotalElement )   ){					GetPort(&oldport);		/* on récupère son pointeur		*/				total=(**Undo_Stack).TotalElement;		HLock((Handle)Undo_Stack);		TheUndo=(UndoRedoElementPtr)&((**Undo_Stack).Element[total-1]);		ST_Ptr=C_ConversionNumeroSTPointeur(TheUndo->Undo_AbsST);				/* on ferme tous les te ouverts listing		*/				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}		/* si nous ne sommes pas au bon sous-titre dans saisie on y va */				if (TheUndo->Undo_AbsST!=(long)G.General_SousTitreEncour)			changeSTCourant=true;		if ( (G.saisieTE) && (TheUndo->Undo_AbsST!=G.saisieTEStNum) ) 		changeSTCourant=true;				if (changeSTCourant){				TransfertSaisieMemoire(); // on ferme le TE				G.General_SousTitreEncour=ST_Ptr->st_AbsNUMST;				UpdateSaisie();					DrawSt_enCourDansListing();			} 		/* maintenant on execute l'ordre de Undo ,G.saisieTEStNum*/		switch(TheUndo->Undo_Type) {			case  Texte_SousTitre:			case  Commentaire_SousTitre:			case  TimecodeIn_SousTitre:			case  TimecodeOut_SousTitre:			case  Duree_SousTitre:			// si pas de te ou te pas du même type on l'ouvre			if(TheUndo->Undo_TexteHandle) { // y a t-il un texte ?				if( (TheUndo->Undo_Type!=G.saisieTEStItem) || (G.saisieTE==nil) ){					if (G.saisieTE) TransfertSaisieMemoire(); // s'il existe on le ferme					DoOpenSaisieTE(TheUndo->Undo_Type); // on ouvre le TE de l'item annuler					}				DoMakeRedo(TheUndo->Undo_Type,0,TheUndo->Undo_AbsST, (long)G.saisieTE);				if 	(G.saisieTE==nil)DoOpenSaisieTE(TheUndo->Undo_Type); // on ouvre le TE de l'item annuler				// on remplace le texte				TESetSelect(0,32766, G.saisieTE);				TEDelete(G.saisieTE);						HLock((Handle)TheUndo->Undo_TexteHandle);				TEStylInsert((Ptr)*(TheUndo->Undo_TexteHandle),GetHandleSize((Handle)TheUndo->Undo_TexteHandle),								(StScrpHandle)TheUndo->Undo_StyleHandle,G.saisieTE);				HUnlock((Handle)TheUndo->Undo_TexteHandle);				DisposeHandle((Handle)TheUndo->Undo_TexteHandle);					if(TheUndo->Undo_StyleHandle) DisposeHandle((Handle)TheUndo->Undo_StyleHandle);									}//if(TheUndo->Undo_TexteHandle)							break;				case  TimecodeIn_SousTitrebcd:				DoMakeRedo(TheUndo->Undo_Type,0,TheUndo->Undo_AbsST,ST_Ptr->st_TimeCodeIn);				ST_Ptr=C_ConversionNumeroSTPointeur(TheUndo->Undo_AbsST);				ST_Ptr->st_TimeCodeIn=TheUndo->Undo_Data;				SetPort((WindowPtr)&G.DialogSaisie);				InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);				SetPort((WindowPtr)&G.ListingWindow);				InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				break;					case  TimecodeOut_SousTitrebcd:				DoMakeRedo(TheUndo->Undo_Type,0,TheUndo->Undo_AbsST,ST_Ptr->st_TimeCodeOut);				ST_Ptr=C_ConversionNumeroSTPointeur(TheUndo->Undo_AbsST);				ST_Ptr->st_TimeCodeOut=TheUndo->Undo_Data;				SetPort((WindowPtr)&G.DialogSaisie);				InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);				SetPort((WindowPtr)&G.ListingWindow);				InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);			break;					} // switch(TheUndo->Undo_Type) 		/* un élément en moins, on réajuste la pile */		(**Undo_Stack).TotalElement--; 		/* on ajuste la taille du handle */		HUnlock((Handle)Undo_Stack);		/*SetHandleSize((Handle)Undo_Stack, ( ((**Undo_Stack).TotalElement)*sizeof(UndoRedoElement))+2);*/				SetPort(oldport);		}//if ( (Undo_Stack) && ((**Undo_Stack).TotalElement )}//DoUseUndopascal void DoUseRedo(void){UndoRedoElementPtr	TheRedo;SousTitreRecordPtr	ST_Ptr;GrafPtr			oldport;Boolean				changeSTCourant;long					total;	/* on regarde s'il y a un élément dans la liste */		if ( (Redo_Stack) && ((**Redo_Stack).TotalElement )   ){						GetPort(&oldport);					/* on récupère son pointeur		*/				total=(**Redo_Stack).TotalElement;		HLock((Handle)Redo_Stack);		TheRedo=(UndoRedoElementPtr)&((**Redo_Stack).Element[total-1]);		ST_Ptr=C_ConversionNumeroSTPointeur(TheRedo->Undo_AbsST);			/* on ferme tous les te ouverts listing		*/				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}		/* si nous ne sommes pas au bon sous-titre dans saisie on y va */				if (TheRedo->Undo_AbsST!=(long)G.General_SousTitreEncour)			changeSTCourant=true;		if ( (G.saisieTE) && (TheRedo->Undo_AbsST!=G.saisieTEStNum) ) 		changeSTCourant=true;				if (changeSTCourant){				TransfertSaisieMemoire(); // on ferme le TE				G.General_SousTitreEncour=ST_Ptr->st_AbsNUMST;				UpdateSaisie();					DrawSt_enCourDansListing();			} 		/* maintenant on execute l'ordre de Redo ,G.saisieTEStNum*/		switch(TheRedo->Undo_Type) {			case  Texte_SousTitre:			case  Commentaire_SousTitre:			case  TimecodeIn_SousTitre:			case  TimecodeOut_SousTitre:			case  Duree_SousTitre:			// si pas de te ou te pas du même type on l'ouvre			if(TheRedo->Undo_TexteHandle) { // y a t-il un texte ?							if( (TheRedo->Undo_Type!=G.saisieTEStItem) || (G.saisieTE==nil) ){					if (G.saisieTE) TransfertSaisieMemoire(); // s'il existe on le ferme					DoOpenSaisieTE(TheRedo->Undo_Type); // on ouvre le TE de l'item annuler					}													// on remplace le texte				TESetSelect(0,32766, G.saisieTE);				TEDelete(G.saisieTE);						HLock((Handle)TheRedo->Undo_TexteHandle);				TEStylInsert((Ptr)*(TheRedo->Undo_TexteHandle),GetHandleSize((Handle)TheRedo->Undo_TexteHandle),								(StScrpHandle)TheRedo->Undo_TexteHandle,G.saisieTE);				HUnlock((Handle)TheRedo->Undo_TexteHandle);				DisposeHandle((Handle)TheRedo->Undo_TexteHandle);					if(TheRedo->Undo_StyleHandle) DisposeHandle((Handle)TheRedo->Undo_StyleHandle);									}//if(TheRedo->Undo_TexteHandle)							break;				case  TimecodeIn_SousTitrebcd:				ST_Ptr->st_TimeCodeIn=TheRedo->Undo_Data;				SetPort((WindowPtr)&G.DialogSaisie);				InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);				SetPort((WindowPtr)&G.ListingWindow);				InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				break;					case  TimecodeOut_SousTitrebcd:				ST_Ptr->st_TimeCodeOut=TheRedo->Undo_Data;				SetPort((WindowPtr)&G.DialogSaisie);				InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);				SetPort((WindowPtr)&G.ListingWindow);				InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);			break;					} // switch(TheRedo->Undo_Type) 		/* un élément en moins, on réajuste la pile */		(**Redo_Stack).TotalElement--; 		/* on ajuste la taille du handle */		HUnlock((Handle)Redo_Stack);		/*SetHandleSize((Handle)Redo_Stack, ( ((**Redo_Stack).TotalElement)*sizeof(UndoRedoElement))+2);*/				SetPort(oldport);		}//if ( (Redo_Stack) && ((**Redo_Stack).TotalElement )}//DoUseRedo