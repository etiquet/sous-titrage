#include "BB.Globals_C.h"#include <Menus.h>#include <Devices.h>#include <Events.h>#include <Gestalt.h>#include <Palettes.h>#include <QuickTimeComponents.h>#include <ImageCompression.h>#include "E3DEMO.H"// les globals 	extern MyQDGlobals QD;	extern AppGlobals G;//#pragma segment Menuvoid FlashTracking(void);extern Ptr		SerBuff1,SerBuff2;void CentreLAFenetreAV(Boolean always);void	DoAppleMenu(short MenuItem);void	DoFileMenu(short MenuItem);void	DoEditMenu(short MenuItem);void DoListeMenu(short MenuItem);void	DoFenetreMenu(short MenuItem);void DoModeMenu(short	MenuItem);void DoQuickOpenMenu(short MenuItem);void DoDebugMenu(short MenuItem);void DoAffichageMenu(short	MenuItem);pascal Boolean AboutModalDialogFilter(DialogPtr theDialog ,EventRecord *event,short *itemhit);pascal void	DoInitSerial(void);		pascal Boolean QuitModalFilter(DialogPtr theDialog ,EventRecord *event,short *itemhit);int	VerifSTDlog(void);int 	VerifTexteDlog(SousTitreRecordPtr* Start,SousTitreRecordPtr* End );int     Preferences(void);pascal OSErr	launchSFG(void);pascal void 	QuitSansFauteGrammaire(void);pascal void 	ActiveSansFauteGrammaire(void);pascal void	 HandleMenuAV(short menuItem);void 	DessineBarreControlListing(void); int	EnTeteDuFilm(void);int DoRechercheST(short flag );int	C_ConfigureToucheFonctions(void);int  RechercheRemplacementTexte(void);int C_Suppression_SousTitre(void);int	   DecalageTexte(void);void 	   ConcatenerFichier(void);void GetMyMenuPrefFile(void );int OffsetLectureTC(void);int  ChangeFontStylDlog(void);extern SeqGrabComponent 	gSeqGrabber;void FlashTrackingSaisie(void);void 	C_TestDrawFastChar(void);void C_TestDrawChar(long face, long border,long shadow, long mask);int       ChangeJustifListDlog(void);void C_ClearVx (void);pascal void Test_Draw_String(void);DialogPtr 		OpenPreferenceAffichageDlog(void);extern DialogPtr 	gMonitor,gDialogReglageSimu,gPaletteKaraoke,gDialogProchainSousTitre,gtestDecodageWindow,gDialogPrefAffichage;extern Boolean 		gDone;/* ------------------------------*/pascal void	Adjust_BB_Menu(void){WindowPtr	FrontMost;MenuHandle	menu;EventRecord	event;short		TheRefNum,Everesult,count;long			TheFreeByte,A;Str255		st0;Boolean  		FlagEdit;TEHandle		te=nil;/* on regarde s'il y a des modifiers */		EventAvail(-1,&event);		FrontMost=(WindowPtr)FrontNonFloatingWindow();/*; ###### on dŽsactive le fast ope menu		bra.s	NotUseBbdfMenu		move.l	G.QuickOpenHandle,d0		beq		PsHandle		move.l	d0,a0		_disposeHandlePsHandle		move.l	#'Bbof',-(sp)		move.l	G.QuickOpenMenuHandle,-(sp)		pea		G.QuickOpenHandle		import 	C_MakeTheBbdfMenu		jsr 		C_MakeTheBbdfMenuNotUseBbdfMenu*/				menu=GetMHandle(133);			CheckItem(menu,1,false);		CheckItem(menu,2,false);		CheckItem(menu,3,false);	/* on allume l'item choisi */		A=G.SaisieModePreferenciel;		if (A==3) A=2;		SetItemMark(menu,A,'');/* le hard tracking */		if (G.Preference_Tracking&1) 			CheckItem(menu,4,true);		else			CheckItem(menu,4,false);		if (G.Preference_Tracking&2) 			CheckItem(menu,5,true);		else			CheckItem(menu,5,false);											GetMyMenuPrefFile();/* menu fentre */		menu=GetMHandle(132);		CheckItem(menu,9,G.General_Preference_DessinGris);		if (G.General_Preference_DessinGris) 			CheckItem(menu,9,true);		else			CheckItem(menu,9,false);/* le menu fichier */		menu=GetMHandle(129);		EnableItem(menu,1);		DisableItem(menu,11);#ifndef  __NoProtect__		/*; $200 (N19) +$100(CMC) */		if (!G.FindFirstKey_error) 			if ( G.Options_dansLaClef&0x300)  EnableItem(menu,11);#endif#ifdef  __NoProtect__		EnableItem(menu,11);#endif	#ifdef  __Demo__		EnableItem(menu,11);#endif/* La fonction Eject */			DisableItem(menu,9);			if ( GetVInfo(1,nil,&TheRefNum,&TheFreeByte) )  DisableItem(menu,9);				else EnableItem(menu,9);			/* ------------- ADJUST THE EDIT MENU ------------- */		menu=GetMHandle(130);				DisableItem(menu,12);		DisableItem(menu,14);		DisableItem(menu,15);		if (G.General_NombreST ==1){			DisableItem(menu,12);			DisableItem(menu,14);			DisableItem(menu,15);		} else {			EnableItem(menu,12);			EnableItem(menu,14);			EnableItem(menu,15);		}/* on regarde s'il y a un texte edit ouvert */				if (  (G.BlockNoteTE)	||			 (G.saisieTE)	||			 (G.ListingTE)  ){			 FlagEdit=false;			 			if ( 	FrontMost==(WindowPtr)G.BlockNoteWindow){	FlagEdit=true; 	te=G.BlockNoteTE; }			if ( 	FrontMost==(WindowPtr)&G.DialogSaisie)	{	FlagEdit=true;	te=G.saisieTE; }			if ( 	FrontMost==(WindowPtr)&G.ListingWindow){	FlagEdit=true;	te=G.ListingTE; }		} // s'il y a un te ouvert		if (FlagEdit){			EnableItem(menu,4);			EnableItem(menu,5);			EnableItem(menu,6);			EnableItem(menu,7);						if ((**te).selEnd-(**te).selStart){				EnableItem(menu,9);				EnableItem(menu,10);			} else {				DisableItem(menu,9);				DisableItem(menu,10);			}						} else {			DisableItem(menu,4);			DisableItem(menu,5);			DisableItem(menu,6);			DisableItem(menu,7);			DisableItem(menu,9);			DisableItem(menu,10);		}		/* ------------- ADJUSTEMENT DU MENU FENETRE ------------- */		menu=GetMHandle(132);						if (G.General_Preference_DessinGris)			CheckItem(menu,17,true);		else			CheckItem(menu,17,false);			if (G.affiche_CR_Flag)			CheckItem(menu,18,true);		else			CheckItem(menu,18,false);		// si simulation prŽsente				if (gMonitor) {			EnableItem(menu,12); 			EnableItem(menu,5);		} else {			DisableItem(menu,5);			DisableItem(menu,12);		}		// on active en fonction si oui ou pas karaokŽ		if (gPaletteKaraoke )  EnableItem(menu,14);			 else   DisableItem(menu,14);			 		// si dŽcodage VISTC	 		if (gtestDecodageWindow )  EnableItem(menu,15);			 else   DisableItem(menu,15);			 			 			 /* ------------- Ajustement du menu affichage ------------ */ 		menu=GetMHandle(134); 				DisableItem(menu,1);		DisableItem(menu,3);		DisableItem(menu,5);		DisableItem(menu,7);		DisableItem(menu,9);#ifdef  __Demo__	if (!gMonitor){	// si fentre simu N'existe pas			EnableItem(menu,1);			EnableItem(menu,3);			EnableItem(menu,5);			//EnableItem(menu,7);	}		#endif		#ifdef  __NoProtect__		EnableItem(menu,1);		EnableItem(menu,3);		EnableItem(menu,5);//		EnableItem(menu,7);		EnableItem(menu,9);#else		if (!G.FindFirstKey_error) 			if ( G.Options_dansLaClef&0x8000) { //8000 broadcast								//EnableItem(menu,7);									EnableItem(menu,5);									EnableItem(menu,3);									EnableItem(menu,1);								}#endif				if (gMonitor)	// si fentre simu existe			EnableItem(menu,9);		else			DisableItem(menu,9);/* on ajuste l'item rŽglage carte affichage	on indique le nom de la carte*/		if (G.Ve_GDHandle){					if(	G.VE_BoardID==0x118 ) {	// nuvista				GetIndString(&st0,129,15);				SetMenuItemText(menu,3,&st0);				EnableItem(menu,3);			}			if(	G.VE_BoardID==0x346 ) {	// nuvista +				GetIndString(&st0,129,16);				SetMenuItemText(menu,3,&st0);				EnableItem(menu,3);			}			if(	G.VE_BoardID==0x2a2 ) {	// video explorer				GetIndString(&st0,129,14);				SetMenuItemText(menu,3,&st0);				EnableItem(menu,3);			}			} else {			if ( (gMonitor) && 	(G.VE_BoardID==0x2a2) ) {	// video explorer				GetIndString(&st0,129,17);				SetMenuItemText(menu,3,&st0);				EnableItem(menu,3);								}else {							/* message pas de carte d'affichage */				GetIndString(&st0,129,13);				SetMenuItemText(menu,3,&st0);				DisableItem(menu,3);			}		}/* ----------- Menu Bug ----------------------*/ 			menu=GetMHandle(137); 			EnableItem(menu,0); 				/* activeFlag = 1;     {set if window being activated}       btnState   = 128;   {set if mouse button up}       cmdKey     = 256;   {set if Command key down}       shiftKey   = 512;   {set if Shift key down}       alphaLock  = 1024;  {set if Caps Lock key down}       optionKey  = 2048;  {set if Option key down}       ControlKey = 4096;  {set if Control key down}       */              /* on dŽsactive le menu bug si pas option key down       		Good Pour dŽbugger       */				if (!G.Ve_GDHandle)			if ( !(event.modifiers&optionKey) )	DisableItem(menu,0);							/* on ajuste les menu pour undo et AV */		AdjustMenuAV();	AdjustMenuUndo();			DrawMenuBar();			} // adjust_Menu					pascal void DoMenuCommand( long  menuResult){GrafPtr	saveport;short	MenuItem=LoWord(menuResult);short	MenuID=HiWord(menuResult);		GetPort(&saveport);		switch(MenuID) {					case	128:	//AppleMenu					DoAppleMenu(MenuItem);			break;			case	129://FileMenu					DoFileMenu(MenuItem);			break;			case	130://EditMenu					DoEditMenu(MenuItem);			break;			case	131://DiversMenu					DoListeMenu(MenuItem);			break;			case	132://fenetreMenu					DoFenetreMenu(MenuItem);			break;			case	133://Mode					DoModeMenu(MenuItem);			break;			case	134://Affichage					DoAffichageMenu(MenuItem);			break;			case	135://DEBUG					DoDebugMenu(MenuItem);			break;			case	136://QuickMenu					DoQuickOpenMenu(MenuItem);			break;						case	138://Gestion de la carte AV				HandleMenuAV(MenuItem);			break;	} // switch		SetPort(saveport);	WaitTicks(4);	HiliteMenu(0);}void	DoAppleMenu(short MenuItem){DialogPtr	dialog;short		daRefNum;Str255		daName;		switch (MenuItem){		case	1:	// about				dialog=GetNewDialog(186,nil,(WindowPtr)-1);				DrawDialog(dialog);				do{}while(!Button());				DisposDialog(dialog);		break;				case	2:	// block note				SelectReferencedWindow((WindowReference)G.BlockNoteWindow);				ShowReferencedWindow	((WindowReference)G.BlockNoteWindow);		break;					/*	case	3:	//  information de license existe 			// on demande les information de license			if (GetLicenseInfo()){			 	h=Get1Resource('STR#',136);				if (h)  ReleaseResource(h);			}			UpdateResFile(gCurResNum);			w=(WindowPtr)&G.BackDropWindow;			SetPort((GrafPtr)w);			InvalRect(&w->portRect);			DoUpdate((WindowPtr)w);			SetPort(StartUpDialog);		break;		*/				default:	/* all non-About items in this menu are DAs */				GetItem(GetMHandle(mApple), MenuItem, &daName);				daRefNum = OpenDeskAcc(daName);		break;			} // switch}	// about menu/*		Menu file*/void	DoFileMenu(short MenuItem){Boolean			doit;short			itemhit;		switch (MenuItem){			case	1:	//new				/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();								/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/			doit=false;			  if (G.ChangeSinceLastSave&0x7fff) { 				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(142,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);					  if (itemhit!=3)	doit=true;				}		  else doit=true;								if (doit) {						EffaceTouslesSousTitres(nil); 						G.CurrentFileType=nil;				// on erase le alias en cours						if (G.aliashandle ) {								DisposeHandle((Handle)G.aliashandle );								G.aliashandle=nil;					  	}					  				// on redessine le fentre					 	SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						DoUpdate((WindowPtr)&G.ListingWindow);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);								DoUpdate((WindowPtr)&G.DialogSaisie);					 	C_SaveData(2);						Alert(154,(ModalFilterProcPtr)nil);	// n'oubliez pas de dŽfinir ....				  } 			break;						case	2:	//file open				/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();									/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/					  if (G.ChangeSinceLastSave&0x7fff) {				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(142,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);					  if (itemhit!=3)	C_DoFileOpen(nil); 				  } else C_DoFileOpen(nil); 			break;						case	5:	//save				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				//SaveData(0);				C_SaveData(0);						break;			case	6:	//save as				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				G.CurrentFileType=nil;				C_SaveData(2);			break;						case	7:	//copie fichier				if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				C_FaireCopie_Fichier(&G.CurrentFileName);			break;									case	9:	//eject disquette				  FlushVol(nil,1);				  UnmountVol(nil,1);				  Eject(nil,1);			break;									case	11://export fichier						if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();				C_ExportFichier();			break;								case	12://concatŽner avec...				ConcatenerFichier();			break;										case	14://page setup				PageSetup();			break;							case	15://imprime			// on ferme le port sŽrie si PB 150				if (G.ModemInRefNum) {						KillIO(G.ModemInRefNum); 						KillIO(G.ModemOutRefNum); 												SerSetBuf(G.ModemInRefNum,SerBuff1,0); //{set the buffer}						FSClose(G.ModemInRefNum);						FSClose(G.ModemOutRefNum);				}								Imprimer();								if (G.ModemInRefNum) {					// on rŽouvre le port						// on rŽ-ouvre le port sŽrie						// on tient compte de la protection logicielle#ifdef __NoProtect__					InitSerial();#endif#ifndef __NoProtect__					// on rŽ-ouvre le port modem					if (!G.FindFirstKey_error)InitSerial();					 else  if (G.SoftProtect==1)InitSerial();					// on inscrit le mode dans les prŽfŽrences#endif						}							break;							case	17://ferme fentre			/* on regarde si c'est une action pour la fentre block note */		 		if ( (FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) &&(G.BlockNoteTE)	)	Close_BlockNoteTE();					if (FrontNonFloatingWindow() ) HideReferencedWindow(FrontNonFloatingWindow());			break;							case	19://quitter					/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();							/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/					  if (G.ChangeSinceLastSave&0x7fff) { 				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(152,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);  					  if (itemhit!=3)		 gDone=true; 			  } else gDone=true; 						break;			}// switch}// file menu/* menu Ždition prŽfŽrences etc... */void	DoEditMenu(short MenuItem){Str255		st0;long			offset,longueur;Handle		hDest;		switch (MenuItem) {			 case	1:	// annuler			 		DoUseUndo();			 break;			 case	2:	// refaire			 		DoUseRedo();			 break;			 			 case	4:	//couper				if(  FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow ) 					if (G.ListingTE)						if (	(**G.ListingTE).selEnd-(**G.ListingTE).selStart) {									TECut(G.ListingTE);									ZeroScrap();									TEToScrap();									G.ChangeSinceLastSave=1;							}				if(  FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE)						if (	(**G.saisieTE).selEnd-(**G.saisieTE).selStart) {									TECut(G.saisieTE);									ZeroScrap();									TEToScrap();									G.ChangeSinceLastSave=1;									Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractres							}				if(  FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow ) 					if (G.BlockNoteTE)						if (	(**G.BlockNoteTE).selEnd-(**G.BlockNoteTE).selStart) {									TECut(G.BlockNoteTE);									ZeroScrap();									TEToScrap();									G.ChangeSinceLastSave=1;							}			 break;			 case	5:	// copier			 				if(  FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow ) 					if (G.ListingTE)						if (	(**G.ListingTE).selEnd-(**G.ListingTE).selStart) {									TECopy(G.ListingTE);									ZeroScrap();									TEToScrap();							}				if(  FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE)						if (	(**G.saisieTE).selEnd-(**G.saisieTE).selStart) {									TECopy(G.saisieTE);									ZeroScrap();									TEToScrap();							}				if(  FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow ) 					if (G.BlockNoteTE)						if (	(**G.BlockNoteTE).selEnd-(**G.BlockNoteTE).selStart) {									TECopy(G.BlockNoteTE);									ZeroScrap();									TEToScrap();							}			 break;			 case	6:	// coller (/!\faire undo SVP)			 				if(  FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 					if (G.ListingTE){									hDest=NewHandle(8);									longueur=GetScrap(hDest,'styl',&offset);									if (longueur) TEStylPaste(G.ListingTE);									DisposeHandle(hDest);									G.ChangeSinceLastSave=1;							}				if( FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE){									hDest=NewHandle(8);									longueur=GetScrap(hDest,'styl',&offset);									if (longueur) TEStylPaste(G.saisieTE);									DisposeHandle(hDest);									G.ChangeSinceLastSave=1;									Draw_Line_Number_Saisie(); // pour actualiser le nombre de caractres							}				if(  FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 					if (G.BlockNoteTE){									hDest=NewHandle(8);									longueur=GetScrap( hDest,'styl',&offset);									if (longueur) TEStylPaste(G.BlockNoteTE);									DisposeHandle(hDest);									G.ChangeSinceLastSave=1;							}			 break;			 			 case	7:	// tout sŽlectionner			 	if(  FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 						if (G.ListingTE){									TESetSelect(0,32767,G.ListingTE);							}				if(  FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 					if (G.saisieTE){									TESetSelect(0,32767,G.saisieTE);							}				if(  FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 					if (G.BlockNoteTE){									TESetSelect(0,32767,G.BlockNoteTE);						}			 break;			 			 //------------------------------			 			 case 9: // passez la sŽlection en majuscule			 if(  FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 						if (G.ListingTE)ChangeSelectionEnCoursMajuscule(G.ListingTE);				if(  FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 						if (G.saisieTE)ChangeSelectionEnCoursMajuscule(G.saisieTE);				if(  FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 						if (G.BlockNoteTE)ChangeSelectionEnCoursMajuscule(G.BlockNoteTE);			 break;			 			 			 case 10: // passez la sŽlection en majuscule			 	if(  FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) 						if (G.ListingTE)ChangeSelectionEnCoursMinuscule(G.ListingTE);				if(  FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie ) 						if (G.saisieTE)ChangeSelectionEnCoursMinuscule(G.saisieTE);				if(  FrontNonFloatingWindow()==(WindowReference)G.BlockNoteWindow) 						if (G.BlockNoteTE)ChangeSelectionEnCoursMinuscule(G.BlockNoteTE);			 break;			 			 			 //------------------------------			 			 case	12:	// insŽrer en tte de film						if (G.ListingTE) {								  SetPort((WindowPtr)&G.ListingWindow);								  TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);								  TEDispose(G.ListingTE);								  G.ListingTE=nil;								  InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						 }		  						TransfertSaisieMemoire();						DrawSt_enCourDansListing();			 			Insert_Before();										/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);											 break;			 case	13:	// insŽrer un sous-titre			 			if (G.ListingTE) {								 SetPort((WindowPtr)&G.ListingWindow);								 TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);								 TEDispose(G.ListingTE);								 G.ListingTE=nil;								 InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						 }						TransfertSaisieMemoire();							C_InsertSt(C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour),32);							CentreListingWindow();							UpdateSaisie();				 break;			 			 case	14:	// effacer un sous-titre							C_ConvertiNumST_String( (C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour))->st_NumeroST,&st0);			 				ParamText(&st0,nil,nil,nil);			 				if (Alert(203,(ModalFilterProcPtr)nil)==2) {				  								 if (G.ListingTE) {									 SetPort((WindowPtr)&G.ListingWindow);									 TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);									 TEDispose(G.ListingTE);									 G.ListingTE=nil;									 InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);								 }	 								 TransfertSaisieMemoire();								 C_DeleteST(C_ConversionNumeroSTPointeur((long)G.General_SousTitreEncour));								 CentreListingWindow();								 UpdateSaisie();															}			 break;			 case	15:	// supprimer un groupe de sous-titre			 			if (G.ListingTE) {							SetPort((WindowPtr)&G.ListingWindow);							TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);							TEDispose(G.ListingTE);							G.ListingTE=nil;							InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						}						TransfertSaisieMemoire();						DrawSt_enCourDansListing();						C_Suppression_SousTitre();			 break;			 			 case	17:	// En tte du film						EnTeteDuFilm();		 					 	/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);											 break;			 case	18:	// prŽf de travail						Preferences();		 					 	/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);							 break;			 case	20:	// configuration lecteur de time code						 ConfigureLectureTc();					 	/* on demande que l'on redessine les fentres */								SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);					 break;			 case 21:			 		OffsetLectureTC();			 break;			 case	23:	// configuration touche fonctions					// ConfigureToucheFonction();					 C_ConfigureToucheFonctions();			 break;		} // switch}/* menu listes de fonctions sur la liste de sous-titre */void DoListeMenu(short MenuItem){SousTitreRecordPtr start,end;		switch (MenuItem) {		case	1:	// recherche sous-titre			DoRechercheST(0); // selecteur sur saisie 0= listing 1= saisie		break;				case	3:	// recherche de texte			RechercheRemplacementTexte();		break;				case	5:		//	dŽcaler du texte			 DecalageTexte();		break;							case	7:	//	changer le style dans liste			//ChangeStyle_FontDialog();			 ChangeFontStylDlog();		break;							case	8:	//	changer la justification dans liste			ChangeJustifListDlog();		break;											case	9:	//	changer le cache dans liste			Configuration_CacheSurZone();		break;							case	11:	//	offset			OffsetTcListe();		break;				/*case	12:	//	modifier durŽe st (fct supprimŽ pour l'instant)			AugmenteDureeTcListe();		break;	*/				case	13:	//	RenumŽroter la liste				if (Alert(135,(ModalFilterProcPtr)nil)==1) {						C_RenumerotationListeSousTitre(	G.General_PremierSTPtr);						G.ChangeSinceLastSave=true;						SetPort((GrafPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						SetPort((GrafPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);				}		break;						case 15:						VerifSTDlog();		break;										case 16:						/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();						if (VerifTexteDlog( &start,&end) )	VerifieTexteListeSousTitre( start, end);		break;					} // switch}/* ouvre la fentre sŽlectionnŽe */void	DoFenetreMenu(short MenuItem){Rect	rect;	WindowPtr	w1;short			i,j,x;		switch (MenuItem) {				case	1:		// home	on range les fentres					if (FrontNonFloatingWindow()==(WindowReference)&G.ListingWindow) {											C_GETMAINSCREENRES(&rect);						w1=(WindowPtr)&G.DialogSaisie;						i=(w1->portRect.right)-(w1->portRect.left);						j=(w1->portRect.bottom)-(w1->portRect.top);						x=(rect.right-rect.left)-i;						x=x/2+rect.left;						MoveWindow((WindowPtr)&G.ListingWindow,x,40+rect.top,false);						SizeWindow((WindowPtr)&G.ListingWindow,i,rect.bottom-3-j-60,true);						Adjust_ListingScrollBar();								}					if (FrontNonFloatingWindow()==(WindowReference)&G.DialogSaisie) {											C_GETMAINSCREENRES(&rect);						w1=(WindowPtr)&G.DialogSaisie;						i=(w1->portRect.right)-(w1->portRect.left);						j=(w1->portRect.bottom)-(w1->portRect.top);						x=(rect.right-rect.left)-i;						x=x/2+rect.left;						MoveWindow((WindowPtr)&G.DialogSaisie,x,rect.bottom-j-3,false);					}																break;				case	3:		// listing					SelectReferencedWindow((WindowReference)&G.ListingWindow);					ShowReferencedWindow	((WindowReference)&G.ListingWindow);				break;			case	4:		// saisie					SelectReferencedWindow((WindowReference)&G.DialogSaisie);					ShowReferencedWindow	((WindowReference)&G.DialogSaisie);				break;			case	5:		// simulation					if (gMonitor) {						SelectReferencedWindow((WindowReference)gMonitor);						ShowReferencedWindow((WindowReference)gMonitor);					}		break;			case	6:		// Bloc-note					SelectReferencedWindow((WindowReference)G.BlockNoteWindow);					ShowReferencedWindow	((WindowReference)G.BlockNoteWindow);				break;			case	7:		// telecommande					SelectReferencedWindow((WindowReference)G.TELECOMMANDEWindow);					ShowReferencedWindow((WindowReference)G.TELECOMMANDEWindow);				break;			case	8:		// palette verification liste					SelectReferencedWindow((WindowReference)G.ErrorsWindow);					ShowReferencedWindow((WindowReference)G.ErrorsWindow);				break;							case	9:		// palette chenille					SelectReferencedWindow((WindowReference)G.ChenilleWindow);					ShowReferencedWindow((WindowReference)G.ChenilleWindow);				break;			case	10:		// palette prochain sous-titre					SelectReferencedWindow((WindowReference)gDialogProchainSousTitre);					ShowReferencedWindow((WindowReference)gDialogProchainSousTitre);				break;			case	11:		// infos techniques					SelectReferencedWindow((WindowReference)G.ServiceWindow);					ShowReferencedWindow((WindowReference)G.ServiceWindow);				break;							case	12:		// rŽglages simu					SelectReferencedWindow((WindowReference)gDialogReglageSimu);					ShowReferencedWindow((WindowReference)gDialogReglageSimu);				break;					case	13:		// logo Bon Bougre					SelectReferencedWindow((WindowReference)G.LogoWindow);					ShowReferencedWindow((WindowReference)G.LogoWindow);				break;									case	14:		// palette karaoke					if (gPaletteKaraoke){					SelectReferencedWindow((WindowReference)gPaletteKaraoke);					ShowReferencedWindow((WindowReference)gPaletteKaraoke);						}			break;				case	15:		// palette gtestDecodageWindow					if (gtestDecodageWindow){					SelectReferencedWindow((WindowReference)gtestDecodageWindow);					ShowReferencedWindow((WindowReference)gtestDecodageWindow);						}			break;// rŽglages pour la fentre listing						case	17:		// tracŽ des zones dans listing					if (G.General_Preference_DessinGris) G.General_Preference_DessinGris=0;					else	G.General_Preference_DessinGris=true;										SetPort((GrafPtr)&G.ListingWindow);					InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);		break;					case 18:					if (G.affiche_CR_Flag) G.affiche_CR_Flag=0;					else	G.affiche_CR_Flag=true;					SetPort((GrafPtr)&G.ListingWindow);					InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);		break;				}//switch} //DoFenetreMenuvoid DoModeMenu(short MenuItem){GrafPtr			savePort;		/* si choix mode de travail */		if (MenuItem>=1 && MenuItem<=2) {						if (G.ListingTE) {							SetPort((WindowPtr)&G.ListingWindow);							TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);							TEDispose(G.ListingTE);							G.ListingTE=nil;							InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						}						TransfertSaisieMemoire();	// patch pour comptabilitŽ avec ancien code ou aucun mode pref = 3						if (MenuItem==2) MenuItem=3;						G.SaisieModePreferenciel=MenuItem;		}				if (MenuItem==4) {			if (G.Preference_Tracking&1) {				G.Preference_Tracking=G.Preference_Tracking&2;			} else {				G.Preference_Tracking=G.Preference_Tracking|1;			}			GetPort(&savePort);			SetPort((GrafPtr)&G.ListingWindow);			FlashTracking();			AfficheTrackingStatus();			DessineBarreControlListing();			SetPort((GrafPtr)savePort);					}						if (MenuItem==5) {			if (G.Preference_Tracking&2) {				G.Preference_Tracking=G.Preference_Tracking&1;			} else {				G.Preference_Tracking=G.Preference_Tracking|2;			}						GetPort(&savePort);			SetPort((GrafPtr)&G.DialogSaisie);			FlashTrackingSaisie();			SetPort((GrafPtr)savePort);		}				}void DoAffichageMenu(short	MenuItem){	switch (MenuItem) {		case	1:			if (G.VE_BoardID==0x2a2) ConfigureVX_UpStreamKeyer();	// on passe en upstream key			DoRenderingFontDialog();			if (G.VE_BoardID==0x2a2)				if (G.VE_Mode) ConfigureVX_DownStreamKeyer();		// on rend le mode prŽalable		break;			case	3:			ConfigurationCarteAffichage();		break;			case	5:			if (gDialogPrefAffichage){					SelectReferencedWindow((WindowReference)gDialogPrefAffichage);					ShowReferencedWindow((WindowReference)gDialogPrefAffichage);				} else  {			    gDialogPrefAffichage=OpenPreferenceAffichageDlog();			}		break;			case	7:		break;		}	 // switch		}void		CC_TestCDrawST(void);void 		C_TestCDrawST(void);		void DoDebugMenu(short MenuItem){	switch (MenuItem){	case 4: 		CC_TestCDrawST();	break;		case 5: 		Test_Draw_String();	break;			case 6: 	C_TestDrawChar(0xffffffff,0xff808080,0, 0x80808080);	break;			case 12: 	break;		//default:		//DoAsmDebugMenu(MenuItem);	} }void DoQuickOpenMenu(short MenuItem){Boolean		doit;short		itemhit;long			L;				/*on regarde s'il y a un ou plusieurs te d'ouvert,	si oui on le ferme sans SaveData le contenu	*/					if (G.ListingTE) {						SetPort((WindowPtr)&G.ListingWindow);						TransfertTE_Memoire(G.ListingTE,G.ListingTEStNum,G.ListingTEStItem);						TEDispose(G.ListingTE);						G.ListingTE=nil;						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);				}				TransfertSaisieMemoire();				DrawSt_enCourDansListing();								/* on regarde s'il faut faire une sauvegarde du fichier actuel avant de quitter	*/				doit=false;			  	if (G.ChangeSinceLastSave&0x7fff) { 				  // on demande son choix ˆ l'utilisateur (sauvegarder, ne pas sauv., annuler)							  itemhit=Alert(142,(ModalFilterProcPtr)QuitModalFilter);					  if (itemhit==1)	C_SaveData(nil);					  if (itemhit!=3)	doit=true;				}		  else	 doit=true;								if (doit) {						EffaceTouslesSousTitres(nil); 						G.CurrentFileType=nil;				// on erase le alias en cours						if (G.aliashandle ) {								DisposeHandle((Handle)G.aliashandle );								G.aliashandle=nil;					  	}					  					  /* on recupre le pointeur du fss dŽcrivant le fichier dŽsignŽ */						HLock(G.QuickOpenHandle);						L=( (MenuItem-1)*70 );					  	L=L+(long)*G.QuickOpenHandle;						C_DoFileOpen((FSSpecPtr)L);					  	HUnlock(G.QuickOpenHandle);				// on redessine le fentre					 	SetPort((WindowPtr)&G.ListingWindow);						InvalRect((Rect*)&((GrafPtr)&G.ListingWindow)->portRect);						DoUpdate((WindowPtr)&G.ListingWindow);					 	SetPort((WindowPtr)&G.DialogSaisie);						InvalRect((Rect*)&((GrafPtr)&G.DialogSaisie)->portRect);								DoUpdate((WindowPtr)&G.DialogSaisie);				  } }pascal Boolean QuitModalFilter(DialogPtr theDialog ,EventRecord *event,short *itemhit){OSErr		result;short		the_itemType,part,dh,dv;Handle		the_Handle;Rect		Rectangle;WindowPtr	window;Point		The_point;unsigned char		key;		result=false;			switch (event->what ) {		case mouseDown:			part = FindWindow(event->where, &window);						switch ( part ) {			case inContent:			SystemClick	(event,window);  //let the system handle it			break;//						case inDrag:                /* pass screenBits.bounds to get all gDevices */					if	(window==(WindowPtr)FrontNonFloatingWindow()) {					GivescreenBits(&Rectangle);	//QD.screenbit bounds					DragWindow(window, event->where,&Rectangle); //&QD.screenbit bounds); //					result=true;					}					break;			}							break;		case keyDown:		case autoKey:                       /* check for menukey equivalents */			key = event->message & charCodeMask;			if ( (event->modifiers & optionKey)&&(key<32)) {	/* option key down */				if ( (event->modifiers & (shiftKey))) {	/* shift key down */// on bouge la fentre par 20							switch	(key){					case 30:						dv=-20;						dh=0;					break;					case 31:						dv=20;						dh=0;					break;					case 28:						dv=0;						dh=-20;					break;					case 29:						dv=0;						dh=20;					break;					}				} else {// on bouge la fentre par 1								switch	(key){					case 30:						dv=-1;						dh=0;					break;					case 31:						dv=1;						dh=0;					break;					case 28:						dv=0;						dh=-1;					break;					case 29:						dv=0;						dh=1;					break;						}				}// on dŽplace la fentre				window=(WindowPtr)FrontNonFloatingWindow();			SetPort(window);			The_point.v=window->portRect.top+dv;			The_point.h=window->portRect.left+dh; 			LocalToGlobal(&The_point);			MoveWindow(window,The_point.h,The_point.v,false);				result=false;				}	else {			switch(key) {			case 3:			case 13:			GetDItem((DialogPtr)FrontNonFloatingWindow(),1,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=1;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);								}				break;				case 'N':			case 'n':			GetDItem((DialogPtr)FrontNonFloatingWindow(),2,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=2;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);								}				break;												case 27:	// on vŽrifie que c'est un  bouton 				GetDItem((DialogPtr)FrontNonFloatingWindow(),3,&the_itemType,&the_Handle,&Rectangle);				if	(the_itemType==(ctrlItem+btnCtrl)){				*itemhit=3;				result=true;				HiliteControl((ControlHandle) the_Handle,2);				WaitTicks(8);				HiliteControl((ControlHandle) the_Handle,0);				}				break;						} //switch			} //else			break;														case activateEvt:			break;				case updateEvt:		if (event->message!=(long)theDialog)	 DoUpdate((WindowPtr)event->message);				// do the Bbou update		else {					DrawDialog(theDialog);				}		break;					}	//	switch		return (result);}			/*ce code permet de demander une valeur pour une fonctiondialog=GetNewDialog(170,nil,(WindowPtr)-1);					SetPort(dialog);										BeginUpdate(dialog);					DrawDialog(dialog);					EndUpdate(dialog);										GetDItem(dialog,1,&itemType,&item,&box);					InsetRect(&rect,-4,-4);					PenSize(3,3);					FrameRoundRect(&rect,16,16);					PenNormal();					NumToString((long)G.HauteurST,&st0);					GetDItem(dialog,2,&itemType,&item,&box);					SetIText(item,&st0);										do {						ModalDialog((ModalFilterProcPtr) nil,&itemhit);						}while (itemhit !=1);										GetDItem(dialog,2,&itemType,&item,&box);					GetIText(item,&st0);					StringToNum(&st0,&num);										G.HauteurST=(short)num;					DisposeDialog(dialog);							w=(WindowPtr)&G.ListingWindow;					SetPort(w);					InvalRect( &w->portRect);*/