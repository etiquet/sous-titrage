#include "BB.Globals_C.h"#include <CursorCtl.h>#include "DrawSousTitre.h"#include "PPCDispatch.h"#include 	"GiveFontInfo.h"extern MyQDGlobals QD;extern AppGlobals G;short ValidST(SousTitreRecordPtr ST_Ptr);short CC_Draw_SousTitre(SousTitreRecordPtr Str,short X,short Y,Ptr ScreenBase,long RowBytes,Rect *rect);static void  	C_TransfertStyleTE_Memoire_Special(TEHandle te,SousTitreRecordPtr ST_Ptr);static void	CopieSt_ST(SousTitreRecordPtr src,  SousTitreRecordPtr dst);void DessineAVST_eng(SousTitreRecordPtr ST_Ptr,Boolean inOffscreen);void DessineAVST(SousTitreRecordPtr ST_Ptr,Boolean inOffscreen);short 	gDrawSTflag;#include <OSUtils.h>//cette routine est un wrapper pour la fonction DessineAVST//elle permet de dessiner un soutitre et ci celui est dans un te actif // elle effectue une subsitutionvoid DessineAVST(SousTitreRecordPtr STPtr,Boolean inOffscreen){SousTitreRecordPtr localST;// on regarde si le sous-titre est actuellement dans un te	// si oui on rŽcupre le texte du te localement ...		localST=STPtr;				if ( ValidST(STPtr) ) {			//erreur de validitŽ des sous-titres			SysBeep(1);			return ;		}						if (G.ListingTE) {			if ( (G.ListingTEStNum==STPtr->st_AbsNUMST) &&(G.ListingTEStItem==Texte_SousTitre) ){			// le te de listing			localST=(SousTitreRecordPtr)NewPtr(10240); //10K devrait tre suffisant pour un sous-titre ...			if (localST){				CopieSt_ST(STPtr,localST);				// on copie les tc , la justif, mask etc ...				C_TransfertStyleTE_Memoire_Special(G.ListingTE,localST);				}			}		}				if (G.saisieTE) {			if ( (G.saisieTEStNum==STPtr->st_AbsNUMST) && (G.saisieTEStItem==Texte_SousTitre) ){			// le te de saisie			localST=(SousTitreRecordPtr)NewPtr(10240);//10K devrait tre suffisant pour un sous-titre ...			if (localST){				CopieSt_ST(STPtr,localST);				// on copie les tc , la justif, mask etc ...				C_TransfertStyleTE_Memoire_Special(G.saisieTE,localST);				}			}		}					if (!localST)localST=STPtr;  // au cas o on n'a pas pu gŽnŽrer une copie locale		DessineAVST_eng(localST,inOffscreen);}// le codeshort CC_Draw_SousTitre(SousTitreRecordPtr STPtr,short X,short Y,Ptr ScreenBase ,long RowBytes,Rect *rect){DrawStParam	DP;PixMapHandle 	Pmh;Rect 		screenbound;short 	i;	//debug	SousTitreRecordPtr localST=nil;		DP.spacewith=G.Display_Font.spaceWidth;		DP.Display_interligne=G.Display_interligne;		DP.kerning=G.Display_Font.NormalKerning;		DP.AutomaticKerning=G.Preference_KernCheck;		DP.Boxing_SizeX=G.Boxing_Size;		DP.Boxing_SizeV=G.Boxing_SizeV;		DP.RGB_OutlineBoxColor=G.RGB_OutlineBoxColor;		DP.RGB_FaceColor=G.RGB_FaceColor;		DP.SafeArea=G.safearea;	// on check ce que l'on nous passe		if (!G.Display_Font.Render_handle) return -1;		if (!G.Display_Font.RenderColor_handle) return -1;		if (!G.Base_Adresse) return -1;		if ( ValidST(STPtr) ) {			//erreur de validitŽ des sous-titres			SysBeep(1);			return -1;		}		// on appelle la routine		SetCCursor(G.CurseurDessineST);				Pmh=(**G.Ve_GDHandle).gdPMap;		DP.screenbound=(**Pmh).bounds; // on rŽcupre la largeur de l'ecran d'affichage	// on effectue un conversion global->local des coordonnŽes top=left=0		DP.screenbound.right-=DP.screenbound.left;		DP.screenbound.left-=DP.screenbound.left; //=0		DP.screenbound.bottom-=DP.screenbound.top;		DP.screenbound.top-=DP.screenbound.top; //=0					// on regarde si le sous-titre est actuellement dans un te	// si oui on rŽcupre le texte du te localement ...				if (G.ListingTE) {			if ( (G.ListingTEStNum==STPtr->st_AbsNUMST) &&(G.ListingTEStItem==Texte_SousTitre) ){			// le te de listing			localST=(SousTitreRecordPtr)NewPtr(10240); //10K devrait tre suffisant pour un sous-titre ...			if (localST){				CopieSt_ST(STPtr,localST);				// on copie les tc , la justif, mask etc ...				C_TransfertStyleTE_Memoire_Special(G.ListingTE,localST);				}			}		}				if (G.saisieTE) {			if ( (G.saisieTEStNum==STPtr->st_AbsNUMST) && (G.saisieTEStItem==Texte_SousTitre) ){			// le te de saisie			localST=(SousTitreRecordPtr)NewPtr(10240);//10K devrait tre suffisant pour un sous-titre ...			if (localST){				CopieSt_ST(STPtr,localST);				// on copie les tc , la justif, mask etc ...				C_TransfertStyleTE_Memoire_Special(G.saisieTE,localST);				}			}		}				//on appelle le dispatcher			if (localST) 	 PPCDispatch_Call_DrawSousTitreEng(&G.Display_Font,localST,X,Y,ScreenBase,RowBytes,&DP,rect);		else 			 PPCDispatch_Call_DrawSousTitreEng(&G.Display_Font,STPtr,X,Y,ScreenBase,RowBytes,&DP,rect);			Show_Cursor(ARROW_CURSOR);		// on dispose le ptr ....	if (localST) DisposePtr((Ptr)localST);		return 0;} //Draw_SousTitre// cette fonction est identique ˆ la C_TransfertStyleTE_Memoire... , mais elle // ne fait pas un certain nombre de test de protection ce qui l'empche d'tre// utilisable sur un sous-titre isolŽ, ce qui est utilisŽ par la fonction CC_Draw_SousTitrestatic void  C_TransfertStyleTE_Memoire_Special(TEHandle te,SousTitreRecordPtr ST_Ptr){Handle	text;long		nLigne,i;Ptr		P;Handle	commentaire;StScrpHandle	stScrap;unsigned long L;short	startsel,endsel,active;// on protge la routine			if (!te) return;						startsel=(**te).selStart;			//{start of selection range}			endsel=(**te).selEnd;			//{end of selection range}			active=(**te).active;			//sauvegarde la valeur						(**te).active=false;				// on ne veut pas de dessin						ST_Ptr->st_StylePtr=nil;			ST_Ptr->st_StyleLenth=nil;			ST_Ptr->st_TexteLenth=nil;/* on compte lenombre de ligne	on ne peut pas utiliser la variable TENLines 	dans le  te car elle enlve une ligne si cr ˆ la fin seul sur une ligne	il faut compter ˆ la main*/			text=(Handle)TEGetText(te);			if (!text) return;						HLock(text);			nLigne=1;			P=*text;						for (i=(**te).teLength;i>=0;i--){				if (*P==13) nLigne++;				P++;			}						HUnlock(text);			ST_Ptr->st_Nlines=nLigne;				ST_Ptr->st_TexteLenth=(**te).teLength;//on sauvegarde la chaine de commentaire			commentaire=nil;			if (ST_Ptr->st_CommentaireLenth){				PtrToHand(ST_Ptr->st_CommentairePtr,&commentaire,ST_Ptr->st_CommentaireLenth);			}			// on regarde rŽcupre le style scrap			if ((**te).txSize==-1) { // vraiment un style te				TESetSelect(0, 32767,te);				stScrap = TEGetStyleScrapHandle(te);				ST_Ptr->st_StyleLenth=GetHandleSize((Handle)stScrap);			} else {				ST_Ptr->st_StyleLenth=nil;	// ce n'est pas un style te donc pas de style				ST_Ptr->st_StylePtr=nil;			}	/* on Žcarte maintemant le sous-titre pour que tout rentre; on calcule la longueur de la zone mŽmoire nŽcessaire */						L=((ST_Ptr->st_TexteLenth+3)/4)*4; 	   			// longueur du texte ajustŽ sur mot long 			L+=((ST_Ptr->st_StyleLenth+3)/4)*4; 			// longueur du style ajustŽ sur mot long 			L+=((ST_Ptr->st_CommentaireLenth+3)/4)*4;	// longueur du commentaire ajustŽ sur mot long 			L+=16;								// en marge de sŽcurite						if (L>10000) {	//assez de mŽmoire ?					SysBeep(1);					return ;				}						ST_Ptr->st_LenthST=L;// on recopie le texte dans le st			if (ST_Ptr->st_TexteLenth){				HLock(text);				BlockMove(*text,(Ptr)ST_Ptr+sizeof(SousTitreRecord),ST_Ptr->st_TexteLenth);				HUnlock(text);			}			// on recopie les style dans le sous-titre				if(stScrap) {				HLock((Handle)stScrap);				// on calcule le pointeur du style				L=(long)ST_Ptr+sizeof(SousTitreRecord);				L+=ST_Ptr->st_TexteLenth;				L=((L+3)/4)*4;				ST_Ptr->st_StylePtr=(Ptr)L;				BlockMove(*stScrap,(Ptr)L,ST_Ptr->st_StyleLenth);				HUnlock((Handle)stScrap);				DisposeHandle((Handle)stScrap);			}// on remet la cha”ne de commentaire s'il elle existe						if (commentaire){				HLock(commentaire);				// on calcule le pointeur du commentaire				L=(long)ST_Ptr+sizeof(SousTitreRecord);				L+=ST_Ptr->st_TexteLenth;				L=((L+3)/4)*4;				L+=ST_Ptr->st_StyleLenth;				L=((L+3)/4)*4;										ST_Ptr->st_CommentairePtr=(Ptr)L;				BlockMove(*commentaire,(Ptr)L,ST_Ptr->st_CommentaireLenth);				DisposeHandle(commentaire);			}									(**te).selStart=startsel;			//{start of selection range}			(**te).selEnd=endsel;				//{end of selection range}			(**te).active=active;			}  //static void CopieSt_ST(SousTitreRecordPtr src,  SousTitreRecordPtr dst){long	L,L1;// on copie le headerdst->st_NextST=nil;dst->st_PreviousST=nil;dst->st_TimeCodeIn =src->st_TimeCodeIn ;dst->st_TimeCodeOut=src->st_TimeCodeOut;dst->st_AbsNUMST=src->st_AbsNUMST; 	//numŽro absolu du stdst->st_NumeroST=src->st_NumeroST;		//(dc.l) numŽro du sous-titre dans la listedst->st_OldNumeroST=src->st_OldNumeroST;dst->st_TexteLenth=src->st_TexteLenth;dst->st_StyleLenth=src->st_StyleLenth;dst->st_LenthST=src->st_LenthST;dst->st_CommentaireLenth=src->st_CommentaireLenth;dst->st_XOffset=src->st_XOffset; dst->st_YOffset=src->st_YOffset; dst->st_Error=src->st_Error; 			//16 possibilitŽes (suffisants je l'espre)dst->st_Nlines=src->st_Nlines;			// nombres de lignes dans le sous-titre	dst->st_Justification=src->st_Justification; 		//justification du texte 0 centrŽe, dst->st_MasKType=src->st_MasKType; 			//type de mask box, line, rectangle; = riendst->st_spare[0]=src->st_spare[0]; 			//6 octets en reservedst->st_spare[1]=src->st_spare[1]; 			//6 octets en reservedst->st_spare[2]=src->st_spare[2]; 			//6 octets en reservedst->st_spare[3]=src->st_spare[3]; 			//6 octets en reservedst->st_spare[4]=src->st_spare[4]; 			//6 octets en reservedst->st_spare[5]=src->st_spare[5]; 			//6 octets en reserve//on copie le contenudst->st_PosOffsetTable=nil;dst->st_StylePtr=nil;src->st_CommentairePtr=nil;/*//a priori,   cela ne sert ˆ rien// on recopie le texte dans le st			if (src->st_TexteLenth){				BlockMove((Ptr)src+sizeof(SousTitreRecord),(Ptr)dst+sizeof(SousTitreRecord),src->st_TexteLenth);			}			// on recopie les style dans le sous-titre				if(src->st_StylePtr && src->st_StyleLenth) {				// on calcule le pointeur du style de destination				L=(long)dst+sizeof(SousTitreRecord);				L+=src->st_TexteLenth;				L=((L+3)/4)*4;				dst->st_StylePtr=(Ptr)L;												BlockMove((Ptr)src->st_StylePtr ,(Ptr)dst->st_StylePtr,src->st_StyleLenth);			}// on remet la cha”ne de commentaire s'il elle existe						if (src->st_CommentairePtr &&src->st_CommentaireLenth ){				// on calcule le pointeur du commentaire en destination				L=(long)dst+sizeof(SousTitreRecord);				L+=src->st_TexteLenth;				L=((L+3)/4)*4;				L+=src->st_StyleLenth;				L=((L+3)/4)*4;				dst->st_CommentairePtr=(Ptr)L;														BlockMove(src->st_CommentairePtr,dst->st_CommentairePtr,src->st_CommentaireLenth);			}*/				}