#include "BB.Globals_C.h"#include <Files.h>// pour la routine d'ecriture async ...typedef struct mypb {HIOParam PB;long	A5;}mypb,*mypbPtr,**mypbHandle;static	mypb gRequestTcPb;static char 	gbuff[100];//protosvoid MesureCpuVitesse(TMXTaskPtr myTask:__A1);void GenerateurInterne(TMXTaskPtr myTask:__A1);pascal void Serial(IOParamPtr pb:__A0,OSErr err:__D0);void RxRs422(Ptr	buff);static void Sony_CompleteReceiveMessage(IOParamPtr pb:__A0,OSErr err:__D0);static void MyRead_VitcComplete(IOParamPtr pb:__A0,OSErr err:__D0);long FiltreTimeCode(long tc,long tcdefault);void CalcVtr_Speed(TMXTaskPtr myTask:__A1);void TxVITCReader(long 	code,long message ,short refnum);// writestatic pascal void C_TxRS422_Async(long command, long parameter, short refnum);//routine de complétion de C_TxRS422static void TxRS422_Async_Completion(IOParamPtr pb:__A0,OSErr err:__D0);asm long GetA5(void):__D0;extern short gWatchdog;long 	gtcasked;// les globalsextern AppGlobals G;extern MyQDGlobals QD;extern Boolean gRefreshInfoW,gCanReadVitc;extern TMXTask gMesureVtrSpeed;// variables	long			DoMainReadSerialRequest;long			DoVitcReadSerialRequest;long			DoAbortIO;short  			CurrentField;	Ptr				SerBuff1,SerBuff2;extern	Boolean RefreshInfoW;Boolean			gMethodeLectureRS422;long			gVitesseVTR;static unsigned long 	gLastTCanalyse;extern long gVitcLuParAV;/* ---  routines ---  */// Cette routine permet la mesure toutes les secondes des performances du logicielvoid MesureCpuVitesse(TMXTaskPtr myTask:__A1){long			savea5;	savea5=SetA5(myTask->tmRefCon);		// on effectue un tranfert des valeurs	G.EventLoop_Speed=G.EventLoop_Counteur;	G.Serial_Main_rate=G.Serial_Main_Count;	G.Serial_Vitc_rate=G.Serial_Vitc_Count;	G.Serial_Sony_rate=G.Serial_Sony_Count;		// on RAZ les compteurs	G.EventLoop_Counteur=0;	G.Serial_Main_Count=0;	G.Serial_Vitc_Count=0;	G.Serial_Sony_Count=0;	gRefreshInfoW=true;	PrimeTime((QElemPtr)myTask,1000);	SetA5(savea5);	// on rend la valeur de A5}// Cette routine permet la mesure de la vitesse du magnétoscopevoid CalcVtr_Speed(TMXTaskPtr myTask:__A1){long			savea5;long			a;Ptr				P;unsigned long 	TC;	savea5=SetA5(myTask->tmRefCon);	// on effectue le calcul en fonction du type de TC lecture	switch(G.LecteurTimeCode_Type){		case 0: // lecteur VITC			TC=G.General_PseudoTimeCode;		break;				case 1: // lecteur VITC			TC=G.Vitc_Readen;		break;						case 2: // rs 422			if (!G.Player_TC_src){// mode Auto Ltc/Vitc ?				TC=G.LastRecevied422TC;			} else {				a=(G.Player_TC_src-1)*4;				P=(Ptr)&G.PlayerStruct.vtr_LTC;				P=P+a;				TC=*((LPtr)P);			}					break;			case 3: // Lecteur VITC carte AV			TC=G.General_TCCourant;		break;								case 5: // Lecteur VITC carte AV			TC=G.General_TCCourant;		break;				}		a=C_ConversionTimeCodeTrames(TC);	a-=C_ConversionTimeCodeTrames(gLastTCanalyse);	gLastTCanalyse=TC;	gVitesseVTR=a;			PrimeTime((QElemPtr)myTask,240); // 1 mesures /6 images	SetA5(savea5);	// on rend la valeur de A5	} // ANALYSE VITESSE// Cette routine permet d'incrémenter le timecode internevoid GenerateurInterne(TMXTaskPtr myTask:__A1){long			savea5;	savea5=SetA5(myTask->tmRefCon);	// on place le registre a5 (on sauvegarde la valeur précedente)	// on incrémente la valeur du générateur interne	G.General_PseudoTimeCode=C_AdditionTimeCode(G.General_PseudoTimeCode,1);		//on envoie une demande de timecode au magnétoscope si protocole RS422	if (G.LecteurTimeCode_Type==2)		switch (G.Player_TC_src){					case 0:						C_TxRS422_Async('TIME',3,G.ModemOutRefNum);					break;										case 1:						C_TxRS422_Async('TIME',1,G.ModemOutRefNum);					break;										case 2:						C_TxRS422_Async('TIME',2,G.ModemOutRefNum);					break;										case 3:						C_TxRS422_Async('TIME',4,G.ModemOutRefNum);					break;										case 4:						C_TxRS422_Async('TIME',4,G.ModemOutRefNum);					break;		}//switch		// si mode générateur interne actif on copie la valeur	if (!G.LecteurTimeCode_Type){		G.General_LastTCCourant=G.General_TCCourant;		G.General_TCCourant=G.General_PseudoTimeCode;		// on active le voyant reception série			if (!G.SerialError) 	G.SerialError=25;			else 			G.SerialError=22;		}		// on regarde s'il faut relancer lecture vitc		/*if (DoVitcReadSerialRequest){			DoVitcReadSerialRequest=0;			G.Vitc_Rx_PB.ioResult=0;			G.Vitc_Rx_PB.ioReqCount=8;			G.Vitc_Rx_PB.ioPosMode=fsFromStart;			G.Vitc_Rx_PB.ioPosOffset=0;			err=PBRead((ParmBlkPtr)&G.Vitc_Rx_PB,true);			DoAbortIO=0;		}*/			// on relance la task	PrimeTime((QElemPtr)myTask,40);	SetA5(savea5);	// on rend la valeur de A5}// cette routine initialise la lecture du time code par le port sériepascal void InitSerial(void) {	SerShk				handshk;	long				response;	OSErr				err;	short				outRefnum,inRefnum;							Gestalt('cput',&response);		gMethodeLectureRS422=false;		// si processeur 601 on change de méthode de lecture du tc		//if ((response&0xFFF) >= 0x101) gMethodeLectureRS422=true; 		// !!!!! IL FAUDRAIT FAIRE TEST SI SERIAL DMA PRESENT !!!!!!		// on regarde si la touche control est enfoncé si oui on demande l'avis à l'utilisateur.		/*	EventAvail (-1,&event);		if (event.modifiers&controlKey)	{			a=Alert(285,nil);			gMethodeLectureRS422=false;			if (a==2) gMethodeLectureRS422=true; 		}*/// si power book 150 ->n° de mac 113// on ouvre le port B (printer);				Gestalt ('mach',&response);		// !!!!!!!!!!!!! temporaire		//response=0x73;				// ouverture port seulement si  lecture TC par port série		G.ModemInRefNum=0;		G.ModemOutRefNum=0;					// si mode de génération TC rs 422	// on s'assure que c'est le mode LTC/VITC qui est utilisé		if ( G.LecteurTimeCode_Type==5 ){			G.Player_TC_src=0;		}						if( ( G.LecteurTimeCode_Type==1 || G.LecteurTimeCode_Type==2|| G.LecteurTimeCode_Type==5)) {				if (response==0x73) {		// c'est un power book 150 on ouvre le port printer (il n' y a pas de port modem  !!!!)			err=OpenDriver("\p.BOut",&outRefnum); 				if (err){				SysBeep(1);				G.ModemOutRefNum=0;				}					err=err|OpenDriver("\p.BIn",&inRefnum);						if (err){				SysBeep(1);				AlertUser(8);				G.ModemInRefNum=0;				}  else {					// pas de problème on affecte les ref num					G.ModemOutRefNum=outRefnum;					G.ModemInRefNum=inRefnum;									}																} else { // pas PW 150				err=OpenDriver("\p.AOut",&outRefnum); 				if (err){					SysBeep(1);					G.ModemOutRefNum=0;					}														err=err|OpenDriver("\p.AIn",&inRefnum);								if (err){					SysBeep(1);					AlertUser(8);					G.ModemInRefNum=0;					} else {						// pas de problème on affecte les ref num						G.ModemOutRefNum=outRefnum;						G.ModemInRefNum=inRefnum;										}																						} // else machine normale // else machine normale		if (err==noErr){			handshk.fXOn=0;			handshk.fCTS= 0;			handshk.errs= 0;			handshk.evts= 0;			handshk.fInX= 0;			handshk.fDTR= 0;		/*	{use control call with csCode=14 instead of SerHShake function}		{Note that it’s only necessary to call the output side, }		{ not the input driver. Changes are reflected to input side.}	*/			if (Control(G.ModemOutRefNum, 14, &handshk)) AlertUser(18);			if (SerReset(G.ModemOutRefNum,1+16384+3072+4096) )  AlertUser(18);			if (SerReset(G.ModemInRefNum,1+16384+3072+4096) ) AlertUser(18);						SerBuff1=NewPtrClear(32000);			SerBuff2=NewPtrClear(32000);				// on place des buffers de mémoire						SerSetBuf(G.ModemInRefNum,SerBuff1,128); //{set the buffer}			SerSetBuf(G.ModemOutRefNum,SerBuff2,128); //{set the buffer}			/* 		On positionne le fils ( RTS) 		pour la commande du relais	en fct du mode en cours*/			if (G.Mode_Commutateur!=1){			// pour l'instant pas activé				Control(G.ModemOutRefNum, 17, nil);				Control(G.ModemOutRefNum, 18, nil);				}				else Control(G.ModemOutRefNum, 17, nil); // forcé activé				// maintenant on initialise les Pb et on demande// (si option) une lecture d'1 octets au système#ifdef __Demo__			goto CanReadTC;#endif	#ifndef __NoProtect__		if (G.SoftProtect==1) goto CanReadTC;		if (G.FindFirstKey_error) return;#endif						CanReadTC:				DoSerialSetup();		} // pas erreur ouverture ports série					} // si mode lecteur VITC ou RS422 	} // InitSerial//---------------/* Cette routine initialise les ≠ pb de réception série	et on demande une lecture d'un octets */	pascal void DoSerialSetup(void){OSErr	anErr;IOParamPtr pb;// on initialise le paramBlock pour la réception mode SONY		pb=(IOParamPtr)&G.Sony_Rx_PB;		pb->ioCompletion=(IOCompletionUPP)&Sony_CompleteReceiveMessage;		pb->ioResult=0;		pb->ioVRefNum=0;		pb->ioRefNum=G.ModemInRefNum;		pb->ioBuffer=G.Sony_Rx_Buffer+1;		pb->ioReqCount=1;		pb->ioPosMode=fsFromStart;		pb->ioPosOffset=0;		// on initialise le paramBlock pour la réception mode VITC		pb=(IOParamPtr)&G.Vitc_Rx_PB;		pb->ioCompletion=(IOCompletionUPP)&MyRead_VitcComplete;		pb->ioResult=0;		pb->ioVRefNum=0;		pb->ioRefNum=G.ModemInRefNum;		pb->ioBuffer=G.Vitc_Rx_PB_Buffer;		pb->ioReqCount=1;		pb->ioPosMode=fsFromStart;		pb->ioPosOffset=0;		// les ParameterBlock pour la transmission			pb=(IOParamPtr)&G.Tx1_PB;		pb->ioCompletion=(IOCompletionUPP)nil;		pb->ioResult=0;		pb->ioVRefNum=0;		pb->ioRefNum=G.ModemOutRefNum;		pb->ioBuffer=(Ptr)G.Tx1_PB_Buffer;		pb->ioReqCount=1;		pb->ioPosMode=fsFromStart;		pb->ioPosOffset=0;				pb=(IOParamPtr)&G.Spare_PB;		pb->ioCompletion=(IOCompletionUPP)nil;		pb->ioResult=0;		pb->ioVRefNum=0;		pb->ioRefNum=G.ModemInRefNum;		pb->ioBuffer=G.Spare_PB_Buffer;		pb->ioReqCount=1;		pb->ioPosMode=fsFromStart;		pb->ioPosOffset=0;					pb=(IOParamPtr)&G.Spare1_PB;		pb->ioCompletion=(IOCompletionUPP)nil;		pb->ioResult=0;		pb->ioVRefNum=0;		pb->ioRefNum=G.ModemOutRefNum;		pb->ioBuffer=G.Spare1_PB_Buffer;		pb->ioReqCount=1;		pb->ioPosMode=fsFromStart;		pb->ioPosOffset=0;	// on demande maintenant une lecture asynchrone// sauf si horloge interne ou lecteur vitc par soft		if (!G.ModemInRefNum) return;#ifndef __Demo__	#ifndef __NoProtect__		if (G.SoftProtect==1) goto CanReadTC;		if (G.FindFirstKey_error) return;	#endif	#endif// si version demo, et temps dépassé on passe en mode tc interne#ifdef __Demo__		if (G.FindFirstKey_error) {				G.LecteurTimeCode_Type=0;				return;				}#endifCanReadTC:		DoAbortIO=0;		DoMainReadSerialRequest=0;		DoVitcReadSerialRequest=0;		pb=(IOParamPtr)&G.Main_Rx_PB;		pb->ioCompletion=(IOCompletionUPP)&Serial ;		pb->ioResult=0;		pb->ioVRefNum=0;		pb->ioRefNum=G.ModemInRefNum;		pb->ioBuffer=G.Main_Rx_PB_Buffer;		pb->ioReqCount=4;		pb->ioPosMode=fsFromStart;		pb->ioPosOffset=0;				if ( G.LecteurTimeCode_Type==1 || G.LecteurTimeCode_Type==2|| G.LecteurTimeCode_Type==5){			anErr=PBRead((ParmBlkPtr)pb,true);		}} //DoSerialSetup//---------------pascal void Serial(IOParamPtr pb:__A0,OSErr err:__D0){OSErr	anErr;long	a,b;long	savea5;IOParamPtr	pb1;	if (err==-27) return;// abortio	savea5=SetA5( ( (IOParamPtrWithGlobalPtr) pb)->A5World  );// S'il y a une erreur, on ne fait rien	if (err){ 				DoAbortIO=err|DoAbortIO;				if (G.LecteurTimeCode_Type) DoMainReadSerialRequest=false;				if (G.LecteurTimeCode_Type) DoVitcReadSerialRequest=false;				SetA5(savea5);				return;				}	switch(G.LecteurTimeCode_Type){		case 0:		break;				case 1:	//lecteur VITC	  		b=pb->ioBuffer[0];			a=b&0xf0;			if (a==0){				pb1=(IOParamPtr)&G.Vitc_Rx_PB;				pb1->ioReqCount=8;				pb1->ioPosMode=fsAtMark;				anErr=PBRead((ParmBlkPtr)pb1,true);				DoMainReadSerialRequest=false; 				DoVitcReadSerialRequest=false; // on redemande une lecture du port				DoAbortIO=0;			} else {				DoAbortIO=0;				DoMainReadSerialRequest=true; // on redemande une lecture du port				DoVitcReadSerialRequest=false;			}		break;				case 5: // mode Rs422 sony		case 2: // mode Rs422 sony			b=pb->ioBuffer[0];			a=b&0xf0;						if ( (a==0x70) ){				a=(b&0x0f)+2;				*(G.Sony_Rx_Buffer)=b;				pb1=(IOParamPtr)&G.Sony_Rx_PB;				pb1->ioReqCount=a;				pb1->ioPosMode=fsFromStart;				pb1->ioPosOffset=0;				anErr=PBRead((ParmBlkPtr)pb1,true);				DoMainReadSerialRequest=false; // on redemande une lecture du port				DoVitcReadSerialRequest=false;						}  else	 {				DoAbortIO=0;				DoVitcReadSerialRequest=false;				DoMainReadSerialRequest=true; // on redemande une lecture du port			}					break;	}//switch			G.Serial_Main_Count++;		DoAbortIO=0;		SetA5(savea5);}//---------------void Sony_CompleteReceiveMessage(IOParamPtr pb:__A0,OSErr err:__D0){long		a,b;long		savea5;Ptr			P;	if (err==-27) return;// abortio	savea5=SetA5( ( (IOParamPtrWithGlobalPtr) pb)->A5World  );// S'il y a une erreur, on ne fait rien	if (err){ 				G.SerialError=0;				DoAbortIO=err|DoAbortIO;				DoMainReadSerialRequest=true;				DoVitcReadSerialRequest=false;				SetA5(savea5);				return;				}						//	 erreur sur infos reçues						a=*(G.Sony_Rx_Buffer);	// on regarde si c'est un code page $10 ou ≠ 70 (on ne le gère pas)		if ( ( (a&0xf0) != 0x10) && ( (a&0xf0) != 0x70) ) { 				DoAbortIO=err|DoAbortIO;				DoMainReadSerialRequest=true;				DoVitcReadSerialRequest=false;				SetA5(savea5);				return;				}			// pas visiblement de problèmes on analyse la reception		RxRs422(G.Sony_Rx_Buffer);	// on indique que l'on reçoit qqchose				if (G.SerialError<=0) G.SerialError=25;			else G.SerialError=22;			// maintenant on recopie pour le logiciel le time code 				if (!G.Player_TC_src){// mode Auto Ltc/Vitc ?			a=G.LastRecevied422TC;		} else {			b=(G.Player_TC_src-1)*4;			P=(Ptr)&G.PlayerStruct.vtr_LTC;			P=P+b;			a=( *((LPtr)P));		}					//filtrage du tc			a=a&0x3f7f7f3f;					if (gVitesseVTR>4){ // si play					a=C_AdditionTimeCode(a,G.OffsetLectureTCPlay);			//a=C_AdditionTimeCode(a,1);		} else { // si stop					a=C_AdditionTimeCode(a,G.OffsetLectureTCStop);				}				// on envèle le filtrage		//a=FiltreTimeCode(a,G.General_TCCourant);				gWatchdog=600;				G.General_LastTCCourant=G.General_TCCourant;		G.General_TCCourant=a;						// on s'occupe d'activer le voyant série		G.Serial_Sony_Count++;			// on redemmande une lecture le la routine principale	 		if (gMethodeLectureRS422){		 		DoMainReadSerialRequest=true; // on redemande une lecture du port	 	 	} else { 								G.Main_Rx_PB.ioResult=0;				G.Main_Rx_PB.ioReqCount=1;				G.Main_Rx_PB.ioPosMode=fsFromStart;				G.Main_Rx_PB.ioPosOffset=0;				err=PBRead((ParmBlkPtr)&G.Main_Rx_PB,true);		}						SetA5(savea5);}//---------------void RxRs422(Ptr	buff){unsigned char a,b;Ptr		P;long 	l;VtrStatusRecordPtr	dest=(VtrStatusRecordPtr)&G.PlayerStruct;// on regarde commande 1	a=*buff;	b=*(buff+1);	// protection du logiciel	#ifdef __Demo__			goto CanReadTC;#endif	#ifdef __NoProtect__			goto CanReadTC;#endif	#ifndef __NoProtect__		if (G.SoftProtect==1) goto CanReadTC;		if (G.FindFirstKey_error) return;#endif									CanReadTC:				// code retour time code	ou status		if( (a&0xf0) == 0x70 )			switch (b){					case	0:		 //CTL_1						dest->vtr_error=0;						P=(Ptr)(&dest->vtr_TTM1);						*(P)=buff[5]; *(P+1)=buff[4]; *(P+2)=buff[3]; *(P+3)=buff[2];					break;										case 	1: 		//CTL_2						dest->vtr_error=0;						P=(Ptr)&(dest->vtr_TTM2);						*(P)=buff[5]; *(P+1)=buff[4]; *(P+2)=buff[3]; *(P+3)=buff[2];					break;										case 	4: 		//LTC					case 	0x14: 	//LTC							dest->vtr_error=0;						P=(Ptr)&(dest->vtr_LTC);						*(P)=buff[5]; *(P+1)=buff[4]; *(P+2)=buff[3]; *(P+3)=buff[2];						G.LastRecevied422TC=dest->vtr_LTC;					break;											case 	5: 	  	//LTC_UB					case 	0x15: 	//LTC_UB							dest->vtr_error=0;						P=(Ptr)&(dest->vtr_LTC_UB);						*(P)=buff[5]; *(P+1)=buff[4]; *(P+2)=buff[3]; *(P+3)=buff[2];					break;										case 	6: 		//VITC							dest->vtr_error=0;						P=(Ptr)&(dest->vtr_VITC);						*(P)=buff[5]; *(P+1)=buff[4]; *(P+2)=buff[3]; *(P+3)=buff[2];						G.LastRecevied422TC=dest->vtr_VITC;					break;										case 	7: 		//VITC_UB					case 	0x16:	//VITC_UB						dest->vtr_error=0;						P=(Ptr)&(dest->vtr_VITC_UB);						*(P)=buff[5]; *(P+1)=buff[4]; *(P+2)=buff[3]; *(P+3)=buff[2];					break;											case 	0x20: 	//STATUS						break;										case 	0x3E: 	//RecordInhibitSense						dest->vtr_error=0;						P=(Ptr)&(dest->vtr_recInhibit);						*(P)=buff[3]; *(P+1)=buff[4];					break;		}// switch			// code retour erreur ou device type		if ( (a&0xF0) ==0x10)			switch (b){				case 	01: 	//ack						dest->vtr_error=0;				break;				case 	0x12:	//Nack						dest->vtr_error=buff[3];						dest->vtr_Ticks=LMGetTime();				break;				case	0x11:	//DeviceType						dest->vtr_error=0;						P=(Ptr)&(dest->vtr_Type);						*(P)=buff[3]; *(P+1)=buff[4];				break;				}//switch				} // Rxsr422//---------------static void MyRead_VitcComplete(IOParamPtr pb:__A0,OSErr err:__D0){long		a;long		savea5;Ptr			P;unsigned char c;	if (err==-27) return;// abortio	savea5=SetA5( ( (IOParamPtrWithGlobalPtr) pb)->A5World  );// S'il y a une erreur, on ne fait rien	if (err){ 				G.SerialError=0;				DoAbortIO=err|DoAbortIO;				DoMainReadSerialRequest=false;				DoVitcReadSerialRequest=false;				SetA5(savea5);				return;				}//	 erreur sur infos reçues	?	P=(Ptr)G.Vitc_Rx_PB_Buffer;		c=*(P);	if ( (c&0xF0) !=0x70){				G.SerialError=0;				DoAbortIO=0;				DoMainReadSerialRequest=true;				DoVitcReadSerialRequest=false;				SetA5(savea5);				return;		 	}	// c'est bon on décode les infos reçues		a=0;	CurrentField=(c&8==0);// on garde en mémoire l'information de trame	a=c&0x07;		c=*(P+1);	if ((c&0xF0) !=0x60){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	a=a<<4;	a=a|c&0xf;		c=*(P+2);	if ((c&0xF0) !=0x50){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	a=a<<4;	a=a|c&0xf;		c=*(P+3);	if ((c&0xF0) !=0x40){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	a=a<<4;	a=a|c&0xf;		c=*(P+4);	if ((c&0xF0) !=0x30){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	a=a<<4;	a=a|c&0xf;		c=*(P+5);	if ((c&0xF0) !=0x20){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	a=a<<4;	a=a|c&0xf;		c=*(P+6);	if ((c&0xF0) !=0x10){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	a=a<<4;	a=a|c&0xf;		c=*(P+7);	if ( (c&0xF0) ){ //	 erreur sur infos reçues	?			G.SerialError=0;			DoAbortIO=0;			DoMainReadSerialRequest=true;			DoVitcReadSerialRequest=false;			SetA5(savea5);			return;		 	}	 		a=a<<4;	a=a|c&0xf;	// problème sur certain lecteur de vitc, il faut éliminer le 	// code horaire, les dizaines d'heures.		//a=a&0x0fffffff;	//a=a|0x10000000;	G.Vitc_Readen=a;	a=a&0x3f7f7f3f;// on filtre le tc reçu			if (gVitesseVTR>4){ // si play					a=C_AdditionTimeCode(a,G.OffsetLectureTCPlay);			a=C_AdditionTimeCode(a,1);		} else { // si stop					a=C_AdditionTimeCode(a,G.OffsetLectureTCStop);				}	G.General_TCCourant= FiltreTimeCode(a,G.General_TCCourant);// on s'occupe d'activer le voyant série	DoAbortIO=0;	G.Serial_Vitc_Count++;	// on indique que l'on reçoit qqchose	if (G.SerialError<=0) G.SerialError=25;			else G.SerialError=22;			// on redemmande une lecture du VITC		DoMainReadSerialRequest=false;	DoVitcReadSerialRequest=true;//------------	DoVitcReadSerialRequest=false;	G.Vitc_Rx_PB.ioResult=0;	G.Vitc_Rx_PB.ioReqCount=8;	G.Vitc_Rx_PB.ioPosMode=fsFromStart;	G.Vitc_Rx_PB.ioPosOffset=0;	err=PBRead((ParmBlkPtr)&G.Vitc_Rx_PB,true);	DoAbortIO=0;//------------			SetA5(savea5);}void TxVITCReader(long 	code,long message ,short refnum){unsigned char buff[12];long	L;short	S;	if (code){		switch(code){// port 2 du HD6303XP/*	b0 led 		b5 b6 b7= code sur 3 bits pour sélection	1 play	2 stop	3 ffwd	4 frew	5 Eject	6 pause	7 shutle-		si shuttle 6 ou 7	b1b2 = vitesse 			0 ->3	   										        _	le système génère une impulsion     ___| |___	*/			case 'NULL':				buff[0]='=';				L=1;				FSWrite(refnum,&L,&buff[0]);				WaitTicks(2);				buff[0]=0;				L=1;				FSWrite(refnum,&L,&buff[0]); 				WaitTicks(4);				buff[0]='=';				L=1;				FSWrite(refnum,&L,&buff[0]);				WaitTicks(2);				buff[0]=0;				L=1;				FSWrite(refnum,&L,&buff[0]); 			break;			case 'PLAY':				buff[0]='='; buff[1]=0x20;				L=2;				FSWrite(refnum,&L,&buff[0]);			break;						case 'STOP':				buff[0]='='; buff[1]=0x40;				L=2;				FSWrite(refnum,&L,&buff[0]);			break;			case 'FREW':				buff[0]='='; buff[1]=0x60;				L=2;				FSWrite(refnum,&L,&buff[0]);			break;						case 'FFWD':				buff[0]='='; buff[1]=0x80;				L=2;				FSWrite(refnum,&L,&buff[0]);			break;						case 'EJEC':				buff[0]='='; buff[1]=0xa0;				L=2;				FSWrite(refnum,&L,&buff[0]);				WaitTicks(6);			break;												case 'SHTL':				buff[0]='=';				S=message;				buff[1]=0xe0;								if(S<0 ) buff[1]= buff[1]|0x4; // shuttle -				if (S<0) S=-S;				if (S>66) buff[1]=buff[1]|0x02; // vitesse rapide												L=2;				FSWrite(refnum,&L,&buff[0]);				WaitTicks(4);				buff[0]='=';				L=1;				FSWrite(refnum,&L,&buff[0]);				buff[0]=0;				L=1;				FSWrite(refnum,&L,&buff[0]); 				WaitTicks(1);				buff[0]='=';				L=1;				FSWrite(refnum,&L,&buff[0]);				buff[0]=0;				L=1;				FSWrite(refnum,&L,&buff[0]); 			break;			}	}				}//'SHTL',0,G.ModemOutRefNum);// cette routine envoie des commandes RS422static pascal void C_TxRS422_Async(long command, long parameter, short refnum){short	i;char		checksum,c;long		LL;OSErr		err;/*	c'est la même routine que TxRS422 mais sous interruption*	fct à transmettre    *	PLAY,STOP,FFWD,etc…**	donnée: long**  n° de port série     */		if (!refnum) return;		// on regarde s'il y a deja une demande en route// si c'est le cas on ne fait rien on attend		if (gtcasked){			gtcasked++;			return;		}								switch (command){			case  'TIME':    //ask TC							gbuff[0]=0x3;				gbuff[1]=0x61;				gbuff[2]=0x0c;				LL=parameter;				c=parameter&0xff;				gbuff[3]=c;				break;			case  'W tc': // envoie une information de timecode (LTC)				gbuff[0]=0x06;				gbuff[1]=0x74;				gbuff[2]=0x04;				LL=parameter;				c=parameter&0xff;				gbuff[3]=c;				parameter=parameter>>8;				c=parameter&0xff;				gbuff[4]=c;				parameter=parameter>>8;				c=parameter&0xff;				gbuff[5]=c;				parameter=parameter>>8;				c=parameter&0xff;				gbuff[6]=c;			break;			default:			return;		}		// on calcule le checksum		c=0;		for (i=1;i<=gbuff[0];i++){			c=c+gbuff[i];				}		gbuff[0]++;		gbuff[gbuff[0]]=c;		// On effectue un write opération		gRequestTcPb.A5=GetA5(); // on place le A5		gRequestTcPb.PB.ioCompletion=(IOCompletionUPP)&TxRS422_Async_Completion; // routine de complétion   		gRequestTcPb.PB.ioRefNum=refnum;		gRequestTcPb.PB.ioBuffer=&gbuff[1];		gRequestTcPb.PB.ioPosMode=fsFromStart;		gRequestTcPb.PB.ioPosOffset=0;		gRequestTcPb.PB.ioReqCount=(long)gbuff[0];				err=PBWrite((ParmBlkPtr)&gRequestTcPb,true); 		gtcasked++;}//C_TxRS422_Async// cette routine raz le compteur pour que l'on puisse envoyer une autre demandestatic void TxRS422_Async_Completion(IOParamPtr pb:__A0,OSErr err:__D0){long		a,b;long		savea5;Ptr			P;	if (err==-27) return;// abortio	savea5=SetA5( ( (mypbPtr) pb)->A5 ); // on recupère le pt des globals// S'il y a une erreur, on ne fait rien	if (err){ 				G.SerialError=0;				DoAbortIO=err|DoAbortIO;				DoMainReadSerialRequest=true;				DoVitcReadSerialRequest=false;				SetA5(savea5);				return;				}				//SysBreak();			gtcasked=0;									SetA5(savea5); // on rend le A5		} //TxRS422_Async_Completionasm long GetA5(void):__D0{	move.l A5,D0	rts}