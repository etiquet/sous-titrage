* ================================================* PROCEDURE Create_FastFont(); * ================================================**	Cette routine effectue le rendu d'une police d'affichage colorŽe*  ˆ partir d'une font dŽjˆ calculŽe, pour une grande rapiditŽe d'affichage*  *Create_FastFont 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFontRender			ds.l	1		; record pour le passage des parramtres de rendusDestinationSize		ds.w	1		; 16 ou 32 bits mode ?RenderEffect		ds.l	1		; effet de rendu ParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkTextBuff	ds.b	256XOffset					ds.w	1YOffset					ds.w	1Pointeur				ds.l	1			; dŽrŽfŽrence du handlehandle					ds.l	1			; handle pour le dessinRGB_Color				ds.W	3Itemchoisi				DS.w	1		; Item choisi par l'utilisateuritemType				ds.w	1		; stockage du type de ItemitemHandle				ds.L	1		; stockage	du handle du itemitemRect				ds		Rect	DialogStorage			ds		dWindLenWaitingDialogStorage	ds		dWindLenThepoint				ds.l	1TotalChar				ds.w	1		; nb total de caractre ˆ rendreCharCounter				ds.w	1		; total de caractre rendubaseLine				ds.w	1		; cf Render sub routineStyleType				ds.w	1		; style en cour	type style MAC   (cf Quick Draw)theStyle				ds.w	1		; style en cour compteur 0....nTheChar					ds.w	1		; caractre en courThePlane				ds.w	1		; plan en cour (face/bordure/ombre)CharRect				ds		Rect	; carrŽ du plan dessinŽFontBitmapPtr			ds.l	1		; pointeur du dŽbut du bitmap de la policeFontBitmapSize			ds.l	1		; taille du "font bitmaps"  FontBitmapHimem			ds.l	1		; pointeur de la fin du bitmap de la police n.u.FontCurrentPtr			ds.l	1		; pointeur relatif positiion dans  le handleFontStylePtr			ds.l	1		; pointeur relatif du styleFontCharPtr				ds.l	1		; pointeur relatif du caractre (Charheader) dans le stylePreviousFontCharPtr		ds.l	1		; pointeur relatif au prŽcŽdent caarctreFontPlanePtr 			ds.l	1		; pointeur relatif du plan dans le caractreSavePort				ds.l	1		; save portsaveD1					ds.l	1		;Row_Bytes				ds.l	1Base_Adresse 			ds.l	1	Row_BytesVX				ds.l	1spare					ds.l	2ItemHit		ds.w	1CurrentcharRect	ds		rect		;LocalSize	EQU 	*			; size of all the local variables		ENDR		SEG	'Rendering'			; case sensitive			WITH	StackFrame,SOUSTITRERECORD,FontRenderRecord,HSLColor	;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \					RenumerotationSubNumero,RenumerotationListeSousTitre,\					ConversionTCstASCII,custom_PlotCIcon,Rendering_font_SubRoutine; 		movem.l d1-d7/a1-a4,-(sp)	; sauvegarde des registres* ----- pour les tests on dessine Žgalement dans la vidŽo explorer; on recherche la base adresse et le rowbyte								clr.l	-(sp)					_GetDeviceList			; ˆ changer 				move.l	(sp)+,d0 				move.l	d0,-(sp) 				move.l	d0,-(sp) 				_GetNexTDevice				move.l	(sp)+,a0		; le handle				move.l	(a0),a0			; handle => pointeur				move.w	gdID(a0),d0		;				move.l	gdPMap(a0),a1				move.l	(a1),a1			; handle => pointeur				move.l	baseAddr(a1),Base_Adresse(a6)				move.w	rowBytes(a1),d0				and.l	#$7fff,d0		; seulement b0-b14 et extension sur 32 bits				move.l	d0,Row_BytesVX(a6)		; on regarde s'il y a un font bitmap en mŽmoire									move.l	FontRender(a6),a0		; taille de la police		tst.l	Render_handle(a0)		beq		Exit_Err					; il n'Žxiste pas de font bitmap					; on demande une zone mŽmoire pour pouvoir dessiner un caractre dans un plan		; on reserve un espace mŽmoire =4 fois la taille de la lettre 		; pour permettre le rendu d'un plan		move.l	FontRender(a6),a0		; taille de la police		move.w	FontSize(a0),d0		mulu	#32,d0				; 4* la taille mots long		move.w	d0,d1						mulu	d1,d0								add.l	#10240,d0			; en sŽcuritŽe		_NewHandle		move.l	a0,handle(a6)		_Hlock						; on locked le handle		move.l	handle(a6),a0				move.l	(a0),a0				; handle => pointeur		move.l	a0,Pointeur(a6); on effectue un calcul prŽalable de l'espace mŽmoire nŽcessaire pour contenir; la police	d'affichage.; on rŽcupre la taille du handle display font; on ouvre un dialog pour indiquer que nous recherchons de la mŽmoire		clr.l	-(sp)		move.w	#176,-(sp)	; id number		pea		WaitingDialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		_DrawDialog		move.l	FontRender(a6),a0				move.l	Render_handle(a0),a0		; display font handle		_GetHandleSize		tst.l	d0		bmi		Exit_err1		; on s'arrte on ferme le dialog recherche mŽmoire; d0 contient la taille du display font; on demande un handle de 3 fois la taille 				mulu.l	#4,d0		;  ; on tente une allocation de mŽmoire				move.l	d0,d7		; on sauvegarde la valeur		move.l	d0,FontBitmapSize(a6)		_NewHandle		tst.w	d0			; demande satisfaite ? 		beq		AllRight_EnoughtMemory	; oui tout va bien		; il n'y a pas assez de mŽmoire		; on indique la quantitŽ de mŽmoire dispo; on regarde s'il y a dŽja un handle alouŽ si oui on le dispose		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		cmpa.l	#00000000,a0		beq.S	non_pas_deja_0; oui , on le dispose		_DisposHandle		move.l	FontRender(a6),a1		; font record		clr.l	RenderColor_handle(a1)		; on place le handle dans le font recordnon_pas_deja_0				_PurgeSpace		move.l	a0,d0		sub.l	#32*1024,d0		; on est bien obligŽ de laisser de la place		divu	#1024,d0		and.l	#$ffff,d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7		; on ouvre un dialog pour indiquer le problme		OpenDialog	(166)		pea		DialogStorage(a6)		_DrawDialog				pea		DialogStorage(a6)		move.w	#4,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)			_SetItext				move.l	d7,d0		; on recupre la valeur		divu	#1024,d0		and.l	#$ffff,d0		lea		TextBuff(a6),a0		clr.w	-(sp)		_Pack7				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		TextBuff(a6)			_SetItext	WaitEvent		import	SpecialModalDialogFilter		pea	SpecialModalDialogFilter		pea	ItemHit(a6)		_ModalDialog		move.w	ItemHit(a6),d0				cmp.w	#1,d0		beq		Exit_bis		; on s'arrte		cmp.w	#2,d0		bne		WaitEvent; l'utilisateur tente de continuer				pea		DialogStorage(a6)		_CloseDialog						_PurgeSpace		move.l	a0,d0		sub.l	#32*1024,d0		; on est bien obligŽ de laisser de la place		move.l	d0,FontBitmapSize(a6)	; on sauvegarde la taille du handle		_NewHandle						tst.w	d0		beq.s	AllRight_EnoughtMemory			; alert ce n'est pas possible		clr.w	-(sp)		move.w	#159,-(sp)		clr.l	-(sp)		_Alert		move.w	(sp)+,d0		bra		Exit_err1		; -----------------------------------------------------------------------		; ok il y a assez de mŽmoire 		AllRight_EnoughtMemory			move.l	a0,a4		; sauvegarde de a0		; on regarde s'il y a dŽja un handle alouŽ		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		cmpa.l	#00000000,a0		beq.S	non_pas_deja; oui , on le dispose		_DisposHandle		; on place le handle dans le font recordnon_pas_deja				move.l	FontRender(a6),a1		; font record		move.l	a4,RenderColor_handle(a1)		move.l	a4,a0		_MoveHHI		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		move.l	(a0),a1					; handle => pointeur		move.l	a1,FontBitmapPtr(a6); on locked le handle		_HLock; on dŽrŽfŽrence le handle				pea		WaitingDialogStorage(a6)		_CloseDialog				; on ferme le dialog demande de mŽmoire		move.l	FontRender(a6),a1		; font record		move.l	RenderColor_handle(a1),a0		move.l	(a0),a1					; handle => pointeur		move.l	a1,FontBitmapPtr(a6)		move.l	FontRender(a6),a1		move.w	#1,interligne(a1); on initialise le  Font record de la police		move.l	FontRender(a6),a1		; font record		move.w	#33,First_Char(a1)		move.w	#255,last_Char(a1); ---; on reserve de la place pour le header du font bitmaps;; rappel  :     	ptr style 1		<-  dŽbut du font bitmaps	);				  / / / / 									) header font bitmap;				ptr style n									) ;;				headerCharN¡1	<- dŽbut 1 er style, dŽbut 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN¡n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn;				    / / / /;				headerCharN¡1	<- dŽbut n me style, dŽbut 1 er char;				bitmapPlane1char1;				bitmapPlanenchar1;				    / / / /;				headerCharN¡n	<-   char n;				bitmapPlane1charn;				bitmapPlanencharn; (il faut rŽserver un  long ptr pour chaque style) ; il faudra changer le nom face number par style number (nombre de style dans le bitmap); initialisation du Displayfont header en tte 	move.l	FontBitmapPtr(a6),a0		; abs ptr du Displayfont		move.l	FontRender(a6),a1			; pointeur du fontRecord	moveq	#0,d0	move.w	Face_Number(a1),d0			; nombre de style ˆ rendre	mulu	#styleHeaderSize,d0			; taille du "styleHeaderSize"	move.l	d0,FontCurrentPtr(a6)		; rŽservation de la place				;  ----------------------------------------------------------------------------;  c'est partie pour la grande boucle; on ouvre un dialog pour indiquer l'Žtat de rendu		clr.l	-(sp)		move.w	#168,-(sp)	; id number		pea		DialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		_setPort		pea		DialogStorage(a6)			_DrawDialog		pea		DialogStorage(a6)		move.w	#2,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		_frameRect		; on dessine la reglette		pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#-1,-(sp)		move.w	#-1,-(sp)		_insetRect		pea		itemRect(a6)		_frameRect				move.w	#32000,RGB_Color(a6)		move.w	#32000,2+RGB_Color(a6)		move.w	#32000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect		pea		itemRect(a6)		_PaintRect						move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor; on calcule le nombre de caractre ˆ rendre; pour l'indicateur d'Žtat.		move.l	FontRender(a6),a0		; font record		move.w	Face_Number(a0),d0		mulu.w	#255-33,d0				; nombre total de caractre ˆ rendre (sauf espace)		move.w	d0,TotalChar(a6)				move.w	#0,CharCounter(a6)		; reset du compteur			move.l	FontRender(a6),a1		clr.w	max_descent(a1)		clr.w	max_Ascent(a1); calcul de l'espace; -------------------------	 boucle 1 : boucle	style	-------------------;( normal, gras, italique ); initialisation boucle style		move.w	#0,TheStyle(a6)		; initialisation	Style_Loop; initialisation pointeurs "Display font" boucle style		move.l	FontBitmapPtr(a6),a0		; abs ptr du Displayfont	move.l	FontCurrentPtr(a6),d0		; on calcule l'adresse du style	import	aligneD0	jsr		aligneD0	move.l	d0,FontStylePtr(a6)				; adresse du "style"	move.l	d0,FontCurrentPtr(a6)			; alignŽ sur dc.l	move.l	#0,d1	move.w	theStyle(a6),d1	move.l	d0,(a0,d1.l*styleHeaderSize)		; on stocke l'adresse du style dans l'en tte	move.l	#0,PreviousFontCharPtr(a6)	; raz; on indique le style du caractre				move.w	TheStyle(a6),d0			case#.w	(d0,if),\ 			(0,Normal_style),\			(1,Italique_style),\			(2,Bold_style) 			bra		EndLoop_Style			; style pas connu on ne le fait pas		Normal_style					clr.w	StyleType(a6)					bra		start_CharLoop		; on y va; ------------ Bold_style; on regarde si le style italique est demandŽ										move.l	FontRender(a6),a0		; font record					move.w	FontStyle(a0),d0					and.w	#1,d0					beq		EndLoop_Style			;pas bold donc ?: on passe au suivant					move.w	#1,StyleType(a6)					bra		start_CharLoop		; on y va; ------------Italique_style; on regarde si le style italique est demandŽ					move.l	FontRender(a6),a0		; font record					move.w	FontStyle(a0),d0					and.w	#2,d0					beq		Bold_style				; pas italique , bold ?					move.w	#2,StyleType(a6); ------------------------start_CharLoop		; boucle 2 : boucle caractres ; de 33 ˆ 255 pour l'instant							move.w	#33,TheChar(a6)		; initialisation		Loop__Char; initialisation des pointeurs "Display font" boucle caractres	move.l	FontBitmapPtr (a6),a0		; abs ptr du Displayfont	move.l	FontCurrentPtr(a6),d0		; pointeur courant	move.l	d0,FontCharPtr(a6)			; pointeur courant => fontchar	add.l	#CharHeaderSize,d0			; header du caractre	move.l	d0,FontCurrentPtr(a6)		; rŽservation de l'espace; on update les pointeurs de cet en tte		move.l	PreviousFontCharPtr(a6),d0	move.l	FontCharPtr(a6),d1	move.l	d0,CH_PreviousChar(a0,d1.l)					; previous Ptr	clr.l	CH_NextChar(a0,d1.l)						; next Ptr		move.w	TheChar(a6),CH_CharNumber(a0,d1.l)		; n¡ de caractre rendu 												move.w	#$caca,CH_Spare(a0,d1.l)			; le spare je met $caca pour mieux identifier cette position; on raz le rectangle 			move.w	#32000,left+CH_Rect(a0,d1.l)	; Å valeur maximum		move.w	#32000,top+CH_Rect(a0,d1.l)		; Å valeur maximum		move.w	#0,right+CH_Rect(a0,d1.l)	; Å valeur maximum		move.w	#0,bottom+CH_Rect(a0,d1.l)		; Å valeur maximum	; on update le nextPtr du char prŽcŽdent (s'il existe)														move.l	PreviousFontCharPtr(a6),d0	beq.s	PasPreviousChar				; nous sommes au premier caractre	move.l	FontCharPtr(a6),CH_NextChar(a0,d0.l)		; ptr next du prŽcŽdent	PasPreviousChar				move.l	FontCharPtr(a6),PreviousFontCharPtr(a6)		; l'actuel char devient le prŽcŽdent 															; au prochain passage																																				; ----- on dessine le caractre dans un buffer -------------				move.l	FontRender(a6),a0		move.w	theStyle(a6),d1		move.w	TheChar(a6),d0		import	GiveDisplayFont_CharInfo		jsr		GiveDisplayFont_CharInfo			; a0 char info , d1 nb de plan		tst.w	d0		bne  	fin_loop_char			; il y a une erreur			move.w	right+CH_Rect(a0),d0		addq.w	#1,d0		mulu	#4,d0					; row bytes (mot long)		move.l	d0,Row_Bytes(a6)				move.l	FontBitmapPtr (a6),a1		; abs ptr du Displayfont		move.l	FontCharPtr(a6),d2				move.w	top+CH_Rect(a0),top+CH_Rect(a1,d2.l)		move.w	left+CH_Rect(a0),left+CH_Rect(a1,d2.l)		move.w	right+CH_Rect(a0),right+CH_Rect(a1,d2.l)		move.w	bottom+CH_Rect(a0),bottom+CH_Rect(a1,d2.l)				move.l	CH_Rect(a0),CurrentcharRect(a6)		move.l	4+CH_Rect(a0),4+CurrentcharRect(a6); on test si rectangle coherent; pour la police		move.w	bottom+CH_Rect(a0),d0	; en hauteur		sub.w	top+CH_Rect(a0),d0		bmi     paschar		cmp.w	#300,d0		bhi		paschar		move.w	right+CH_Rect(a0),d0	; en largeur		sub.w	left+CH_Rect(a0),d0		bmi     paschar		cmp.w	#300,d0		bhi		paschar				cmp.w	#$ca,TheChar(a6)		bne.s	PasCapaschar				clr.l	CH_Rect(a1,d2.l)		clr.l	4*CH_Rect(a1,d2.l)		clr.w	CH_Spare(a1,d2.l)				bra		fin_loop_char		; on ne dessine pas le caractre $CA		PasCa		; on recupre le max base line; !!! note: la base line est une valeur nŽgative !		move.w	pi_Baseline+CharHeaderSize(a0),d0	; base line de la face		cmp.w	#2,d1		; border ?			blo.s	FoundMaxBaseLine		cmp.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0	; base line border		blt.s	@shadowMax		move.w	pi_Baseline+PlaneInfoSize+CharHeaderSize(a0),d0	; base line border@shadowMax		cmp.w	#3,d1		; shadow ?			blo.s	FoundMaxBaseLine		cmp.w	pi_Baseline+PlaneInfoSize*2+CharHeaderSize(a0),d0	; base line border		blt.s	FoundMaxBaseLine		move.w	pi_Baseline+PlaneInfoSize*2+CharHeaderSize(a0),d0	; base line borderFoundMaxBaseLine						move.w	d0,CH_Spare(a1,d2.l)		; spare pour base ligne		neg.w	d0							; base line*-1 => ascent		move.l	FontRender(a6),a1; calcul de max Ascent				cmp.w	max_Ascent(a1),d0		blo.s	not_MaxAscent		move.w	d0,max_Ascent(a1)not_MaxAscent		; on calcule du descent du char		move.w	bottom+CH_Rect(a0),d1		add.w	pi_Baseline+CharHeaderSize(a0),d1	; descent= bottom-baseline (face)		cmp.w	max_descent(a1),d1		blo.s	not_Maxdescent		move.w	d1,max_descent(a1)		not_Maxdescent		move.w	max_Ascent(a1),d1		add.w	max_descent(a1),d1;		move.w	bottom+CH_Rect(a0),d1		cmp.w	interligne(a1),d1		blt.s	Not_MaxHeight		move.w	d1,interligne(a1)		Not_MaxHeight				; --------------------------------------------------						clr.w	-(sp)					move.l	FontRender(a6),-(sp)		move.w	TheChar(a6),-(sp)		move.w	theStyle(a6),-(sp)		move.l	G.RGB_FaceColor,-(sp)			move.l	G.RGB_BorderColor,-(sp)		move.l	G.RGB_ShadowColor,-(sp)		move.l	#0,-(sp)		; Bgdcolor				move.w	#0,-(sp)		; transparent black for bgd					move.w	#0,-(sp)	;x		move.w	d0,-(sp)	;y  ; base line 		move.l	Pointeur(a6),-(sp)		; block mŽmoire temporaire		move.l	Row_Bytes(a6),-(sp)		; largeur pour des long word		import		Draw_A_Char		jsr			Draw_A_Char				move.w		(sp)+,d0		; largeur du carctre (on s'en fout ici); ----- on recopie ce caractre dans le fast font bitmap --------; boucle de recopie		move.w	#0,d6						move.l	Base_Adresse(a6),a4		; base VX				move.l	Pointeur(a6),a0						;bitmap source		move.l	Row_Bytes(a6),d5		move.l	FontCurrentPtr(a6),a1		adda.l	FontBitmapPtr (a6),a1				; pointeur absolu pour recopie		; on calcule le row byte pour l'arrivŽe 16 ou 32 bits				move.l	Row_Bytes(a6),d4					;row byte source bitmap		cmp.w	#16,DestinationSize(a6)				; 16 ou 32 bits		bne.s	Boucle_recopieVerticale				; non, mode 32 bits		lsr.l	#1,d4								; row byte sur 16 bits		; d5 = row byte de la source; d4 = row byte de l'arrivŽe; a0 = ptr de la source; a1 = ptr de l'arrivŽe ; d7= X ; d6= Y		Boucle_recopieVerticale		move.w	#0,d7		; largeur (pts)Boucle_recopieHorizontale		move.l	(a0,d7.w*4),d0						; donnŽes de la source		; mode 16 ou 32 bits		cmp.w	#32,DestinationSize(a6)						beq.s	Mode32bits; -----   mode 16 bits; on convertie le mots long en word, pour les dŽtails voir Color QuickDraw direct color ; RGB 8888 en   RGB1555 (alpha, red,green,blue)		move.l	d0,d2		clr.l	d0		; alpha channel		move.l	d2,d1		and.l	#$ff000000,d1		beq.s	MakeBlue					;  =0 => alphabit=0 		or.w	#$8000,d0					; ­0 alphabit =1MakeBlue		; blue 						|... aaaaaaaa rrrrrrrr gggggggg (bbbbb)| bbb 		lsr.l	#3,d2		move.l	d2,d1		and.l	#%0000000000011111,d1				or.w	d1,d0; green 					|......	aaaaaaaa rrrrrrrr (ggggg)ggg bb| bbbbbb					lsr.l	#3,d2		move.l	d2,d1		and.l	#%0000001111100000,d1		or.w	d1,d0; red	 					|.........	aaaaaaaa (rrrrr)rrr ggggggg| g bbbbbbbb					lsr.l	#3,d2		move.l	d2,d1		and.l	#%0111110000000000,d1		or.w	d1,d0; on le place dans la mŽmoire		move.w	d0,(a1,d7.w*2)		; word		bra.s	finligne; ----Mode32bits; on le place dans la mŽmoire		move.l	d0,(a1,d7.w*4)		; long;		move.l	d0,(a4,d7.w*4)		; dans la VXfinligne		addq.W	#1,D7			cmp.w	right+CurrentcharRect(a6),d7		bls		Boucle_recopieHorizontale				add.l	d5,a1			; ligne suivante destination		add.l	d5,a0			; ligne suivante source		add.l	Row_BytesVX(a6),a4				addq.W	#1,D6			cmp.w	bottom+CurrentcharRect(a6),d6		bls		Boucle_recopieVerticale; ----- update du ptr de la zone mŽmoire --------------				move.w	bottom+CurrentcharRect(a6),d0				addq.w	#1,d0				move.w	right+CurrentcharRect(a6),d1				addq.w	#1,d1				mulu	d1,d0				lsl.l	#1,d0		; pour 16 bits				cmp.w	#16,DestinationSize(a6)				; mode 16 ou 32 bits				beq.s	M_16				lsl.l	#1,d0		; pour 32 bitsM_16					import	aligneD0				jsr		aligneD0				; il vaut mieux car si la base est dc.l												; on peut travailler en mot long (plus rapide) 				add.l	FontCurrentPtr(a6),d0	; "reservation de l'espace" 				move.l	d0,FontCurrentPtr(a6)				move.l	d0,FontPlanePtr(a6)		* -------- fin loop des plans incr loop caractresfin_loop_char 		bsr		IncrementReglette		; pour indiquer la progression; on affiche les variables utilisŽes par le programme dans la fentre Status		bsr		WriteSTate; on incrŽmente le compteur de boucle		move.w	TheChar(a6),d0		addq.w	#1,d0		move.w	d0,TheChar(a6)		cmp.w	#255,d0			; pour l'instant		blo		Loop__Char; -----------;fin boucle styleEndLoop_Style	move.w	TheStyle(a6),d0	addq.w	#1,d0	add.w	#1,TheStyle(a6)	move.l	FontRender(a6),a0			; pointeur du fontRecord	cmp.w	Face_Number(a0),d0	blo		Style_Loop	; le rendu est terminŽ; on l'indique ˆ l'utilisateur; on taille le handle ˆ la taille voulue			move.l	FontBitmapPtr(a6),a0	; a0= adresse absolue de l'espace  			move.l	FontRender(a6),a1		; font record			move.l	RenderColor_handle(a1),a0			_Hunlock			move.l	FontRender(a6),a1		; font record			move.l	RenderColor_handle(a1),a0			move.l	FontCurrentPtr(a6),d0			_SetHandleSize				Exit		pea		DialogStorage(a6)		_CloseDialog				move.l	handle(a6),a0		_HUnlock					; on unlocked le handle				move.l	handle(a6),a0		; on release la mŽmoire		_DisposHandle		bra		Exit_Err; --------------------------------Exit_bis						pea		DialogStorage(a6)		_CloseDialog				move.l	handle(a6),a0		_HUnlock					; on unlocked le handle				move.l	handle(a6),a0		; on release la mŽmoire		_DisposHandleExit_Err1		pea		WaitingDialogStorage(a6)		_CloseDialog				; on ferme le dialog demande de mŽmoireExit_Err				movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0); --------------------------IncrementReglette; cette routine rafraichie la reglette				pea		DialogStorage(a6)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				add.w	#1,CharCounter(a6)		move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		;largeur reglette		mulu	CharCounter(a6),d0								divu	TotalChar(a6),d0		add.w	left+itemRect(a6),d0				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		move.w	#50000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#10000,RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		move.w	#35000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#55535,RGB_Color(a6)		move.w	#65535,4+RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#10000,RGB_Color(a6)		move.w	#20000,4+RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#55535,RGB_Color(a6)		move.w	#65535,4+RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intŽrieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#50000,4+RGB_Color(a6)		move.w	#10000,2+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts; --------------------------; cette routine transfre le texte dans le stat item dŽterminŽ par d1Str2StatItem				move.l	a0,d7			; sauvegarde de la chaine				pea		DialogStorage(a6)		move.w	d1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move.w	#srcCopy,-(sp)				_textMode								move	Left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),d0		add.w	#9,d0		move.w	d0,-(sp)					; la hauteur top-baseline au pif		_MoveTo				move.l	d7,-(sp)		_drawString		_PenNormal		rts		; --------------------------; cette routine convertie la valeur contenue dans d0 en texte ; dans le stat item dŽterminŽ par d1Num2StatItem		 		move.w	d1,saveD1(a6)		lea		textBuff(a6),a0		bsr		num2StrWord		move.w	saveD1(a6),d1		move.w	d1,d7				pea		DialogStorage(a6)		move.w	d1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem						move	Left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),d0		add.w	#9,d0		move.w	d0,-(sp)					; la hauteur top-baseline au pif		_MoveTo		move.w	#srcCopy,-(sp)				_textMode		pea		TextBuff(a6)		_drawString		_PenNormal		rts		; -------------------------------------------------------		testUserStop; un event mouse down ?			clr.w	-(sp)		_button				move.w	(sp)+,d0		bne.s	@1				; ok mouse down		rts				 		@1		pea		Thepoint(a6)	; oui mais o ?		_GetMouse				clr.w	-(sp)		pea		DialogStorage(a6)		move.l	thePoint(a6),-(sp)		_FindDitem			move.w	(sp)+,d0		bmi.s	No_UserStop		; nŽgatif pas dans item		bne		No_UserStop		 ; =0 donc item 1 = good, true, ok, youpi etc... ; on hilite le bouton		pea		DialogStorage(a6)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem			wait_Up				pea		Thepoint(a6)	; oui mais o ?		_GetMouse				clr.w	-(sp)		move.l	thepoint(a6),-(sp)		pea		itemRect(a6)		_PtInRect		move.w	(sp)+,d0		beq.s	@1				move.l	ItemHandle(a6),-(sp)		move.w	#inButton,-(sp)		_HiliteControl		bra.s		@2		@1		move.l	ItemHandle(a6),-(sp)		move.w	#0,-(sp)		_HiliteControl		@2				clr.w	-(sp)		_button				move.w	(sp)+,d0		bne.s	wait_Up			; user a lachŽ dans bouton ?		pea		Thepoint(a6)	; oui mais o ?		_GetMouse		clr.w	-(sp)				move.l	thepoint(a6),-(sp)		pea		itemRect(a6)		_PtInRect		move.w	(sp)+,d0				beq.s		No_UserStop ; non		OkShoot_in						move.w	#1,d0			; on retourne ­0		rts		No_UserStop		move.w	#0,d0			; non,non,non il n'y a rien ˆ signaler ...		rts; --------------------------------------------------------------------WriteSTate		Pea		SavePort(a6)		_GetPort				pea		G.ServiceWindow		_SetPort						move.w	#4,-(sp)		move.w	#246,-(sp)		_MoveTo						pea		#'-------------------------------------------'		_DrawString				bsr		Newline				pea		#'Variables utilisŽes pour le rendu de police '		_DrawString		; ------  font bitmap Ptr		move.l	FontBitmapPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontBitmapPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  font bitmap Ptr		move.l	FontBitmapPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontBitmapPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  FontBitmapSize		move.l	FontBitmapSize(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontBitmapSize :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine		; ------  font FontCurrentPtr		move.l	FontCurrentPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontCurrentPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine		; ------  fFontStylePtr		move.l	FontStylePtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontStylePtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine		; ------  FontCharPtr		move.l	FontCharPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'FontCharPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  PreviousFontCharPtr		move.l	PreviousFontCharPtr(a6),d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'PreviousFontCharPtr :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  the stack		move.l	a7,d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'Stack :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine; ------  A6 link		move.l	a6,d0		lea		textBuff(a6),a0		bsr		num2StrLong		pea		#'A6 link :'		_DrawString		pea		textBuff(a6)		_DrawString				bsr		NewLine				move.l		SavePort(a6),-(sp)		_SetPort		rts		; -------------------------------------		Newline		pea	ThePoint(a6)		_GetPen				move.w	top+ThePoint(a6),d0		move.w	#4,-(sp)		add.w	#10,d0		move.w	d0,-(sp)		_moveTo				rts; ------------------------------------				num2StrLong; on effectue la conversion en hexa ascii d'un mot long		move.w	#7,d7		move.b	#9,(a0)+	; longueur de la chaine		move.b	#'$',(a0)+	; identifiant hŽxadŽcimalloop_num2StrLong		rol.l	#4,d0		; on commence par le poid le + fort		move.b	d0,d1		and.b	#$0f,d1		cmp.b	#09,d1		; si ²9  => on ajoute $30 ('0') sinon 'A'-10		bhi.s	@1		add.b	#$30,d1		; nombre		bra.S	@2@1		add.b	#65-10,d1@2		move.b	d1,(a0)+		dbra	d7,loop_num2StrLong		rts; --------------------------------------------num2StrWord; on effectue la conversion en hexa ascii d'un mot		move.w	#3,d7		move.b	#5,(a0)+	; longueur de la chaine		move.b	#'$',(a0)+	; identifiant hŽxadŽcimalloop_num2StrWord		rol.w	#4,d0		; on commence par le poid le + fort		move.b	d0,d1		and.b	#$0f,d1		cmp.b	#09,d1		; si ²9  => on ajoute $30 ('0') sinon 'A'-10		bhi.s	@1		add.b	#$30,d1		; nombre		bra.S	@2@1		add.b	#65-10,d1@2		move.b	d1,(a0)+		dbra	d7,loop_num2StrWord		rts				DbgInfo.new	Create_FastFont		; this name will appear in the debugger		align 4			ENDP