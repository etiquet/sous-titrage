#pragma segment FonctionsDeBaseListepascal void EcritPreferenceTravail(void);pascal void C_InsertSt(SousTitreRecordPtr ST,long AskLongueur){SousTitreRecordPtr	P,P1; 		//offset absolu du sous-titreunsigned long	deplacement; 			//distance de déplacement pour insérer le sous-titreunsigned long	a,L;Ptr					P2,P3,P4;		// on ajuste la longueur sur un dc.l						if (AskLongueur>32){			AskLongueur=((AskLongueur+3)/4)*4;		} else	{			AskLongueur=32;		}		/* oui, nous somme au dernier soustitre ;determiner fin dernier st, + alignement dc.l,+ test longueur rajouter<= hi-mem;si ok lincker nextST ancien dernier sous titre, avec nouveau st, puis nouveau;PREviousST avec ADDR debut ancien dernier ST.;mettre nextST à 0 */	// on détermine qu'elle type d'insersion il faut exécuter			if (ST->st_NextST==nil) {		// à la fin de la liste		// on calcule le pointeur du prochain st			L=sizeof(SousTitreRecord)+ST->st_LenthST;			P=ST+(SousTitreRecordPtr)L;			a=(unsigned long)P;			a=((a+3)/4)*4;			a=(SousTitreRecordPtr)a;		// on regarde si l'on dépasse la fin de la liste			if ( ((long)P+AskLongueur+sizeof(SousTitreRecord)+2)>G.General_HIMEMST ) {				AlertUser(5);	// on envoie un message pour le dire			} else {				// on initialise l'en tête du nouveau sous-titre								ST->st_NextST=(Ptr)P;	// on chaîne le nouveau st				P->st_PreviousST=(Ptr)ST;				P->st_NextST=nil;				G.General_DernierSTPtr=P;							P->st_LenthST=AskLongueur;				P->st_StyleLenth=nil;				P->st_TexteLenth=nil;				P->st_CommentairePtr=nil;				P->st_CommentaireLenth=nil;				P->st_StylePtr=nil;				P->st_TimeCodeIn=-1;				P->st_TimeCodeOut=-1;				P->st_Error=nil;				P->st_XOffset=nil;				P->st_YOffset=nil;				P->st_PosOffsetTable=nil;				P->st_Nlines=nil;				P->st_Justification=nil;	// justification du texte 0 centrée, 				P->st_MasKType=nil;		// type de mask box, line, rectangle; = rien						// le numéro du sous-titre							P->st_NumeroST=(ST->st_NumeroST & 0xFFFFFF)+1;				P->st_OldNumeroST=P->st_NumeroST;				P->st_AbsNUMST=ST->st_AbsNUMST+1;			// on ajoute 1 au nombre total de sous-titre							a=G.General_NombreST;				a=a+1;				G.General_NombreST=a;				G.General_SousTitreEncour=(short)a;			// On update le control de a fenêtre listing								SetCtlMax(G.ListingVScroll,G.General_NombreST);						}				} else { 	//(ST.st_NextST==nil) 			// il y a t-il assez de mémoire	pour insérer ce nouveau sous-titre		L=G.General_DernierSTPtr->st_LenthST+2L+AskLongueur+sizeof(SousTitreRecord);		P=(SousTitreRecordPtr)L;		P=P+G.General_DernierSTPtr;				if ( (P)>G.General_HIMEMST ) {				AlertUser(5);	// on envoie un message pour le dire			} else {				/*	in faut insérer le sous-titre à l'intérieur de la liste	 	on indique à la liste des undo que l'on insert un sous-titre		cela permet d'ajuster la liste des undos. */			ManageUndoRedoListeForInsert(ST->st_AbsNUMST);		// on déplace la mémoire vers le haut pour laisser la place pour le sous-titre			P1=(SousTitreRecordPtr)ST->st_NextST; // on sauvegarde le next			deplacement=AskLongueur+sizeof(SousTitreRecord);			P3=(Ptr)P+(Ptr)sizeof(SousTitreRecord);			P2=(Ptr)ST->st_NextST;			L=(long)P3-deplacement;			P4=(Ptr)L;					// on deplace le block de memoire			while(P4>=P2) {					*((short*)P3)=*((short*)P4);					P3-=2;					P4-=2;					}				// on modifie le pointeur du dernier sous-titre			G.General_DernierSTPtr+=(SousTitreRecordPtr)deplacement;			G.General_DernierSTPtr->st_NextST=nil;						// on calcule les pointeurs de chaînage du nouveau sous-titre créé			P1=(SousTitreRecordPtr)ST->st_NextST; 							P1->st_PreviousST=(Ptr)ST;			P1->st_NextST=(Ptr)P1+(Ptr)deplacement;						P1=(SousTitreRecordPtr)P1->st_NextST;			 if (P1->st_PreviousST) {			 			P1->st_PreviousST=(Ptr)ST->st_NextST;						P1->st_PreviousST-=(Ptr)deplacement;						}		// on chaîne le reste de la liste des sous-titres				do {				 if (P1->st_NextST) 					P1->st_NextST+=(Ptr)deplacement;				 if (P1->st_PreviousST) 			P1->st_PreviousST+=(Ptr)deplacement;				 if (P1->st_PosOffsetTable) 		P1->st_PosOffsetTable+=(Ptr)deplacement;				 if (P1->st_StylePtr) 				P1->st_StylePtr+=(Ptr)deplacement;				 if (P1->st_CommentairePtr) 	P1->st_CommentairePtr+=(Ptr)deplacement;	 			P2=(Ptr)P1;				 P1=(SousTitreRecordPtr)P1->st_NextST;				 if (P1>G.General_DernierSTPtr || P1<G.General_PremierSTPtr){					P2=P2;					}			} while (P1 !=nil);		// on renumérote tout les numéro absolu de la liste des sous-titres		RenumerationAbsST();				// on gère le problème de renumérotation		// on incrémente le numéro secondaire		// on regarde si l'on est repassé par 0 si oui on place 255					P1=(SousTitreRecordPtr)ST->st_NextST;		// le nouveau sous-titre		P1->st_NumeroST=ST->st_NumeroST;  // oui on l'incrémente		P1->st_NumeroST+=0x01000000;  // oui on l'incrémente		if ( P1->st_NumeroST & 0xFF000000 == 0)   P1->st_NumeroST=(P1->st_NumeroST & 0xFFFFFF) | 0xFF000000; 		P1->st_OldNumeroST=P1->st_NumeroST;		G.General_SousTitreEncour=P1->st_AbsNUMST;		G.General_NombreST+=1;		SetCtlMax(G.ListingVScroll,G.General_NombreST);//on initialise l'en tête du nouveau sous-titre				P1->st_LenthST=AskLongueur;				P1->st_StyleLenth=nil;				P1->st_TexteLenth=nil;				P1->st_CommentairePtr=nil;				P1->st_CommentaireLenth=nil;				P1->st_StylePtr=nil;				P1->st_TimeCodeIn=-1;				P1->st_TimeCodeOut=-1;				P1->st_Error=nil;				P1->st_XOffset=nil;				P1->st_YOffset=nil;				P1->st_PosOffsetTable=nil;				P1->st_Nlines=nil;				P1->st_Justification=nil;	// justification du texte 0 centrée, 				P1->st_MasKType=nil;		// type de mask box, line, rectangle; = rien			//  on appelle la liste pour renuméroter les n° secondaire s'ils existent		if (G.Preference_Renumerotation==0) 				C_RenumerotationSubNumero(P1);			}// il y a t-il assez de mémoire	?				} //(ST.st_NextST==nil)  else			// il faut renuméroter la liste ?	// appel de la routine de renumerotation (à partir du n° précedent)					if (G.Preference_Renumerotation) 				C_RenumerotationListeSousTitre(ST);		G.ChangeSinceLastSave=true;  //on indique qu'il y a eu modif	/*  il faut invalider le cache du conversion num pointeur	et les caches du dernier sous-titre dessiné */		G.General_DernierNumConvertiPtr=nil;				G.Sous_titre_dessined=nil;			G.Sous_titreInOffscreen=nil;			G.TravailAFaire_Affichage=0; }pascal void C_DeleteST(SousTitreRecordPtr	ST_Ptr){long							longueur,deplacement,a;SousTitreRecordPtr	previous,next,P,P1,P2;Ptr							P3;short						s;				/* 			on sauvegarde les pointeur next et previous du sous-titre qui va ètre effacé		*/			previous=(SousTitreRecordPtr)ST_Ptr->st_PreviousST;			next=(SousTitreRecordPtr)ST_Ptr->st_NextST;		/* on indique aux fonctions annuler et refaire ce que l'on fait		*/		/* on regarde si nous sommes à la fin de la liste ou non */	if (ST_Ptr->st_NextST==nil){			/* oui nous y sommes.				on vérifie que ce n'est pas le premier sous-titre,				car il faut laisser au moin 1 sous-titre dans la liste */			  	if (ST_Ptr!=G.General_PremierSTPtr){					ManageUndoRedoListeForDelete(ST_Ptr->st_AbsNUMST);			/* on efface par pointeur le dernier sous-titres */			G.General_DernierSTPtr=previous;			G.General_DernierSTPtr->st_NextST=nil;						/* 1 sous-titre de moins */				a=G.General_NombreST;				a=a-1;				G.General_NombreST=a;				G.General_SousTitreEncour=(short)a;				SetCtlMax(G.ListingVScroll,G.General_NombreST);							/* 	on invalide un certain nombre de mémoire cache,				qui ne sont plus valides	*/					G.General_DernierNumConvertiPtr=nil; 	//raz du cache de recherche			G.Sous_titreInOffscreen=nil;			G.Sous_titre_dessined=nil; 				G.ChangeSinceLastSave=true;				// on indique qu'il y a eu changement				}// pas le premier sous-titre							} else {			// on flush les caches du processeur			FlushInstructionCache();			FlushDataCache();			s=GetCtlMax(G.ListingVScroll)-1;			/* 1 sous-titre de moins */			G.General_NombreST--;			a=G.General_NombreST&0xffff;			if (a!=(long )s) {					SysBeep(1);					Debugger();					}								s=a;			SetCtlMax(G.ListingVScroll,s);				  		ManageUndoRedoListeForDelete(ST_Ptr->st_AbsNUMST);	  		/*	  			nous ne sommes pas à la fin de la liste,				on déplace la mémoire vers le bas pour effacer le sous-titre			*/	  		deplacement=(long)next-(long)ST_Ptr;	 		a=(long)G.General_DernierSTPtr->st_LenthST+	sizeof(SousTitreRecord);			P2=(SousTitreRecordPtr)a+G.General_DernierSTPtr;			P3=(Ptr)ST_Ptr;						// on deplace le block de memoire			while(P3<=P2) {					*((short*)P3)=*((short*)P3+(short*)deplacement);					if (P3>( G.General_PremierSTPtr+(Ptr)G.General_HIMEMST ) ) DebugStr("\p ooops");					if (P3<G.General_PremierSTPtr) DebugStr("\p ooops");					P3=P3+2;					}  			// on modifie le pointeur du dernier sous-titre			G.General_DernierSTPtr-=(SousTitreRecordPtr)deplacement;			G.General_DernierSTPtr->st_NextST=nil;		  	G.General_PremierSTPtr->st_PreviousST=nil;			/* on place les pointeurs de chaînage du 1er sous titre déplacé*/			a=(long)ST_Ptr->st_NextST;			ST_Ptr->st_NextST=(Ptr)a;			ST_Ptr->st_PreviousST=(Ptr)previous+deplacement;						    		/* on chaîne le reste de la liste des sous-titres				et on modifie les pointeurs des parramètres comme style, commentaire...			*/	 		P=ST_Ptr;			do {				if (P>G.General_DernierSTPtr) DebugStr("\p ooops");				if (P<G.General_PremierSTPtr) DebugStr("\p ooops");				if (P->st_NextST)						P->st_NextST-=(Ptr)deplacement;				if (P->st_PreviousST) 				P->st_PreviousST-=(Ptr)deplacement;				if (P->st_PosOffsetTable) 		P->st_PosOffsetTable-=(Ptr)deplacement;				if (P->st_StylePtr) 					P->st_StylePtr-=(Ptr)deplacement;				if (P->st_CommentairePtr) 		P->st_CommentairePtr-=(Ptr)deplacement;									P1=P;				P=(SousTitreRecordPtr)P->st_NextST;				if (P>G.General_DernierSTPtr || P<G.General_PremierSTPtr) P1=P1;			} while (P !=nil & P<=G.General_DernierSTPtr);			// on renumérote tout les numéros absolus de la liste des sous-titres			RenumerationAbsST();			s=(short)ST_Ptr->st_AbsNUMST;			G.General_SousTitreEncour=s;			SetCtlValue(G.ListingVScroll,s);		/* On regarde s'il y a un sous-numéro 			si oui, il faut renuméroter la liste des sub-numéro		*/					if (ST_Ptr->st_NumeroST&0xff000000) C_RenumerotationSubNumero(previous);			if (G.Preference_Renumerotation) C_RenumerotationListeSousTitre(previous);			RenumerationAbsST();					/* On invalide un certain nombre de mémoire cache,			 qui ne seront plus valides		*/					G.General_DernierNumConvertiPtr=nil; 	//raz du cache de recherche			G.Sous_titreInOffscreen=nil;			G.Sous_titre_dessined=nil; 				G.ChangeSinceLastSave=true;				// on indique qu'il y a eu changement	  }			} //C_deleteST									* ========================================		* PROCEDURE	Transfert_BlockTTI_Soustitre()			* ========================================**	Cette routine convertie les caractères de block TTI vers des caractères*	Utilisés par Bon Bougre™, Que faire des systèmes Double Hauteur etc.. ???.**	Entrée: A0 contient le pointeur sur un block TTI*			A1 pointeur du sous-titre de destination (qui doit ètre créer avant cette routine)*	*Transfert_BlockTTI_Soustitre 		PROC	EXPORT		with	StackFrameImportationFichier,N19_GSI,N19_TTI,SOUSTITRERECORD		move.l	G.General_DernierSTPtr,a2		; pointeur du sous-titre en cour 		move.l	Pointeur(a6),a3					; pointeur du block TTI;------- on récupère le handle de la table de conversion.		move.l	G.ResourceDATA1000,a4		cmpa.l	#00000,a4		bne		ResourceExiste		; la resource existe		; on récupère la resource puisqu'elle n'est pas en mémoire				clr.l	-(sp)		move.l	#'DATA',-(SP)		move.W	#1000,-(SP)		_GetResource		suba.l	a4,a4		; on raz a4		move.L	(SP)+,D0		beq.s	TexteOuCommentaire			; la resource n'est pas présente		move.L	D0,G.ResourceDATA1000			move.l	d0,a4		ResourceExiste				move.l	(a4),a4					; Handle		;-------  Texte ou commentaireTexteOuCommentaire						cmp.b	#01,CF(a3)		; Drapeau de remarque ?		beq 	Commentaire		cmp.b	#00,CF(a3)		; Drapeau de remarque ?		bne 	Exit			; pas texte on ignore le block TTI; --------------------------------------------------------------------; traitement du texteTexte	; on initialise la couleur par défaut du texte (noir à l'affichage Blanc à l'incrustation);		lea		texteStyle(a6),a0		move.w	#0,tsColor+red(a0)			move.w	#0,tsColor+blue(a0)			move.w	#0,tsColor+green(a0)	; on initialise la police par défaut		move.w	G.General_FontNumber,tsFont(a0); le style par défaut		clr.w	tsFace(a0); la taille par défault			; note cette valeur est changée entre les deux fenêtres listing et saisie		move.w	#9,tsSize(a0)	; 9 pour la fenètre listing; on raz les flags	du sous-titres		clr.l	st_Flags(a2); un ligne de texte				move.w	#1,st_Nlines(a2)		; on  détermine la longueur max du texte; pour déterminer le pointeur du style 		lea		TF(a3),a0		move.w	#111,d7			; longueur maxRecherche_Longueur_Texte_Loop		cmp.b	#$8f,(a0,d7.w)	; $8f octets non utilisé		bne.s	Found_LongueurTexte		dbra 	d7,Recherche_Longueur_Texte_Loop		moveq	#0,d7	; pas de caractèresFound_LongueurTexte		move.w	d7,d0		addq.w	#1,d0		; longueur du texte		ext.l	d0		import	AligneD0		jsr		AligneD0	; longueur du texte aligné sur mots long			add.l	#st_sizeOf,d0	; longueur du header du sous-titre			move.l	a2,a0		adda.l	d0,a0		move.l	a0,st_StylePTR(a2)	; pointeur du style rec					move.l	#st_sizeOf,d0	; longueur du header du sous-titre			move.l	a2,a1		adda.l	d0,a1			; pointeur du texte dans le sous-titre; on place un style neutre au début de ligne				move.w	#-1,-(sp)		; tous les parramètres		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	#0,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style		; ---- on recopie le texte dans le sous-titre 						lea		TF(a3),a3		moveq	#0,d6			; compteur pour écriture dans sous-titre		RecopieTexte_Loop				move.b	(a3)+,d0	; lecture d'un octets		; on détermine la signification du caractères		cmp.b	#$20,d0		blo 	Code_Teletexte				cmp.b	#$8f,d0		beq 	fin_recopie_texte; code de fin du texte				cmp.b	#$A0,d0		bhi.s	Caracteres		cmp.b	#$80,d0		blo.s	Caracteres; --------------------; c'est un code de contrôle $80 -> $a0		cmp.b	#$8a,d0			; retour chariot ?		bne.s	PasCr			; non		move.b	#$0d,(a1,d6.w)	; on place le retour chariot		add.w	#1,D6		add.w	#1,st_Nlines(a2)	; on augmente le nombre de ligne; on regaarde s'il est suivi par un autre CR (dans le cas d'une double hauteur !); il faudra vérifier si double hauteur #########		cmp.b	#$8a,(a3)		bne 	Fin_loop_Recopie_Texte	; non ce nest pas le cas; oui il y a un autre CR		move.b	(a3)+,d0	; on l'élimine		bra 	Fin_loop_Recopie_Texte	; non ce nest pas le cas	; -----PasCr	cmp.b	#$80,d0			; début italique		bne.s	Pas_DebutItalique; c'est l'attribut pour les italiques, on ajoute un style				move.w	#2,tsFace+texteStyle(a6)		; style italic		move.w	#doFace+doColor+doFont,-(sp)	; la fonction		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style		bra 	Fin_loop_Recopie_Texte; -----Pas_DebutItalique				cmp.b	#$81,d0			; fin italique ?		bne.s	Pas_FinItalique				move.w	#0,tsFace+texteStyle(a6)		; plus style		move.w	#doFace+doColor+doFont,-(sp)	; la fonction		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style				bra 	Fin_loop_Recopie_Texte; -----Pas_FinItalique; on ne gère pas les autres attributs (sous-lignage, emboîtage)				bra 	Fin_loop_Recopie_Texte; ---------------------------------------------------------; c'est un caractères affichable $20 -> $7f et $a1-> $FFCaracteres			; si char < $80 sauf $ on ne change rien		cmp.b	#'$',d0		bne.s	PasCaractereSpecial_txt		move.b	#'€',(a1,d6.w)	; on place le caractère		add.w	#1,D6			bra 	Fin_loop_Recopie_Texte; -----PasCaractereSpecial_txt				cmp.b	#$7f,d0		bhi		Conversion_caractere_Txt		move.b	d0,(a1,d6.w)	; on place le caractère		add.w	#1,D6			bra 	Fin_loop_Recopie_Texte		; -----		; il faut effectuer une conversion Conversion_caractere_txt				bsr		ConversionChar		move.b	d0,(a1,d6.w)	; on place le caractère		add.w	#1,D6					bra 	Fin_loop_Recopie_Texte		; ---------------------------------------------------------; c'est un code de contrôle Teletexte >$20Code_Teletexte;		bra 	Fin_loop_Recopie_Texte	; ############ !!!!!!!!!!!!!!				cmp.b	#$07,d0			; alphaNoir ?		bra.s	Pas_Alpha;		bhi.s	Pas_Alpha	; ################; couleur des caractères		lea		tableCouleur(pc),a0		and.l	#$7,d0		mulu	#6,d0	; poiteur sur la couleur		move.w	red(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+red(a6)		move.w	green(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+green(a6)		move.w	blue(a0,d0.w),d1		move.w	d1,tsColor+texteStyle+blue(a6)						move.w	#doColor,-(sp)	; uniquement couleur		pea		texteStyle(a6)	; le record		move.l	a2,-(sp)		; le sous-titre		move.w	d6,-(sp)		; la position de départ du style		import	Add_style		jsr		Add_style				bset	#9,st_Flags(a2)	; couleur type teletext				bra.s		Fin_loop_Recopie_Texte; table de conversion couleurs ceefax => RBGColor 		tableCouleur			dc.w	$0000,$0000,$0000	; noir		dc.w	$8080,$0000,$0000	; rouge		dc.w	$0000,$8080,$0000	; vert		dc.w	$8080,$8080,$0000	; jaune		dc.w	$0000,$0000,$ffff	; bleu		dc.w	$8080,$0000,$8080	; magenta		dc.w	$0000,$8080,$8080	; cyan		dc.w	$ffff,$ffff,$ffff	; blanc; -------		Pas_Alpha				cmp.b	#$0c,d0					; hauteur normale ?		beq.s	Fin_loop_Recopie_Texte	; par défaut; -------				cmp.b	#$0d,d0					; double hauteur ?		bne.s	pas_DoubleHauteur		; non				bset	#11,st_Flags(a2)			; double hauteur 		bra.s	Fin_loop_Recopie_Texte	; -------		pas_DoubleHauteur			cmp.b	#$0e,d0					; double largeur ?		bne.s	pas_DoubleLargeur		; non				bset	#10,st_Flags(a2)			; double largeur		bra.s	Fin_loop_Recopie_Texte	; -------pas_DoubleLargeur		cmp.b	#$0e,d0					; double taille ?		bne.s	Fin_loop_Recopie_Texte	; non				bset	#10,st_Flags(a2)			; double largeur		bset	#11,st_Flags(a2)			; double hauteur Fin_loop_Recopie_Texte		dbra	d7,RecopieTexte_Loopfin_recopie_texte	; on regarde s'il y a un cr à la fin du texte; si oui on l'élimine		cmp.b	#$0d,-1(a1,d6.w)		bne.s	PasDeCr_alafindutexte				move.w	st_Nlines(a2),d0		sub.w	#1,d0			beq.s	LaisseUneLigne		; il faut une ligne au moins, que diable !		move.w	d0,st_Nlines(a2)LaisseUneLigne				subQ.w	#1,d6						; on ne peut pas faire dbra		bne		fin_recopie_texte		PasDeCr_alafindutexte		and.l	#$ffff,d6		bne.s	ChainePAsVide		; si texte vide pas de style				clr.l	st_StyleLenth(a2)		clr.l	st_StylePtr(a2)		ChainePAsVide				move.l	d6,st_TexteLenth(a2)		bra		Fin_Block_TTI; -------------------------------------------------; traitement des commentaireCommentaire		bra		Fin_Block_TTI		; --------------------------------------------------------------; On regarde l'état du parramètre d'extension EBN du block TTIFin_Block_TTI; faut-il prendre le tc ; on prend le tc du premier block TTI ? 		move.l	Pointeur(a6),a3					; pointeur du block TTI		cmp.b	#1,CS(a3)		bhi 	PasPremier_BlockTTI; on récupère le tc in		lea		TCI(a3),a0		import	Conversion_TCN19__Bcd		jsr		Conversion_TCN19__Bcd		move.l	d0,st_TimeCodeIn(a2)		; on récupère le tc Out		lea		TCO(a3),a0		import	Conversion_TCN19__Bcd		jsr		Conversion_TCN19__Bcd		move.l	d0,st_TimeCodeOut(a2)		; on récupère la position verticale du sous-titre		moveq	#0,d0		move.b	VP(A3),d0		clr.w	st_YOffset(A2); ##		move.w	d0,st_YOffset(A2); on indique que c'est une position verticale télétexte				move.w	st_flags(a2),d0		bset	#12,d0		move.w	d0,st_flags(a2)				; on récupère la justification du sous-titre		lea 	tableConversionJustif(pc),a0		moveq	#0,D0		move.b	JC(A3),d0		cmp.b	#4,d0	; on prévient les erreurs		blo.s	@SupJustif		moveq	#2,D0@SupJustif				move.b	(a0,d0.w),d0		move.b	d0,st_Justification(a2)						; maintenant on regarde s'il faut remonter les sous-titres; c'est à dire que la position de départ est différentes		; on regarde si ce sont des caractères double-hauteur		; si double hauteur départ en ligne 22; si simple hauteur départ en ligne 23		btst	#11,st_Flags(a2)			; double hauteur 		beq.s	Pas_double_Hauteur		move.b	VP(A3),d0		; c'est une double hauteur		move.l	#24,D0		sub.b	VP(A3),d0		divu	#2,D0; nombre de ligne		sub.w	st_Nlines(a2),d0				bra.s	Add_CR; -----Pas_double_Hauteur		move.w	#24,D0		sub.b	VP(A3),d0Add_CR; on additionne des cr à la fin du texte		tst.l	st_TexteLenth(a2)		beq		PasPremier_BlockTTI ; si pas de texte pas de cr en plus 				tst.w	d0		beq.S	PasPremier_BlockTTI; pas de cr		lea		(a1,D6.w),A1; on ajoute le nombre de ligne // nombre de cr				add.w	d0,st_Nlines(A2)		subq.w	#1,d0Add_CR_loop		addi.l	#1,st_TexteLenth(a2)		move.b	#$0d,(a1)+		dbra	d0,Add_CR_loop								PasPremier_BlockTTI		cmp.b	#$ff,EBN(a3)				; dernier Block TTI ?		bne.s	Exit						; non		; on calcule la taille du sous-titre		move.l	st_stylePtr(a2),d0		beq.s	pasdestyle		sub.l	a2,d0				; début du sous-titre		sub.l	#st_sizeOf,d0		; espace aloué au texte				move.l	st_styleLenth(a2),d1	; taille des styles		import	aligned1		jsr		aligned1		add.l	d1,d0pasdestyle		move.l	st_CommentaireLenth(a2),d1		import	aligned1		jsr		aligned1		add.l	d1,d0		add.l	#8,d0		; en secu			move.l	d0,st_LenthST(a2)	; longueur du sous-titre		; oui on insert un sous-titre	pour le prochain ST				move.l	a2,a0		move.l	#0,d0		import	InsertST		jsr		InsertSTExit	rts; sous-routine de conversion caractère N19 => mac; a4 pointe sur la table de conversionConversionChar		movem.l	a4,-(sp)		; on sauvegarde a4		move.b	d0,d1				and.b	#$F0,d1		cmp.b	#$c0,d1		beq.s	accentuation; c'est un caractère simpleLoop_Recherche_Single_Char				move.w	2(a4),d1				; code n19			beq.s	Exit_Conv_char			; fin de la table pas trouvé on sort directement		cmp.b	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.S	Loop_Recherche_Single_CharFound_The_Char		move.b	1(a4),d0Exit_Conv_char		movem.l	(sp)+,a4		; récupération a4		rts; --------------------------------------	; c'est une accentuation		accentuation		; on lit le caractère suivant		asl.w	#8,d0		; code accent b15-b8		move.b	(a3)+,d0	; lecture d'un octets	(le caractère b7-b0)Loop_Recherche_double_Char				move.w	2(a4),d1				; code n19			beq.s	Exit_Conv_char			; fin de la table,on sort avec le caractère simple dans d0		cmp.w	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.S	Loop_Recherche_double_ChartableConversionJustif			dc.b	00	; 0= centrée			dc.b	01	; gauche			dc.b	00	; centrée			dc.b	02	; justif droite						dc.b	02	; 0= centrée			dc.b	01	; 1= gauche			dc.b	03	; 2=Droite			dc.b	00	; 		DbgInfo.new	Transfert_BlockTTI_Soustitre		align 4			ENDP		* ================================================* PROCEDURE		Add_style()* ================================================; Cette routine ajoute un style dans un sous-titre; si le style existe déja, il change les  parramètres désignée par Fonct_demande;;				SEG	'Conversions'			; case sensitiveAdd_style	 	PROC	EXPORT			; any source file can use this routineStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointFonct_demande		ds.w	1	; la fonctionThe_StyleRec		ds.l	1	; le recordSTPtr				ds.l	1	; le sous-titreStartChar			ds.w	1	; la position de départ du styleParamSize			EQU	ParamBegin-*				; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkLocalSize			EQU 	*			; size of all the local variables		ENDR		WITH	StackFrame,StandardFileReply,SFReply,SOUSTITRERECORD		; cover our local stack frame				LINK	A6,#LocalSize		; allocate our local stack frame				import	ConversionTrames_TimeCode,CopySTR		movem.l	d0-d7/a1-a4,-(sp)	; sauvegarde des registres		; on commence par déterminer s'il ya un style à la position demandée			move.l	stPtr(a6),d0		beq		Exit			; Pas de pointeur de sous-titre on ne fait rien		move.l	d0,a4		move.l	st_StylePtr(A4),d0		beq		Exit			; pas de pointeur de style ; on ne fait rien pour l'instant		move.l	d0,A3			; pointeur du style; on regarde le nombre de style			tst.l	st_styleLenth(a4)		beq		Nouveau_Style_Vierge	; il n'y a pas de style on en ajoute 1				move.w	(a3),d7		; nombre de style en mémoire; on recherche s'il y a un style du même numéro		subq.w	#1,d7		move.w	d7,d0		mulu	#20,d0		; offset dans la table		move.l	a3,a2		adda.l	#0000002,a2			adda.l	d0,a2		; dernier styleLoop_recherche_Style				move.w	StartChar(a6),d6		and.l	#$ffff,d6		cmp.l	scrpStartChar(a2),d6		beq		Found_Same_style		bhi		Found_style_Sup				suba.l	#00000020,a2			; style précédent		dbra	d7,Loop_recherche_Style; si nous sommes ici dans la boucle c'est qu'il y a un pb; --------- on ajoute un nouveau style ---------------Nouveau_Style	; on créer un style		move.l	a3,a0	; pointeur de style		move.w	(a0),d0	; nombre de style		addq.w	#1,d0		move.w	d0,(a0)+	; nombre de style +1		; on recopie le style précédent		mulu	#20,d0		adda.l	d0,a0		move.l	a0,a3		; on sauvegarde le pointeur de style				move.l	a0,a1		; le nouveau style				sub.l	#00020,a0	; l'ancienne valeur		move.l	#20,d0		_BlockMove				move.l	a3,a0	;on récupère le pointeur de style		bsr		Fill_The_Style	; on place les attributs demandés		add.l	#20,st_StyleLenth(a4)	; longueur des styles		bra		Exit; --------- on créer un  style ---------------Nouveau_Style_Vierge		move.l	a3,a0	; pointeur de style		move.w	#1,(a0)+	; nombre de style		move.w	#-1,Fonct_demande(a6)		bsr		Fill_The_Style	; on place les attributs demandés		move.l	#22,st_StyleLenth(a4)	; longueur des styles+octet de nombre		bra		Exit; -----------------------------------------; il y a déja un style à cette position de style; on replace le par les nouvelles valeurs demandée; d7 contient le nombre de style à changer; a2 pointe sur le style en questionFound_Same_style		move.l	a2,a0		bsr		Fill_The_Style	; on place le style		bra		Exit; -----------------------------------------; la position du caractère n'existe pas dans les styles; Il faut insérer un style avant celui pointé par a2Found_style_Sup; on recopie le style précédent				move.l	a2,a0	; source		move.l	a2,a1			move.l	#20,d0		adda.l	d0,a1	; destination		move	#20,d0		; taille du déplacement				_BlockMove			; déplacement		add.w	#1,(a3)		; un style de plus		move.L	a1,a0		; on insère le style		bsr		Fill_The_Style	; on place le style		add.l	#20,st_StyleLenth(a4)	; longueur des styles				Exit	movem.l	(sp)+,d0-d7/a1-a4	; récupération des registres		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller; routine pour changer le style; A0 pointe sur le style Fill_The_Style		move.w	StartChar(a6),d6		and.l	#$ffff,d6		move.l	d6,scrpStartChar(a0)				move.l	The_StyleRec(a6),a1	; the style rec		; changement de font	?		move.w	Fonct_demande(a6),d0		and.w	#DoFont,d0		beq.s	Do_Size		; non		move.l	tsFont(a1),scrpFont(a0)			; Changement de tailleDo_Size			move.w	Fonct_demande(a6),d0		and.w	#DoSize,d0		beq.s	Do_Face		; non		move.w	tsSize(a1),scrpSize(a0)			; Changement de styleDo_Face			move.w	Fonct_demande(a6),d0		and.w	#DoFace,d0		beq.s	Do_Color		; non		move.b	tsFace+1(a1),scrpFace(a0)			move.b	tsFace+1(a1),scrpFace+1(a0)			; Changement de couleurDo_Color			move.w	Fonct_demande(a6),d0		and.w	#DoColor,d0		beq.s	Exit_sub		; non		 		move.w	tsColor+red(a1),scrpColor+red(a0) 		move.w	tsColor+green(a1),scrpColor+green(a0) 		move.w	tsColor+blue(a1),scrpColor+blue(a0)Exit_sub			move.w	scrpSize(a0),d0			move.w	d0,scrpAscent(a0)		; au pif		move.w	d0,d1		lsr.w	#1,d2		and.w	#$00ff,d1		add.w	d1,d0			move.w	d0,scrpHeight(a0)		; au pif		rts		DbgInfo.new		Add_style	; this name will appear in the debugger		align 4			ENDP								* ========================================		* PROCEDURE	Conversion_TCN19__Bcd()			* ========================================** Cette routine convertie le format de time code de la norme N19* vers le format utilisé par le logiciel** entrée: a0 pointe sur la chaîne tc N19	; * sortie: D0 contient le tc en BCD***Conversion_TCN19__Bcd 		PROC	EXPORT						with	StackFrameImportationFichier,N19_GSI,N19_TTI						import	SpinCursor		movem.l	d1,-(sp)						moveq	#0,d0; heure				moveq	#0,d1		move.b	(a0),d1				divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0		asl.l	#4,d0; minute				moveq	#0,d1		move.b	1(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0				asl.l	#4,d0;seconde				moveq	#0,d1		move.b	2(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0				asl.l	#4,d0				;images				moveq	#0,d1		move.b	3(a0),d1		divu	#10,d1		and.l	#$000f000f,d1		or.b	d1,d0		asl.l	#4,d0		swap	d1		or.b	d1,d0		Exit	movem.l	(sp)+,d1		rts				DbgInfo.new	Conversion_TCN19__Bcd		align 4			ENDP								* ===============================================*	Procedure	ExportationDeFichier_N19()* ===============================================; Cette procédure exporte le fichier en cour dans la norme N19;StackFrameExportN19	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin			EQU	*			; start parameters after this pointParamblock			ds.l	1	; adresse du block de paramètreReply				ds.l	1	; nom du fichierParamSize	EQU	ParamBegin-*	; size of all the passed parametersRetAddr 			DS.L	1	; place holder for return addressA6Link				DS.L	1	; place holder for A6 linkPointeur			ds.l	1	; pointeur en coursbuff1				ds.b	256	; buffer temporaire	n°1buff2				ds.b	256	; buffer temporaire	n°2ItemType			ds.w	1ItemHandle 			ds.l	1itemRect 			ds		rectLargeurReglette		ds.w	1NombreSTLusRect		ds		rectrectangle			ds		rectLastXpos			ds.w	1DateTime			ds		DateTimeRecBlockGSI			ds.b	1028		; le block GSISTPtr				ds.l	1			; pointeur du sous-titre en courRGB_Color			ds.W	3			; pour la reglettePopUp_PaysOrigine	ds.l	1			; NombreTotalST		ds.w	1TheDialogPtr		ds.l	1; attributs caarctère// charactèresthejust			ds.w	1			; la justification du textethestyle		ds.w	1			; le style en courstheLaststyle	ds.w	1			; le dernier style utiliséNextStyle		ds.l	1			; pointeur du prochain style theChar			ds.w	1			; le caractèretheFont			ds.w	1			; la policeThe_color		ds.w	3			; rgbColorLocalSize	EQU 	*			; size of all the local variables		ENDRExportationDeFichier_N19			PROC	EXPORT		WITH	StackFrameExportN19,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame		with	N19_GSI,N19_TTI,DateTimeRec; on utilise le même stackframe		LINK	A6,#LocalSize		; allocate our local stack frame				import	ConversionNumeroSTPointeur,TraitementErreurFichier,\				AFFICHENUMSAISIE,SpinCursor,CONVERSIONChar,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR					; on ouvre un dialogue pour indiquer à l'utilisateur que nous sommes en train d'Exporter; un fichier au norme N19									clr.l	-(sp)			move.w	#138,-(sp)			clr.l	-(sp)			move.l	#-1,-(sp)			_GetNewDialog			move.l	(sp),TheDialogPtr(a6)			_DrawDialog						move.l	TheDialogPtr(a6),-(sp)			_SetPort		; on dit que c'est pour exporter un fichier N19				move.l	TheDialogPtr(a6),-(sp)			move.w	#5,-(sp)	; item 5			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem			move.l	ItemHandle(a6),-(sp)			pea	#'Exportation de fichier  N19-1991'			_SetItext					move.l	TheDialogPtr(a6),-(sp)			move.w	#9,-(sp)	; item 9			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem								move.l	ItemHandle(a6),-(sp)			pea	#'        '			_SetItext							; on affiche le nom du fichier				move.l	TheDialogPtr(a6),-(sp)			move.w	#1,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						move.l	ItemHandle(a6),-(sp)			move.l	Reply(a6),-(sp)			_SetItext							; on trace la ligne sous le titre			move.l	TheDialogPtr(a6),-(sp)			move.w	#4,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)			_GetDItem						_penNormal						move.w	#SrcCopy,-(sp)			_TEXTMode					pea		itemRect(a6)			_FrameRect				;on entoure la reglette				move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem								_penNormal						pea		itemRect(a6)			_FrameRect						move.w	right+itemRect(a6),d0			sub.w	left+itemRect(a6),d0			sub.w	#6,d0			move.w	d0,LargeurReglette(a6)									move.w	bottom+itemRect(a6),bottom+rectangle(a6)			subq.w	#2,bottom+rectangle(a6)			move.w	top+itemRect(a6),top+rectangle(a6)			addq.w	#2,top+rectangle(a6)						move.w	left+itemRect(a6),left+Rectangle(a6)			add.w	#2,left+rectangle(a6)				move.l	TheDialogPtr(a6),-(sp)			move.w	#2,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		NombreSTLusRect(a6)			_GetDItem						move.l	TheDialogPtr(a6),-(sp)			move.w	#3,-(sp)	; item 1			pea		ItemType(a6)			pea		ItemHandle(a6)			pea		itemRect(a6)		; coordonnées de la reglette			_GetDItem		; on récupère la table de conversion mac N19;------- on récupère le handle de la table de conversion.		move.l	G.ResourceDATA1000,a4		cmpa.l	#00000,a4		bne		ResourceExiste		; la resource existe		; on récupère la resource puisqu'elle n'est pas en mémoire				clr.l	-(sp)		move.l	#'DATA',-(SP)		move.W	#1000,-(SP)		_GetResource		suba.l	a4,a4		; on raz a4		move.L	(SP)+,D0		move.L	D0,G.ResourceDATA1000			ResourceExiste				; On Génère le block d'information GSI;------------ on transfère les attributs généraux; transfert des nom de film etc...						lea		BlockGSI(a6),a4		; buffer pour le block gsi; on raz le block GSI			move.w	#1024,d0			subq.w	#1,d0LoopClearGSI			move.b	#' ',(a4)+			dbra	d0,LoopClearGSI						lea		BlockGSI(a6),a4		; buffer pour le block gsi; -------- on place le n° de page de code			move.b	#'8',cpn(a4)			move.b	#'5',cpn+1(a4)			move.b	#'0',cpn+2(a4)			; -------- on place le code du format de disquette DFC			move.b	#'S',3(a4)			move.b	#'T',3+1(a4)			move.b	#'L',3+2(a4)			move.b	#'2',3+3(a4)			move.b	#'5',3+4(a4)			move.b	#'.',3+5(a4)			move.b	#'0',3+6(a4)			move.b	#'1',3+7(a4); -------- on place le type norme d'affichage			move.b	#'0',DSC(a4)	; sous-titrage ouvert			move.w	G.Preference_N19_TypeTeletexte,d0			beq.S	@1						move.b	#'1',DSC(a4)	; télétexte niveau 1@1; --- on place le code caractère				move.w	G.CodeCaractere,d0						sub.w	#1,d0			add.w	#$30,d0			move.b	d0,CCT+1(a4)			move.b	#'0',CCT(a4)			; --- lecture code de langue												Pea		buff1(a6)			move.w	#130,-(sp)			move.w	G.CodeLangue,-(sp)			import	GetIndString			jsr		GetIndString			move.w	buff1+1(a6),d0			move.w	d0,LC(a4)			; --- lecture du pays d'origine									clr.l	-(sp)			move.w	#2007,-(sp)			_GetRMenu			move.l	(sp)+,PopUp_PaysOrigine(a6)						move.w	G.PaysOrigine,d0						move.l	PopUp_PaysOrigine(a6),-(sp)			move.w	d0,-(sp)			pea		Buff1(a6)			_GetItem			; on recherche la parenthèse			lea		buff1+1(a6),a0			moveq	#0,d6				move.b	buff1(a6),d6	; nombre max de char			RechercheParenthese_Loop						cmp.b	#'(',(a0,d6.w)			beq.s	Found_Parenthese			dbra	d6,RechercheParenthese_Loop				bra.s	Titre_original_Programme	; pas trouvé (			; On place les trois lettres dans le block GSIFound_Parenthese								lea		1(a0,d6.w),a0			lea		CO(a4),a1			move.b	(a0)+,(a1)+			move.b	(a0)+,(a1)+			move.b	(a0)+,(a1)+			; -------- on recopie le titre original du programmeTitre_original_Programme			lea	G.Preference_TitreOriginal,a0			lea		OPT(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le titre original de l'épisodeTitre_original_Episode						lea	G.Preference_TitreEpisodeOriginal,a0			lea		OET(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie la traduction titre original du programmeTraduction_Titre_original_programme			lea	G.Preference_TitreFrancais,a0			lea		TPT(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie la traduction titre original de l'épisodeTraduction_Titre_original_Episode						lea	G.Preference_TitreEpisodeTraduit,a0			lea		TET(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC; -------- on recopie Le nom du traducteurNom_du_traducteur						lea	G.Preference_NomAdaptateur,a0			lea		TN(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie Les coordonnées du traducteurCoordonnees_du_traducteur						lea	G.Preference_CoordonneesAdaptateur,a0			lea		TCD(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le code de référence de la liste des sous-titresCode_de_reference			lea	G.CodeDeReference,a0			lea		SLR(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC						; ------- Date de création			move.l	G.DateDeCreation,d0			lea		Buff1(A6),a0			_Secs2Date			lea		Buff1(A6),a0			moveq	#0,D0			move.w	Year(a0),d0			lea		Buff2(A6),a0			clr.w	-(sp)			_PacK7						lea		Buff2(A6),a0			move.b	3(A0),CD(a4)			move.b	4(A0),CD+1(a4)						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Month(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+2(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+3(a4)						moveq	#0,D0			move.w	Day(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+4(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,CD+5(a4); ------- Date de révision						move.l	G.ModifieLe,d0			lea		Buff1(A6),a0			_Secs2Date						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Year(a0),d0			lea		Buff2(A6),a0			clr.w	-(sp)			_PacK7						lea		Buff2(A6),a0			move.b	3(A0),RD(a4)			move.b	4(A0),RD+1(a4)						lea		Buff1(A6),a0			moveq	#0,D0			move.w	Month(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+2(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+3(a4)						moveq	#0,D0			move.w	Day(a0),d0			move.l	d0,d1			divu	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+4(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RD+5(a4)			; ------- Numéro de la révision			moveq	#0,d1			move.w	G.Revision,d1			divu.w	#10,d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RN(a4)						swap	d1			and.w	#$f,d1			or.w	#$30,d1			move.b	d1,RN+1(a4)			; -------- on recopie l'éditeur de la liste des sous-titreEditeur_liste						lea		G.EditeurListe,a0			lea		PUB(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			; -------- on recopie le nom du monteur de la liste des sous-titreMonteur_liste						lea		G.NomDuMonteur,a0			lea		EN(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC; -------- on recopie les coordonnées du monteur de la liste des sous-titreCoordonnee_Monteur_liste						lea		G.CoordonneeMonteur,a0			lea		ECD(a4),a1			moveq	#0,d0			move.b	(a0)+,d0			import	Recopie_StringMacPC			jsr		Recopie_StringMacPC			* ###* ###	Il faudrait en théorie faire du code pour gérer plusieures disquettes* ###		; ----   on place ne nombre de disquette		move.b	#'1',TND(a4)	; un disquette; ----   le numéro d'ordre de la disquette		move.b	#'1',DSN(a4)PasErreurNumeroDisquette; ----    on place Le nombre de block TTI pour cette disquette			move.l	G.General_NombreST,d0			lea		Buff1(a6),a0			clr.w	-(sp)			_Pack7						move.b	#'0',TNB(a4)			move.b	#'0',TNB+1(a4)			move.b	#'0',TNB+2(a4)			move.b	#'0',TNB+3(a4)			move.b	#'0',TNB+4(a4)			moveq	#0,d0			move.b	Buff1(a6),d0			beq		Nombre_ST						lea		TNB+5(a4),a1			lea		Buff1+1(a6),a0			adda.l	d0,a0			subq.W	#1,d0loop_NumberTTI			move.b	-(a0),-(a1)			dbra	d0,loop_NumberTTI							; ----    Le nombre de sous-titre pour cette disquette; on converti ascii décimal => binaireNombre_ST			move.l	G.General_NombreST,d0			lea		Buff1(a6),a0			clr.w	-(sp)			_Pack7						move.b	#'0',TNS(a4)			move.b	#'0',TNS+1(a4)			move.b	#'0',TNS+2(a4)			move.b	#'0',TNS+3(a4)			move.b	#'0',TNS+4(a4)			moveq	#0,d0			move.b	Buff1(a6),d0			beq		Nombre_ST			lea		TNS+5(a4),a1			lea		Buff1+1(a6),a0			adda.l	d0,a0			subq.W	#1,d0loop_NumberST			move.b	-(a0),-(a1)			dbra	d0,loop_NumberST@1			; ----    Le nombre de Groupe de sous-titre pour cette disquette; on converti ascii décimal => binaire						move.b	#'0',TNG(a4)			move.b	#'0',TNG+1(a4)			move.b	#'0',TNG+2(a4)			;Nombre maximum de lignes						move.b	#'2',MNR(a4)			move.b	#'3',MNR+1(a4)			;Nombre maximal de caractères par ligne			move.b	#'4',MNC(a4)			move.b	#'0',MNC+1(a4)			; ----   Le time code début du programme			move.l	G.TcDebutFilm,d0			lea		buff1(a6),A0			import	ConversionTCstASCII			jsr		ConversionTCstASCII			lea		buff1(a6),A0			Lea 	TCP(a4),a1			move.b	1(a0),(A1)			move.b	2(a0),1(A1)			move.b	4(a0),2(A1)			move.b	5(a0),3(A1)			move.b	7(a0),4(A1)			move.b	8(a0),5(A1)			move.b	10(a0),6(A1)			move.b	11(a0),7(A1); ----   Le premier st du programme			lea		buff1(a6),A0			move.l	G.General_PremierTC,d0			import	ConversionTCstASCII			jsr		ConversionTCstASCII 						lea		buff1(a6),A0			Lea 	TCF(a4),a1			move.b	1(a0),(A1)			move.b	2(a0),1(A1)			move.b	4(a0),2(A1)			move.b	5(a0),3(A1)			move.b	7(a0),4(A1)			move.b	8(a0),5(A1)			move.b	10(a0),6(A1)			move.b	11(a0),7(A1); ----  Le status du time code			move.b	#'1',TCS(a4)		; utilisation prévu du time code			; on écrit le block TTI dans le fichier						move.l	paramBlock(a6),a0			move.l	#1024,ioReqCount(a0)			move.l	a4,ioBuffer(a0)			move.w	#fsfromStart,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						; maintenant on effectue l'écriture des blocks TTI 			; ---------------- Ecriture du fichier ----------------------------						; boucle nombre de diskette ; boucle nombre de sous-titre ; initialisation			move.l	G.BufferTransfert,Pointeur(a6)			sub.l	#128,Pointeur(a6)	; pour la boucle						move.l	G.SIZEBufferTransfert,D7			move.l	G.General_PremierSTPtr,STPtr(a6)	; le premier sous-titre			move.l	st_AbsNUMST,d0			move.w	d0,NombreTotalST(a6)			; -------	boucle de recopie des sous-titresLoop_Nombre_de_Soustitre						add.l	#128,Pointeur(a6)	; block TTI suivant			; a t-on rempli le buffer de transfert ?			move.l	G.BufferTransfert,d0			add.l	G.SIZEBufferTransfert,d0			sub.l	#256,d0						; taille du buffer- 256 octets						cmp.l	Pointeur(a6),d0						bhi.s	PasRempliBuffer						; on écrit le buffer dans le fichier						move.l	paramBlock(a6),a0			move.l	Pointeur(a6),d0			;l'octet suivant le dernier block TTI fabriqué			sub.l	G.BufferTransfert,d0			move.l	d0,ioReqCount(a0)			move.l	G.BufferTransfert,ioBuffer(a0)			move.w	#fsatMark,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						move.l	G.BufferTransfert,Pointeur(a6)PasRempliBuffer			;le block TTI est entier donc nous le plaçons dans un sous-titreTTI_EnEntier 			import	Transfert_Soustitre_BlockTTI	; ## on utilise la même pile 			jsr		Transfert_Soustitre_BlockTTI		; incrémentation du curseur du dialogue			bsr		Rafraichi_Curseur_ExportN19; fin de boucle block TTI			move.l	STPtr(a6),a0			move.l	st_NextST(a0),d0			beq.S	PlusDeSous_titre	; c'est fini			move.l	d0,STPtr(a6)			Sub.w	#1,NombreTotalST(a6)			bne.s	Loop_Nombre_de_Soustitre		PlusDeSous_titre; fin de boucle disquette			move.l	paramBlock(a6),a0			move.l	Pointeur(a6),d0			sub.l	G.BufferTransfert,d0			add.l	#128,d0			move.l	d0,ioReqCount(a0)		; dernier block TTI +128 octets			move.l	G.BufferTransfert,ioBuffer(a0)			move.w	#fsatMark,ioPosMode(a0)			move.l	#0,ioPosOffset(a0)			_Write						move.l	paramBlock(a6),a0			move.l	46(a0),d0	;ioPosOffset			move.l	d0,28(a0)	; iomisc			_SetEOFexit		move.l	TheDialogPtr(a6),-(sp)			_DisposDialog			PEA	QD.Arrow		; got arrow cursor at InitGraf			_SetCursor								UNLK	A6			; destroy the link			MOVEA.L	(SP)+,A0		; pull off the return address			ADDA.L	#ParamSize,SP		; strip all of the caller's parameters			JMP	(A0)			; return to the caller			DbgInfo.new		ExportationDeFichier_N19	; this name will appear in the debugger			align 4				* --- Cette routine rafraichie le dialog de progression d'écriture du fichier type N19Rafraichi_Curseur_ExportN19 ; on effectue le rafraichissement du dialog; on calcule la position en x de la reglette		move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d0		mulu	LargeurReglette(a6),d0				move.l	G.General_NombreST,d1		divu	d1,d0	; resultat dans d0				cmp.w	LastXpos(a6),d0		beq.s	onnedessinepas				move.w	d0,LastXpos(a6)		; on dessine la reglette								bsr		Draw_Reglette		; on affiche le n° de St Lu		move.w	left+NombreSTLusRect(a6),-(sp)		move.w	bottom+NombreSTLusRect(a6),-(sp)		_MoveTo				move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d0				lea		buff2(a6),a0		clr.w	-(sp)	; num to string		_Pack7				_PenNormal				pea		buff2(a6)		_DrawString					onnedessinepas				rts						Draw_Reglette; cette routine rafraichie la reglette				move.l	d0,d6		; sécu de la valeur				move.l	TheDialogPtr(a6),-(sp)		move.w	#3,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		itemRect(a6)		move.w	#2,-(sp)		move.w	#2,-(sp)		_insetRect				sub.w	#1,bottom+itemRect(a6)				move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		;largeur reglette		move.l	STPtr(a6),a0		move.l 	st_AbsNUMST(a0),d1		mulu	d1,d0				move.l	G.General_NombreST,d1		divu	d1,d0	; resultat dans d0		add.w	left+itemRect(a6),d0				move.w	d0,right+itemRect(a6)						move.w	right+itemRect(a6),d0		sub.w	left+itemRect(a6),d0		cmp.w	#2,d0		bhi.s	Do_Reflet				move.w	#10000,RGB_Color(a6)		move.w	#50000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor						pea		itemRect(a6)		_PaintRect		move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		rtsDo_Reflet		move.w	#0,RGB_Color(a6)		move.w	#20000,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect						move.w	#5535,RGB_Color(a6)		move.w	#20535,2+RGB_Color(a6)		move.w	#5535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo				move.w	right+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo		move.w	#15535,RGB_Color(a6)		move.w	#55535,2+RGB_Color(a6)		move.w	#15535,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	right+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_LineTo				move.w	left+itemRect(a6),-(sp)		move.w	top+itemRect(a6),-(sp)		_MoveTo		move.w	left+itemRect(a6),-(sp)		move.w	bottom+itemRect(a6),-(sp)		_LineTo; on dessine l'intérieur du rectangle		pea		itemRect(a6)		move.w	#1,-(sp)		move.w	#1,-(sp)		_insetRect				add.W	#1,right+itemRect(a6)		add.W	#1,bottom+itemRect(a6)		move.w	#10000,RGB_Color(a6)		move.w	#45000,2+RGB_Color(a6)		move.w	#10000,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				pea		itemRect(a6)		_PaintRect				move.w	#0,RGB_Color(a6)		move.w	#0,2+RGB_Color(a6)		move.w	#0,4+RGB_Color(a6)		pea		RGB_Color(a6)		_RGBForecolor				_PenNormal				rts				ENDP								* ==============================================*	Procedure	RECOPIE_STRINGMACPC()* ==============================================; cette routine convertie une chaîne Mac en une chaîne PC;;	entrée: D0 longueur;			A0 source ptr ;			A1 destination ptr RECOPIE_STRINGMACPC	proc export		movem.l	d7,-(sp)		move.w	d0,d7		beq.S	Exit	; rien à faire		subq.W	#1,d7Loop_recopieChar		move.b	(A0)+,d0		cmp.b	#$0d,d0		bne.s	LRC_PasOD		move.b	#$0d,(a1)+		move.b	#$0A,(a1)+		bra.s	LRC_FinRecopieLRC_PasOD				moveq	#1,d1	; conversion Mac => PC		bsr		CONVERSIONChar		move.b	d0,(a1)+LRC_FinRecopie			dbra	d7,Loop_recopieCharExit	movem.l	(sp)+,d7		rts		dbgInfo.new	RECOPIE_STRINGMACPC		endP* ===============================================*	Procedure	Transfert_Soustitre_BlockTTI()* ===============================================; Cette procédure Fabrique un block TTI à partir d'un sous-titre; en fct des parramètres d'initialisation;Transfert_Soustitre_BlockTTI			PROC	EXPORT		WITH	StackFrameExportN19,StandardFileReply,SFReply,DateTime,SOUSTITRERECORD		; cover our local stack frame		with	N19_GSI,N19_TTI,DateTimeRec; on utilise le même stackframe; on garde la même pile que la routine appelante		import	ConversionNumeroSTPointeur,TraitementErreurFichier,\				AFFICHENUMSAISIE,SpinCursor,\				ConversionTCstASCII,SoustractionTimeCode,ConversionTimeCode_Trames,\				ConversionTrames_TimeCode,CopySTR,ConversionBcd_TCN19					; on commence par placer le n° de sous-titre						move.l	Pointeur(a6),A3			move.l	StPtr(a6),A4			move.l	st_ABSNUMST(A4),d0	;(LSB)			move.b	d0,SN(a3)	; poids faible			asr.l	#8,D0		; (MSB)			move.b	d0,SN+1(a3)	; poids fort								; numéro block st extension etc...			move.b	#0,SGN(a3)		; pas de groupe			move.b	#$FF,EBN(a3)	; pas de block d'extension			move.b	#0,CS(a3)		; pas état cumulatif (sous-titres ajouté)					; la justification	du texte 								lea 	tableConversionJustif(pc),a0			moveq	#0,D0			move.b	st_Justification(a4),d0			cmp.b	#3,d0	; on prévient les erreurs			blo.s	@SupJustif			moveq	#0,D0@SupJustif					move.b	(a0,d0.w),d0			move.b	d0,JC(A3)			; drapeau de remarque ######## pour l'instant pas de remarque			move.b	#0,CF(a3)										; position verticale			move.w	st_Nlines(a4),d0	; nombre de ligne			bne		do_vp				move.b	#23,VP(A3)			; si pas de ligne on ce place à la ligne 23			bra.s	doTCIndo_vp						tst.w	G.Preference_DoubleHauteur			beq.S	PasDoubleHauteur_1			mulu	#2,d0PasDoubleHauteur_1			move.w	#24,d1			sub.w	d0,d1			move.b	d1,VP(A3)			; time code in		doTCIn						move.l	st_TimeCodeIN(a4),d0			lea		TCI(a3),a0			jsr	ConversionBcd_TCN19			; time code out								move.l	st_TimeCodeOUT(a4),d0			lea		TCO(a3),a0			jsr	ConversionBcd_TCN19			; fini pour les attributs du sous-titre on passe au texte du sous-titre			move.l	a4,a2			move.l	#st_sizeOf,d0			adda.l	d0,a2			; pointeur du texte					lea		TF(a3),a3	; champ de texte; ------- on raz la zone de texte on place $8f partout			move.w	#111,d6LoopEraseTF	move.b	#$8F,(a3,d6.w)						dbra	d6,LoopEraseTF						clr.w	theLaststyle(a6)	; style normal			clr.w	thestyle(a6)		; style normal			clr.w	NextStyle(a6)			 			moveq 	#0,d7		; compteur de lecture de char dans ST			moveq	#0,d6		; compteur du nombre de char dans ce block TTI			; --------- boucle caractère//caractère	; on ouvre une première ligne; texte vide ?			move.l	StPTR(a6),a0			tst.l	st_texteLenth(a0)			beq		FinRecopieCaracteres	; texte vide									tst.w	G.Preference_N19_TypeTeletexte			beq.s	RecopieCaractere_LOOP			; non pas télétexte			bsr		NouvelleLigne	; on place les attributs d'une nouvelle ligne			RecopieCaractere_LOOP			move.l	d7,d0			bsr		GiveChar_et_style	; on récupère le style et le char			addq.w	#1,d7			move.w	theChar(a6),d0			cmp.w	#-1,d0			beq		FinRecopieCaracteres		; c'est fini								tst.w	G.Preference_N19_TypeTeletexte			bne 	PasGestionstyle			; mode télétexte	pas de style		; --- on gère les style	-------------------------------------------------------				move.w	thestyle(a6),d1			cmp.w	theLaststyle(a6),d1			beq		PasGestionstyle				;c'est le même on ne fait rien						_Debugger; - on change de style; on regarde ce qui change			move.w	theLaststyle(a6),d1	;			move.w	thestyle(a6),d2			eor.w	d1,d2	; ce qui change est à 1						btst	#1,d2		; changement dans les italiques			beq.s	PasChangementdansitalique; ----			; changement dans italique			moveq	#0,d1			move.w	thestyle(a6),d1			eor.w	#$2,d1			and.w	#$2,d1			lsr		#1,d1			move.w	#$80,d0			or.w	d1,d0				; 80 si italique, 81 si fin italique									move.b	d0,(a3)+			addq.W	#1,d6; -----PasChangementdansitalique						btst	#0,d2		; changement dans les gras			beq.s	PasChangementdansGras			; -----			; changement dans gras  ### (gras = emboitage ???)			move.w	thestyle(a6),d1			eor.w	#$1,d1			and.w	#$1,d1			move.w	#$82,d0			or.w	d1,d0				; 84 si emboitage, 85 si fin emboitage						move.b	d0,(a3)+			addq.W	#1,d6PasChangementdansGras			btst	#2,d2		; changement souligné			beq.s	PasGestionSouligne			; -----			; changement dans souligné			move.w	thestyle(a6),d1			eor.w	#$4,d1			and.w	#$4,d1			lsr		#2,d1			move.w	#$82,d0			or.w	d1,d0				; 82 si souligné, 83 si plus souligné						move.b	d0,(a3)+				; début des italiques			addq.W	#1,d6PasGestionSouligne			move.w	thestyle(a6),theLaststyle(a6)			move.w	theChar(a6),d0; -----------------------------------------------------------------------------PasGestionstyle					cmp.b	#$d,d0			; CR/LF	?			beq.s	findeligne						cmp.b	#'$',d0			bne.s	pasChar24			move.b	#$a4,d0			; conversion à la main du char '$'pasChar24									cmp.b	#$7f,d0			bhi.s	ConverttheChar	; il faut convertir les caractères			move.b	d0,(a3)+			addq.w	#1,d6			bra		FinBoucle_Char			; il faut convertir les caractères	(accentuation ...)		ConverttheChar			bsr		conversion_Char				bra		FinBoucle_Char			;---------------- fin de la ligne en cour -------------findeligne		; sommes nous en mode télétexte ?			tst.w	G.Preference_N19_TypeTeletexte			bne.s	TeletexteFinligne			; nous ne sommes pas en télétexte;			move.b	#$8a,(a3)+	;CR/LF;			add.w	#1,d6		; 1 chars de plus						bra		FinBoucle_Char			; ---------			; oui nous sommes en telétexte; double hauteur ?TeletexteFinligne			tst.w	G.Preference_DoubleHauteur			beq.s	PasDoubleHauteur; ----------  nous sommes en double hauteur						move.b	#$0a,(a3)+	; fin incrustation			move.b	#$0a,(a3)+	; fin incrustation			move.b	#$8a,(a3)+	; CR/LF			move.b	#$8a,(a3)+	;CR/LF			add.w	#4,d6		; 4 chars de plus						bra		FinNouvelleLigne			; ---------- nous ne sommes pas en double hauteurPasDoubleHauteur			move.b	#$0a,(a3)+	; fin incrustation			move.b	#$8a,(a3)+	;CR/LF			add.w	#2,d6		; 1 chars de plusFinNouvelleLigne; on place les attributs d'une nouvelle ligne			bsr		NouvelleLigne			bra		FinBoucle_Char; ------------------------------------------------						FinBoucle_Char					cmp.w	#111,d6			bhi		SupauTTI						bra		RecopieCaractere_LOOP; c'est fini de recopié			FinRecopieCaracteres			 			move.b	#$8a,(a3)+			; #### normalement pas besoin			add.w	#1,d6		; 1 chars de plus						bra		Exit						; --------- il faut ajouter un block TTI car nous n'avons pas -----------; --------- assez de place pour tous nos caractères	---------------------						; c'est fini pour ce TTI #### attention pour ètre en règle avec N19; il faudrait prévoir la possibilité de créer des block TTI d'extensions; pour des sous-titres dépassant 112 chars; nb: avec les attributs télétexte cela peut aller vite; 3 lignes de 32 chars :;   96 (chars) +6*13 (attributs)  +4*2(fin de ligne) + 2 cr/lf =182; sans compter les caractères accentués cela peut ne pas rentré dans un seul TTISupauTTI			break							; on retourne à l'appeleur; À TCIAO BONSOIR .....exit		rts* ============================= SUB ROUTINES =============================; ----- routine pour créer une nouvelle ligne ----------------------------NouvelleLigne			tst.w	G.Preference_N19_TypeTeletexte			bne.s	NL_Teletexte			; pas mode télétexte			rts		; on ne fait rien si pas télétexte			; Mode télétexte on ajoute des codes d'attributs pour la ligne à venirNL_Teletexte			move.b	#$1c,(a3)+		; fond noir  ####(code inutile car valeur par defaut)			move.b	#$07,(a3)+		; charBlanc  ####(code inutile car valeur par defaut)						tst.w	G.Preference_DoubleHauteur			bne.s	NL_DoubleHauteur			tst.w	G.Preference_DoubleLargeur			bne.s	NL_DoubleLargeur			; donc simple hauteur simple largeur						move.b	#$0b,(a3)+	; début d'incrustation			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#2,d6				rts			; -------NL_DoubleHauteur			tst.w	G.Preference_DoubleLargeur			bne.s	NL_TailleDouble			move.b	#$0d,(a3)+	; double hauteur			move.b	#$0b,(a3)+	; début d'incrustation			move.b	#$0b,(a3)+	; début d'incrustation 	;#### (pourquoi en mettre 2 ?)			move.w	G.Preference_Couleur,d0				move.b	d0,(a3)+	; couleur du texte			addq.w	#4,d6				rts			; -------	; largeur double			NL_DoubleLargeur			move.b	#$0e,(a3)+	; double largeur			move.b	#$0b,(a3)+	; début d'incrustation			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#3,d6				rts; -------		; taille doubleNL_TailleDouble			move.b	#$0f,(a3)+	; double hauteur			move.b	#$0b,(a3)+	; début d'incrustation			move.b	#$0b,(a3)+	; début d'incrustation	;#### (pourquoi en mettre 2 ?)			move.w	G.Preference_Couleur,d0			move.b	d0,(a3)+	; couleur du texte			addq.w	#4,d6				rts; -------------------------------------------------------------------;  sous-routine qui donne l'ascii et le style d'un caractère	GiveChar_et_style		; d0 = indice du caractère 0 ≈ Nmax		movem.l	d1-d2/a1-a2,-(sp)		move.l	StPtr(a6),a0		cmp.l	st_TexteLenth(a0),d0	; dans le st ?		blo.S	Char_Exist		move.w	#-1,d0					; caractère pas dans la liste		move.w	d0,theChar(a6)				movem.l	(sp)+,d1-d2/a1-a2		rts; ---------------------------------------		Char_Exist				move.l	a0,a1		move.l	#st_sizeOf,d1		adda.l	d1,a1				; pointeur du texte		move.l	d0,d1				; sauvegarde du n° de char			_debugger		tst.l	st_StylePtr(a0)		; il y a t-il des styles dans ce sous-titre ?			bne.s	RechercheProchainStyle;non, pas de style => parramètre par défaut				clr.w	thestyle(a6)			; style normal 		move.w	#1,theJust(a6)			; centrée		move.w	#0,theFont(a6)			; 1 ère font de la liste		move.l	#-1,NextStyle(a6)		; pas de prochain style		bra.s	PasDeStyle RechercheProchainStyle		move.l	NextStyle(a6),d2		beq.s	RechercheCont			; il n'y en a pas il faut le rechercher		cmp.l	d2,d1					; char pos <inférieur au prochain style ?		blo.s	PasDeStyle				; on ne change pas; -------------------		; on détermine quel style appartient au caractèreRechercheCont		move.l	st_StylePtr(a0),a2		; pointeur du style		move.w	(a2)+,d2				; nombre de style		subq.w	#1,d2		move.l	#20,d0		sub.l	d0,a2		LoopStyle			move.l	#20,d0		add.l	d0,a2			;scrpRecSize (décimal 20) on est obligé de forcer l'ASM en Long mode		cmp.l	(a2),d1		blo.s	FoundNext		move.w	scrpFont(a2),theFont(a6)		moveq	#0,d0		move.b	scrpFace(a2),d0		move.w	d0,thestyle(a6); style suivant				dbra	d2,LoopStyle				move.w	#-1,NextStyle(a6)			; pour indiquer qu'il n'y a plus de style		bra.s	PasDeStyle		FoundNext		move.l	(a2),NextStyle(a6); ---------PasDeStyle; on récupère le caractère		moveq	#0,d0		move.b	(a1,d1.w),d0					; caractère (long)		move.w	d0,thechar(a6)			movem.l	(sp)+,d1-d2/a1-a2		rts; --------------------------------------------------------------------; sous-routine de conversion caractère mac => n19; a4 pointe sur la table de conversionconversion_Char		movem.l	d1-d2/a4,-(sp)		; on sauvegarde d1-d2/a4		move.l	G.ResourceDATA1000,d1		beq		pasDeResource1000		move.l	d1,a4				move.l	(a4),a4			; handle	Loop_Recherche_double_Char				move.w	(a4),d1				; code Mac dans la table de conversion		beq.s	pasDeResource1000	; fin de la table,on sort avec le caractère simple dans d0		cmp.w	d1,d0		beq.S	Found_The_Char		adda.l	#000004,a4				; code suivant		bra.s	Loop_Recherche_double_Char; erreur diverses on ne modifie pas le caractèrepasDeResource1000		move.b	d0,(a3)+		addq.w	#1,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rts		; -----Found_The_Char		move.w	2(a4),d1		asr.w	#8,d1		; 8bits poids fort		move.w	2(a4),d2		tst.b	d1			; accentutation ?		beq		PasAccentuation				move.b	d1,(a3)+		move.b	d2,(a3)+		addq.w	#2,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rtsPasAccentuation				move.b	d2,(a3)+		addq.w	#1,d6		movem.l	(sp)+,d1-d2/a4		; on recupère d1-d2/a4		rts		; -----------------------------------------------------------tableConversionJustif			dc.b	02	; 0= centrée			dc.b	01	; 1= gauche			dc.b	03	; 2=Droite			dc.b	00	; 			DbgInfo.new		Transfert_Soustitre_BlockTTI	; this name will appear in the debugger			align 4				endp			* ========================================		* PROCEDURE	ConversionBcd_TCN19()			* ========================================** Cette routine convertie le time code bcd en format N19l** entrée: D0 contient le tc en BCD*		  A0 pointe sur letc n19 qui doit ètre rempli* sortie: D0 contient le tc N19**ConversionBcd_TCN19 		PROC	EXPORT		with	StackFrameImportationFichier,N19_GSI,N19_TTI		import	SpinCursor		movem.l	d1-d2,-(sp)						move.l	d0,d1	; sauvegarde du timecode		; si tc =-1 vide on place 00 00 00 00		cmp.l	#-1,d0		bne.s	DoConversionTC		move.b	#0,3(a0)		move.b	#0,2(a0)		move.b	#0,1(a0)		move.b	#0,0(a0)		movem.l	(sp)+,d1-d2		rtsDoConversionTC		; images				and.l	#$f,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,3(a0)				; secondes		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,2(a0)		; minutes		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,1(a0)		; heures		asr.l	#4,d1		move.l	d1,d0		and.l	#$F,d0		asr.l	#4,d1		move.l	d1,d2		and.l	#$f,d2		mulu	#10,d2		add.w	d2,d0		move.b	d0,0(a0)							Exit	movem.l	(sp)+,d1-d2		rts				DbgInfo.new	ConversionBcd_TCN19		align 4			ENDP				* ======================================================================*	Fonction	EcarteSousTitre();* ======================================================================**	Cette routine écarte le sous-titre désigner par a0*	à la longueur désigner par d0	(elle sera alignée .l)**	sortie d0= 0 si pas erreur 				SEG	'Traitement'EcarteSousTitre		proc	Export	StackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*			; start parameters after this pointParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1			; place holder for return addressA6Link			DS.L	1			; place holder for A6 linklongueur		ds.l	1			; longueur demandéePtrSousTitre	ds.l	1			; pointeur du sous-titreLenthST			ds.l	1deplacement			ds.l	1LocalSize		EQU 	*			; size of all the local variables		ENDR		IMPORT	CentreListingWindow,DrawListingWindow,WaitTicks,DoMenuCommand, \				AdjustMenus,ConversionNumeroSTPointeur,ConversionTimeCodePointeur,\				ConversionchaineASCIITc		WITH	StackFrame,SOUSTITRERECORD		; cover our local stack frame		link	a6,#LocalSize		movem.l	d1-d7/a1-a4,-(sp)		; nous avons la longueur du texte		; il faut aligner sur un mot long la longueur totale; c'est mieux !; on peut faire le calcul sur 16 bits car un sous-titre > 32k, n'existe pas à mon avis.		move.l	a0,PtrSousTitre(a6) ; sécu ptr		import	AligneD0		jsr		AligneD0		move.l	d0,d7		move.l	d7,longueur(a6)		; on regarde s'il y a assez de place pour caser le sous-titre; methode sûre => on calcule l'espace dispo en fonctions des pointeurs du sous-titre suivant				cmp.l	st_LenthST(a0),d7		bhi.s 	IlFautEcarter		moveq	#0,d0		bra		Exit; ----------------------------------------------		IlFautEcarter		; non il faut donner plus de place au sous-titre; on ecarte (on utilise la même routine que insertST, sauf pour les pointeurs et numéro; on commence par regarder s'il y a assez de mémoire			move.l	a0,d0			add.l	d7,d0			add.l	#st_SizeOf,d0				cmp.l	G.General_HIMEMST,d0					bge		IST_PasSuffisemmentDeMemoire	; on ne peut pas faire le boulot; on  regarde si le st est le dernier ST dans la liste; dans ce cas on change juste la variable taille. 			cmp.l	G.General_DernierSTPtr,a0			bne.s	PasDernierStDansLaListe			; oui dernier dans la liste	; --------------------------DernierDansLAliste			move.l	d7,st_LenthST(a0)			moveq	#0,d0			bra		Exit			; non, ce n'est pas le dernier, il faut décaler.; ----------------------------------------------PasDernierStDansLaListe; ON CALCULE LA LONGUEUR EFFECTIVE DU DEPLACEMENT; on vérifie la longueur du déplacement						move.l	PtrSousTitre(a6),a0			move.l	(a0),d1					; pointeur suivant			beq		DernierDansLAliste			sub.l	a0,d1					; pointeur courant			move.l	#st_SizeOf,d0			sub.l	d0,d1					; taille réelle du sous-titre						move.l	st_LenthST(a0),d7			cmp.l	d7,d1; a little problem, reel size of the sub t. element is not the good one !			bhs.s	No_Problem			move.l	d7,d1No_Problem							move.l	PtrSousTitre(a6),a0			move.l	longueur(a6),d0									sub.l	d1,d0				; largeur du déplacement			move.l	d0,deplacement(a6)			; on  place la nouvelle longueur du sous-titre						move.l	longueur(a6),st_LenthST(a0)			; on prépare les pointeurs pour le déplacement de la mémoire					move.l	G.General_DernierSTPtr,a1			move.l	st_LenthST(a1),d1			add.l	#st_SizeOf,d1				adda.l	d1,a1				; pblm l'assembleur mettrait adda.w ! si pas cette opération			move.l	st_NextST(a0),a0	; on prend le ptr du suivant			; on décale le reste des sous-titres, de la valeur contenue par d0; on fait le décalage du haut vers le bas, comme cela on conserve le contenu; des sous-titres; a0= pointe sur début de la zone à transférer; a1 = pointe sur la fin de la zone à transférer; d0= la longueur du déplacement; on fait une copie mot (16 bits) par motCopyLoop	move.w	(a1),(a1,d0.l)			sub.l	#2,a1			cmp.l	a0,a1			bhs.s	CopyLoop; -------------  chaînage des sous-titres et valeurs internes au sous-titre; on place les nouveaux vecteurs de chainages des sous titres.; vecteur= addresse absolue du st; on modifie les pointeurs du sous-titre ecarter  ; --- on change le next st du sous-titre courant 			move.l	PtrSousTitre(a6),a3			move.l	st_nextST(a3),a1			add.l	d0,a1					; d0 toujours =longueur			move.l	a1,st_nextST(a3)		; a1 = Ptr du sous-titre suivant			; --- on change le previous st du sous-titre déplacé ; on prend la valeur du st en cour => previous du suivant 			move.l	PtrSousTitre(a6),a3			move.l	a3,d1			sub.l	d0,d1					; on enlève le déplacement (car passage dans la boucle)								move.l	d1,st_PreviousST(a1)						; --- on change les coordonnées du dernier sous-titre en mémoire			move.l	G.General_DernierSTPtr,a2			add.l	d0,a2			move.l	a2,G.General_DernierSTPtr									; --- on chaîne les sous-titres			move.l	a1,a0			; on part du next st						move.l	deplacement(a6),d7; ----------Loop_Chainage_soustitre			move.l	st_PreviousST(a0),d0			beq.s	@1						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_PreviousST(a0)@1						move.l	st_CommentairePTR(a0),d0			beq.s	@2						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_CommentairePTR(a0)@2			move.l	st_StylePTR(a0),d0			beq.s	@3						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_StylePTR(a0)@3			move.l	st_PosOffsetTable(a0),d0			beq.s	@4						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_PosOffsetTable(a0)@4			move.l	st_NextST(a0),d0			beq.S	@5 			add.l	d7,d0			move.l	d0,st_NextST(a0)			move.l	d0,a0			cmp.l	G.General_DernierSTPtr,a0		; pas au dessus de la liste			bls.s	Loop_Chainage_soustitre				; on a terminé@5; -------------------------------------------------------------------; on invalide le cache du conversion num->pointeur			clr.l	G.General_DernierNumConvertiPtr			clr.l	G.Sous_titre_dessined			clr.l	G.Sous_titreInOffscreen			bra		Exit ; il n'a plus assez de mémoire pour insérer un sous-titreIST_PasSuffisemmentDeMemoire:; faire alerte			clr.w	-(sp)			move.w	#133,-(sp)			clr.l	-(sp)			_Alert			move.w	(sp)+,d0			move.l	#-1,d0		; code erreur => d0			; on regarde si le sous-titre est plus grand, est ce qu'il faut le resserer ?; je pense que pour l'instant cela n'est pas utile au dévelloppement, mais; il faudra le faire !EXIT	clr.l	G.General_DernierNumConvertiPtr		clr.l	G.Sous_titre_dessined		clr.l	G.Sous_titreInOffscreen		movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6			; destroy the link		MOVEA.L	(SP)+,A0		; pull off the return address		ADDA.L	#ParamSize,SP		; strip all of the caller's parameters		JMP	(A0)			; return to the caller		DbgInfo.New	EcarteST 		endp	* ================================================* PROCEDURE Insert_before(longueur d0); * ================================================*  	Cette routine créer un sous-titre avant le premier sous-titre de la liste* 	attention ! il ne faut pas plus de 255 1 er sous-titre sans renumérotation**	D0 indique la taille du sous-titre,	*	si d0=0 la routine insere 32 caracteres**	Insert_before 	PROC	EXPORTStackFrame	RECORD	{A6Link},DECR		; build a stack frame recordParamBegin	EQU	*			; start parameters after this pointParamSize	EQU	ParamBegin-*		; size of all the passed parametersRetAddr 	DS.L	1			; place holder for return addressA6Link		DS.L	1			; place holder for A6 linkPtrSousTitre	ds.l	1		; offset absolu du sous-titrelongueur		ds.l	1previous		ds.l	1deplacement		ds.l	1LocalSize	EQU 	*			; size of all the local variables		ENDR			SEG	'ListeSoustitre'			WITH	StackFrame,SOUSTITRERECORD		;			LINK	A6,#LocalSize			IMPORT	DrawListingWindow,AFFICHENUMSAISIE,RenumerationAbsST, \						RenumerotationSubNumero,RenumerotationListeSousTitre; intialisation				movem.l d1-d7/a1-a4,-(sp)			move.l	G.General_PremierStPtr,PtrSousTitre(a6)			move.l	#0,-(sp)			import	ManageUndoRedoListeForInsert			jsr		ManageUndoRedoListeForInsert; on détermine la longueur du déplacement en fonction ; de la longueur du premier sous-titre 		move.l	G.General_PremierSTPtr,a0		move.L	st_NextST(a0),d0		sub.l	a0,d0	; longueur totale du premier sous-titre		move.l	d0,deplacement(a6)				; ça y est c'est aligné		; on regarde s'il y a assez de place pour caser le sous-titre		move.l	G.General_DernierSTPtr,a1		add.L	st_lenthST(a1),a1		move.l	#st_sizeOf,d1	; on ajoute la taille du header		add.l	d1,a1		add.l	d7,a1		cmp.l	G.General_HIMEMST,a1			bge		before_PasSuffisemmentDeMemoire	; on ne peut pas faire le boulot			; on prépare les pointeurs pour le déplacement de la mémoire; on effectue la recopie de haut vers le bas			move.l	G.General_DernierSTPtr,a1			add.l	st_LenthST(a1),a1			move.l	#st_SizeOf,d1	; pblm l'assembleur mettrait adda.w ! sinon			adda.l	d1,a1			move.l	G.General_PremierSTPtr,a0				; on décale le reste des sous-titres, de la valeur contenue par d0; on fait le décalage du haut vers le bas, comme cela on conserve le contenu; des sous-titres; a0= pointe sur début de la zone à transférer; a1 = pointe sur la fin de la zone à transférer; d0= la longueur du déplacement; on fait une copie mot (16 bits) par motCopyLoop	move.w	(a1),(a1,d0.l)			sub.l	#2,a1			cmp.l	a0,a1			bhs.s	CopyLoop				; on place les nouveaux vecteurs de chainages des sous titres.; vecteur= addresse absolue du st; on modifie les pointeurs du sous-titre ecarter ; on actualise le dernier sous-titre			move.l	G.General_DernierSTPtr,a2			add.l	d0,a2			move.l	a2,G.General_DernierSTPtr			clr.l	st_NextST(a2)									; -------------  chaînage des sous-titres et valeurs internes au sous-titre; on place les nouveaux vecteurs de chainages des sous titres.; vecteur= addresse absolue du st; on modifie les pointeurs du sous-titre ecarter  ; --- on change le next st du sous-titre courant  			move.l	PtrSousTitre(a6),a3			move.l	a3,a0 			adda.l	d0,a0								move.l	a0,st_nextST(a3)			clr.l	st_PreviousST(a3)			;et le previous du suivant 						move.l	d0,d7			sub.l	d7,a3					; on annule l'addition au prochain passage			move.l	a3,st_PreviousST(a0)												; --- on chaîne les sous-titres			Loop_Chainage_soustitre			move.l	st_PreviousST(a0),d0			beq.s	@1						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_PreviousST(a0)@1						move.l	st_CommentairePTR(a0),d0			beq.s	@2						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_CommentairePTR(a0)@2			move.l	st_StylePTR(a0),d0			beq.s	@3						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_StylePTR(a0)@3			move.l	st_PosOffsetTable(a0),d0			beq.s	@4						; si nul on de change pas			add.l	d7,d0			move.l	d0,st_PosOffsetTable(a0)@4			move.l	st_NextST(a0),d0			beq.S	@5 			add.l	d7,d0			move.l	d0,st_NextST(a0)			move.l	d0,a0			cmp.l	G.General_DernierSTPtr,a0		; pas au dessus de la liste			bls.s	Loop_Chainage_soustitre				; ------ on a terminé la chaînage -------------------------------------@5			; on invalide le cache du conversion num->pointeur			clr.l	G.General_DernierNumConvertiPtr			clr.l	G.Sous_titre_dessined			clr.l	G.Sous_titreInOffscreen; on actualise les valeurs intracèque au sous-titre inséré									move.l	G.General_PremierSTPtr,a0; on place  1 comme numéro de sous-titre						move.l	#1,st_NumeroST(a0)			move.l	#1,st_OldNumeroST(a0)			move.l	#1,st_AbsNumST(a0)						move.l	st_nextST(a0),a1	; a1 =suivant st			move.l	st_NumeroST(a1),d1		; on additionne 1 au numéro secondaire du 2 ème st			move.l	st_NumeroST(a1),d1			add.l	#$01000000,d1			bcc   	before_PASErreurNumerotation; nous sommes arrivé à 256 sous-valeurs donc il y a dépassement 		before_ErreurNumerotation:			clr.w	-(sp)			move.w	#134,-(sp)			clr.l	-(sp)			_Alert			move.l	PtrSousTitre(a6),a0			move.l	st_NumeroST(a0),d1			move.w	(sp)+,d0			cmp.w	#1,d0	; ok gadget			bne 	before_PASErreurNumerotation			; l'utilisateur a répondu CANCEL on n'incrémente pas le numéro de sous-titre; tant pis il y aura plusieur ST de même numéro				before_renum	move.l	d1,st_NumeroST(a1)	; on renumérote les numéro absolu			jsr		RenumerationAbsST			move.l	st_AbsNUMST(a0),d0			move.w	d0,G.General_SousTitreEncour			; on ajoute un au nombre total de sous-titre						move.l	G.General_NombreST,d0			add.l	#1,d0			move.l	d0,G.General_NombreST			; on tranfère cette valeur au control listing  				move.l	G.ListingVScroll,-(sp)			move.w	d0,-(sp)			_SetMaxCtl												; ON initialise le nouveau sous-titre			move.l	G.General_PremierSTPtr,a1			move.l	deplacement(a6),d0			sub.l	#st_sizeof,d0			move.l	d0,st_lenthST(A1)			clr.l	st_StyleLenth(a1)			clr.l	st_TexteLenth(a1)			clr.l	st_CommentairePtr(a1)			clr.l	st_CommentaireLenth(a1)			clr.l	st_StylePtr(a1)			move.l	#-1,st_TimeCodeIn(a1)			move.l	#-1,st_TimeCodeOut(a1)			clr.w	st_Error(a1)			clr.w	st_Xoffset(a1)			clr.w	st_Yoffset(a1)			clr.l	st_PosOffsetTable(a1)			clr.b	st_Justification(A1)	; justification du texte 0 centrée, 			clr.b	st_MasKType(a1)			; type de mask box, line, rectangle; = rien; on renumérote la fin de la liste			move.l	a1,a0			jsr		RenumerotationListeSousTitre			bra		EXIT			; on calcule numéro absolu du sous-titre conserné; ----------------------------------------before_PASErreurNumerotation:			move.l	d1,st_NumeroST(a1)PasZeroBefore						jsr		RenumerationAbsST			move.l	st_AbsNUMST(a0),d0			move.w	d0,G.General_SousTitreEncour			; on ajoute un au nombre total de sous-titre			move.l	G.General_NombreST,d0			add.l	#1,d0			move.l	d0,G.General_NombreST; on tranfère cette valeur au control listing  				move.l	G.ListingVScroll,-(sp)			move.w	d0,-(sp)			_SetMaxCtl												; ON DÉFINIE les différentes longueur enfct de			move.l	G.General_PremierSTPtr,a1			clr.l	st_StyleLenth(a1)			clr.l	st_TexteLenth(a1)			clr.l	st_CommentairePtr(a1)			clr.l	st_CommentaireLenth(a1)			clr.l	st_StylePtr(a1)			move.l	#-1,st_TimeCodeIn(a1)			move.l	#-1,st_TimeCodeOut(a1)			clr.w	st_Error(a1)			clr.w	st_Xoffset(a1)			clr.w	st_Yoffset(a1)			clr.l	st_PosOffsetTable(a1)						move.l	G.General_PremierSTPtr,a0				; a0 pointe sur le sous-titre en cours			move.l	st_nextST(a0),a0								; le suivant			cmp.l	#0,a0			beq		Zorglub			jsr		RenumerotationSubNumero						; il faut renuméroter la liste en numéro secondaire ?	Zorglub		tst.w	 G.Preference_Renumerotation			beq		exit			move.l	PtrSousTitre(a6),a0		; a0 pointe sur le sous-titre en cours			jsr		RenumerotationListeSousTitre															bra		Exit ; il n'a plus assez de mémoire pour insérer un sous-titrebefore_PasSuffisemmentDeMemoire:; faire alerte			clr.w	-(sp)			move.w	#133,-(sp)			clr.l	-(sp)			_Alert			move.w	(sp)+,d0			move.l	#-1,d0		; code erreur => d0Exit	;  il faut invalider le cache du conversion num pointeur		clr.l	G.General_DernierNumConvertiPtr				clr.l	G.Sous_titre_dessined		clr.l	G.Sous_titreInOffscreen		move.w	#1,G.General_SousTitreEnCour		move.l	G.ListingVScroll,-(sp)		move.w	#1,-(sp)		_SetCtlValue		movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)				DbgInfo	Insert_before			; this name will appear in the debugger		align 4			ENDP		-----------------------		* ================================================* PROCEDURE  TransfertStyleTE_Memoire(TEHandle: te,STptr: ptr)* ================================================**	Cette routine transfère les styles et le texte d'un edit record dans un sous-titre en mémoire*				SEG	'Traitement'TransfertStyleTE_Memoire  		PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*					; start parameters after this pointTEHandle		ds.l	1				; handle du te a transférerSTPtr			ds.l	1				; pointeur du sous-titreParamSize		EQU	ParamBegin-*		; size of all the passed parametersRetAddr 		DS.L	1				; place holder for return addressA6Link			DS.L	1				; place holder for A6 linkNbRuns			ds.w	1				; nombre de  runs dans le TENbStyle			ds.w	1				; nombre de ligne dans le TENbLine			ds.w	1				; nombre de ligne dans le TETEStyleRecPtr	ds.l	1				; pointeur du TEStyleRecTEStyleTablePtr	ds.l	1				; pointeur de TEStyleTableLHTablePtr		ds.l	1				; pointeur du TELHTableStyle_Lenth		ds.l	1				; longueur du styleTexteBuff		ds.b	255				; sauvegarde du commentaireStScrapHandle	ds.l	1				; handle du Style scrapLocalSize		EQU 	*				; size of all the local variables		ENDR			with	SOUSTITRERECORD,StackFrame,AppGlobals				link	a6,#LocalSize			import	ConversionNumeroSTPointeur,EcarteSousTitre				movem.l	d0-d7/a0-a4,-(sp)			clr.w	nbLine(a6)			clr.w	NbRuns(a6)			clr.w	NbStyle(a6)			clr.l	Style_Lenth(a6)			clr.l	TEStyleRecPtr(a6)			clr.l	TEStyleTablePtr(a6)			clr.l	LHTablePtr(a6)			; on recherche les parramètres nRuns,nLines,nStyle						 			move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle			move.w	TeNlines(a0),NbLine(a6)			; nombre de ligne dans le TE						; on compte lenombre de ligne; on ne peut pas utiliser la variable TENLines ; dans le  te car elle enlève une ligne si cr à la fin seul sur une ligne; il faut compter à la main 			move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle			move.l	teTextH(a0),a1					move.l	(a1),a1				; handle			move.w	teLength(a0),d0			beq.s	Got_numberofline	; iln'y a pas de ligne			move.w	d0,d2			subq	#1,d2			moveq	#1,d0		Line_Count_loop			move.b	(a1)+,d1			cmp.b	#$0d,d1				; carriage return			bne.s	L_C_1			addq.l	#1,d0L_C_1		dbra	d2,Line_Count_loop			; on à le nombre deligne dans d0Got_numberofline			move.l	STPtr(a6),a1			move.w	d0,st_NLines(a1)				move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle						move.w	teSize(a0),d0			cmp.w	#-1,d0			beq		StyleEditRec			; ce n'est pas un edit record "stylé"; donc on RAZ le style ptr et lenthPasStyle_dansleTe			move.l	STPtr(a6),a0			clr.l	st_StylePtr(a0)			clr.l	st_StyleLenth(a0)						move.l	TeHandle(a6),a0			move.l	(a0),a4				; c'est un handle						moveq	#0,d0			move.w	teLength(a4),d0			bra		sauvegardeChaineDecommentaire   ; ok c'est un "styled" TE on y vaStyleEditRec			move.l	teFont(a0),a0	; handle du TEstyleRec			move.l	(a0),a0			; handle						move.l	a0,TEStyleRecPtr(a6)	; pointeur du TEStyleRec			move.w	nRuns(a0),nbRuns(a6)	; nombre de runs			move.w	nStyles(a0),nbStyle(a6)	; nombre de Style; on calcule la taille de mémoire nécessaire pour stocker le style; stylelenth= 2+20scrpNStyles		; on selectionne tous le texte						move.l	#0,-(sp)			move.l	#32767,-(sp)			move.l	TEHandle(a6),-(sp)			_TeSetSelect			clr.l	-(sp)			move.l	TEHandle(a6),-(sp)					move.w	#6,-(sp)		;	_GetStylScrap			_TEDispatch			move.l	(sp)+,d0			; on teste s'il y a un style handle						beq		PasStyle_dansleTe						move.l	d0,a0			move.l	a0,StScrapHandle(a6)			; on récupère la taille du handle									move.l	StScrapHandle(a6),a0			_GetHandleSize			tst.l	d0			bmi		PasStyle_dansleTe			move.l	d0,Style_Lenth(a6)					; on sauvegarde la chaine de commentaire	; si elle existe bien sûr …sauvegardeChaineDecommentaire			clr.w	TexteBuff(a6)						move.l	STPtr(a6),a0						tst.l	st_CommentaireLenth(a0)			beq.s	pasCommentaireAsauver						move.l	st_CommentaireLenth(a0),d0			lea.l	TexteBuff(a6),a1			move.b	d0,(a1)+			move.l	st_CommentairePtr(a0),a0			_BlockMove			pasCommentaireAsauver; on écarte maintemant le sous-titre pour que tout cela rentre; on calcule la longueur de la zone mémoire nécessaire						move.l	stPtr(a6),a0			move.l	TeHandle(a6),a1			move.l	(a1),a1				; c'est un handle			moveq	#0,d0			move.w	teLength(a1),d0		; taille du texte			import	AligneD0			jsr		AligneD0			move.l	Style_Lenth(a6),d1	; taille du style			import	AligneD1			jsr		AligneD1			add.l	d1,d0				; texte + style						move.b	TexteBuff(a6),d1	; taille du commentaire			and.l	#$ff,d1			add.l	d1,d0; on rajoute 16 pour prévenir un débordement sur le sous titre suivant (pour les alignements)			add.l	#16,d0				; en réserve pour l'instant 			; on calibre la longueur du sous-titre 					import	EcarteSousTitre			jsr		EcarteSousTitre				; on recopie le texte dans le sous-titre						move.l	TeHandle(a6),a0			move.l	(a0),a4				; c'est un handle						moveq	#0,d0			move.w	teLength(a4),d0			bne		RecopieTexte					;il n'y a pas de texte => donc pas de style (normal non ?)			move.l	stPtr(a6),a0			clr.l	st_texteLenth(a0)			clr.w	st_Nlines(a0)			clr.l	st_StyleLenth(a0)			clr.l	st_StylePtr(a0)			bra		RecopieCommentaireRecopieTexte					move.l	tetextH(a4),a0			move.l	(a0),a0			;handle; on recopie le texte dans le st			move.l	stPtr(a6),a1			move.l	d0,st_TexteLenth(a1)						move.l	#st_SizeoF,d1			adda.l	d1,a1						_BlockMove			; on va placer les styles mais on regarde si c'est un TE styled									move.l	TEHandle(a6),a0			move.l	(a0),a0			; handle			move.w	teSize(a0),d0			cmp.w	#-1,d0			bne		RecopieCommentaire				; on place le style dans le sous-titre  ; on calcule le pointeur du style						move.l	STPtr(a6),a0			move.l	#st_SizeOf,d0			add.l	st_TexteLenth(a0),d0			import	AligneD0			jsr		AligneD0			move.l	a0,a4			add.l	d0,a4		; a4 = pointeur du début dela zone style aligne dc.l		 			; on place le pointeur et la longueur dans le sous-titre						move.l	a4,st_StylePtr(a0)			move.l	Style_Lenth(a6),d0			move.l	d0,st_StyleLenth(a0)			; on recopie le TE Style Scrap			move.l	StScrapHandle(a6),a0			move.l	(a0),a0		; handle	=> ptr dans a0			move.l	a4,a1		; adresse de destination			add.l	d0,a4		; pointeur sur prochaine case libre après styl			move.l	Style_Lenth(a6),d0			_BlockMove; on rend la mémoire du handle			move.l	StScrapHandle(a6),a0			_disposHandle			; on recopie le commentaire s'il existeRecopieCommentaire			tst.b	TexteBuff(a6)			beq.s	Exit			; il n'y en a pas donc c'est fini				; on calcule le pointeur de la chaine de commentaire						move.l	stPtr(a6),a2			move.l	a2,a1			move.l	st_TexteLenth(a2),d0			add.l	#st_SizeOF,d0			import	AligneD0			jsr		AligneD0	; longueur texte aligné dc.l; 								move.l	st_StyleLenth(a2),d1			import	AligneD1			jsr		AligneD1	; longueur styles dc.l			add.l	d1,d0			; 						adda.l	d0,a1			move.l	a1,st_CommentairePtr(a2)	; pointeur de la chaine de commentaire						lea		TexteBuff(a6),a0		; chaine de caractères sauvegardée			moveq	#0,d0			move.b	(a0)+,d0			move.l	d0,st_CommentaireLenth(a2)			_blockMove			exit		move.l	stPtr(a6),a0						movem.l	(sp)+,d0-d7/a0-a4			UNLK	A6			MOVEA.L	(SP)+,A0		; save the caller's address			ADDA.L	#ParamSize,SP		; strip the caller's parameters			JMP	(A0)									DbgInfo.New	TransfertStyleTE_Memoire			align 4				ENDP* ================================================* PROCEDURE TransfertTE_Memoire(te: handle,num sous-titre: absNum,item : st item); * ================================================*	* Cette routine transfert le contenu du te dans la liste des sous-titres* en fonction 					SEG	'Traitement'TransfertTE_Memoire 	PROC	EXPORTStackFrame		RECORD	{A6Link},DECR		; build a stack frame recordParamBegin		EQU	*						; start parameters after this pointTEHandle		ds.l	1					; handle du teNum				ds.l	1					; abs num du sous-titreItem			ds.w	1					; item du sous-titreParamSize		EQU	ParamBegin-*			; size of all the passed parametersRetAddr 		DS.L	1					; place holder for return addressA6Link			DS.L	1					; place holder for A6 linkpointeur		ds.l	1Commentaire		ds.b	256buffer			ds.b	64rectangle		ds		rectCarriageReturn	ds.w	1ThePort			ds.l	1LocalSize		EQU 	*					; size of all the local variables				ENDR							IMPORT	AdjustMenus,Terminate,DoGrowWindow,DoZoomWindow,DrawWindow, \					ControlActionProc,DrawListingWindow, \					SpecialThumbControlActionProc,AFFICHENUMSAISIE,SelectWindow,\					TransfertMemoireSaisie,TransfertSaisieMemoire,ConversionNumeroSTPointeur							WITH	StackFrame,EventRecord,soustitrerecord,AppGlobals	; cover our local stack frame			link	a6,#LocalSize						movem.l	d1-d7/a1-a4,-(sp)									move.l	num(a6),d0			jsr		ConversionNumeroSTPointeur			move.l	a0,pointeur(a6)						pea		thePort(a6)			_GetPort			; sauvegarde du port en cours						move.w	Item(a6),d0			case#.w	(d0,if),\			(Texte_SousTitre,copieTexte),\			(TimecodeIn_SousTitre,TcodeIn),\			(TimecodeOut_SousTitre,TcodeOut),\			(Duree_SousTitre,Chaine_Duration),\ 			(Commentaire_SousTitre,Chaine_Commentaire)					bra		Exit; --------------------------------------Chaine_Duration		move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0;		beq		Exit				; pour l'instant on ne change rien; on recopie la chaîne de caractères		lea.l	Commentaire(a6),a1		move.b	d0,(a1)+				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove		; on converti la chaine en time code		lea.l	Commentaire(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine durée pas valide				import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode			move.l	d0,d7				lea.l	Commentaire(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Commentaire(a6),a0		moveq	#0,d0		move.l	a0,a1		add.l	#4,a1		move.l	a1,-(sp)		move.l	#7,-(sp)		move.l	TEHandle(a6),-(sp)		_teSetText		move.l	pointeur(a6),a0		move.l	st_timeCodein(a0),d2		move.l	st_timeCodeOut(a0),d3				cmp.l	#-1,d2			bne.s	calculeTcout	; tc in valide		cmp.l	#-1,d3		beq 	Exit					; tc out valide tc in pas valide; on peut calculer tcin = tc out - durée		move.l	d3,d0		move.l	d7,d1		import	SOUSTRACTIONTIMECODE		jsr		soustractionTimeCode		move.l	pointeur(a6),a0		move.l	d0,st_timeCodein(a0)		bra		Exit		; autre cas on calcule le tc outcalculeTcout		move.l	d2,d0		move.l	d7,d1		import	AdditionTimeCode		jsr		additionTimeCode		move.l	pointeur(a6),a0		move.l	d0,st_timeCodeout(a0)		bra		Exit;--------Chaine_Commentaire		; on commence par recopier le texte du te dans un buffer		move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		; longueur du commentaire; 		beq		Exit				; pour l'instant on ne change rien: il n'y a pas de commentaire				cmp.l	#255,d0		blo.s	PasSup255Commentaire		move.l	#255,d0		PasSup255Commentaire				lea.l	Commentaire(a6),a1		move.b	d0,(a1)+				; a1 pointe sur le 1er caractère				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove		; on calcule maintenant l'espace nécessaire dans le sous-titre pour stocker la chaîne de commentaire		lea.l	Commentaire(a6),a1		move.b	(a1),d0		; longueur du commentaire		and.l	#$ff,d0		move.l	pointeur(a6),a0		add.l	st_TexteLenth(a0),d0	;longueur du texte		add.l	st_StyleLenth(a0),d0	;Longueur du style		add.l	#16,d0		; en reserve; on calibre la longueur du sous-titre 		; a0 ptr st, d0 longueur demandée				import	EcarteSousTitre		jsr		EcarteSousTitre	; on calcule le pointeur du commentaire		move.l	pointeur(a6),a2		move.l	a2,d1				add.l	#st_SizeOf,d1			; taille du header		add.l	st_TexteLenth(a2),d1	; taille du texte			import	AligneD1		jsr		AligneD1				; premier alignement		add.l	st_StyleLenth(a2),d1	; longueur du style		add.l	#4,d1					; 4 octets de séparations		import	AligneD1		jsr		AligneD1				move.l	d1,st_CommentairePtr(a2)	; pointeur du commentaire		move.l	d1,a1				lea		commentaire(a6),a0		; chaine de caractères sauvegardé		moveq	#0,d0		move.b	(a0)+,d0				; longueur du commentaire; et ptr chaine +1 (str 255 !)		move.l	d0,st_CommentaireLenth(a2)				_blockMove						; on recopie le commentaire		bra		Exit		; -------------------------------------------------------		TcodeIn; on commence par recopier le texte du te dans un buffer		move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		beq		TCinVide								lea.l	Commentaire(a6),a1		move.b	d0,(a1)+				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove		; on converti la chaine en time code		lea.l	Commentaire(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine in non valide		import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		bra.s	pasTCinVide; --TCinVide		moveq.l	#-1,d0pasTCinVide		move.l	pointeur(a6),a0		move.l	d0,st_timeCodeIn(a0)		lea.l	Commentaire(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Commentaire(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	TEHandle(a6),-(sp)		_teSetText				bra		Exit; ---------------------------------------------------------------------TcodeOut		move.l	TeHandle(a6),a0		move.l	(a0),a4				; c'est un handle		moveq	#0,d0		move.w	teLength(a4),d0		beq		TCOutVide								lea.l	Commentaire(a6),a1		move.b	d0,(a1)+				move.l	tetextH(a4),a0		move.l	(a0),a0			;handle				_BlockMove		; on converti la chaine en time code		lea.l	Commentaire(a6),a0		import	ConversionchaineASCIITc		jsr		ConversionchaineASCIITc		cmp.l	#-1,d0		beq		Exit		; chaine in valide				import	ConversionTimeCode_Trames		jsr		ConversionTimeCode_Trames		import	ConversionTrames_TimeCode		jsr		ConversionTrames_TimeCode		bra.s	pasTCOutVideTCOutVide		moveq.l	#-1,d0pasTCOutVide				move.l	pointeur(a6),a0		move.l	d0,st_timeCodeOut(a0)		lea.l	Commentaire(a6),a0				import	ConversionTCstASCII		jsr		ConversionTCstASCII				lea.l	Commentaire(a6),a0		moveq	#0,d0		move.b	(a0)+,d0		move.l	a0,-(sp)		move.l	d0,-(sp)		move.l	TEHandle(a6),-(sp)		_teSetText		bra		Exit; -----------------------------------------------------------copieTexte	; nous sommes ici pour recopier le texte	; on commence par recopier la chaine de commentaire dans un buffer, s'il y en a une		move.l	TEHandle(a6),-(sp)		move.l	pointeur(a6),-(sp)		import	TransfertStyleTE_Memoire		;(TEHandle: te,STptr: ptr)			jsr		TransfertStyleTE_Memoire							; -----------------------------------------------------------									Exit		; on update le sous-titres dns la fenêtre listing		move.l		Num(a6),-(sp)		import		DrawSt_enCourDansListing_ByPointeur		jsr			DrawSt_enCourDansListing_ByPointeur	; on le redessine dans listing								; on redessine le suivant si tc out		cmp.w		#TimecodeOut_SousTitre,Item(a6)		bne			SupDernier		move.l		num(a6),d0		addq.l		#1,d0		cmp.l		G.General_NombreST,d0		bhi.s		SupDernier		move.l		d0,-(sp)		import		DrawSt_enCourDansListing_ByPointeur		jsr			DrawSt_enCourDansListing_ByPointeur	; on le redessine dans listingSupDernier								; on regarde si le sous-titre était celui en cour		move.l	num(a6),d0		cmp.w	G.General_sousTitreEnCour,d0		beq.s	EnCour				add.w	#1,d0	; ou bien celui d'après		cmp.w	G.General_sousTitreEnCour,d0		bne.s	PAsEnCour				EnCour				pea		G.DialogSaisie		_SetPort				lea		G.DialogSaisie,a0		pea		PortRect(a0)		_InvalRectPAsEnCour					movem.l	(sp)+,d1-d7/a1-a4		UNLK	A6		MOVEA.L	(SP)+,A0		; save the caller's address		ADDA.L	#ParamSize,SP		; strip the caller's parameters		JMP	(A0)		DbgInfo.new	TransfertTE_Memoire			; this name will appear in the debugger		align 4						ENDP		end	