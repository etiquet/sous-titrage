////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// VEDriverAccess.h//______________________________________________________________________________________________________________________//                                                Copyright (c) 1993//                                   INTELLIGENT RESOURCES INTEGRATED SYSTEMS INC.//                                                All Rights Reserved.////                           This is unpublished work and is the proprietary source code of//                                   INTELLIGENT RESOURCES INTEGRATED SYSTEMS INC.//                                       and should be treated as confidential//______________________________________________________________________________________________________________________//// Author		Date			Description// ------		----			-----------// APJ			01/04/94		Added comments from driver to function prototypes.//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#ifndef	_VEDriverAccess_h_#define	_VEDriverAccess_h_//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////___ Headers to include.//__________________________________________________________#ifndef  _IRIncludes_h_#include "IRIncludes.h"#endif#ifndef __TYPES__#include <Types.h>#endif//	Note: In many of these structures members that appear to be//	booleans are declared as "bitstate". This is because they are in//	fact 4-state variables: false, true, dontChange, and dontKnow.//	Symbols are defined in "VEDriver.h" for these states.typedef short bitstate;// -------------------------------------------------//	Structure Definitions for use in parameter lists// -------------------------------------------------struct VEAddressData {	short		depth;	short		rowBytes;	short		rows;	bitstate	interleaved;};typedef struct VEAddressData VEAddressData;struct VEBankState {	short			bankID;	short			CCCEnable;	short			bankDepth;	unsigned char	CLUTIndexMSBs;	unsigned char	pad1;};typedef struct VEBankState VEBankState;struct VEBankPairState {	short	pairID;	short	pairMode;	short	RGB555LSBs;	short	alphaMode;};typedef struct VEBankPairState VEBankPairState;struct VEBusMuxState {	short	busMux;					// BusMux: { BusMuxVB1, BusMuxVB2 }	short	busCompMask;			// INTEGER: { BusCompMaskA + BusCompMaskB + BusCompMaskC + BusCompMaskD }	short	channel;				// ChannelID: { memBankChannel, DYUVdecoderChannel, ABdecoderChannel, CDdecoderChannel }};typedef struct VEBusMuxState VEBusMuxState;struct VEDYUV8State {	short		bankID;					// BankID: { NoBank, BankA, BankB, BankC, BankD }	short		yLUT;					// Ptr: NIL, or pointer to 16 byte y LUT	short		uvLUT;					// Ptr: NIL, or pointer to 16 byte uv LUT	bitstate	interpolate;			// BitState:  enable chrominance interpolation};typedef struct VEDYUV8State VEDYUV8State;struct VEControlState {	short	control;					// ControlID:	short	priority;					// priority	short	channel;					// ChannelID:};typedef struct VEControlState VEControlState;struct VEChannelColorState {	short			channel;			// ChannelID: display source	short			colorFormat;		// Color24, Color24fromAlpha, Color24fromRed, Color24fromGreen, Color24fromBlue	unsigned long	color;				// RGB8888 color};typedef struct VEChannelColorState VEChannelColorState;struct VEAlphaDisplaySource {	short	channel;	short	theDefault;};typedef struct VEAlphaDisplaySource VEAlphaDisplaySource;struct VECaptureState {	short	box;							// CaptureBox1	short	captureEnables;					// BusCompMask: { A + B + C + D }	short	captureRectID;					// currently unused, set to zero	Rect	captureRect;					// QuickDraw rect	short	captureChannel;					// capture source	short	captureFormat;					// Capture32Bits, CaptureRGB555, CaptureYCcEvenPixelCc,											// CaptureYCcAveragePixelCc, CaptureAlphaToComponents,											// CaptureRedToComponents, CaptureGreenToComponents, CaptureBlueToComponents	short	captureStart;					// startOdd, startEven, startNext, startNow	long	captureLength;					// captureField, captureFrame, captureContinuous	Boolean	waitTillDone;					// If true, wait till done capturing};typedef struct VECaptureState VECaptureState;struct VEClockState {	short	chroma;				// enable the chroma clock output	short	square;				// convert the VCO Clock and the Reference Clock from pulses to square waves	short	line;				// enable the shift clock to the line command processor	short	vRAM;				// enable the shift clock to the video memory	short	DCLK;				// drive the clock pins on the digital video ports as outputs	short	PCLK;				// sync the phase clock to input instead of free running};typedef struct VEClockState VEClockState;struct VEClockDivider {	short	divider;			// PixelClkDivider, ChromaClkDivider, VCOClkDivider, ReferenceClkDivider 	long	interval;			// divider value (period of clock)	short	squareClock;		// convert from pulses to square waves (divide by 2)};typedef struct VEClockDivider VEClockDivider;struct VEMasterControl {	bitstate		refresh;		// enables RAM refresh	bitstate		transfer;		// enables Transfer Cycles to video RAM	bitstate		interrupt;		// master interrupt enable for the entire board};typedef struct VEMasterControl VEMasterControl;struct VEInterruptStates {	bitstate		time;			// Absolute time interrupt	bitstate		pen;			// Light Pen interrupt	bitstate		penTrigger;		// Light Pen trigger interrupt	bitstate		directPen;		// Actual state of pen	bitstate		directTrigger;	// Actual state of trigger};typedef struct VEInterruptStates VEInterruptStates;struct VEInterruptMode{	short	mode;				// InterruptEveryFrame, InterruptEveryField, InterruptEveryLine	Point	where;				// the point on the screen this interrupt is set for};typedef struct VEInterruptMode VEInterruptMode;struct VEHVInterruptMode{	short	mode;				// FreezeHVStatus, ContinuousHVStatus, LightPenHVStatus	Point	where;				// horizontal and vertical coordinates (based on mode)};typedef struct VEHVInterruptMode VEHVInterruptMode;struct VEHVControl {	bitstate		onOff;			// timing sequencer	bitstate		interleave;		// if enabled, generate adjusted clocks};typedef struct VEHVControl VEHVControl;struct VETimeSequencerState {	short		HRAM;			// Address within horizontal display sequencer	short		VRAM;			// Address within vertical display sequencer	short		HCnt;			// Address within horizontal display sequencer	short		VCnt;			// Address within vertical display sequencer	short		HLV;			// Horizontal load value	short		VLV;			// Vertical load value	short		command1;		// H/V command pair	short		command2;	short		commandCount;	// Command pair counter activation value};typedef struct VETimeSequencerState VETimeSequencerState;struct VESyncControl {	short		inputSyncSource;		// SyncFromSame, syncSource0, syncSource1	bitstate	IREclamp;				// if true, IRE clamping in effect	bitstate	interlace;				// if true, sync is interlaced	bitstate	EQAndSer;				// equalization and serration is in effect	bitstate	syncOnVideo;			// if true, sync is output on video signals	bitstate	VBDigital;				// if true, VideoBahn Digital Master	bitstate	VBComposite;			// if true, VideoBahn Composite Master	short		TTLsync;				// TTLsyncSame, TTLsyncOff, TTLsyncHsync, TTLsyncHESsync, TTLsyncComposite12PixelDelay,										// TTLsyncComposite11PixelDelay, TTLsyncComposite10PixelDelay, TTLsyncComposite1PixelDelay,										// TTLsyncCompositeNoPixelDelay};typedef struct VESyncControl VESyncControl;struct VEGenlockControl {	short		genlockControl;			// genlock control word	short		genlockReserved;		// RESERVED (should be zero on input)	short		HorzNoLockThreshold;	// the number of times genlock must miss a horizontal										// frame before search mode begins	short		VertNoLockThreshold;	// the number of times genlock must miss a vertical										// frame before search mode begins	short		hLockAquisitionTime;	// the number of frame locks required before HLockStatus set	bitstate	hLockStatus;			// if true, horizontal lock achieved	bitstate	vLockStatus;			// if true, vertical lock achieved	bitstate	singleHSSmode;			// if true, only one horizontal start sync command can be issued};typedef struct VEGenlockControl VEGenlockControl;struct VEBankConfiguration {	short		ConcatenateMode;		// Bank concatenation mode	bitstate	ABInterleaving;			// 8  bit interleave, only valid for some configs	bitstate	CDInterleaving;			// 8  bit interleave, only valid for some configs	bitstate	ABCDInterleaving;		// 16 bit interleave, only valid for some configs};typedef struct VEBankConfiguration VEBankConfiguration;#define BankAttributeRecord_size		8struct BankAttributeRecord {	short		bankID;	short		attributeID;			// attributeID: { BankDisplayOffset | BankDisplayZoom | BankDisplayMosaic }	Point		attribute;				// BankDisplayOffset | BankDisplayZoom | BankDisplayMosaic};typedef struct BankAttributeRecord BankAttributeRecord;struct VEBankDisplayAttributes {	long					numRecs;			// number of records	BankAttributeRecord		theAttributes[12];	// the actual data (max of 4 banks * 3 attributes)};typedef struct VEBankDisplayAttributes VEBankDisplayAttributes;struct VEVDESyncLoadState {	bitstate		multiplier;					// if true, multiplier control registers are loaded synchronously	bitstate		evenMultConstants;	bitstate		oddMultConstants;	bitstate		CLUTMatrixOffset;	bitstate		defaultDisplayChannel;	bitstate		captureDataSourceFormat;	bitstate		evenFieldSync;	bitstate		oddFieldSync;};typedef struct VEVDESyncLoadState VEVDESyncLoadState;struct VEVSCSyncLoadState {	bitstate		bankOffsets;	bitstate		bankZooms_Mosaics;	bitstate		captureBankEnables;	bitstate		reserved;	bitstate		captureWindow;	bitstate		rectangles;	bitstate		busMux_bankDepth;	bitstate		CLUTOffsets;	bitstate		lineControl_priority;	short			syncLoadMode;			// evenFieldEndOfBlanking, evenFieldEndOfSync, oddFieldEndOfBlanking											// oddFieldEndOfSync, noSyncLoad, evenOddEndOfBlanking,											// evenOddEndOfSync};typedef struct VEVSCSyncLoadState VEVSCSyncLoadState;struct VEHWStatus {	short		VSCVersion;	short		VDEVersion;	short		NICVersion;	bitstate	EEPROMStatus;			// if true, EEPROM is present and functional	bitstate	videoSets;				// if true, 2 sets of video RAM are present else only 1	bitstate	vmemType;				// if true, 1 or 2MByte devices are used else 4MByte	long		InputModuleStatus;	long		lightPenStatus;			// currently unused and zero	long		outputModuleStatus;		// Returns the output module ID in LSByte	long		displayCardStatus;		// Returns the default start ID in 31:24, Serial Number in 23:0	long		displayCardSignature;	// Returns the main card Signature ( board type )};typedef struct VEHWStatus VEHWStatus;struct VEDVPState {	short		port;					// digitalVideoPort1, digitalVideoPort2	bitstate	inputEnable;			// if True, port is enabled for input	bitstate	outputEnable;			// if True, port is enabled for output	short		channel;				// memBankChannel, DYUVEecoderChannel, ABdecoderChannel, CDdecoderChannel	long		DVPWriteValue;			// DVP write register value	long		DVPReadValue;			// value read from DVP	};typedef struct VEDVPState VEDVPState;struct VEMultiplierConstants {	short		multiplierID;			// multiplier1	short		arraySelect;			// access to the odd and/or even array	void		*arrayPtr;				// Pointer to array of Fixed multiplier constants	Rect		arrayBounds;			// QuickDraw rect (sizes array)};typedef struct VEMultiplierConstants VEMultiplierConstants;struct VEMultiplierState {	short		multiplierID;			// multiplier1	short		channel;				//	short		busComp;				// busCompA, busCompB, busCompC, busCompD	short		multiplierMode;			// 	short		filterTaps;				// 9 or 18	short		clampedBits;			// 8 or 16	bitstate	CLUT2Override;			// if True, even multiplier output overrides CLUT2	short		multiplexMode;			// dependent, independent};typedef struct VEMultiplierState VEMultiplierState;struct VEMultiplierSigns {	short		multiplierID;			// multiplier1	short		signType;				// BlendInputSigns, TransformInputSigns, MultiplierOutputSigns, PartialSumOutputSign	short		arraySelect;			// access to the odd and/or even array	void		*arrayPtr;				// Pointer to word array of multiplier signs	Rect		arrayBounds;			// QuickDraw rect (sizes array)};typedef struct VEMultiplierSigns VEMultiplierSigns;struct VEICFState {	Fixed		ICFScaleFactor;			// 16.16 value. 2.7 useable bits	Fixed		blendRatioTotal;		// 16.16 value. 3.7 useable bits	Fixed		blendRatioRate;			// 16.16 value. 3.9 useable bits};typedef struct VEICFState VEICFState;struct VENoiseState {	short		channel;				// videoBus2Channel, liveDigitalInChannel, monochrome8BitNoise, color24BitNoise	short		busComp;				// busCompA, busCompB, busCompC, busCompD	short		syncMode;				// nonSyncNoise, frameSyncNoise	short		taps;					// 13, 19 (repeat every 8,191 values, or every 524,287 values)	short		bits;					// 7, 8 (7-bit noise, or 8-bit noise)};typedef struct VENoiseState VENoiseState;struct VECLUTState {	short			CLUTID;				// CLUT1, CLUT2	short			CLUTMode;	unsigned short	mixRatio;			// $FFFF is 100%	short			channel;			// videoBus2Channel, multiplierOutChannel	short			busComp;			// busCompA, busCompB, busCompC, busCompD};typedef struct VECLUTState VECLUTState;struct VECLUTMatrixState {	short		CLUTID;					// CLUT1, CLUT2	short		size;					// MatrixSize16, MatrixSize32	Point		start;					// QuickDraw point};typedef struct VECLUTMatrixState VECLUTMatrixState;struct VEXEntryRecord {	void		*csTable;				// Pointer to an array of color specs	short		csStart;				// Which spec in array to start with, or -1	short		csCount;				// Number of color spec entries to set	short		CLUTID;					// CLUT1, CLUT2	short		csCLUTMode;};typedef struct VEXEntryRecord VEXEntryRecord;struct VEThresholderState {	short			thresholderID;		// thresholder1	unsigned long	loColor;			// RGB888	unsigned long	hiColor;			// RGB888	short			dim;				// number of elements of the sign bit array	void			*compMasks;			// pointer to the array to be read from	short			colorFormat;		// color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue	short			transitionMode;		// transitionInactive, transitionInside, transitionOutside, transitionInsideAndOutside};typedef struct VEThresholderState VEThresholderState;struct VERectangleState {	short		rectangleID;			// rectangle1, rectangle2, rectangle3, rectangle4	Rect		bounds;					// QuickDraw rect	short		control;				// define active region};typedef struct VERectangleState VERectangleState;struct VELineControl {	short		mode;					// lineControlOff, activeLineControl, preScanLineControl, activeAndPreScanLineControl	Rect		theRect;				// defines the region, in lines and commands	void		*commands;				// Ptr: pointer to raw or pseudo line control commands};typedef struct VELineControl VELineControl;struct VEPixelState {	short		pixelSelect;			// PixelSelect0, PixelSelect1	short		multiplierID;			// multiplier1	short		multiplierColumn;		// Column affected (1..3) (also called multiplier source)	short		multiplierChannel;		// inputModuleChannel, liveDigitalInChannel, videoBus1Channel, videoBus2Channel, CLUT1Channel, CLUT2Channel, multiplierOutChannel, liveDigitalInAlpha_partialSum16Channel	short		thresholderID;			// thresholder1	short		thresholderChannel;		// inputModuleChannel, liveDigitalInChannel, videoBus1Channel, videoBus2Channel, CLUT1Channel, CLUT2Channel, multiplierOutChannel, liveDigitalInAlpha_partialSum16Channel	short		colorFormat;			// Color24, Color24fromAlpha, Color24fromRed, Color24fromGreen, Color24fromBlue	Fixed		pixelICF;				// 16.16 value. 1.7 useable bits};typedef struct VEPixelState VEPixelState;struct VEPixelControl {	short		mode;					// PixelControlMode: { pixelIs8BitICF, pixelIs4BitDisplayChannel4BitPriority,										// pixelIs7BitICF1BitChoiceControl,pixelIs8BitChoiceControl,										// pixelIsCaptureAndShiftControl}	short		source;					// ICFSource: { ICFSourceFromPixelControl, ICFSourceFromNoise }	short		signState;				// if true ICF is 8 bit signed value -0.9999 to 0.9999										// if false ICF is 8 bit value 0 to 1.9999	short		ICFScaleSource;			// ICFScaleFactorSource: { ICFscaleFactorFromRegister, ICFscaleFactorFromPixelControl, ICFscaleFactorFromNoise }};typedef struct VEPixelControl VEPixelControl;struct VEPixelNoiseControl {	short		noiseBits;				// 8-bit noise, or 9-bit noise	bitstate	signedNoise;			// if true noise is signed	bitstate	synchronous;			// if true noise is synchronous to a frame};typedef struct VEPixelNoiseControl VEPixelNoiseControl;struct VESerialState {	bitstate	IMDOutputEnable;		// if True, enables IMD as output	bitstate	IMCOutput;				// output bit	bitstate	IMIOutput;				// output bit	bitstate	IMDOutput;				// output bit	bitstate	IMDInput;				// input bit};typedef struct VESerialState VESerialState;// --------------------------------------------------------------////	The interfaces are organized by Inside Video Explorer chapter.////	In general, they are defined as VEGetxxx/VESetxxx pairs.//// --------------------------------------------------------------#ifdef __cplusplusextern "C" {#endif////	Video Memory Configuration//	/********************************************************	This routine gets the way video memory is addressed by the Macintosh CPU.	Note that there are only three categories of depths used. One is CLUT	mode which is for 1, 2, 4, and 8 bits per pixel, the other is 16 bit	direct, the third is 32 bit direct. In the case of CLUT mode, a value of	of 1 is returned.		cs parameter record:		depth		- word: pixel depth { 1/2/4/8, 16, 32 }		rowBytes	- word: hardware row bytes { 1K, 2K, 4K }		rows		- word: rows { 512, 1K, 2K, 4K, 8K }		interleaving	- bitstate: for double plane interleaving	********************************************************/pascal short VEGetMemoryAddressing(short		theDriver,		// which driver (card)								   short*		depth,			// pixel depth { 1, 2, 4, 8, 16, 32 }								   short*		rowBytes,		// hardware row bytes { 1K, 2K, 4K }								   short*		rows,			// rows { 512, 1K, 2K, 4K, 8K }								   bitstate*	interleaved); 	// double plane interleaving	/********************************************************	This routine sets the way video memory is addressed by the Macintosh CPU.		NOTE: See the routines SetMemoryBankConfiguration, SetBusMuxChannel,	and SetBankState to control how memory is addressed and decoded by	the Video Explorer.		cs parameter record:		depth		-> word:	pixel depth { 1, 2, 4, 8, 16, 32 }		rowBytes	-> word:	hardware row bytes { 1K, 2K, 4K }		rows		-> word:	rows { 512, 1K, 2K, 4K, 8K }		interleaving	-> BitState:	for double plane interleaving	********************************************************/pascal short VESetMemoryAddressing(short		theDriver,		// which driver (card)								   short		depth,			// pixel depth { 1, 2, 4, 8, 16, 32 }								   short		rowBytes,		// hardware row bytes { 1K, 2K, 4K }								   short		rows,			// rows { 512, 1K, 2K, 4K, 8K }								   bitstate	interleaved);	// double plane interleaving	/********************************************************	This routine gets the X and Y offset of where the Macintosh addresses	pixel 0,0. This can be used to get the offset QuickDraw uses to draw	to the screen. Normally QuickDraw should have an offset of (0,0).		NOTE: Call VEGetBankDisplayAttributes to get the display offset.		cs parameter record:		offset		- point:	X and Y offset of where the Macintosh						addresses pixel 0,0	********************************************************/pascal short VEGetPhysicalMemoryOffset(short	theDriver,		// which driver (card)									   Point*	theOffset);	/********************************************************	This routine sets the X and Y offset of where the Macintosh addresses	pixel 0,0. This can be used for offsetting where QuickDraw draws to	the screen.		NOTE: Call VESetBankDisplayAttributes to control the display offset.		cs parameter record:		offset		-> point:	X and Y offset of where the Macintosh						addresses pixel 0,0	********************************************************/pascal short VESetPhysicalMemoryOffset(short	theDriver,		// which driver (card)									   Point	theOffset);	/********************************************************	Get the NuBus memory write protect mask.		cs parameter record:		mask		- long:	32 bit mask	********************************************************/pascal short VEGetMemoryProtectMask(short	theDriver,			// which driver (card)									long*	theMask);	/********************************************************	Set the NuBus memory write protect mask.		cs parameter record:		mask		-> long:	32 bit mask	********************************************************/pascal short VESetMemoryProtectMask(short	theDriver,			// which driver (card)									long	theMask);////	Video Memory Decoder//	/********************************************************	Get the CCC enables and depth for a bank. If bank "noBank" is	specified, nothing is returned.		cs parameter record:		bankID		-> BankID:	{ noBank, bankA, bankB, bankC, bankD }		CCCEnable	<- BitState:	CCCEnable state		bankDepth	<- word:	{ 1, 2, 4, 8 }		CLUTIndexMSBs	<- byte:	most significant bits for depth<8 [bits left justified]	********************************************************/pascal short VEGetBankState(short			theDriver,			// which driver (card)							VEBankState*	theState);	/********************************************************	Set the CCC enables and depth for a bank. In the event that the bank "noBank"	is specified, nothing is changed.		cs parameter record:		bankID		-> BankID:	{ noBank, bankA, bankB, bankC, bankD }		CCCEnable	-> BitState:	CCCEnable state		bankDepth	-> word:	{ 1, 2, 4, 8 }		CLUTIndexMSBs	-> byte:	most significant bits for depth<8 [bits left justified]	********************************************************/pascal short VESetBankState(short			theDriver,			// which driver (card)							short			bankID,				// which bank							short			bankDepth,			// 1, 2, 4, 8							Byte			CLUTIndexMSBs);		// most significant bits for depth<8	/********************************************************	Get AB/CD decoder mode.		cs parameter record:		pairID		-> PairID:	{ pairAB, pairCD }		pairModes	<- PairMode:	{ pairModeRGB555, pairModeYCc, pairModeCCC4 }		RGB555LSBs	<- word:	RGB555 LSBs		alphaMode	<- AlphaMode:	{ alphaBitNotUsed, alphaBitIsGreen, alphaBitIsSavedThresholder, alphaBitIsSourceEnable }	********************************************************/pascal short VEGetPairDecoder(short 			theDriver,			// which driver (card)							  VEBankPairState*	thePairState);	/********************************************************	Set AB/CD decoder mode.		cs parameter record:		pairID		-> PairID:	{ pairAB, pairCD }		pairModes	-> PairMode:	{ pairModeRGB555, pairModeYCc, pairModeCCC4 }		RGB555LSBs	-> word:	if pairModes=pairModeRGB555	 RGB555 LSBs		alphaMode	-> AlphaMode:	if pairModes=pairModeRGB555	 { alphaBitNotUsed, alphaBitIsGreen,						alphaBitIsSavedThresholder, alphaBitIsSourceEnable }	********************************************************/pascal short VESetPairDecoder(short 			theDriver,			// which driver (card)							  VEBankPairState	thePairState);	/********************************************************	Get AB/CD decoder mode.		cs parameter record:		pairID		-> PairID:	{ pairAB, pairCD }		pairModes	<- PairMode:	{ pairModeRGB555, pairModeYCc, pairModeCCC4 }		RGB555LSBs	<- word:	RGB555 LSBs		alphaMode	<- AlphaMode:	{ alphaBitNotUsed, alphaBitIsGreen, alphaBitIsSavedThresholder, alphaBitIsSourceEnable }	********************************************************/pascal short VEGetPairDecoderMode(short		theDriver,			// which driver (card)								  short		thePair,			// PairID: { PairAB, PairCD }								  short*	theMode);			// PairMode: { PairModeRGB555, PairModeYCc, PairModeCCC4 }							 	/********************************************************	Get the CCC enables and depth for a bank. If bank "noBank" is	specified, nothing is returned.		cs parameter record:		bankID		-> BankID:	{ noBank, bankA, bankB, bankC, bankD }		CCCEnable	<- BitState:	CCCEnable state		bankDepth	<- word:	{ 1, 2, 4, 8 }		CLUTIndexMSBs	<- byte:	most significant bits for depth<8 [bits left justified]	********************************************************/pascal short VEGetBankDepth(short	theDriver,					// which driver (card)							short	theBank,					// BankID { NoBank, BankA, BankB, BankC, BankD }							short*	theDepth);					// 1, 2, 4, 8	/********************************************************	Set the CCC enables and depth for a bank. In the event that the bank "noBank"	is specified, nothing is changed.		cs parameter record:		bankID		-> BankID:	{ noBank, bankA, bankB, bankC, bankD }		CCCEnable	-> BitState:	CCCEnable state		bankDepth	-> word:	{ 1, 2, 4, 8 }		CLUTIndexMSBs	-> byte:	most significant bits for depth<8 [bits left justified]	********************************************************/pascal short VESetBankDepth(short	theDriver,					// which driver (card)							short	theBank,					// BankID: { NoBank, BankA, BankB, BankC, BankD }							short	theDepth);					// 1, 2, 4, 8	/********************************************************	Get video bus source channel. Note that video bus 1 has all components	controlled by a given channel, where as video bus 2 can have each	component set to a different channel.		Channels returned for video bus 1: memBank, DYUVdecoder, ABdecoder, CDdecoder	Channels returned for video bus 2 components BCD: memBank, CCC2decoder, DYUVdecoder, ABdecoder	Channels returned for video bus 2 component  A  : memBank, CCC2decoder		Note: This only returns a single channel, so for videoBus2, only	one bit of busCompMask should be set. for videoBus1, busCompMask	is ignored.		cs parameter record:		busMux		-> BusMux:	{ VB1, VB2 }		busCompMask	-> BusCompMask:	{ A | B | C | D } [ only used for VB2 ]		channel		<- Channel:	{ MemBank, DYUVdecoder, ABdecoder, CDdecoder, CCC2decoder }	********************************************************/pascal short VEGetBusMuxChannel(short	theDriver,			// which driver (card)								short	theBusMux,			// BusMux { BusMuxVB1, BusMuxVB2 }								short	theComponent,		// BusCompMask { BusCompMaskA, BusCompMaskB, BusCompMaskC, BusCompMaskD }								short*	theChannel);		// ChannelID: { memBankChannel, DYUVdecoderChannel, ABdecoderChannel, CDdecoderChannel }	/********************************************************	Set video bus source channel. Note that video bus 1 has all components	controlled by a given channel, where as video bus 2 can have each	component set to a different channel.		Valid channels for video bus 1: memBank, DYUVdecoder, ABdecoder, CDdecoder	Valid channels for video bus 2 components BCD: memBank, CCC2decoder, DYUVdecoder, ABdecoder	Valid channels for video bus 2 component  A  : memBank, CCC2decoder		An error is returned if the channel passed is not legal for	the bus and components specified.		cs parameter record:		busMux		-> BusMux:	{ VB1, VB2 }		busCompMask	-> BusCompMask:	{ A + B + C + D } [ only used for VB2 ]		channel		-> Channel:	{ MemBank, DYUVdecoder, ABdecoder, CDdecoder, CCC2decoder }	********************************************************/pascal short VESetBusMuxChannel(short	theDriver,			// which driver (card)								short	theBusMux,			// BusMux { BusMuxVB1, BusMuxVB2 }								short	theComponent,		// BusCompMask { BusCompMaskA, BusCompMaskB, BusCompMaskC, BusCompMaskD }								short	theChannel);		// ChannelID: { memBankChannel, DYUVdecoderChannel, ABdecoderChannel, CDdecoderChannel }	/********************************************************	Set the DYUV8 decoder bank and LUTs. In the event that the bank "noBank"	is specified, nothing is changed.		cs parameter record:		bankID		-> BankID:	{ noBank, bankA, bankB, bankC, bankD }		yLUT		-> Ptr:		NIL, or pointer to 16 byte y LUT		uvLUT		-> Ptr:		NIL, or pointer to 16 byte uv LUT		interpolate	-> BitState:	enable chrominance interpolation	********************************************************/pascal short VESetDYUV8Decoder(short	theDriver,				// which driver (card)							   short	theInputBank,			// BankID: { NoBank, BankA, BankB, BankC, BankD }							   char*	theUvLut,				// PTR: NIL, or pointer to 16 byte y LUT							   char*	theYLut,				// PTR: NIL, or pointer to 16 byte uv LUT							   bitstate	theInterpolateFlag);	// enable chrominance interpolation////	Priority Resolver//	/********************************************************	Get the priority of the display control.		cs parameter record:		control		-> ControlID		priority	<- word:	priority	********************************************************/pascal short VEGetPriority(short	theDriver,					// which driver (card)						   short	thePriorityControl,			// control ID						   short*	thePriority);				// priority (0-15)	/********************************************************	Set the priority of the display control. Note that it is not legal	to change the priority of the default control.		cs parameter record:		control		-> ControlID		priority	-> word:	priority	********************************************************/pascal short VESetPriority(short	theDriver,					// which driver (card)						   short	thePriorityControl,			// control ID						   short	thePriority);				// priority (0-15)	/********************************************************	Get the channel of the display control.		cs parameter record:		control		-> ControlID		channel		<- ChannelID: { inputModuleChannel, liveDigitalInChannel, videoBus1Channel, videoBus2Channel,					CLUT1Channel, CLUT2Channel, multiplierOutChannel, defaultColor1Channel, defaultColor2Channel,					liveDigitalInAlphaChannel, videoBus2AlphaChannel, zero_PartialSum16Channel }		Note that you can set the priority for the LineControl, but you cannot	directly set its channel. Instead the channel can be set indirectly	through a line control command.	********************************************************/pascal short VEGetChannel(short		theDriver,					// which driver (card)						  short		thePriorityControl,			// control ID						  short*	theChannel);				// channel ID	/********************************************************	Set the channel of the display control.		Note that you can set the priority for the LineControl, but you cannot	directly set its channel. Instead the channel can be set indirectly	through a line control command.		cs parameter record:		control		-> ControlID:		channel		-> ChannelID: { inputModuleChannel, liveDigitalInChannel, videoBus1Channel, videoBus2Channel,					CLUT1Channel, CLUT2Channel, multiplierOutChannel, defaultColor1Channel, defaultColor2Channel,					liveDigitalInAlphaChannel, videoBus2AlphaChannel, zero_PartialSum16Channel }	********************************************************/pascal short VESetChannel(short	theDriver,					// which driver (card)						  short	thePriorityControl,			// control ID						  short	theChannel);				// channel ID	/********************************************************	This gets the color format for the display source. The format will either	be all 3 components unaltered (24-bits, 8 bits/component), or one of the	components duplicated to the other two components.		NOTE: Use GetThresholderColorFormat for getting the color format of	the RangeThresholder inputs.		cs parameter record:		channel		-> ChannelID: { inputModuleChannel, liveDigitalInChannel, videoBus1Channel,					videoBus2Channel, CLUT1Channel, CLUT2Channel, multiplierOutChannel }		colorFormat	<- ColorFormat: { color24, color24fromRed, color24fromGreen, color24fromBlue }	********************************************************/pascal short VEGetColorFormat(short		theDriver,				// which driver (card)							  short		theChannel,				// channel ID							  short*	theFormat);				// { Color24, Color24fromAlpha, Color24fromRed, Color24fromGreen, Color24fromBlue }	/********************************************************	This sets the color format for the display source. The format will either	be all 3 components unaltered (24-bits, 8 bits/component), or one of the	components duplicated to the other two components.		NOTE: Use SetThresholderColorFormat for setting the color format for	the RangeThresholder inputs.		cs parameter record:		channel		->	ChannelID: { inputModuleChannel, liveDigitalInChannel, videoBus1Channel,						videoBus2Channel, CLUT1Channel, CLUT2Channel, multiplierOutChannel }		colorFormat	->	ColorFormat: { color24, color24fromRed, color24fromGreen, color24fromBlue }	********************************************************/pascal short VESetColorFormat(short	theDriver,				// which driver (card)							  short	theChannel,				// channel ID							  short	theFormat);				// { Color24, Color24fromAlpha, Color24fromRed, Color24fromGreen, Color24fromBlue }	/********************************************************	This gets the display output colors (constant color display sources).		cs parameter record:		channel	-> ChannelID: { defaultColor1Channel, defaultColor2Channel, multiplierDefaultColorChannel }		color	<- long:	RGB888	********************************************************/pascal short VEGetChannelColor(short			theDriver,		// which driver (card)							   short			theChannel,		// channel ID							   unsigned long*	theColor);		// RBG888 format	/********************************************************	This sets the display output colors (constant color display sources).		cs parameter record:		channel	-> ChannelID:	{ defaultColor1Channel, defaultColor2Channel, multiplierDefaultColorChannel }		color	-> long:	RGB888	********************************************************/pascal short VESetChannelColor(short			theDriver,		// which driver (card)							   short			theChannel,		// channel ID							   unsigned long	theColor);		// RBG888 format	/********************************************************	Get the default Alpha Source that the Display Mux should use.		cs parameter record:		channel		- ChannelID: { liveDigitalInChannel, videoBus2Channel, CLUT2Channel}		default		- AlphaDisplayMode: { selectedAlphaChannelMode, associatedAlphaChannelMode}	********************************************************/pascal short VEGetAlphaDisplayChannel(short		theDriver,		// which driver (card)									  short*	channel,		// channel ID									  short*	theDefault);	// selectedAlphaChannelMode, associatedAlphaChannelMode	/********************************************************	Set the default Alpha Source that the Display Mux should use.		cs parameter record:		channel		-> ChannelID: { sameChannel, liveDigitalInChannel, videoBus2Channel, CLUT2Channel}		default		-> AlphaDisplayMode: { selectedAlphaChannelMode, associatedAlphaChannelMode}	********************************************************/pascal short VESetAlphaDisplayChannel(short	theDriver,		// which driver (card)									  short	channel,		// channel ID									  short	theDefault);	// selectedAlphaChannelMode, associatedAlphaChannelMode//// Capture Multiplexer//	/********************************************************	This gets the 32-bit capture color constant.		cs parameter record:		color	<- long:	ARGB8888	********************************************************/pascal short VEGetCaptureColor(short			theDriver,		// which driver (card)							   unsigned long*	theColor);		// RBG888 format	/********************************************************	This sets the 32-bit capture color constant.		cs parameter record:		color		-> long:	ARGB8888	********************************************************/pascal short VESetCaptureColor(short			theDriver,		// which driver (card)							   unsigned long	theColor);		// RBG888 format	/********************************************************	This gets the rectangular capture window.		cs parameter record:		box		-> word:		CaptureBoxID { captureBox1 }		captureRect	<- RECT:		QuickDraw rectangle	********************************************************/pascal short VEGetCaptureWindow(short	theDriver,				// which driver (card)								short	theCaptureBox,			// {capture1}								Rect*	theRect);				// Quickdraw rectangle	/********************************************************	This sets the rectangular capture window.		cs parameter record:		box		-> word:	CaptureBoxID { captureBox1 }		captureRect	-> RECT:	QuickDraw rectangle	********************************************************/pascal short VESetCaptureWindow(short	theDriver,				// which driver (card)								short	theCaptureBox,			// {capture1}								Rect	theRect);				// Quickdraw rectangle	/********************************************************	This gets the channel being captured.		cs parameter record:		box		-> CaptureBoxID: { captureBox1 }		captureChannel	<- ChannelID: { multiplierY_inputModuleChannel, liveDigitalInChannel, partialSumHigh8_multiplierOutChannel,					videoBus2Channel, displayMuxChannel, defaultCaptureColorChannel, partialSum16AR16GBChannel }	********************************************************/pascal short VEGetCaptureChannel(short		theDriver,			// which driver (card)								 short		theCaptureBox,		// {capture1}								 short*		theChannel);		// source channel ID	/********************************************************	This sets the channel being captured.		cs parameter record:		box		-> CaptureBoxID: { captureBox1 }		captureChannel	-> ChannelID: { multiplierY_inputModuleChannel, liveDigitalInChannel, partialSumHigh8_multiplierOutChannel,					videoBus2Channel, displayMuxChannel, defaultCaptureColorChannel, partialSum16AR16GBChannel }	********************************************************/pascal short VESetCaptureChannel(short		theDriver,			// which driver (card)								 short		theCaptureBox,		// {capture1}								 short		theChannel);		// source channel ID	/********************************************************	This gets the capture format.		cs parameter record:		box		-> word:	CaptureBoxID { captureBox1 }		captureFormat	<- CaptureFormat { capture32Bits, captureRGB555, captureYCcEvenPixelCc,						captureYCcAveragePixelCc, captureAlphaToComponents, captureRedToComponents,						captureGreenToComponents, captureBlueToComponents }	********************************************************/pascal short VEGetCaptureFormat(short	theDriver,				// which driver (card)								short	theCaptureBox,			// {capture1}								short*	theCaptureFormat);		// Type CaptureFormat: what format	/********************************************************	This sets the capture format.		cs parameter record:		box		-> word:	CaptureBoxID { captureBox1 }		captureFormat	-> CaptureFormat { capture32Bits, captureRGB555, captureYCcEvenPixelCc,						captureYCcAveragePixelCc, captureAlphaToComponents, captureRedToComponents,						captureGreenToComponents, captureBlueToComponents }	********************************************************/pascal short VESetCaptureFormat(short	theDriver,				// which driver (card)								short	theCaptureBox,			// {capture1}								short	theCaptureFormat);		// Type CaptureFormat: what format	/********************************************************	This sets the capture enable state for each of the memory banks,	and also turns capture off or on for a specified time. If	captureEnables is set to zero, (no banks enabled), then the	other parameters are ignored and capturing is turned off.		NOTE: if the Video Explorer is not in an interlaced mode,	startEven, and startOdd values for captureStart are	essentially ignored and treated as startNext.			cs parameter record:		box		-> CaptureBoxID: { captureBox1 }		captureEnables	-> word:	BusCompMask { A + B + C + D }		captureStart	-> CaptureStart:	{ startEven, startOdd, startNext, startNow }		captureLength	-> CaptureLength:	{ captureField, captureFrame, captureContinuous }		waitTillDone	-> Boolean: If true, wait till done capturing	********************************************************/pascal short VESetCaptureState(short	theDriver,				// which driver (card)							   short	theCaptureBox,			// {capture1}							   short	theEnables,				// { BusCompMaskA + BusCompMaskB + BusCompMaskC + BusCompMaskD }							   short	theCaptureStart,		// startOdd, startEven, startNext							   long		theCaptureLength,		// captureField, captureFrame, captureContinuous							   Boolean	waitTillDone);			// false means immediate return	/********************************************************	This gets the capture enable state for each of the memory banks.		cs parameter record:		box		-> CaptureBoxID: { captureBox1 }		captureEnables	<- word:	BusCompMask { A + B + C + D }	********************************************************/pascal short VEGetBankCaptureEnables(short		theDriver,			// which driver (card)									 short		theCaptureBox,		// {capture1}									 short*	theEnables);		// { BusCompMaskA + BusCompMaskB + BusCompMaskC + BusCompMaskD }////	Clock Control//	/********************************************************	This gets various details about the master clock system		cs parameter record:		chroma	<- BitState:	enable the chroma clock output		square	<- BitState:	convert the VCO Clock and the Reference Clock from pulses to square waves		line	<- BitState:	enable the shift clock to the line command processor		vRAM	<- BitState:	enable the shift clock to the video memory		DCLK	<- BitState:	drive the clock pins on the digital video ports as outputs		PCLK	<- BitState:	sync the phase clock to input instead of free running	********************************************************/pascal short VEGetClockState(short			theDriver,			// which driver (card)							 VEClockState*	theClockState);	/********************************************************	This sets various details about the master clock system		cs parameter record:		chroma	-> BitState:	enable the chroma clock output		square	-> BitState:	convert the VCO Clock and the Reference Clock from pulses to square waves		line	-> BitState:	enable the shift clock to the line command processor		vRAM	-> BitState:	enable the shift clock to the video memory		DCLK	-> BitState:	drive the clock pins on the digital video ports as outputs		PCLK	-> BitState:	sync the phase clock to input instead of free running	********************************************************/pascal short VESetClockState(short			theDriver,			// which driver (card)							 VEClockState*	theClockState);	/********************************************************	Get the source of the master clock signal		cs parameter record:		masterClockSource	- MasterClockSource: { masterClockFromVCO, masterClockFromInputModule, 						masterClockFromReference, masterClockFromDigitalVideoPort }	********************************************************/pascal short VEGetMasterClockSource(short	theDriver,									short*	theSource);	/********************************************************	Set the source of the master clock signal		cs parameter record:		masterClockSource	-> MasterClockSource: { masterClockFromVCO, masterClockFromInputModule, 						masterClockFromReference, masterClockFromDigitalVideoPort }	********************************************************/pascal short VESetMasterClockSource(short	theDriver,									short	theSource);	/********************************************************	Get the programmable divider interval and output mode for one of	the clock dividers.		cs parameter record:		divider		-> ClockDivider: { pixelClockDivider, chromaClockDivider, VCOClockDivider, referenceClockDivider }		interval	<- long: (chromaClockDivider will only be 2,4,6,8,10,12,14,16)		squareClock	<- BitState: Divide by 2 and produce square wave instead of pulse	********************************************************/pascal short VEGetClockDividerInterval(short		theDriver,			// which driver (card)									   short		divider,			// PixelClkDivider, ChromaClkDivider, VCOClkDivider, ReferenceClkDivider 									   long*		interval,			// divider value (period of clock)									   bitstate*	squareClock);		// convert from pulses to square waves (divide by 2)	/********************************************************	Set the programmable divider interval and output mode for one of the clock dividers.	Not all clock dividers have a controllable squareClock. Attempting to	set the output mode on such clock dividers results in an error.		cs parameter record:		divider		-> ClockDivider: { pixelClockDivider, chromaClockDivider, VCOClockDivider, referenceClockDivider }		interval	-> long: (chromaClockDivider may only be 2,4,6,8,10,12,14,16)		squareClock	-> BitState: Divide by 2 and produce square wave instead of pulse	********************************************************/pascal short VESetClockDividerInterval(short	theDriver,			// which driver (card)									   short	divider,			// PixelClkDivider, ChromaClkDivider, VCOClkDivider, ReferenceClkDivider 									   long		interval,			// divider value (period of clock)									   bitstate	squareClock);		// convert from pulses to square waves (divide by 2)////	Absolute Timing//	/********************************************************	Get the master control bits. These control RAM refresh, transfer cycles	to video RAM, and a master interrupt enable.		cs parameter record:		refresh		<- BitState: enables RAM refresh		transfer	<- BitState: enables Transfer Cycles to video RAM		interrupt	<- BitState: master interrupt enable for the entire board	********************************************************/pascal short VEGetMasterControl(short		theDriver,			// which driver (card)								bitstate*	refresh,			// enables RAM refresh								bitstate*	transfer,			// enables Transfer Cycles to video RAM								bitstate*	interrupt);			// master interrupt enable for the entire board	/********************************************************	Set the master control bits. These control RAM refresh, transfer cycles	to video RAM, and a master interrupt enable.		cs parameter record:		refresh		-> BitState: enables RAM refresh		transfer	-> BitState: enables Transfer Cycles to video RAM		interrupt	-> BitState: master interrupt enable for the entire board	********************************************************/pascal short VESetMasterControl(short		theDriver,			// which driver (card)								bitstate	refresh,			// enables RAM refresh								bitstate	transfer,			// enables Transfer Cycles to video RAM								bitstate	interrupt);			// master interrupt enable for the entire board	/********************************************************	Get the rate at which memory is refreshed. The RefreshRate is the product of	15.625µs and the reference clock frequency minus 1.		cs parameter record:		RefreshRate	<- long	********************************************************/pascal short VEGetRefreshRate(short	theDriver,				// which driver (card)							  long*	theRefreshRate);	/********************************************************	Set the rate at which memory is refreshed. The RefreshRate is the product of	15.625µs and the reference clock frequency minus 1.		Note: The maximum legal value is currently $0FFF.		cs parameter record:		RefreshRate	-> long	********************************************************/pascal short VESetRefreshRate(short	theDriver,				// which driver (card)							  long	theRefreshRate);	/********************************************************	Get enable states for the cards interrupts.		cs parameter record:		time		<- BitState: Absolute time interrupt		pen		<- BitState: Light Pen interrupt		pentrigger	<- BitState: Light Pen trigger interrupt	********************************************************/pascal short VEGetInterruptEnables(short		theDriver,			// which driver (card)								   bitstate*	time,				// Absolute time interrupt								   bitstate*	pen,				// Light Pen interrupt								   bitstate*	penTrigger);		// Light Pen trigger interrupt	/********************************************************	Set enable states for the cards interrupts.		cs parameter record:		time		-> BitState: Absolute time interrupt		pen		-> BitState: Light Pen interrupt		PenTrigger	-> BitState: Light Pen trigger interrupt	********************************************************/pascal short VESetInterruptEnables(short	theDriver,			// which driver (card)								   bitstate	time,				// Absolute time interrupt								   bitstate	pen,				// Light Pen interrupt								   bitstate	penTrigger);		// Light Pen trigger interrupt	/********************************************************	This gets the interrupt bits. Although a status call can be made to	the driver with the immediate bit set to get the status of pending	interrupts, this is quite impractical. However, this also returns	the immediate state of the Pen and Pen trigger.		cs parameter record:		time		<- BitState: Absolute time interrupt		pen		<- BitState: Light Pen interrupt		pentrigger	<- BitState: Light Pen trigger interrupt		directPen	<- BitState: Actual state of pen		directTrigger	<- BitState: Actual state of trigger	********************************************************/pascal short VEGetInterruptStatus(short					theDriver,			// which driver (card)								  VEInterruptStates*	theStates);	/********************************************************	This sets the interrupt clear bits. Although a control call can be	made to the driver with the immediate bit set, this is quite impractical.	Application software should not be clearing hardware interrupts. This	call is here solely for completeness.		cs parameter record:		time		-> BitState: Absolute time interrupt		pen		-> BitState: Light Pen interrupt		penTrigger	-> BitState: Light Pen trigger interrupt	********************************************************/pascal short VESetInterruptClears(short		theDriver,			// which driver (card)								  bitstate	time,				// Absolute time interrupt								  bitstate	pen,				// Light Pen interrupt								  bitstate	penTrigger);		// Light Pen trigger interrupt	/********************************************************	Get the frequency of the absolute interrupt. If interrupting	on every line, the vertical interrupt point is not set.		WARNING: This routine is here solely for completeness. The interrupt	mode is controlled by the driver, and should not need to be known by	most applications.		cs parameter record:		mode		<- AbsoluteInterruptMode: { interruptEveryFrame, interruptEveryField, interruptEveryLine }		where		<- Point: the point on the screen this interrupt is set for	********************************************************/pascal short VEGetAbsoluteInterruptMode(short	theDriver,			// which driver (card)										short*	mode,				// FreezeHVStatus, ContinuousHVStatus, LightPenHVStatus										Point*	where);				// horizontal and vertical coordinates (based on mode)	/********************************************************	Set the frequency of the absolute interrupt. If interrupting	on every line, the vertical interrupt point is not set.		NOTE: Interrupt routines should be installed with SIntInstall,	or SlotVInstall.		WARNING: Do not use this call without first disabling video driver	interrupts with the SetInterrupt control call. Beware that cursor	interrupts then becomes disabled for that screen. Also you are taking	your life into your own hands installing your own custom interrupt	routine.		cs parameter record:		mode		-> AbsoluteInterruptMode: { interruptEveryFrame, interruptEveryField, interruptEveryLine }		where		-> Point: the point on the screen this interrupt is set for	********************************************************/pascal short VESetAbsoluteInterruptMode(short	theDriver,			// which driver (card)										short	mode,				// FreezeHVStatus, ContinuousHVStatus, LightPenHVStatus										Point	where);				// horizontal and vertical coordinates (based on mode)	/********************************************************	Get the mode for how the horizontal and vertical status counters	are updated. Also, get the counter values.		Note: The where field only returns legal values for the counters	if the mode is freezeHVStatus.		cs parameter record:		mode		<- HVStatusMode: { freezeHVStatus, continuousHVStatus, lightPenHVStatus }		where		<- Point: the video signal point on the screen	********************************************************/pascal short VEGetHVStatus(short	theDriver,			// which driver (card)						   short*	mode,				// FreezeHVStatus, ContinuousHVStatus, LightPenHVStatus						   Point*	where);				// horizontal and vertical coordinates (based on mode)	/********************************************************	Set the mode for how the horizontal and vertical status counters	are updated.		WARNING: The HorizontalCounterStatus and VerticalCounterStatus should be	read only when the HVStatusMode is freezeHVStatus. Incorrect values may	be returned in any other mode.		cs parameter record:		mode		-> HVStatusMode: { freezeHVStatus, continuousHVStatus, lightPenHVStatus }	********************************************************/pascal short VESetHVStatus(short	theDriver,			// which driver (card)						   short	theMode);	/********************************************************	Get the state of the master on/off switch of the timing sequencer.	This is turned on during normal operation.		cs parameter record:		onOff		<- BitState:		interleave	<- BitState: if enabled, generate adjusted clocks	********************************************************/pascal short VEGetHVControl(short		theDriver,			// which driver (card)							bitstate*	onOff,				// timing sequencer							bitstate*	interleave);		// if enabled, generate adjusted clocks	/********************************************************	Set the state of the master on/off switch of the timing sequencer.	This must be turned on for normal operation.		cs parameter record:		onOff		-> BitState:		interleave	-> BitState: if enabled, generate adjusted clocks	********************************************************/pascal short VESetHVControl(short		theDriver,			// which driver (card)							bitstate	onOff,				// timing sequencer							bitstate	interleave);		// if enabled, generate adjusted clocks	/********************************************************	Get the time sequencer support registers.		cs parameter record:		HRAM	<- word		VRAM	<- word		HCnt	<- word		VCnt	<- word		HLV	<- word		VLV	<- word	********************************************************/pascal short VEGetTimeSequencerParameters(short					theDriver,		// which driver (card)										  VETimeSequencerState*	theState);	/********************************************************	Set the time sequencer support registers.		cs parameter record:		HRAM	-> word		VRAM	-> word		HCnt	-> word		VCnt	-> word		HLV	-> word		VLV	-> word		Warning: Calling this routine will cause a momentary sync loss.	********************************************************/pascal short VESetTimeSequencerParameters(short					theDriver,		// which driver (card)										  VETimeSequencerState*	theState);	/********************************************************	Get the Horizontal Time Sequence Command at program location HRAM.		cs parameter record:		HRAM		-> word: address of the command entry		command1	<- word: horizontal command pair		command2	<- word:		commandCount	<- word: command pair counter activation value		Warning: Calling this routine will cause a momentary sync loss.	********************************************************/pascal short VEGetHorizontalSequenceCommands(short	theDriver,		// which driver (card)											 short	HRAM,			// Address within horizontal display sequencer											 short*	command1,		// H/V command pair											 short*	command2,											 short*	commandCount);	// Command pair counter activation value	/********************************************************	Set the Horizontal Time Sequence Command at program location HRAM.		cs parameter record:		HRAM		-> word: address of the command entry		command1	-> word: horizontal command pair		command2	-> word:		commandCount	-> word: command pair counter activation value		Warning: Calling this routine will cause a momentary sync loss.	********************************************************/pascal short VESetHorizontalSequenceCommands(short	theDriver,		// which driver (card)											 short	HRAM,			// Address within horizontal display sequencer											 short	command1,		// H/V command pair											 short	command2,											 short	commandCount);	// Command pair counter activation value	/********************************************************	Get the Vertical Time Sequence Command at program location VRAM.		cs parameter record:		VRAM		-> word: address of the command entry		command1	<- word: vertical command pair		command2	<- word:		commandCount	<- word: command pair counter activation value		Warning: Calling this routine will cause a momentary sync loss.	********************************************************/pascal short VEGetVerticalSequenceCommands(short	theDriver,			// which driver (card)										   short	VRAM,				// Address within vertical display sequencer										   short*	command1,			// H/V command pair										   short*	command2,										   short*	commandCount);		// Command pair counter activation value	/********************************************************	Set the Vertical Time Sequence Command at program location VRAM.		cs parameter record:		VRAM		-> word: address of the command entry		command1	-> word: vertical command pair		command2	-> word:		commandCount	-> word: command pair counter activation value		Warning: Calling this routine will cause a momentary sync loss.	********************************************************/pascal short VESetVerticalSequenceCommands(short	theDriver,			// which driver (card)										   short	VRAM,				// Address within vertical display sequencer										   short	command1,			// H/V command pair										   short	command2,										   short	commandCount);		// Command pair counter activation value	/********************************************************	Get control info about syncronization.		cs parameter record:		inputSyncSource	<- SyncSource: { syncSource0, syncSource1 }		IREClamp	<- BitState: if true, IRE clamping in effect		interlace	<- BitState: if true, sync is interlaced		EQAndSer	<- BitState: if true, equalization and serration is in effect		syncOnVideo	<- BitState: if true, sync is output on video signals		VBDigital	<- BitState: if true, driving digital sync on Video Bahn		VBComposite	<- BitState: if true, driving composite sync on Video Bahn		TTLSync		<- TTLSyncMode: { TTLsyncOff, TTLsyncHsync, TTLsyncHESsync, TTLsyncComposite12PixelDelay,						TTLsyncComposite11PixelDelay, TTLsyncComposite10PixelDelay,						TTLsyncComposite1PixelDelay, TTLsyncCompositeNoPixelDelay }	********************************************************/pascal short VEGetSyncControls(short			theDriver,				// which driver (card)							   VESyncControl*	theControls);	/********************************************************	Set control info about syncronization.		cs parameter record:		inputSyncSource	-> SyncSource: { syncFromSame, syncSource0, syncSource1 }		IREClamp	-> BitState: if true, IRE clamping in effect		interlace	-> BitState: if true, sync is interlaced		EQAndSer	-> BitState: if true, equalization and serration is in effect		syncOnVideo	-> BitState: if true, sync is output on video signals		VBDigital	-> BitState: if true, drive digital sync on Video Bahn		VBComposite	-> BitState: if true, drive composite sync on Video Bahn		TTLSync		-> TTLSyncMode: { TTLsyncSame, TTLsyncOff, TTLsyncHsync, TTLsyncHESsync, TTLsyncComposite12PixelDelay,						TTLsyncComposite11PixelDelay, TTLsyncComposite10PixelDelay, TTLsyncComposite1PixelDelay,						TTLsyncCompositeNoPixelDelay }		NOTE: When setting the VBDigital state, this is set in both the SyncMode	register as well as the ClockControl register DCLK control.	********************************************************/pascal short VESetSyncControls(short			theDriver,				// which driver (card)							   VESyncControl*	theControls);	/********************************************************	Get control info about the genlock section.		cs parameter record:		genlockControl		<- word: controls the genlock bits		genlockReserved		-- word: this word is reserved.		horzNoLockThreshold	<- word: this is the number of times genlock must miss						 a horizontal frame before search mode begins		vertNoLockThreshold	<- word: this is the number of times genlock must miss						 a vertical frame before search mode begins		hLockAquisitionTime	<- word: this is the number of frame locks						required before HLockStatus is set		hLockStatus		<- BitState: if true, horizontal lock achieved		vLockStatus		<- BitState: if true, vertical lock achieved		singleHSSmode		<- BitState: if true, only one horizontal start sync command can be issued by the							sequencer after a horizontal HSS enable command.	********************************************************/pascal short VEGetGenlockControls(short				theDriver,			// which driver (card)								  VEGenlockControl*	theControls);		/********************************************************	Set control info about the genlock section.		cs parameter record:		genlockControl		-> word: controls the genlock bits		genlockReserved		-- word: this word is reserved. It should be set to zero.		horzNoLockThreshold	-> INTEGER: this is the number of times genlock must miss						 a horizontal frame before search mode begins		vertNoLockThreshold	-> INTEGER: this is the number of times genlock must miss						 a vertical frame before search mode begins		hLockAquisitionTime	-> INTEGER: this is the number of frame locks						 required before HLockStatus is set		singleHSSmode		-> BitState: if true, only one horizontal start sync command can be issued by the							sequencer after a horizontal HSS enable command.	********************************************************/pascal short VESetGenlockControls(short				theDriver,			// which driver (card)								  VEGenlockControl*	theControls);////	Relative Timing//	/********************************************************	This gets the current memory bank configuration. This controls how	the video memory is displayed from.		NOTE: Call GetMemoryAddressing to determine how memory is addressed by	the Macintosh CPU.		cs parameter record:		ConcatenateMode		<- MemoryConcatenation: Bank concatenation mode		ABInterleaving		<- BitState: 8  bit interleave, only valid for some configs		CDInterleaving		<- BitState: 8  bit interleave, only valid for some configs		ABCDInterleaving	<- BitState: 16 bit interleave, only valid for some configs	********************************************************/pascal short VEGetMemoryBankConfiguration(short					theDriver,		// which driver (card)										  VEBankConfiguration*	theConfig);	/********************************************************	This sets the current memory bank configuration. This controls how	the video memory is displayed from.		NOTE: Call SetMemoryAddressing to control how memory is addressed by	the Macintosh CPU.		NOTE: See below for a list of which concatenation modes are legal for	the different interleaving modes. This is a hardware limitation. There	is no validity checking on the concatenation mode parameter.		cs parameter record:		ConcatenateMode		-> MemoryConcatenation:						{ concatTheSame,						  concatA_B_C_D, concatABX_C_D, concatABY_C_D,						  concatA_B_CDX, concatABX_CDX, concatABY_CDX,						  concatA_B_CDY, concatABX_CDY, concatABY_CDY,						  concatACX_BDX, concatACY_BDY,						  concatABX_CDXX, concatABY_CDYY, concatABX_CDXY }		ABInterleaving		-> BitState: 8  bit interleave, only valid for these configs							{ concatABX_C_D, concatABX_CDX, concatABX_CDY,							  concatACX_BDX, concatABX_CDXX, concatABX_CDXY }		CDInterleaving		-> BitState: 8  bit interleave, only valid for these configs							{ concatA_B_CDX, concatABX_CDX, concatABY_CDX,							  concatACX_BDX, concatABX_CDXX, concatABX_CDXY }		ABCDInterleaving	-> BitState: 16 bit interleave, only valid for these configs							{ concatACX_BDX, concatABX_CDXX, concatABX_CDXY }	********************************************************/pascal short VESetMemoryBankConfiguration(short					theDriver,		// which driver (card)										  VEBankConfiguration*	theConfig);	/********************************************************	Get the display attributes for the video banks.		NOTE: Use GetPhysicalMemoryOffset to Get NuBus memory addressing offsets.		This driver call uses a variable length parameter block. The block is sized	by the first parameter, numRecs.  Each record contains information that	directs the driver to get a specific attribute for a given memory bank. Since	the records have self contained information, they may appear in any order.		If numRecs = 0 the driver will return one BankAttributeRecord that contains the 	maximum number of banks and attributes that currently exist		EXAMPLE:   get offset, zoom and mosaic for all banks		  Parameter Block befor GetBankDisplayAttributes Status Call			numRecs		= 12				the number of display attribute records that follow		attRec[0]	= {BankA,BankDisplayOffset,{?,?}}		attRec[1]	= {BankB,BankDisplayOffset,{?,?}}		attRec[2]	= {BankC,BankDisplayOffset,{?,?}}		attRec[3]	= {BankD,BankDisplayOffset,{?,?}}		attRec[4]	= {BankA,BankDisplayZoom,{?,?}}		attRec[5]	= {BankB,BankDisplayZoom,{?,?}}		attRec[6]	= {BankC,BankDisplayZoom,{?,?}}		attRec[7]	= {BankD,BankDisplayZoom,{?,?}}		attRec[8]	= {BankA,BankDisplayMosaic,{?,?}}		attRec[9]	= {BankB,BankDisplayMosaic,{?,?}}		attRec[10]	= {BankC,BankDisplayMosaic,{?,?}}		attRec[11]	= {BankD,BankDisplayMosaic,{?,?}}			  Parameter Block after GetBankDisplayAttributes Status Call			numRecs		= 12				the number of display attribute records that follow		attRec[0]	= {BankA,BankDisplayOffset,{3,4}}		attRec[1]	= {BankB,BankDisplayOffset,{3,4}}		attRec[2]	= {BankC,BankDisplayOffset,{3,4}}		attRec[3]	= {BankD,BankDisplayOffset,{3,4}}		attRec[4]	= {BankA,BankDisplayZoom,{2,2}}		attRec[5]	= {BankB,BankDisplayZoom,{2,2}}		attRec[6]	= {BankC,BankDisplayZoom,{2,2}}		attRec[7]	= {BankD,BankDisplayZoom,{2,2}}		attRec[8]	= {BankA,BankDisplayMosaic,{0,0}}		attRec[9]	= {BankB,BankDisplayMosaic,{0,0}}		attRec[10]	= {BankC,BankDisplayMosaic,{0,0}}		attRec[11]	= {BankD,BankDisplayMosaic,{0,0}}			EXAMPLE:   get the number of banks and attributes currently available		  Parameter Block befor GetBankDisplayAttributes Status Call			numRecs		= 0				the number of display attribute records that follow		attRec[0]	= {?,?,{?,?}}			  Parameter Block after GetBankDisplayAttributes Status Call			numRecs		= 12				the number of display attribute records that follow		attRec[0]	= {4,3,{?,?}}			currently 4 banks and 3 attributes per bank			BankAttributeRecord		bankID		-> BankID:			{ BankA, BankB, BankC, BankD }		attributeID	-> AttributeID 			{ BankDisplayOffset | BankDisplayZoom | BankDisplayMosaic }		point		<- Point:		cs parameter record:		numRecs			-> long: the number of display attribute records that follow		attributeRecs[numRecs]	-> BankAttributeRecord:	********************************************************/pascal short VEGetBankDisplayAttributes(short						theDriver,			// which driver (card)										VEBankDisplayAttributes*	theDisplayAttributes);	/********************************************************	Set the display attributes for the video banks.		NOTE: Use SetPhysicalMemoryOffset to set NuBus memory addressing offsets.		This driver call uses a variable length parameter block. The block is sized	by the first parameter, numRecs.  Each record contains information that	directs the driver to set a specific attribute for a given memory bank. Since	the records have self contained information, they may appear in any order.		EXAMPLE:   set offset=3,4 zoom=2,2 and mosaic=0,0 for all banks		  Parameter Block			numRecs		= 12				the number of display attribute records that follow		attRec[0]	= {BankA,BankDisplayOffset,{3,4}}		attRec[1]	= {BankB,BankDisplayOffset,{3,4}}		attRec[2]	= {BankC,BankDisplayOffset,{3,4}}		attRec[3]	= {BankD,BankDisplayOffset,{3,4}}		attRec[4]	= {BankA,BankDisplayZoom,{2,2}}		attRec[5]	= {BankB,BankDisplayZoom,{2,2}}		attRec[6]	= {BankC,BankDisplayZoom,{2,2}}		attRec[7]	= {BankD,BankDisplayZoom,{2,2}}		attRec[8]	= {BankA,BankDisplayMosaic,{0,0}}		attRec[9]	= {BankB,BankDisplayMosaic,{0,0}}		attRec[10]	= {BankC,BankDisplayMosaic,{0,0}}		attRec[11]	= {BankD,BankDisplayMosaic,{0,0}}			EXAMPLE:   set mosaic=0,0 zoom=0,0 for bank pair AB and mosaic=-10,-10 zoom=22,22 for bank pair CD		  Parameter Block			numRecs		= 8				the number of display attribute records that follow		attRec[0]	= {BankA,BankDisplayMosaic,{0,0}}		attRec[1]	= {BankB,BankDisplayMosaic,{0,0}}		attRec[2]	= {BankA,BankDisplayZoom,{0,0}}		attRec[3]	= {BankB,BankDisplayZoom,{0,0}}		attRec[4]	= {BankC,BankDisplayMosaic,{-10,-10}}		attRec[5]	= {BankD,BankDisplayMosaic,{-10,-10}}		attRec[6]	= {BankC,BankDisplayZoom,{22,22}}		attRec[7]	= {BankD,BankDisplayZoom,{22,22}}			CAUTION: Points associated with the mosaic attribute should have positive values	within the range of 0 to 1023.  Negative values cause a linear mode where the	apparent zoom factor is:   1.0 - (zoom factor/mosaic factor)		BankAttributeRecord		bankID		-> BankID:			{ NoBank, BankA, BankB, BankC, BankD }		attributeID	-> AttributeID 			{ BankDisplayOffset | BankDisplayZoom | BankDisplayMosaic }		point		-> Point:		cs parameter record:		numRecs			-> long: the number of display attribute records that follow		attributeRecs[numRecs]	-> BankAttributeRecord:	********************************************************/pascal short VESetBankDisplayAttributes(short						theDriver,			// which driver (card)										VEBankDisplayAttributes*	theDisplayAttributes);	/********************************************************	This gets the live mosaic factors. Note, the Y mosaic factor is	currently always returned as 0. Vertical mosaicing can	be achieved by programming the display control program.		cs parameter record:		mosaicFactor	- Point: the vertical and horizontal mosiac factor (0=x1)	********************************************************/pascal short VEGetLiveMosaics(short		theDriver,			// which driver (card)							  Point*	theFactor);			// image contribution factor	/********************************************************	This sets the live mosaic factors. Note, the Y mosaic factor is	currently unused and will be ignored. Vertical mosaicing can	be achieved by programming the display control program.		cs parameter record:		mosaicFactor	-> Point: the vertical and horizontal mosiac factor (0=x1)	********************************************************/pascal short VESetLiveMosaics(short	theDriver,			// which driver (card)							  Point	theFactor);			// image contribution factor////	NuBus Interface//	/********************************************************	Get synchonus register loading controls		cs parameter record:		multiplier		<- BitState: if true, multiplier control registers are loaded synchonusly		evenMultConstants	<- BitState: 		oddMultConstants	<- BitState:		clutMatrixOffset	<- BitState:		defaultDisplayChannel	<- BitState:		captureDataSourceFormat	<- BitState:		evenFieldSync		<- BitState: if true above register writes are delayed till the end of an even field		oddFieldSync		<- BitState: if true above register writes are delayed till the end of an odd field	********************************************************/pascal short VEGetVDESyncLoadControl(short					theDriver,			// which driver (card)									 VEVDESyncLoadState*	theState);	/********************************************************	Set synchronous register loading controls		cs parameter record:		multiplier		-> BitState: if true, multiplier control registers are loaded synchronously		evenMultConstants	-> BitState: 		oddMultConstants	-> BitState:		clutMatrixOffset	-> BitState:		defaultDisplayChannel	-> BitState:		captureDataSourceFormat	-> BitState:		evenFieldSync		-> BitState: if true above register writes are delayed till the end of an even field		oddFieldSync		-> BitState: if true above register writes are delayed till the end of an odd field	********************************************************/pascal short VESetVDESyncLoadControl(short					theDriver,			// which driver (card)									 VEVDESyncLoadState*	theState);	/********************************************************	Get synchronous register loading controls		cs parameter record:		bankOffsets		<- BitState:		bankZooms_Mosaics	<- BitState:		captureBankEnables	<- BitState:		bankConfig_CCCEnables	<- BitState:		captureWindow		<- BitState:		rectangles		<- BitState:		busMux_bankDepth	<- BitState:		CLUTOffsets		<- BitState:		lineControl_priority	<- BitState:		syncLoadMode		<- SyncLoadMode { evenFieldEndOfBlanking,  evenFieldEndOfSync,							oddFieldEndOfBlanking, oddFieldEndOfSync,							noSyncLoad, evenOddEndOfBlanking, evenOddEndOfSync}	********************************************************/pascal short VEGetVSCSyncLoadControl(short					theDriver,			// which driver (card)									 VEVSCSyncLoadState*	theState);	/********************************************************	Set synchronous register loading controls		cs parameter record:		bankOffsets		-> BitState:		bankZooms_Mosaics	-> BitState:		captureBankEnables	-> BitState:		bankConfig_CCCEnables	-> BitState:		captureWindow		-> BitState:		rectangles		-> BitState:		busMux_bankDepth	-> BitState:		CLUTOffsets		-> BitState:		lineControl_priority	-> BitState:		syncLoadMode		-> SyncLoadMode { evenFieldEndOfBlanking,  evenFieldEndOfSync,							oddFieldEndOfBlanking, oddFieldEndOfSync,							noSyncLoad, evenOddEndOfBlanking, evenOddEndOfSync}	********************************************************/pascal short VESetVSCSyncLoadControl(short					theDriver,			// which driver (card)									 VEVSCSyncLoadState*	theState);	/********************************************************	This is similar to SetDefaultMode, except this switches modes without	any communications with the MacOS, and does not save this setting in	PRAM. It is the responsibility of the application software which calls	this routine to swap the video mode back to its previous state for	subsequent QuickDraw activity to be performed correctly.		WARNING: This can change the scanrate and may cause loss of sync	depending on the monitor in use.		cs parameter record:		newMode		-> word: new sResource ID		oldMode		<- word: sResource ID before the call	********************************************************/pascal short VESetExtendedVideoMode(short	theDriver,			// which driver (card)									short	newMode,									short*	oldMode);	/********************************************************	Get the hardware status of the Video Explorer.		cs parameter record:		VSCVersion		<- word:		VDEVersion		<- word:		WICVersion		<- word:		EEPROMStatus		<- BitState: if true, EEPROM is present and functional		videoSets		<- BitState: if true, 2 sets of video RAM are present else only 1		vMemType		<- BitState: if true, 1 or 2MByte devices are used else 4MByte		inputModuleStatus	<- long:		lightPenStatus		<- long: currently unused and zero		outputModuleStatus	<- long: Returns the output module ID in LSByte		displayCardStatus	<- long: Returns the default start ID in 31:24, Serial Number in 23:0		displayCardSignature	<- long: Returns the main card Signature ( board type )	********************************************************/pascal short VEGetHWStatus(short		theDriver,				// which driver (card)						   VEHWStatus*	theStatus);//// VideoBahn Interface//	/********************************************************	Get digital video port characteristics (input enable, output enable,	and output channel).		NOTE: The set of channels allowed for output is different for each	video port. In particular, digitalVideoPort1 can output CLUT1, whereas	digitalVideoPort2 can output CLUT2.		cs parameter record:		port		-> DigitalVideoPort: { digitalVideoPort1, digitalVideoPort2 }		inputEnable	<- BitState: if True, port is enabled for input		outputEnable	<- BitState: if True, port is enabled for output		channel		<- ChannelID: required for output only	********************************************************/pascal short VEGetDigitalVideoPort(short		theDriver,			// which driver (card)								   VEDVPState*	theState);	/********************************************************	Set digital video port characteristics (input enable, output enable,	and output channel). This does not set the output channel if the	channel is not being enabled for output.		NOTE: The set of channels allowed for output is different for each	video port. In particular, digitalVideoPort1 can output CLUT1, whereas	digitalVideoPort2 can output CLUT2.		cs parameter record:		port		-> DigitalVideoPort: { digitalVideoPort1, digitalVideoPort2 }		inputEnable	-> BitState: if True, port is enabled for input		outputEnable	-> BitState: if True, port is enabled for output		channel		-> ChannelID: required for output only					{inputModuleChannel, DVPWriteDataChannel} only for DC	********************************************************/pascal short VESetDigitalVideoPort(short		theDriver,			// which driver (card)								   VEDVPState*	theState);	/********************************************************	Read the value currently on the Digital Video Ports.		cs parameter record:		port		-> DigitalVideoPort: { digitalVideoPort1, digitalVideoPort2 }		DVPReadValue	<- long: DVP read register value	********************************************************/pascal short VEReadDVPData(short	theDriver,			// which driver (card)						   short	thePort,						   long*	theData);	/********************************************************	Get the Digital Video Port output value.		cs parameter record:		port		-> DigitalVideoPort: { digitalVideoPort1, digitalVideoPort2 }		DVPWriteValue	<- long: DVP write register value	********************************************************/pascal short VEGetDVPWriteValue(short	theDriver,			// which driver (card)								short	thePort,								long*	theData);	/********************************************************	Write the Digital Video Port output value.		cs parameter record:		port		-> DigitalVideoPort: { digitalVideoPort1, digitalVideoPort2 }		DVPWriteValue	-> long: DVP write register value	********************************************************/pascal short VESetDVPWriteValue(short	theDriver,			// which driver (card)								short	thePort,								long	theValue);//// Multiplier Array//	/********************************************************	This gets a set of multiplier constants.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		arraySelect	<- OddEven: access to the odd or even array		arrayPtr	<- *Fixed: points to local array to be used for the destination		arrayBounds	<- Rect: defines the subset of the multiplier array to access and					indirectly sizes the local array. Rect is a QuickDraw					style rectangle imposed on a coordinate system with an					origin at 0,0.		Currently defined rectangle of multiplier constants:		K1	K2	K3		K4	K5	K6		K7	K8	K9			Multiplier constants usage for blending (up to three sources):		|R|	|K1   0   0 |	|R|	|K2   0   0 |	|R|	|K3   0   0 |	|R|		|G|  =	| 0  K4   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K6   0 | *	|G|		|B|	| 0   0  K7 |	|B|1	| 0   0  K8 |	|B|2	| 0   0  K9 |	|B|3			Multiplier constants usage for color space transformations:		|R|	|K1   0   0 |	|R|	|K4   0   0 |	|R|	|K7   0   0 |	|R|		|G|  =	| 0  K2   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K8   0 | *	|G|		|B|	| 0   0  K3 |	|B|1	| 0   0  K6 |	|B|2	| 0   0  K9 |	|B|3			Multiplier constants usage for 9-Tap Filter [P(n) = pixel(n)]:		 K9	 K8	 K7	 K6	 K5	 K4	 K3	 K2	 K1	Partial		  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x   +	Sum Input		P(n-8)	P(n-7)	P(n-6)	P(n-5)	P(n-4)	P(n-3)	P(n-2)	P(n-1)	P(n)	for pixel n			Multiplier constants usage for 18-Tap Filter:		odd K9	odd K8	odd K7	odd K6	odd K5	odd K4	odd K3	odd K2	odd K1		  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +		P(n-17)	P(n-16)	P(n-15)	P(n-14)	P(n-13)	P(n-12)	P(n-11)	P(n-10)	P(n-9)			even K9	even K8	even K7	even K6	even K5	even K4	even K3	even K2	even K1	 Partial		  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    + Sum Input		P(n-8)	P(n-7)	P(n-6)	P(n-5)	P(n-4)	P(n-3)	P(n-2)	P(n-1)	P(n)	 for pixel n			NOTE: If arraySelect is "odd", or "even", it is referencing one	of the arrays. If it "both", then it is referencing two of the	arrays, and thus twice as many multiplier constants. In this case	the array has a third dimension, outer, dimension. The data for	the second set of multiplier constants follows the data for the	first set of mutiplier constants in memory. For example, if	arrayBounds = { 0, 0, 2, 3 }, and arraySelect = both, then the	constants in memory are as follows:		K1 even, K2 even, K3 even, K4 even, K5 even, K6 even,		K1 odd,  K2 odd,  K3 odd,  K4 odd,  K5 odd,  K6 odd	********************************************************/pascal short VEGetMultiplierConstants(short						theDriver,			// which driver (card)									  VEMultiplierConstants*	theConstants);	/********************************************************	This sets a set of multiplier constants.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		arraySelect	-> OddEven: access to the odd and/or even array		arrayPtr	-> *Fixed: points to local array to be used as the source		arrayBounds	-> Rect: defines the subset of the multiplier array to access and					indirectly sizes the local array. Rect is a QuickDraw					style rectangle imposed on a coordinate system with an					origin at 0,0.		Currently defined rectangle of multiplier constants:		K1	K2	K3		K4	K5	K6		K7	K8	K9			Multiplier constants usage for blending (up to three sources):		|R|	|K1   0   0 |	|R|	|K2   0   0 |	|R|	|K3   0   0 |	|R|		|G|  =	| 0  K4   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K6   0 | *	|G|		|B|	| 0   0  K7 |	|B|1	| 0   0  K8 |	|B|2	| 0   0  K9 |	|B|3			Multiplier constants usage for color space transformations:		|R|	|K1   0   0 |	|R|	|K4   0   0 |	|R|	|K7   0   0 |	|R|		|G|  =	| 0  K2   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K8   0 | *	|G|		|B|	| 0   0  K3 |	|B|1	| 0   0  K6 |	|B|2	| 0   0  K9 |	|B|3			Multiplier constants usage for 9-Tap Filter [P(n) = pixel(n)]:		 K9	 K8	 K7	 K6	 K5	 K4	 K3	 K2	 K1	Partial		  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x   +	Sum Input		P(n-8)	P(n-7)	P(n-6)	P(n-5)	P(n-4)	P(n-3)	P(n-2)	P(n-1)	P(n)	for pixel n			Multiplier constants usage for 18-Tap Filter:		odd K9	odd K8	odd K7	odd K6	odd K5	odd K4	odd K3	odd K2	odd K1		  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +		P(n-17)	P(n-16)	P(n-15)	P(n-14)	P(n-13)	P(n-12)	P(n-11)	P(n-10)	P(n-9)			even K9	even K8	even K7	even K6	even K5	even K4	even K3	even K2	even K1	 Partial		  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    +  x    + Sum Input		P(n-8)	P(n-7)	P(n-6)	P(n-5)	P(n-4)	P(n-3)	P(n-2)	P(n-1)	P(n)	 for pixel n			NOTE: If arraySelect is "odd", or "even", it is referencing one	of the arrays. If it "both", then it is referencing two of the	arrays, and thus twice as many multiplier constants. In this case	the array has a third dimension, outer, dimension. The data for	the second set of multiplier constants follows the data for the	first set of mutiplier constants in memory. For example, if	arrayBounds = { 0, 0, 2, 3 }, and arraySelect = both, then the	constants in memory are as follows:		K1 even, K2 even, K3 even, K4 even, K5 even, K6 even,		K1 odd,  K2 odd,  K3 odd,  K4 odd,  K5 odd,  K6 odd	********************************************************/pascal short VESetMultiplierConstants(short						theDriver,			// which driver (card)									  VEMultiplierConstants*	theConstants);	/********************************************************	Get the constants source for the multiplier.		For the videoBus2Channel the red component is used, and thus the busComp	parameter would be busCompB. For liveDigitalInChannel the alpha	component is used, and thus the busComp parameter would be busCompA.	For pseudo channels which only have single components, busComp is ignored.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		channel		<- ChannelID: { lineOrPixelConstantsChannel, NoiseGeneratorChannel, videoBus2Channel,					liveDigitalInChannel, multiplierConstantsChannel }		busComp		<- BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VEGetMultiplierConstantsChannel(short	theDriver,			// which driver (card)											 short	multiplierID,		// multiplier1											 short*	channel,			//											 short*	busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Set the constants source for the multiplier.		NOTE: For the videoBus2Channel the red component is used, and thus the	busComp parameter should be set to busCompB. For liveDigitalInChannel	the alpha component is used, and thus the busComp parameter should be	set to busCompA. For pseudo channels which only have single components,	busComp is ignored. In the future, it is possible that other components	will be selectable for the various sources of multiplier constants.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		channel		-> ChannelID: { lineOrPixelConstantsChannel, NoiseGeneratorChannel, videoBus2Channel,					liveDigitalInChannel, multiplierConstantsChannel }		busComp		-> BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VESetMultiplierConstantsChannel(short	theDriver,			// which driver (card)											 short	multiplierID,		// multiplier1											 short	channel,			//											 short	busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Get the ICF (image contribution factor) parameters. Pass an ICF scale	factor and a blend ratio total.		NOTE: Although this returns a Fixed point value (16.16), the	maximum range allowable by the current hardware is -2.0..+2.0,	in a 2.7 bit format for the ICFScaleFactor, and -4.0..+4.0,	in a 3.7 bit format for the blendRatioTotal.		cs parameter record:		ICFScaleFactor	<- Fixed: 16.16 value		blendRatioTotal	<- Fixed: 16.16 value	********************************************************/pascal short VEGetMultiplierICFControls(short	theDriver,				// which driver (card)										Fixed*	ICFScaleFactor,			// 16.16 value. 2.7 useable bits										Fixed*	blendRatioTotal);		// 16.16 value. 3.7 useable bits	/********************************************************	Set the ICF (image contribution factor) parameters. Pass an ICF scale	factor and a blend ratio total.		NOTE: Although this accepts a Fixed point value (16.16), the	maximum range allowable by the current hardware is -2.0..+2.0,	in a 2.7 bit format for the ICFScaleFactor, and -4.0..+4.0,	in a 3.7 bit format for the blendRatioTotal.		cs parameter record:		ICFScaleFactor	-> Fixed: 16.16 value		blendRatioTotal	-> Fixed: 16.16 value	********************************************************/pascal short VESetMultiplierICFControls(short	theDriver,				// which driver (card)										Fixed	ICFScaleFactor,			// 16.16 value. 2.7 useable bits										Fixed	blendRatioTotal);		// 16.16 value. 3.7 useable bits	/********************************************************	This gets the multiplier mode.		NOTE: Some multiplierModes are only valid if the pixelClockDivider is	non-zero. These include multTransformThenBlend, multBlendThenTransform,	multTransformThenTransform, and 18-tap filtering modes. This call gets	the mutliplier mode without checking this validity condition.		NOTE: Currently, if using CLUT2 override, the input selected by	CLUTSource2 must be one of the Video Bus 2 components. This can be	set using the call SetCLUTSource. This does no check to ensure that	this condition exists.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		multiplierMode	<- MultiplierMode: { multTransform, multBlend, multTransformThenBlend,					multBlendThenTransform, mult2D8BitFilter, mult2D16BitFilter,					mult16BitFrameAccumulator, multTransformThenTransform }		filterTaps	<- word: 9 or 18		clampedBits	<- word: 8 or 16		CLUT2Override	<- BitState: if True, even multiplier output overrides CLUT2		multiplexMode	<- MultiplierMultiplexMode: { multDependent, multIndependent }	********************************************************/pascal short VEGetMultiplierMode(short				theDriver,			// which driver (card)								 VEMultiplierState*	theState);	/********************************************************	This sets the multiplier mode.		NOTE: Some multiplierModes are only valid if the pixelClockDivider is	non-zero. These include multTransformThenBlend, multBlendThenTransform,	multTransformThenTransform, and 18-tap filtering modes. This call sets	the mutliplier mode without checking this validity condition.		NOTE: Currently, if using CLUT2 override, the input selected by	CLUTSource2 must be one of the Video Bus 2 components. This can be	set using the call SetCLUTSource.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		multiplierMode	-> MultiplierMode: { multTransform, multBlend, multTransformThenBlend,					multBlendThenTransform, mult2D8BitFilter, mult2D16BitFilter,					mult16BitFrameAccumulator, multTransformThenTransform }		filterTaps	-> word: 9 or 18		clampedBits	-> word: 8 or 16		CLUT2Override	-> BitState: if True, even multiplier output overrides CLUT2		multiplexMode	-> MultiplierMultiplexMode: { multDependent, multIndependent }	********************************************************/pascal short VESetMultiplierMode(short				theDriver,			// which driver (card)								 VEMultiplierState*	theState);	/********************************************************	This gets the multiplier input and output formats (signed/unsigned).	Note that not all of the Multiplier Sign Types require a 2 dimensional	array and not all will pay attention to the odd/even pixel flag.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		arraySelect	-> OddEven: access to the odd or even array		signType	-> MultSignType: { BlendInputSigns, TransformInputSigns, MultiplierOutputSigns, PartialSumOutputSign }		arrayPtr	-> *Sign: points to local array to be used as the source		arrayBounds	-> Rect: defines the subset of sign bits to access and indirectly					sizes the local array. Rect is a QuickDraw style rectangle					imposed on a coordinate system with an origin at 0,0.		Currently defined rectangle of multiplier signs:		S1	S2	S3		S4	S5	S6		S7	S8	S9			Multiplier constants and signs usage for blending (up to three sources):		|R|	|K1   0   0 |	|R|	|K2   0   0 |	|R|	|K3   0   0 |	|R|		|G|  =	| 0  K4   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K6   0 | *	|G|		|B|	| 0   0  K7 |	|B|1	| 0   0  K8 |	|B|2	| 0   0  K9 |	|B|3			S1: red input 1		S2: red input 2		S3: red input 3		S4: green input 1	S5: green input 2	S6: green input 3		S7: blue input 1	S8: blue input 2	S9: blue input 3			Multiplier constants and signs usage for color space transformations:		|R|	|K1   0   0 |	|R|	|K4   0   0 |	|R|	|K7   0   0 |	|R|		|G|  =	| 0  K2   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K8   0 | *	|G|		|B|	| 0   0  K3 |	|B|1	| 0   0  K6 |	|B|2	| 0   0  K9 |	|B|3			S1: red input 1		S2: green input 1	S3: blue input 1		S4: red input 2		S5: green input 2	S6: blue input 2		S7: red input 3		S8: green input 3	S9: blue input 3			NOTE: Currently, the odd and even multiplier inputs cannot have		separately controlled sign inputs. Thus arraySelect must be set		to "both" for blend control and transform control.			NOTE: Currently, the signs for transformation inputs must be the same		for all three input sources. (e.g. S1 = S4 = S7). Typically, all three		inputs are set to the same source for transformations, so this should		not be a problem. For future compatibility, the driver will only look		at the signs for the first input source, and the array should have		three components with bounds no greater than { 0, 0, 1, 3 }.		This is modeled below:				|R|	|K1  K2  K3 |	|R|			|G|  =	|K4  K6  K6 | *	|G|			|B|	|K7  K8  K9 |	|B|t				S1: red (inputs 1, 2, & 3)			S2: green (inputs 1, 2, & 3)			S3: blue (inputs 1, 2, & 3)			Multiplier output signs:		There are two multiplier outputs	 odd, and even. The bounds parameter		is ignored. ArraySelect determines which multiplier output signs are		affected:			arraySelect = odd or even:	(pass three signs)				S1: red output				S2: green output				S3: blue output			arraySelect = both:		(pass six signs)				S1: red output even				S2: green output even				S3: blue output even					S4: red output odd				S5: green output odd				S6: blue output odd			Partial sum output sign:		The bounds and arraySelect parameters are ignored.		Pass one sign parameter for the partial sum output sign.	********************************************************/pascal short VEGetMultiplierSigns(short					theDriver,			// which driver (card)								  VEMultiplierSigns*	theSigns);	/********************************************************	This sets the multiplier input and output formats (signed/unsigned).	Note that not all of the Multiplier Sign Types require a 2 dimensional	array and not all will pay attention to the odd/even pixel flag.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		signType	-> MultSignType: { BlendInputSigns, TransformInputSigns, MultiplierOutputSigns, PartialSumOutputSign }		arraySelect	-> OddEven: access to the odd or even array		arrayPtr	-> *Sign: points to local array to be used as the source		arrayBounds	-> Rect: defines the subset of sign bits to access and indirectly					sizes the local array. Rect is a QuickDraw style rectangle					imposed on a coordinate system with an origin at 0,0.		Currently defined rectangle of multiplier signs:		S1	S2	S3		S4	S5	S6		S7	S8	S9			Multiplier constants and signs usage for blending (up to three sources):		|R|	|K1   0   0 |	|R|	|K2   0   0 |	|R|	|K3   0   0 |	|R|		|G|  =	| 0  K4   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K6   0 | *	|G|		|B|	| 0   0  K7 |	|B|1	| 0   0  K8 |	|B|2	| 0   0  K9 |	|B|3			S1: red input 1		S2: red input 2		S3: red input 3		S4: green input 1	S5: green input 2	S6: green input 3		S7: blue input 1	S8: blue input 2	S9: blue input 3			Multiplier constants and signs usage for color space transformations:		|R|	|K1   0   0 |	|R|	|K4   0   0 |	|R|	|K7   0   0 |	|R|		|G|  =	| 0  K2   0 | *	|G|  +	| 0  K5   0 | *	|G|  +	| 0  K8   0 | *	|G|		|B|	| 0   0  K3 |	|B|1	| 0   0  K6 |	|B|2	| 0   0  K9 |	|B|3			S1: red input 1		S2: green input 1	S3: blue input 1		S4: red input 2		S5: green input 2	S6: blue input 2		S7: red input 3		S8: green input 3	S9: blue input 3			NOTE: Currently, the odd and even multiplier inputs cannot have		separately controlled sign inputs. Thus arraySelect must be set		to "both" for blend control and transform control.			NOTE: Currently, the signs for transformation inputs must be the same		for all three input sources. (e.g. S1 = S4 = S7). Typically, all three		inputs are set to the same source for transformations, so this should		not be a problem. For future compatibility, the driver will only look		at the signs for the first input source, and the array should have		three components with bounds no greater than { 0, 0, 1, 3 }.		This is modeled below:				|R|	|K1  K2  K3 |	|R|			|G|  =	|K4  K6  K6 | *	|G|			|B|	|K7  K8  K9 |	|B|t				S1: red (inputs 1, 2, & 3)			S2: green (inputs 1, 2, & 3)			S3: blue (inputs 1, 2, & 3)			Multiplier output signs:		There are two multiplier outputs	 odd, and even. Each multiplier output		has three components. Each output value can be treated as signed or		unsigned.			S1: red even output	S2: green even output	S3: blue even output		S4: red odd output	S5: green odd output	S6: blue odd output			The bounds parameter is ignored. Set arraySelect to evenIndex, oddIndex,		or both to specify the which multiplier output signs are being affected.		Partial sum output sign:		The bounds and arraySelect parameters are ignored.		Pass one sign parameter for the partial sum output sign.	********************************************************/pascal short VESetMultiplierSigns(short					theDriver,			// which driver (card)								  VEMultiplierSigns*	theSigns);	/********************************************************	Get the noise channel and the type of sync. The noise channel can be	noise (8 or 24 bit), or instead, a black and white source expanded	from a single component of Video Bus 2, or the Digital Video Port.		NOTE: In the future it is possible other channels and other components may	be legal for black and white generation. Currently, for videoBus2Channel all	components are legal. For liveDigitalInChannel only the alpha component is	legal. BusComp is set to busCompNone for monochrome8BitNoise and color24BitNoise.		cs parameter record:		channel		<- ChannelID: { videoBus2Channel, liveDigitalInChannel, monochrome8BitNoise, color24BitNoise }		busComp		<- BusComp: { busCompA, busCompB, busCompC, busCompD }		syncMode	<- NoiseSync: { nonSyncNoise, frameSyncNoise }		taps		<- word: { 13, 19 } (repeat every 8,191 values, or every 524,287 values)		bits		<- word: { 7, 8 } (7-bit noise, or 8-bit noise)	********************************************************/pascal short VEGetNoiseChannel(short			theDriver,			// which driver (card)							   VENoiseState*	theState);	/********************************************************	Set the noise channel and the type of sync. The noise channel can be	noise (8 or 24 bit), or instead, a black and white source expanded	from a single component of Video Bus 2, or the Digital Video Port.		NOTE: In the future it is possible other channels and other components may	be legal for black and white generation. Currently, for videoBus2Channel all	components are legal. For liveDigitalInChannel only the alpha component is	legal. BusComp is ignored for monochrome8BitNoise and color24BitNoise.		cs parameter record:		channel		-> ChannelID: { videoBus2Channel, liveDigitalInChannel, monochrome8BitNoise, color24BitNoise }		busComp		-> BusComp: { busCompA, busCompB, busCompC, busCompD }		syncMode	-> NoiseSync: { nonSyncNoise, frameSyncNoise }		taps		-> word: { 13, 19 } (repeat every 8,191 values, or every 524,287 values)		bits		-> word: { 7, 8 } (7-bit noise, or 8-bit noise)	********************************************************/pascal short VESetNoiseChannel(short			theDriver, 			// which driver (card)							   VENoiseState*	theState);	/********************************************************	Get the source of data for filter mode of a multiplier.		NOTE: In the future it is possible other channels and other components	may be legal for the multiplier filter source. Currently, for videoBus2Channel	only the alpha component is legal. For multipliersFirstInputChannel only the	the red, green, and blue components are legal.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		channel		<- ChannelID: { videoBus2Channel, multipliersFirstInputChannel }		busComp		<- BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VEGetMultiplierFilterChannel(short		theDriver,			// which driver (card)										  short		multiplierID,		// multiplier1										  short*	channel,			//										  short*	busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Set the source of data for filter mode of a multiplier.		NOTE: In the future it is possible other channels and other components	may be legal for the multiplier filter source. Currently, for videoBus2Channel	only the alpha component is legal. For multipliersFirstInputChannel only the	the red, green, and blue components are legal.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		channel		-> ChannelID: { videoBus2Channel, multipliersFirstInputChannel }		busComp		-> BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VESetMultiplierFilterChannel(short	theDriver,			// which driver (card)										  short	multiplierID,		// multiplier1										  short	channel,			//										  short	busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Get the source of the multiplier's partial sum input.		Note: For zeroComponentInputChannel the BusComp parameter	is a don't care and returns busCompNone.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		channel		<- ChannelID: { memBankChannel, zeroComponentInputChannel }		busComp		<- BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VEGetMultiplierPartialSumInChannel(short	theDriver,			// which driver (card)												short	multiplierID,		// multiplier1												short*	channel,			//												short*	busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Set the source of the multiplier's partial sum input.		NOTE: In the future it is possible other channels may be legal for	the multiplier partial sum input. For memBankChannel all components	are legal. For zeroComponentInputChannel the BusComp parameter	is ignored.		cs parameter record:		multiplierID	-> MultiplierID: { multiplier1 }		channel		-> ChannelID: { memBankChannel, zeroComponentInputChannel }		busComp		-> BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VESetMultiplierPartialSumInChannel(short	theDriver,			// which driver (card)												short	multiplierID,		// multiplier1												short	channel,			//												short	busComp);			// busCompA, busCompB, busCompC, busCompD//// CLUTs//	/********************************************************	Set the mode of a CLUT pair. Normal for CLUT1 refers to 256 RGB888 colors,	and for CLUT2 refers to the full 256 colors as RGB565 colors. Compressed	for CLUT2 refers to 128 RGB888. Mixed for CLUT1 refers to using the high	bits of the inputModuleChannel mixed with the low bits of the CLUTSource	to determine the index. CCC modes allow the CLUTs to follow the matrix	pixel addressing of the CCC pixel format.		NOTE: Currently all CLUTMode selectors set the mode for both CLUT1	and CLUT2. Thus the CLUTID is not used. For future compatibility,	this should be set to CLUT1.		cs parameter record:		CLUTID		-> CLUTID: { CLUT1, CLUT2 }		CLUTMode	-> CLUTMode: { normalNormalCLUT, normalCompressedCLUT, normalMatrixCLUT,					mixedNormalCLUT, mixedCompressedCLUT, mixedMatrixCLUT,					pairedNormalCLUTs, pairedCompressedCLUT,					CCC2BitNormal, CCC2BitCompressedCLUT,					matrixNormalCLUT, matrixCompressedCLUT, matrixMatrixCLUT }		********************************************************/pascal short VESetCLUTMode(short	theDriver,				// which driver (card)						   short	CLUTID,					// CLUT1, CLUT2						   short	CLUTMode);	/********************************************************	Get the mix ratio of a CLUT. The CLUT does not need to be in mixed	mode to get the mix ratio. The mix ratio is the percentage of	CLUT data to mix with the mix source (e.g. Live A/D).		NOTE: Currently CLUT2 cannot be mixed at all. Passing CLUT2	will result in an error.		NOTE: The mix ratio can be represented more finely as a percent	than can be programmed for with the current hardware. Thus it is	possible a GetCLUTMixRatio may return a slightly different percent	than what was passed to SetCLUTMixRatio.		cs parameter record:		CLUTID		-> CLUTID: { CLUT1, CLUT2 }		mixRatio	<- unsigned word: $FFFF is 100%	********************************************************/pascal short VEGetCLUTMixRatio(short			theDriver,			// which driver (card)							   short			CLUTID,				// CLUT1, CLUT2							   unsigned short*	mixRatio);			// $FFFF is 100%	/********************************************************	Set the mix ratio of a CLUT. The CLUT does not need to be in mixed	mode to set the mix ratio. The mix ratio is the percentage of	CLUT data to mix with the mix source (e.g. Live A/D).		NOTE: Currently CLUT2 cannot be mixed at all. Passing CLUT2	will result in an error.		cs parameter record:		CLUTID		-> CLUTID: { CLUT1, CLUT2 }		mixRatio	-> unsigned word: $FFFF is 100%	********************************************************/pascal short VESetCLUTMixRatio(short			theDriver,			// which driver (card)							   short			CLUTID,				// CLUT1, CLUT2							   unsigned short	mixRatio);			// $FFFF is 100%	/********************************************************	Get the CLUT's source (where the index values come from).		NOTE: In the future it is possible other channels and other components	may be legal CLUT sources. Currently, for videoBus2Channel all	components are legal. For multiplierOutChannel only the red (or Y)	component is legal.		cs parameter record:		CLUTID	-> CLUTID: { CLUT1, CLUT2 }		channel	<- ChannelID: { videoBus2Channel, multiplierOutChannel, matrixAddressGeneratorChannel}		busComp	<- BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VEGetCLUTSource(short	theDriver,			// which driver (card)							 short	CLUTID,				// CLUT1, CLUT2							 short*	channel,			// videoBus2Channel, multiplierOutChannel							 short*	busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Set the CLUT's source (where the index values come from).		NOTE: In the future it is possible other channels and other components	may be legal CLUT sources. Currently, for videoBus2Channel all	components are legal. For multiplierOutChannel only the red (or Y)	component is legal.		cs parameter record:		CLUTID	-> CLUTID: { CLUT1, CLUT2 }		channel	-> ChannelID: { videoBus2Channel, multiplierOutChannel }		busComp	-> BusComp: { busCompA, busCompB, busCompC, busCompD }	********************************************************/pascal short VESetCLUTSource(short		theDriver,			// which driver (card)							 short		CLUTID,				// CLUT1, CLUT2							 short		channel,			// videoBus2Channel, multiplierOutChannel							 short		busComp);			// busCompA, busCompB, busCompC, busCompD	/********************************************************	Get the matrix size and starting point of the CLUT matrix. The	CLUT does not need to be in matrix mode to get these parameters.		NOTE: The start point is the x,y screen coordinate. This is not	necessarily the same as the QuickDraw global coordinate which	could have an offset due to multiple monitors.		cs parameter record:		CLUTID	-> CLUTID: { CLUT1, CLUT2 }		size	-> CLUTmatrixSize: { MatrixSize16, MatrixSize32 }		start	-> Point: (QuickDraw point)	********************************************************/pascal short VEGetCLUTMatrixConfiguration(short		theDriver,		// which driver (card)										  short		CLUTID,			// CLUT1, CLUT2										  short*	size,			// MatrixSize16, MatrixSize32										  Point*	start);			// QuickDraw point	/********************************************************	Set the matrix size and starting point of the CLUT matrix. The	CLUT does not need to be in matrix mode to set these parameters.		NOTE: The start point is the x,y screen coordinate. This is not	necessarily the same as the QuickDraw global coordinate which	could have an offset due to multiple monitors.		cs parameter record:		CLUTID	-> CLUTID: { CLUT1, CLUT2 }		size	-> CLUTmatrixSize: { MatrixSize16, MatrixSize32 }		start	-> Point: (QuickDraw point)	********************************************************/pascal short VESetCLUTMatrixConfiguration(short	theDriver,		// which driver (card)										  short	CLUTID,			// CLUT1, CLUT2										  short	size,			// MatrixSize16, MatrixSize32										  Point	start);			// QuickDraw point////	Thresholder//	/********************************************************	Get the Range the thresholder is watching for.		cs parameter record:		ThresholderID	-> ThresholderID: { thresholder1 }		loColor		<- long:	RGB888		hiColor		<- long:	RGB888	********************************************************/pascal short VEGetThresholderRange(short			theDriver,			// which driver (card)								   short			thresholderID,		// thresholder1								   unsigned long*	loColor,			// RGB888								   unsigned long*	hiColor);			// RGB888	/********************************************************	Set the Range the thresholder is watching for.		cs parameter record:		thresholderID	- ThresholderID: { thresholder1 }		loColor	-> long: RGB888		hiColor	-> long: RGB888	********************************************************/pascal short VESetThresholderRange(short			theDriver,			// which driver (card)								   short			thresholderID,		// thresholder1								   unsigned long	loColor,			// RGB888								   unsigned long	hiColor);			// RGB888	/********************************************************	Get the signs the thresholder is using for comparison.		cs parameter record:		ThresholderID	-> ThresholderID: { thresholder1 }		dim		-> word:	number of elements of the sign bit array (0..3)		arrayPtr	-> *Sign:	pointer to the thresholder signs array		Currently the defined array of thresholder signs is three elements:			S1	S2	S3			S1 = red source component		S2 = green source component		S3 = blue source component	********************************************************/pascal short VEGetThresholderSigns(short	theDriver,				// which driver (card)								   short	thresholderID,			// thresholder1								   short	dim,					// number of elements of the sign bit array								   void*	compMasks);				// pointer to the array to be read from	/********************************************************	Set the signs the thresholder is using for comparison.		cs parameter record:		ThresholderID	-> ThresholderID: { thresholder1 }		dim		-> word:	number of elements of the sign bit array (0..3)		arrayPtr	-> *Sign:	pointer to the thresholder signs array		Currently the defined array of thresholder signs is three elements:			S1	S2	S3			S1 = red source component		S2 = green source component		S3 = blue source component	********************************************************/pascal short VESetThresholderSigns(short	theDriver,				// which driver (card)								   short	thresholderID,			// thresholder1								   short	dim,					// number of elements of the sign bit array								   void*	compMasks);				// pointer to the array to be read from	/********************************************************	Get the Color Format the thresholder is using on input.		cs parameter record:		thresholderID	-> ThresholderID: { thresholder1 }		colorFormat	<- ColorFormat: { color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue }	********************************************************/pascal short VEGetThresholderColorFormat(short	theDriver,				// which driver (card)										 short	thresholderID,			// thresholder1										 short*	colorFormat);			// color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue	/********************************************************	Set the Color Format the thresholder is using on input.		cs parameter record:		thresholderID	-> ThresholderID: { thresholder1 }		colorFormat	-> ColorFormat: { color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue }	********************************************************/pascal short VESetThresholderColorFormat(short		theDriver,				// which driver (card)										 short		thresholderID,			// thresholder1										 short		colorFormat);			// color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue	/********************************************************	Get the Transition Mode the thresholder is using on output.		cs parameter record:		thresholderID	-> ThresholderID: { thresholder1 }		transitionMode	<- TransitionMode: { transitionInside, transitionOutside, transitionInactive }	********************************************************/pascal short VEGetThresholderTransitionMode(short	theDriver,				// which driver (card)											short	thresholderID,			// thresholder1											short*	transitionMode);		// transitionInactive, transitionInside, transitionOutside, transitionInsideAndOutside	/********************************************************	Set the Transition Mode the thresholder is using on output.		cs parameter record:		thresholderID	-> ThresholderID: { thresholder1 }		transitionMode	-> TransitionMode: { transitionInactive, transitionInside, transitionOutside, transitionInsideAndOutside }	********************************************************/pascal short VESetThresholderTransitionMode(short	theDriver,				// which driver (card)											short	thresholderID,			// thresholder1											short	transitionMode);		// transitionInactive, transitionInside, transitionOutside, transitionInsideAndOutside////	Rectangle Control//	/********************************************************	Get a rectangle's bounds.		cs parameter record:		rectangleID	-> RectangleID:	{ rectangle1, rectangle2, rectangle3, rectangle4 }		bounds		<- Rect:	QuickDraw Rect	********************************************************/pascal short VEGetRectangleBounds(short	theDriver,			// which driver (card)								  short	theRectID,			// which rectangle								  Rect*	theBounds);			// Quickdraw rect	/********************************************************	Set a rectangle's bounds.		cs parameter record:		rectangleID	-> RectangleID:	{ rectangle1, rectangle2, rectangle3, rectangle4 }		bounds		-> Rect:	QuickDraw Rect	********************************************************/pascal short VESetRectangleBounds(short	theDriver,			// which driver (card)								  short	theRectID,			// which rectangle								  Rect	theBounds);			// Quickdraw rect	/********************************************************	Get a rectangle's control of when it's active.		cs parameter record:		rectangleID	-> RectangleID:		{ rectangle1, rectangle2, rectangle3, rectangle4 }		control		<- RectangleControl:	{ normalYNormalXInside, normalYNormalXOutside,						normalYInvertedXInside, normalYInvertedXOutside,						invertedYNormalXInside, invertedYNormalXOutside,						invertedYInvertedXInside, invertedYInvertedXOutside }	********************************************************/pascal short VEGetRectangleControl(short	theDriver,			// which driver (card)								   short	theRectID,			// which rectangle								   short*	theControl);		// define active region	/********************************************************	Set a rectangle's control of when it's active.		cs parameter record:		rectangleID	-> RectangleID:		{ rectangle1, rectangle2, rectangle3, rectangle4 }		control		-> RectangleControl:	{ normalYNormalXInside, normalYNormalXOutside,							normalYInvertedXInside, normalYInvertedXOutside,							invertedYNormalXInside, invertedYNormalXOutside,							invertedYInvertedXInside, invertedYInvertedXOutside }	********************************************************/pascal short VESetRectangleControl(short	theDriver,			// which driver (card)								   short	theRectID,			// which rectangle								   short	theControl);		// define active region////	Line Control//	/********************************************************	Get the rate at which line blending changes per pixel.		NOTE: Although this returns a Fixed point value (16.16), the	maximum range allowable by the current hardware is -4.0..+4.0,	in a <3 bits>.<9 bits> format.		cs parameter record:		rate	<- Fixed: 16.16 value	********************************************************/pascal short VEGetBlendRatioRateOfChange(short	theDriver,			// which driver (card)										 Fixed*	theRate);	/********************************************************	Set the rate at which line blending changes per pixel.		NOTE: Although this accepts a Fixed point value (16.16), the	maximum range allowable by the current hardware is -4.0..+4.0,	in a <3 bits>.<9 bits> format.		cs parameter record:		blendRatioRate	-> Fixed: 16.16 value	********************************************************/pascal short VESetBlendRatioRateOfChange(short		theDriver,			// which driver (card)										 Fixed		theRate);	/********************************************************	Get the line control mode, ie. what type of line commands are active.		cs parameter record:		mode 	<- LineControlMode:	{ lineControlOff, activeLineControl, preScanLineControl, activeAndPreScanLineControl }	********************************************************/pascal short VEGetLineControlMode(short		theDriver,			// which driver (card)								  short*	theMode);	/********************************************************	Set the line control mode, ie. what type of line commands are active.		cs parameter record:		mode 	-> LineControlMode:	{ lineControlOff, activeLineControl, preScanLineControl, activeAndPreScanLineControl }	********************************************************/pascal short VESetLineControlMode(short	theDriver,			// which driver (card)								  short	theMode);	/********************************************************	Copy the line command buffer to some local storage.		cs parameter record:		rect 		-> Rect:	defines the region, in lines and commands		commands	-> Ptr:		pointer to LineControlCommand	********************************************************/pascal short VEGetRawLineCommands(short	theDriver,			// which driver (card)								  Rect	theRect,								  void*	theCommands);	/********************************************************	Copy the local command buffer to the line command memory on the VX card.		The rectangle parameter is the destination bounds into the hardware	line command array. For example, to copy two line commands for the first	480 lines, the rectangle would be {0, 0, 480, 2}, and the source	pointer would point to to a buffer of 960 line control commands (480	entries of two commands each). Each line control command is a single	long word.		cs parameter record:		rect 		-> Rect:	defines the region, in lines and commands		commands	-> Ptr:		load the line commands from this array	********************************************************/pascal short VESetRawLineCommands(short	theDriver,			// which driver (card)								  Rect	theRect,								  void*	theCommands);////	Pixel Control//	/********************************************************	Get the mode used by pixel control.		cs parameter record:		mode 		<- PixelControlMode:  { pixelIs8BitICF, pixelIs4BitDisplayChannel4BitPriority,							pixelIs7BitICF1BitChoiceControl, pixelIs8BitChoiceControl,							pixelIsCaptureAndShiftControl }		source		<- ICFSource:	{ ICFSourceFromPixelControl, ICFSourceFromNoise }		signState	<- BitState:	{ if true ICF is 8 bit signed value -.9999 to 9999						   if false ICF is 8 bit value 0 to 1.9999 }		ICFScaleSource 	<- ICFscaleFactorSource: { ICFscaleFactorFromRegister, ICFscaleFactorFromPixelControl,						   ICFscaleFactorFromNoise }	********************************************************/pascal short VEGetPixelControlMode(short	theDriver,		// which driver (card)								   short*	theMode,								   short*	theSource,								   short*	theSignState,								   short*	theICFScaleSource);	/********************************************************	Set the mode used by pixel control.		cs parameter record:		mode 	-> PixelControlMode:	{ pixelIs8BitICF, pixelIs4BitDisplayChannel4BitPriority,						pixelIs7BitICF1BitChoiceControl, pixelIs8BitChoiceControl,						pixelIsCaptureAndShiftControl }		source		-> ICFSource:	{ ICFSourceFromPixelControl, ICFSourceFromNoise }		signState	-> BitState:	{ if true ICF is 8 bit signed value -.9999 to 9999						   if false ICF is 8 bit value 0 to 1.9999 }		ICFScaleSource 	-> ICFscaleFactorSource: { ICFscaleFactorFromRegister, ICFscaleFactorFromPixelControl,						   ICFscaleFactorFromNoise }	********************************************************/pascal short VESetPixelControlMode(short	theDriver,		// which driver (card)								   short	theMode,								   short	theSource,								   short	theSignState,								   short	theICFScaleSource);	/********************************************************	Get one of the ICF Pixel registers.		NOTE: Although this returns a Fixed point value (16.16), the	maximum range allowable by the current hardware is -1.0..+1.0,	in a 1.7 bit format for the ICF value.		cs parameter record:		pixelSelect 	-> PixelSelectChoice:	{ pixel0Select, pixel1Select }		pixelICF	<- Fixed: 16.16 value	********************************************************/pascal short VEGetPixelICF(short	theDriver,				// which driver (card)						   short	pixelSelect,			// PixelSelect0, PixelSelect1						   Fixed*	pixelICF);				// 16.16 value. 1.7 useable bits	/********************************************************	Set one of the ICF Pixel registers.		NOTE: Although this accepts a Fixed point value (16.16), the	maximum range allowable by the current hardware is -1.0..+1.0,	in a 1.7 bit format for the ICF value.		cs parameter record:		pixelSelect 	-> PixelSelectChoice:	{ pixel0Select, pixel1Select }		pixelICF	-> Fixed: 16.16 value	********************************************************/pascal short VESetPixelICF(short	theDriver,				// which driver (card)						   short	pixelSelect,			// PixelSelect0, PixelSelect1						   Fixed	pixelICF);				// 16.16 value. 1.7 useable bits	/********************************************************	This gets the channel the Multiplier is watching.		cs parameter record:		pixelSelect		-> PixelSelectChoice: { Pixel0Select, Pixel1Select }		multiplierID		-> MultiplierID: { multiplier1 }		multiplierColumn	-> INTEGER: Column affected (1..3) [column = PixelMultiplierInputSource]		multiplierChannel	<- Channel: {inputModuleChannel, liveDigitalInChannel, videoBus1Channel,							videoBus2Channel, CLUT1Channel, CLUT2Channel,							MultiplierDefaultColorChannel, NoiseGeneratorChannel }	********************************************************/pascal short VEGetPixelMultiplierChannel(short	theDriver,				// which driver (card)										 short	pixelSelect,			// PixelSelect0, PixelSelect1										 short	multiplierID,			// multiplier1										 short	multiplierColumn,		// Column affected (1..3) (also called multiplier source)										 short*	multplierChannel);		// which channel	/********************************************************	This sets the channel the Multiplier is watching.		cs parameter record:		pixelSelect		-> PixelSelectChoice: { pixel0Select, pixel1Select }		multiplierID		-> MultiplierID: { multiplier1 }		multiplierColumn	-> INTEGER: Column affected (1..3) [column = PixelMultiplierInputSource]		multiplierChannel	-> Channel: {inputModuleChannel, liveDigitalInChannel, videoBus1Channel,							videoBus2Channel, CLUT1Channel, CLUT2Channel,							MultiplierDefaultColorChannel, NoiseGeneratorChannel }	********************************************************/pascal short VESetPixelMultiplierChannel(short	theDriver,				// which driver (card)										 short	pixelSelect,			// PixelSelect0, PixelSelect1										 short	multiplierID,			// multiplier1										 short	multiplierColumn,		// Column affected (1..3)										 short	multplierChannel);		// which channel	/********************************************************	This gets the channel the thresholder is watching.		cs parameter record:		pixelSelect		-> PixelSelectChoice: { Pixel0Select, Pixel1Select }		thresholderID		-> ThresholderID: { thresholder1 }		thresholderChannel	<- Channel: 	********************************************************/pascal short VEGetPixelThresholderChannel(short		theDriver,					// which driver (card)										  short		pixelSelect,				// PixelSelect0, PixelSelect1										  short		thresholderID,				// thresholder1										  short*	thresholderChannel);		// which channel	/********************************************************	This sets the channel the thresholder is watching.		cs parameter record:		pixelSelect		-> PixelSelectChoice: { Pixel0Select, Pixel1Select }		thresholderID		-> ThresholderID: { thresholder1 }		thresholderChannel	-> Channel: 	********************************************************/pascal short VESetPixelThresholderChannel(short	theDriver,					// which driver (card)										  short	pixelSelect,				// PixelSelect0, PixelSelect1										  short	thresholderID,				// thresholder1										  short	thresholderChannel);		// which channel	/********************************************************	This gets the color format for the pixel0/pixel1 color format.	The format will either be all 3 components unaltered (24-bits, 8 bits/	component), or one of the components duplicated to the other two components.		cs parameter record:		pixelSelect	-> word:	{ Pixel0Select, Pixel1Select }		ColorFormat	<- word:	{ color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue }	********************************************************/pascal short VEGetPixelDisplayChannelColorFormat(short	theDriver,				// which driver (card)												 short	pixelSelect,			// PixelSelect0, PixelSelect1												 short*	colorFormat);			// Color24, Color24fromAlpha, Color24fromRed, Color24fromGreen, Color24fromBlue	/********************************************************	This sets the color format for the pixel0/pixel1 color format.	The format will either be all 3 components unaltered (24-bits, 8 bits/	component), or one of the components duplicated to the other two components.		cs parameter record:		pixelSelect	-> PixelSelectChoice: { Pixel0Select, Pixel1Select }		ColorFormat	-> word:	{ color24, color24fromAlpha, color24fromRed, color24fromGreen, color24fromBlue }	********************************************************/pascal short VESetPixelDisplayChannelColorFormat(short	theDriver,				// which driver (card)												 short	pixelSelect,			// PixelSelect0, PixelSelect1												 short	colorFormat);			// Color24, Color24fromAlpha, Color24fromRed, Color24fromGreen, Color24fromBlue	/********************************************************	Get the Pixel Noise Generator's Mode		cs parameter record:		noiseBits			<- word: { 8, 9 } (8-bit noise, or 9-bit noise)		signedNoise			<- BitState:	if true noise is signed		synchronous			<- BitState:	if true noise is synchronous to a frame	********************************************************/pascal short VEGetPixelNoiseMode(short		theDriver,				// which driver (card)								 short*		noiseBits,				// 8-bit noise, or 9-bit noise								 bitstate*	signedNoise,			// if true noise is signed								 bitstate*	synchronous);			// if true noise is synchronous to a frame	/********************************************************	Set the Pixel Noise Generator's Mode		cs parameter record:		noiseBits			-> word: { 8, 9 } (8-bit noise, or 9-bit noise)		signedNoise			-> BitState:	if true noise is signed		synchronous			-> BitState:	if true noise is synchronous to a frame	********************************************************/pascal short VESetPixelNoiseMode(short		theDriver,				// which driver (card)								 short		noiseBits,				// 8-bit noise, or 9-bit noise								 bitstate	signedNoise,			// if true noise is signed								 bitstate	synchronous);			// if true noise is synchronous to a frame////	Analog Input Module//	/********************************************************	Get serial communictions info from the input module.		NOTE: Regardless of whether the IMD output is enabled, this	sets the output state. If enabling IMD for output, the state	is set first, so there is no glitch when enabling the output.		NOTE: The order in which the outputs are set are IMC, IMD, and IMI.	Thus if the serial bus were used for clocking data, the data can be	stablized on IMC and IMD (if enabled for output), then IMI would be	written to clock it.		cs parameter record:		IMDOutputEnable	<- BitState: if True, enables IMD as output		IMCOutput	<- BitState: output bit		IMIOutput	<- BitState: output bit		IMDOutput	<- BitState: output bit		IMDInput	<- BitState: input bit	********************************************************/pascal short VEGetSerialBusControl(short			theDriver,				// which driver (card)								   VESerialState*	theState);	/********************************************************	Set serial communictions info from the input module.		NOTE: Regardless of whether the IMD output is enabled, this	sets the output state. If enabling IMD for output, the state	is set first, so there is no glitch when enabling the output.		NOTE: The order in which the outputs are set are IMC, IMD, and IMI.	Thus if the serial bus were used for clocking data, the data can be	stablized on IMC and IMD (if enabled for output), then IMI would be	written to clock it.		cs parameter record:		IMDOutputEnable	-> BitState: if True, enables IMD as output		IMCOutput	-> BitState: output bit		IMIOutput	-> BitState: output bit		IMDOutput	-> BitState: output bit	********************************************************/pascal short VESetSerialBusControl(short			theDriver,				// which driver (card)								   VESerialState*	theState);	/********************************************************	Get the status of the analog input module.		cs parameter record:		status	<- long: daughterboard status signature	********************************************************/pascal short VEGetLiveADConfigurationStatus(short	theDriver,				// which driver (card)											long*	theStatus);////	RAMDAC//	/********************************************************	This gets the base address of the memory mapped Brooktree 473 RAMDAC.	This is provided so that the DAC can be programmed directly.		For the Docking Card:	This gets the base address of the memory mapped output module RAMDAC	 (assuming it has one).  THis is a Bt473 on the RGB output module, and a	 Bt291 on the D1 output module.		NOTE: The driver already initializes the RAMDAC, and the color environment	can be set through GetGamma and SetGamma driver calls.	********************************************************/pascal short VEGetDACInfo(short	theDriver,				// which driver (card)						  long*	theInfo);//___ Moved here from Old XDriverAccess. (TWP, 93/09/29)short VDDoPBStatus(short theDriver, short theCode, char* theVEParam);short VDDoPBControl(short theDriver, short theCode, char* theVEParam);#ifdef __cplusplus}#endif////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#endif