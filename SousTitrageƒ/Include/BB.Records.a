* ----------- DEBUGGING INFORMATION -------------* This is used as a global switch to turn off the generation of debugging information.* The MACRO "DbgInfo" will generate this debugging information if set to 1.			INCLUDE	'TimeEqu.a'		; pour utiliser le time managerDebuggerInfo	EQU	1* ================================================* --------   MACRO DEFINITIONS SECTION  ----------* ================================================* ------------- GENERATE A PASCAL "CASE" OR "IF" SEQUENCE -------------* The following macro is used to generate a branch based on an index value* in a D-register with a value from 0 to N.  The branch is through a table* of relative addresses also generated by this macro. The macro is called* in one of two forms as follows:*  {Form #1}	Case#		(Dreg,Default),case0,case1,...caseN*  {Form #2}	Case#.<size>	(Dreg,IF),(cst0,case0),...,(cstN,caseN)* In Form #1, the "Default" specifies a label for any omitted case labels not* specified explicitly. The "case0", "case1",..."caseN" are case labels* identifying the various cases to be processed.  A case label may be omitted,* in which case the "Default" is used. The "Default" may also be omitted, but* in that case all case labels must be specified. If there are fewer case labels* than there are cases, but there are N possible values for the case index, the* proper number of trailing commas must be supplied to generate the defaults.* In Form #2, the default is specified as the word "IF".  In this form the macro* generates a set of compares (CMPI's) and branches (BEQ) for each specified* case (there is no implicit default).	Each case is a constant/label pair.* The constant is compared (CMPI.W) and an branch is done (BEQ) to the case if* the Dreg equals the constant.  A size may be specified for all the branches* as a <size> attribute to the Case# call itself.  This must either be an "S"* or "W" to generate BEQ.S's or BEQ.W's.  The default is for "S".		MACRO		Case#.&Size 	&IdxDef		PRINT		Push,NoMDir 	; only list generated code		LCLA		&i		; index to macro parameters		LCLA		&n		; total number of macro parameters		LCLC		&Dreg,&Def	; the Dreg and Default parameters		LCLC		&sz 		; the <size> value&Dreg		SETC		&IdxDef[1]	; pick off 1st opnd of sublist&Def		SETC		&IdxDef[2]	; pick off 2nd opnd of sublist&n		SETA		&Nbr(&Syslist)	; done for efficiency&i		SETA		2		; cases start at 2nd parameter IF &UpCase(&Def) <> 'IF' THEN.* Create the jump table and the index value* -----------------------------------------------	ADD 		&Dreg,&Dreg	MOVE		Case&SysNdx(&Dreg),&Dreg	JMP 		Case&SysNdx(&Dreg)Case&SysNdx	WHILE &i <= &n DO				; process each case label	   IF &SysList[&i] <> '' THEN		DC.W		&SysList[&i]-Case&SysNdx	   ELSE		DC.W		&Def-Case&SysNdx	   ENDIF	   &i: SETA &i+1 				; count off parameter	ENDWHILE ELSE							; process (Cst,lbl) pairs.* Create a series of CMPI and BEQ instructions* -----------------------------------------------	&Sz: SETC &Default(&Size, 'S') 			; setup size attribute	WHILE &i <= &n DO				; process each (Cst,lbl) pair	   CMPI.&sz		#&SysList[&i,1],&Dreg	   BEQ.w 	&SysList[&i,2]	   &i: SETA &i+1				; count off parameter	ENDWHILE ENDIF		PRINT	Pop 				; restore original print status		ENDM* ------------- GENERATE DEBUGGER SYMBOL INFORMATION -------------* This Macro will generate information for the debugger to read and display* as its module name.  This aids in debugging Asm code while looking at it* in the debugger.  This macro can only work if called at the end of stack* frame.  The appearance of the Macro statement in the source code must occur* immediately after the final "JMP   (A0)" or "RTS" instruction following the UNLINK.* Spaces may be included in the name, but no quotes are allowed.*  {Form #1}	DbgInfo		ModName*  {Form #2}	DbgInfo.New	Really Long Module Name For MacsBug 6.0* There are now two naming conventions used in MacsBug, Form #1 is the older MacsBug,* or TMON, and Form #2 is the newer MacsBug 6.0.  The older method would only* allow for a fixed length of eight characters.  If a shorter name is passed to* this Macro, it will extend the length to 8 chars with trailing spaces.* MacsBug 6.0 will now allow for a variable length C type string. This Macro will* create the proper DC statements and takes into account word alignment issues.		MACRO		DbgInfo.&Opt 	&ModName#	; the name to be used in the Debugger		PRINT		Push,NoMDir 	; Only list generated code		LCLC		&DbgName#	; name to generate for MacsBug		LCLC		&DbgTemp	; temporary name variable		LCLC		&New		; variable used to test old vs. new		LCLC		&S		; variable used to save PRINT state IF DebuggerInfo THEN						; do we want debugging info?    IF &ModName# ≠ '' THEN					; did we get a module name?	&New: SETC &UpCase(&Opt)				; make option all upper case	IF (&New = 'NEW') THEN					; do we want new style?.* Create the new MacsBug naming convention* -----------------------------------------------	   &DbgTemp: SETC	&ModName#			; generate new type symbols	   IF &Len(&ModName#) < 32 THEN				; if module name < 32 chars		IF &Len(&ModName#) // 2 = 0 THEN 		; add space if even so that...		   &DbgTemp: SETC &Concat(&ModName#,' ') 	; string length plus length byte...		ENDIF						; will align to word boundary	   &DbgName#: SETC &Concat(&Chr($80 + &Len(&ModName#)), &DbgTemp)	   ELSE							; Length > 32 characters		IF &Len(&ModName#) // 2 = 1 THEN 		; add space if length is odd		   &DbgTemp: SETC &Concat(&ModName#,' ')		ENDIF	   &DbgName#: SETC &Concat(&Chr($80), &Chr(&Len(&ModName#)), &DbgTemp)	   ENDIF	ELSE							; make it the older style.* Create the older MacsBug naming convention* -----------------------------------------------	   IF &Len(&ModName#) < 8 THEN				; if module name < 8 chars		&DbgName#: SETC &Concat(&ModName#,'       ')	; add at least 7 spaces		&DbgName#: SETC &Concat(&Chr($80 + &ORD(&SubStr(&DbgName#,1,1))), &SubStr(&DbgName#,2,7))	   ELSE							; there are at least 8 chars		&DbgName#: SETC &Concat(&Chr($80 + &ORD(&SubStr(&ModName#,1,1))), &SubStr(&ModName#,2,7))	   ENDIF	ENDIF			IF demo=1 THEN	   		&DbgName#:SETC 'Fuck you!'			ENDIF.* Create the DC.B with the debugger name, and include the NULs if new MacsBug option* -----------------------------------------------	&S: SETC &Setting('STRING')		; preserve STRING status	IF &S ≠ 'ASIS' THEN			; only change it if not already ASIS	   STRING    ASIS	   		DC.B      '&DbgName#'	   IF (&New = 'NEW') THEN		DC.W		0		; fake literal size for new MacsBug	   ENDIF	   		STRING    &S	ELSE	   		DC.B      '&DbgName#'	   IF (&New = 'NEW') THEN		DC.W		0		; fake literal size for new MacsBug	   ENDIF	ENDIF   ENDIF ENDIF		PRINT	Pop 			; restore original print status		ENDM		MACRO		BREAK		PRINT		Push,NoMDir		Pea		#'BREAK'		_DEBUGSTR		PRINT	Pop 		ENDM*	******************************************************************	Macro OpenDialog*	*****************************************************************;  	cette routine ouvre un dialog temporaire ;	;; 		MACRO 		OpenDialog   &id   		PRINT		Push,NoMDir 		clr.l	-(sp)		move.w	#&id ,-(sp)	; id number		pea		DialogStorage(a6)			move.l	#-1,-(sp)		_GetNewDialog		move.l	(sp)+,d0   ;; on trace le contour du bouton rechercher				pea		DialogStorage(a6)		move.w	#1,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem				pea		DialogStorage(a6)		_SetPort				move.w	#3,-(sp)		move.w	#3,-(sp)		_PenSize				pea		itemRect(a6)		move.w	#-4,-(sp)		move.w	#-4,-(sp)		_InsetRect				pea		itemRect(a6)		move.w	#16,-(sp)		move.w	#16,-(sp)		_FrameRoundRect 		PRINT	Pop  		ENDM*	******************************************************************	Macro Changetexte &item,&text*	*****************************************************************;  	cette routine change le texte d'un item du dialog  DialogStorage(a6);	;	elle assume que le dialog est DialogStorage(a6); 		MACRO 		Changetexte (&item,&text) 		PRINT		Push,NoMDir 		pea		DialogStorage(a6)		move.w	#&item,-(sp)		pea		ItemType(a6)		pea		ItemHandle(a6)		pea		itemRect(a6)		_GetDItem		move.l	ItemHandle(a6),-(sp)		pea		&text			_SetItext 		PRINT	Pop  		ENDM* ================================================* ---------------  EQUATE SECTION  ---------------* ================================================* Some various EQUATES we'll use throughout the program.* -----------------------------------------------false		EQU	0		; the value of Falsetrue		EQU	$0101		; and you thought True = 1, HA!nil		EQU	0		; a NIL pointer to test againstdemo  equ 0** Défintion des segments du programmeSegmentConversion	equ	2ToolTrapBit	EQU	11		; this bit is on for Tool trapsWaitNextEvent	EQU	$A860		; the WaitNextEvent trap numberUnimplemented	EQU	$A89F		; the Unimplemented trap numberEnvironsVersion	EQU	1		; this is the version of the SysEnvirons we wantSleepValue	EQU	$0	; the sleeping time ($7FFFFFFF = MaxLongInt)SuspendResume	EQU	1		; the suspend/resume event number of an OSEventNoEvents	EQU	0		; no events maskExtremeNeg	EQU	-32768		; for wide open rects and regions, see AdjustCursorExtremePos	EQU	32767-1		; -1 is because of a bug in regions, see AdjustCursor* This is the minimum result from the following equation:*	applLimit - applZone = minimum heap size* for the application to run. It will insure that enough memory will* be around for reasonable-sized scraps, FKEYs, etc. to exist with the* application, and still give the application some 'breathing room'.* To derive this number, we ran under a MultiFinder partition that was* our requested minimum size, as given in the 'SIZE' resource.MinHeap		EQU	60*1024		; minimum heap size in bytes* This is the minimum exceptable result from PurgeSpace, when called* at initialization time, for the application to run. This number acts* as a double-check to insure that there really is enough memory for the* application to run, including what has been taken up already by* pre-loaded resources, the scrap, code, and other sundry memory blocks.MinSpace	EQU	10*1024		; minimum stack space in bytes* The following equates use for resources.  That's why they have a "r" in front.* -----------------------------------------------rMenuBar	EQU	128		; application's menu barrUserAlert	EQU	129		; error alert for userrWindow		EQU	128		; application's windowrAboutAlert	EQU	128		; about alertrStopRect	EQU	128		; rectangle for Stop lightrGoRect		EQU	129		; rectangle for Go light* The following equates are for menu definitions, obviously.* -----------------------------------------------AppleMenu	EQU	128		;  Apple menuAboutItem	EQU	1FileMenu	EQU	129		;  File menuNewItem		EQU	1OpenItem	EQU	2SaveItem	EQU	4SaveAsItem	EQU	5ExportItem	EQU	7	PageSetupItem	EQU	9PrintItem	EQU	10QuitItem	EQU	12EditMenu	EQU	130		;  Edit menuUndoItem	EQU	1CutItem		EQU	3CopyItem	EQU	4PasteItem	EQU	5ClearItem	EQU	6InsererSTItem	EQU	8OterSTItem	EQU	9PreferenceItem  EQU 11Preference2Item	equ	12lecteurTimeCode	equ	14touchesFonction	equ	16; équivalence pour NICE FELLOW  francisation des 	EQUAnnulerItem	equ	UndoItemCouperItem		equ	CutItemCopierItem		equ	CopyItemCollerItem		equ	PasteItemEffacerItem		equ	ClearItem		DiversMenu			EQU	131		;  style menuStyleItem			equ	1TailleItem			equ	2RechercherItem		equ	4RechercherTexteItem	equ	6ContinuerItem		equ	7RemplacerItem		equ	9VerifierListeItem	equ	11DecalerItem			equ	13ClasserItem			equ	15OffsetTCItem		equ	17RenumeroterItem		EQU	19fenetreMenu		equ		132HomeItemMenu			equ		1SaisieItemMenu			equ		3ListingItemMenu			equ		4ServiceItemMenu			equ		5TimeCodeItemMenu		equ		6DialogItemMenu			equ		7TelecommandeItemMenu	equ		8ConfigTCWindowItem		equ		10ModeTravailMenu			EQU	133SaisieMode_TimecodeItem	equ	1SaisieMode_TexteItem	equ	2SaisieMode_AucunItem	equ	3SaisieMode_checkMarkChar	equ	'»'TrackingItemMenu		equ	8Tracking_CheckMarkChar	equ		'≠'* -----------------------------------------------DITopLeft	EQU	$00500070	; position of Disk Init dialogs* correspondance pour dialog préférence page 1 et 2Pref_OkItem				equ	1Pref_CancelItem			equ	2Pref_TitreOriginalItem	equ	4Pref_TitreFrancaisItem	equ	3Pref_NomAdaptateurItem	equ	5Pref_ClientItem			equ	6Pref_commentaire		equ	7Preference_NombreSauvItem	equ	8Preference_AutoCheckItem	equ	9Preference_UtilCheckItem	equ	10Preference_KernCheckItem	equ	11Preference_IntervalItem		equ	12Preference_LisiItem			equ	13Preference_RenumerotationItem	equ 30* correspondance pour dialog préférence page 2Preference_EnchaineSoustraireOutItem	equ	3Preference_EnchaineAddTCInItem			equ	4Preference_FinderItem					equ	5Preference_SaisieLockItem				equ	11Preference_OffsetTimeCodeCheckItem		equ	14Preference_OffsetTimeCodeTEItem			equ	15* ------------------------------------------------typeSaisieWindow 	 	equ 1typeListingWindow		equ 2typeServiceWindow		equ	3typeTimeCodeWindow		equ	4typeAffichageWindow		equ	5TypeTelecommandeWindow	equ	6typeBackDropWindow		equ	1000* ------------------------------------------------* correspondance pour le dialogue SaisieDialSaisie_StsuivantItem		equ	1DialSaisie_StPrecedantItem		equ	2DialSaisie_InsertItem			equ	3DialSaisie_Rechercher			equ	4DialSaisie_PopUpItem			equ	5DialSaisie_TCInControlplus		equ	6DialSaisie_TCInControlmoin		equ	7DialSaisie_TCOutControlplus		equ	8DialSaisie_TCOutControlmoin		equ	9DialSaisie_MarKInItem			equ	10DialSaisie_MarkOutItem			equ	11DialSaisie_TexteSTTEItem		equ	12DialSaisie_CommentaireTEItem	equ	13DialSaisie_TcInTEItem			equ	14DialSaisie_TcOutTEItem			equ	15DialSaisie_DureeTEItem			equ	16DialSaisie_NumStItem			equ	17DialSaisie_TotalStItem			equ	18DialSaisie_LisibiliteItem		equ	19DialSaisie_NormalItem			equ	26DialSaisie_ItalicItem			equ	27DialSaisie_GrasItem				equ	28DialSaisie_SouligneItem			equ	29SaisieMode_Timecode				equ	1SaisieMode_Texte				equ	2SaisieMode_Aucun				equ	3* --------------- ITEM POUR DIALOG RECHERCHER SOUS-TITREDial_Rechercher_RechercheItem	equ	1Dial_Rechercher_AnnulerItem		equ	2Dial_Rechercher_TcTEItem		equ	3Dial_Rechercher_NumTe			equ	4Dial_Rechercher_RatioTCItem		equ	5Dial_Rechercher_RationNumItem	equ	6* -------------- paramètres pour le dessin de listing window ListingHauteurCarreST			equ	64	; au lieu de 52ListingEntre2CarreSt			equ	3MODULO	EQU	2	; ratio* -------------- équivalences pour les edits textes * -------------- et les code de UndoTexte_SousTitre					equ		1Commentaire_SousTitre			equ		2TimecodeIn_SousTitre			equ		3TimecodeOut_SousTitre			equ		4Duree_SousTitre					equ		5TimecodeIn_SousTitrebcd			equ		6	;undo uniquementTimecodeOut_SousTitrebcd		equ		7	;undo uniquement* -------------- uniquement 625/50 pour l'instant				FrameRate						equ	25* --------------- équivalence pour routines fichierAsciiType_Brute					equ		1 	; fichier ascii brute cf reaAsciiType_TraitementDeTexte		equ		2	; fichier ascii type traitement de texte	; idem mais plus court en texte	AsciiType_1						equ		1AsciiType_2						equ		2	* --------------- équivalence pour routine exportation vers d'autre systèmeFichier_TypeTexte				equ		1Fichier_TypeN19					equ		2Fichier_TypeCMC					equ		3; ---DialExport_OkItem					equ		1DialExport_CancelItem				equ		2DialExport_TypeCMCItem				equ		3DialExport_TypeTexteItem			equ		5DialExport_TypeN19Item				equ		4DialExport_ConversionMSDOSItem		equ		6DialExport_CommentaireItem			equ		7DialExport_SousNumeroItem			equ		8; ---; dialogues rechercher / remplacer textesDial_RechercherItem					equ		1Dial_RemplacerItem					equ		1Dial_AnnulerItem					equ		2Dial_RechercherTEItem				equ		3Dial_MajusculeItem					equ		4Dial_RevenirDebutItem				equ		5Dial_Commentaire					equ		6Dial_DansZoneItem					equ		7Dial_DebutZoneTEItem				equ		8Dial_FinZoneTEItem					equ		9Dial_RemplacerTEItem				equ		10; ----; dialog décaler les textesDial_Decaler_DecalerItem			equ	1Dial_Decaler_AnnulerItem			equ	2Dial_Decaler_DebutTEItem			equ	3Dial_Decaler_FinTEItem				equ	4Dial_Decaler_DestinationTEItem		equ	5Dial_Decaler_NettoyerItem			equ	14; DIALOG "offset sur les time-codes"; dialog pour confirmation offset tc listeDial_OffsetTcListe_OkItem					equ	1Dial_OffsetTcListe_AnnulerItem				equ	2Dial_OffsetTcListe_TouteLaListeItem			equ	3Dial_OffsetTcListe_PartieDeListeItem		equ	4Dial_OffsetTcListe_FromTEItem				equ	5Dial_OffsetTcListe_ToTEItem					equ	6Dial_OffsetTcListe_OffsetTEItem				equ	7; dialog pour configuration fenètre time-codeDial_TCWindow_OK							equ	1Dial_TCWindow_Cancel						equ	2Dial_TCWindow_STenCour						equ	3Dial_TCWindow_STsuivant						equ	4Dial_TCWindow_BarGraph						equ	5Dial_TCWindow_Decompte						equ	6Dial_TCWindow_Bandeau						equ	7Dial_TCWindow_TEechelle						equ	8Dial_TCWindow_Rectangle						equ	9* ================================================* ----------------  RECORD TYPES  ----------------* ================================================* This section is declaring record structures.  These records are* templates.  No data is allocated at this point.  These are just* structures, similar to Pascal TYPEs.  They simply generate a list* of equate offsets.  Since none of these types are defined already* in the MPW AIncludes, we'll need to define them.* ------------- MOUSE POINT TYPE -------------Point		RECORD	0v		DS.W	1h		DS.W	1		ORG 	vvh		DS.W	h		ENDR* ------------- RECTANGLE TYPE -------------Rect		RECORD	0Top 		DS.W	1Left		DS.W	1Bottom		DS.W	1Right		DS.W	1		ORG 	TopTopLeft		DS.L	1BotRight	DS.L	1		ENDR* ------------- BITMAP TYPE -------------BitMap		RECORD	0baseAddr	DS.L	1rowBytes	DS.W	1bounds		DS.L	Rect		ENDR* ------------- EVENT RECORD TYPE -------------EventRecord 	RECORD	0What		DS.W	1Message 	DS.L	1When		DS.L	1Where		DS.L	PointModify		DS.W	1		ENDR* *************************************************************************** Record pour le passage de parramètre à la routine de rendu des caractères* ou bien description de la police en mémoire* **************************************************************************FontRenderRecord			RECORD	0NextFont_Handle			ds.l	1		; handle de la police suivante ; 0 si dernièreRender_handle			ds.l	1		; handle de la police en mémoire 0 si pas en mémoireRenderColor_handle		ds.l	1		; handle de la police colorée en mémoireFirst_Char				ds.w	1		; N° du 1 er caractère en mémoirelast_Char				ds.w	1		; N° du dernier  caractère en mémoirePlane_Number			ds.w	1		; nombre de plan pour chaque caractèreFace_Number				ds.w	1		; nombre de style par caractèreNormalKerning			ds.w	1		; kerning normal pour la fontmax_Ascent				ds.w	1		; ascent de la fontmax_descent				ds.w	1		; descent de la fontspaceWidth				ds.w	1		; largeur de l'espace $20, $cainterligne				ds.w	1		; distance normale entre 2 ligne de texteUseBold					ds.w	1		; KerningTable			ds.l	1		; table de kerning pour la font;spare_1					ds.w	5		; pour le futurFontSize				ds.w	1		; taille de la policeFontChar				ds.w	1		; n° du caractère àrendreFontNumber				ds.w	1		; n° de la police dans le macFontName				ds.b	256		; Name of fontFontStyle				ds.w	1		; style du caractèresFontRatio				ds.w	1		; $403 => 4:3 $1009 => 16:9FontQuality				ds.w	1		; facteur de grossissement (n.u.)FaceThickness			ds.w	1		; epaisseur de la face	FaceSkew				ds.w	1		;(n.u.)	FaceInclinaison			ds.w	1		;(nu)FaceHeight				ds.w	1		;(nu)FaceWidth				ds.w	1		;(nu)FaceBlur				ds.w	1		; facteur de blur  FacePlain				ds.w	1		; PlainOutline	(nu)FaceEffect				ds.l	1		; effect de rendu	(nu)FaceTextur				ds.l	1		; (nu)FaceRGBAlpha			ds.l	1		; (nu)FaceRGBAlpha2			ds.l	1		; (nu)FaceSpread				ds.w	1		; (nu)FaceSpare				ds.l	2		; (nu)BorderThickness		ds.w	1		; epaisseur de la face	BorderXoffset		ds.w	1		; offset en XBorderYoffset		ds.w	1		; offset en YBorderSkew			ds.w	1		;(n.u.)	BorderInclinaison	ds.w	1		;(nu)BorderHeight		ds.w	1		;(nu)BorderWidth			ds.w	1		;(nu)BorderBlur			ds.w	1		; facteur de blur  BorderPlain			ds.w	1		; PlainOutline	(nu)BorderEffect		ds.l	1		; effect de rendu	(nu)BorderTextur		ds.l	1		; (nu)BorderRGBAlpha		ds.l	1		; (nu)BorderRGBAlpha2		ds.l	1		; (nu)BorderSpread		ds.w	1		; (nu)BorderSpare			ds.l	2		; (nu)ShadowThickness		ds.w	1		; epaisseur de la face	ShadowXoffset		ds.w	1		; offset en XShadowYoffset		ds.w	1		; offset en YShadowSkew			ds.w	1		;(n.u.)	ShadowInclinaison	ds.w	1		;(nu)ShadowHeight		ds.w	1		;(nu)ShadowWidth			ds.w	1		;(nu)ShadowBlur			ds.w	1		; facteur de blur  ShadowPlain			ds.w	1		; PlainOutline	(nu)ShadowEffect		ds.l	1		; effect de rendu	(nu)ShadowTextur		ds.l	1		; (nu)ShadowRGBAlpha		ds.l	1		; (nu)ShadowRGBAlpha2		ds.l	1		; (nu)ShadowSpread		ds.w	1		; (nu)ShadowSpare			ds.l	2		; (nu)FontRenderRecord_SizeOf		equ	*					endR********************   descriptif des paramètres de la police rendue dans la mémoire; nb : on utilise les mêmes code pour les police colorées; pour l'instant on définie ici les paramètres suivant; ####; note 1: il pourra ètre nécéssaire d'insérer,; un coefficient de réentrée par la droite pour coller les caractères entres eux comme le T par ex; et aussi la hauteur max pour que cela puisse ètre actif.; on pourra utilisé le spare pour cela;; note 2: il faudra placer dans le style spare  adr: n° de style*8 +4;			le max ascent de la police.b , max descent.b , style type.b;;; note 3: il faut inclure dans le font record les parramètres suivants:;			normal spacing, underline position, min spacing ?, ... styleHeaderSize	equ	$0000008		CharHeaderSize	equ	00000020		CH_NextChar		equ	0CH_PreviousChar	equ	4CH_CharNumber	equ	8CH_Spare		equ	10		;(distance de réentrée, hauteur max de réentré ?)CH_Rect			equ	12PlaneInfoSize	equ	16pi_Rect			equ	0		; rectangle du planpi_PlaneBase	equ	8		; ptr du plan charpi_Baseline		equ	12		; base line du planpi_spare		equ	14		; spare * *************************************************** Header Descriptif de chaque caractère en mémoire* est indiqué ici à titre indicatif mais n'est pas utilisé  tel que ; dans le programmeRendered_In_Memory	RECORD	0NextChar		ds.l	1			;ptr  caractère suivantPreviousChar	ds.l	1			;ptr	caractère précédent	CharNumber		ds.w	1			;n° du caractère	; permet de connaitre l'absence d'un char dans la liste; area de rectangle pour définir la position des caractères; par rapport à chaque plan , chaque style; n représente le nombre de plan -1 ;rect0			ds		rect;\;\;\;\;Rectn			ds		rect; bitmap indique un plan mémoire de dimension    V= bottom ; H= Right; les paramètres left et top indique l'offset en position de chaque plan // caractère ;bitmap0			bitmap;\;\;\;\;Bitmapn			bitmap						endR* =================================================* =================================================* =================================================* =================================================* =================================================* ------------- THE QUICKDRAW WORLD -------------MyQDGlobals		RECORD	0private				ds.b 	76	RandSeed			DS.L	1ScreenBits		DS.B	BitMapArrow				DS.B	68dkGray				DS.B	8ltGray				DS.B	8Gray					DS.B	8Black				DS.B	8White				DS.B	8GrafPort 			DS.L	1thePort	equ	GrafPort 						ENDR* ------------- ALL OF OUR GLOBAL DATA -------------* Note the minimal amount of globals we're using.  Data such as* the EventRecord, WindowRecords, etc. do not belong in global data* allocation.  Only data that basically doesn't change through out the* execution of the program is considered global.  The boolean flags are* global, since they affect the state of the program at any given time.* Also note that any appearance of a DS outside of a stack frame will* be allocated off of A5 and becomes part of global data storage.	AppGlobals		RECORD	0		; this is our global data storage; ------------- HasWNEvent			ds.w	1		; boolean for WaitNextEvent trap, see ForceEnvironsInBackground			ds.w	1		; boolean for if in background, see OSEventMac					ds.b	SysEnvRec	; the system environment record, see ForceEnvirons;  ------------ le stockage des fenêtres du logiciel   ---------------BackDropWindow							ds.b	windowSizeDisplayWindow								ds.b	windowSizeListingWindow								ds.b	windowSizeOffscreenDisplay							ds.l	1;	GWorldPtrOffscreenListing							ds.l	1; GWorldPtrOffscreenSaisie								ds.l	1; GWorldPtrOffscreenRendering							ds.l	1; GWorldPtrOffscreenChenille							ds.l	1; GWorldPtrDuplicateOffscreenRendering					ds.l	1; GWorldPtrRenderingWindow							ds.b	windowSizeServiceWindow								ds.l		1		; Dlg ptrLogoWindow									ds.l		1		; Dlg ptrSpareWindow								ds.l	1SpareWindow1								ds.l	1SpareWindow2								ds.l	1;  ------------ le stockage des dialog du logiciel   ---------------BlockNoteWindow			ds.l	1 		;DialogPtrDialogAlertStorage			ds.b 	170	 	;dWindLenDialogSaisie				ds.b	170	 	;dWindLenDialogStorage				ds.b 170 		;dWindLenTELECOMMANDEWindow		ds.l	1		; DialogPtrChenilleWindow				ds.l	1		; DialogPtrErrorsWindow				ds.l	1		;	la fenêtre des erreursPerformanceWindow			ds.l	1		;	la fenêtre pour afficher les performances;  ------------ pour clef de protectionsoftware // fichier prèfSoftProtect	ds.w	1StartTicks	ds.l	1 ;pour temps  max demodemocount		ds.l	1 ;pour max affichage sous-titre;  ------------ pointeur ou handle de resourceResourceDATA128			ds.l	1		; HANDLE 	conversion MsDos<=> MacResourceDATA129			ds.l	1		; HANDLE	conversion Majuscule<=> MinusculeResourceDATA130			ds.l	1		; HANDLE	conversion Accentué <=> MajusculeResourceDATA1000			ds.l	1		; HANDLE	conversion Accentué <=> MajusculeIconHandle1				ds.l	1		; icon vitc onIconHandle2				ds.l	1		; icon vitc off	IconSauvegardeOn			ds.l	1		;sauvegarde onIconSauvegardeOff			ds.l	1		;sauvegarde offTheRes_number			ds.w	1			; Le refnum  des resources;  ------------ Handle de resource préférencePreference_PourAffichage				ds.l	1		; data 201Preference_PourTravail					ds.l	1		; data 202Preference_PourDernierePoliceAlias			ds.l	1		; data 202Preference_PourDernierFilmAlias			ds.l	1		; data 203; ---- pattern pour les fenêtresBackDrop_PatNum			ds.w	1Listing_PatNum				ds.w	1Saisie_PatNum				ds.w	1; ---- fonction  automatique à la lecture d'un fichier BbofAutoOpenBlockNote			ds.w	1AutoOpenCheckList			ds.w	1AutoOpenLastFont			ds.w	1Preference_MultiFinder		ds.w	1AutoOpenLastFile			ds.w	1; ------------ le control handle de listingListingVScroll					ds.l	1; ------------ le control handle de la fenêtre errors */ErrorWindowScroll				ds.l	1;; Handle pour la liste des erreurs trouvées */ListeError						ds.l	1;;  ------------ handle pour le quick openQuickOpenHandle				ds.l	1QuickOpenMenuHandle			ds.l	1;  ------------ handle de color cursorCurseurDessineST				ds.l	1;CurseurClearBuffer				ds.l	1;CurseurTransfert				ds.l	1;; --------  Buffers Offscreen  OffscreenDisplayBase		ds.l	1	;base bufferBlockNoteTE				ds.l	1		; handle du te pour le block noteBlockNoteTE_Item			ds.w	1	; item correspondant au te; --------  plan mémoire supplémentaire pour la fabrication des borduresDuplicateOffscreenBuffer				ds.l	1DuplicateOffscreenBuffer_handle	ds.l	1RenderingFont_handle					ds.l	1AltPixMapHandle					ds.l	1ListingTE							ds.l	1ListingTeStNum						ds.l	1	; abs num du te en cour 	ListingTeStItem						ds.w	1	; item en courListingMaxDisplay					ds.w	1CaseATickCountListing				ds.l	1General_futurSousTitreEncour			ds.w	1CaseALastPointListing				ds.l	1saisieTE								ds.l	1saisieTeStNum						ds.l	1	; abs num du te en cour 	saisieTeStItem						ds.w	1	; item en courGeneral_OffsetSurListing				ds.w	1 	; pour détection click listingGeneral_ClickOnce					ds.w	1  ; pour détection double Click;-------   Alias du fichier en cours ---aliashandle						ds.l		1		; handle pour le alias du fichier en cour; --------   Handle du menu fontPopUp_Source_Font_List				ds.l	1bufferTimecodeCourant				ds.b	64			; pour la conversion tc => ascii (près à l'emplois); --------   ADRESSE DU BUFFERTRANSFERTBufferTransfert					ds.L	1SIZEBufferTransfert					ds.L	1                              ; --------   PARAMETRES POUR LE FICHIER EN COUR ****CurrentvRefNum				ds.w	1CurrentFileType				ds.L	1	; TEXT Bbof ETC pas actifCurrentVersionNumber			ds.b	1unused						ds.b	1	CurrentFileName             			ds.b	256	            CurrentDirID					ds.l	1; attention les adresses de ces variables sont utilisés par la routine d'interuption; ne pas changer les longueurs sans vérifier la routine d'interuption "SERIAL"; ---- état du lecteur sérieSerialError						ds.w	1	VitcFilter							ds.l	1		; filtre pour le lecteur vitcSerial_WatchDog					ds.l	1		; chien de garde pour le lecteur sérieSendVtrTime_state					ds.w	1		; dernière demande de tc completed si =0; ---- patch pour la configuration du lecteur de timecodeLecteurTimeCode_Type							ds.w	1		; type de l'interface timecodePlayer_TC_src									ds.w	1		; choix du tc playerMode_Commutateur								ds.w	1		; mode commutateur; ---- tc pour le logicielVitc_Readen									ds.l	1General_TCCourant								ds.l	1General_LastTCCourant							ds.l	1General_PseudoTimeCode							ds.l	1LastRecevied422TC								ds.l	1	; pour mode auto Ltc/vitc; ----  Les IOParams pour E/S série Main_Rx_PB					ds.b	ioPosOffset+4;	// pour la routine principale sérieGeneral_A5register_1			ds.l	1;Main_Rx__PB_Buffer			ds.l	1;Sony_Rx_PB					ds.b	ioPosOffset+4;// pour la reception protocole SonyGeneral_A5register_2			ds.l	1;Tx_modem_Buffer				ds.l	1;Vitc_Rx_PB					ds.b	ioPosOffset+4;// pour la reception protocooe Lecteur VitcGeneral_A5register_3			ds.l	1;Vitc_Rx_PB_Buffer				ds.l	1;Tx1_PB						ds.b	ioPosOffset+4;//pour l'interogation du time codeGeneral_A5register_4			ds.l	1;Tx1_PB_Buffer					ds.l	1;Spare_PB						ds.b	ioPosOffset+4;// spare pour transmissionGeneral_A5register_5			ds.l	1;Spare_PB_Buffer				ds.l	1;Spare1_PB					ds.b	ioPosOffset+4;// spare2 pour transmissionGeneral_A5register_6			ds.l	1;Spare1_PB_Buffer				ds.l	1;;/* Divers Compteurs pour mesurer les  performances Logiciel/Machine  */EventLoop_Speed				ds.l	1;EventLoop_Counteur				ds.l	1;Serial_Main_Count				ds.l	1;Serial_Main_rate				ds.l	1;Serial_Vitc_Count				ds.l	1;Serial_Vitc_rate				ds.l	1;Serial_Sony_Count				ds.l	1;Serial_Sony_rate				ds.l	1;;/* record pour le time manager de la routine d'interrogation du times code et status;des vtrs */performanceTask				ds.b tmXQSizeAskTcTask					ds.b tmXQSizeGenerateurTask					ds.b tmXQSizeVtrTask_flag_1					ds.w	1;  //flag pour la routine status/time; ----------indicateur si AppleTalk a été fermé par nos soinAppleTalkClosed						ds.w	1General_OffsetTimeCode					ds.l	1		; offset sur tc Lu (trames signé); -----------mémoire pour le dernier sous-titre trouvéGeneral_SousTitretrouve			ds.w	1		; sous- titre trouvé lors d'une recherche; sauvegarde des RefNums des des sérials  driversModemOutRefNum		ds.w	1ModemInRefNum		ds.w	1; ------------mémoire pour le sous-titre en courGeneral_SousTitreEncour				ds.l	1		; sous-titre en cour de traitement;;General_SousTitreEncour_spare		; //spare dans C_ globals.h   pour avoir la même longueurGeneral_LastSousTitrecourant		ds.l	1		; dernier sous-titre en cour de traitementGeneral_SousTitrecourant				ds.l	1		; sous-titre en cour de traitementGeneral_SousTitreCourantPtr		ds.l	1		; son pointeur; ----------- flags de transfert entre routine interruptionet routine principaleTcInaAttendre								ds.l	1		;TcOutaAttendre							ds.l	1		;TravailAFaire_Affichage				ds.w	1		;; ----------- mémoire pour le dessin du sous-titre à l'écranGeneral_SousTitreHasChange		ds.l	1		; true si le st courant a changéGeneral_DrawState						ds.l	1		; état du rendererGeneral_STCourantOnScreen			ds.l	1		; le st courant est-il a l'écranSous_titre_dessined						ds.l	1		; cache du st dans la ramSous_titreInOffscreen					ds.l	1		; cache du st dans le buffer offscreenDrawState									ds.w	1		; flag pour dialoguer avec la vbl task				graphDevForRenderFont				ds.l	1		; le gdevice pour les rendu de charOffscreenRenderedRect					ds.l	2ScreenRenderedRect						ds.l	2OffscreenRendered						ds.w	1ScreenRendered							ds.w	1General_SousTitreDisplayed			ds.w	1		; AbsNumdu st à l'écran; ----------- structure contenant le status des VTRsRecorderStruct								ds.b	66PlayerStruct								ds.b	66; ----------- chaine de caractères pour rechercher/remplacerRechercher_STR							ds.b	256Remplacer_STR							ds.b	256Rechercher_Majuscule					ds.w	1	; si true case sensitiveRechercher_RevenirDebut				ds.w	1	; wrap around searchRechercher_Commentaire				ds.w	1	; flag pour indiquer si la rechehche doit se faire dans la chaine commentaireRechercher_DansZoneFlag				ds.w	1	; flag si zone de rechercheRechercher_DebutZone 					ds.l	1	; ptr du premier st de rechercheRechercher_finZone 						ds.l	1	; ptr du dernier st de rechercheRechercher_STPTr						ds.l	1	; pointeur du dernier sous titre trouveRechercher_StartOffset 				ds.w	1	; position du premier caractère trouvéRechercher_EndOffset 					ds.w	1	; position du dernier caractère trouvéRechercher_InCommentaire			ds.w	1	; flags pour indiquer si la chaine a été trouver dans un commentaire; ----------- variable pour le chien de gardeWatchDogSerial								ds.l	1	;  variable pour le port sérieWatchDogSave								ds.l	1	; variable pour sauvegarde automatiqueChangeSinceLastSave					ds.w	1	; true si liste mofifiée depuis dernière sauvegarde; ---------- flags pour tracking de la fenètre listingPreference_HardTracking				ds.w	1Preference_Tracking					ds.w	1; ---------- cache pour la routine conversion num => ptr General_DernierNumConvertiPtr	ds.l	1; ---------- sauvegarde pour le dialog changer style et policeChangeStyleDialog_Mode			ds.w	1ChangeStyleDialog_style			ds.w	1ChangeStyleDialog_font				ds.w	1ChangeStyleDialog_debut			ds.l	1ChangeStyleDialog_fin				ds.l	1; -------- variables pour l'exportation vers d'autres logicielsPreference_TypeExport					ds.w	1Preference_ConvertMsDos				ds.w	1Preference_InclureCommentaire		ds.w	1Preference_InclureSousNumero			ds.w	1Preference_N19_TypeTeletexte		ds.w	1Preference_DoubleHauteur				ds.w	1Preference_DoubleLargeur				ds.w	1Preference_Couleur							ds.w	1; mémoire pour l'affichage de la fenètre time code; c.f. déclaration de variablesPreference_DisplayTimeCode			ds.w	1Bandeau_LastTC								ds.l	1Echelle_Bandeau								ds.w	1last_BarGraph									ds.w	1General_HIMEMST								ds.l	1; ---------début de la liste des sous-titreGeneral_PremierSTPtr					ds.l	1General_DernierSTPtr					ds.l	1; ---------tc correspondant au 1er tc valideGeneral_PremierTC						ds.l	1General_PremierTCPtr					ds.l	1; ---------offset et tc correspondant au tc valide dans la liste sous-titreGeneral_DernierTC 						ds.l	1General_DernierTCPtr					ds.l	1TPrStatus										ds.b	26		; status pour l'impression; --------- coordonnées pour la carte d'affichageBase_Adresse						ds.l	1Row_Bytes							ds.l	1sparebyte								ds.l	3Ve_Slot								ds.w	1	; n° du slot de la vidéo explorerVe_RefNum							ds.w	1	; ref num du driver de la vidéo explorerVE_GDHandle							ds.l	1	; gd handle de la video explorerVE_pixelDeph						ds.w	1	; Nb de bits par pixelVE_BoardID							ds.w	1	; board idVE_HATCHECK						ds.l	1	; pour le blend mode VX		VE_Mode								ds.w	1	; upstream keyer /downstream keyer; --------------	 structure pour le driver nu vista Display_Font							ds.b		FontRenderRecord	; parramètre de la police d'affichageSpare									ds.l	1PopUp_Font							ds.l	1	; POUR LE MENU POLICE (POP-UP)PopUp_FontNumberList			ds.l	1	; handle pour la table de correspondance 					NuvistaHardware					ds.l		4nuvistaHphase						ds.w		1; ------------- structure pour les hardware nu vista+NuvistaMixer		ds.b		32NuvistaAnalog		ds.b		20nuvistaCltReg		ds.b		58; -------------zone mémoire pour les variables de la EVE3 keyEveHandle							ds.L	1	; handle des routines apiEve_SerialNumber			ds.l	1	; n° de série de la clef (n° Rainbow Tech)FindFirstKey_error			ds.w	1	; erreur du premier appel de la clef; cette variables est placée dans plus loin dans de record; mais elle est indiquée ici pour mémoire;Appl_SerialNumber_InKey		GFR0_inKey						ds.l	1 	; n° de serie écrit dans la clef pour le logiciel (GFR 0_1) Options_dansLaClef			ds.l	1	; (GFR 2_3) Options du logiciel validesGFR2_inKey						ds.l	1; le reste des GFRsGfr4_inkey			ds.w	1Gfr5_inkey			ds.w	1Gfr6_inkey			ds.w	1Gfr7_inkey			ds.w	1Gfr8_inkey			ds.w	1Gfr9_inkey			ds.w	1GfrA_inkey			ds.w	1GfrB_inkey			ds.w	1GfrC_inkey			ds.w	1GfrD_inkey			ds.w	1GfrE_inkey			ds.w	1GfrF_inkey			ds.w	1; ----------------------------------------------; item <=> n° de font***		Stockage de la routine de saut à la vbl task		; Pour pouvoir accéder aux variables globales pendant une intéruption; on place la valeur de a5 juste devant la routineVBL_Structure						ds.b	14		; VBL taskVBL_A5								ds.L	1			; the a5 wordVBL_StartRoutinePtr			ds.b	32		; start of VBLtask 32 octects pour le code (suffisant);	Movem.l	d0-d7/a3-a5,-(sp)	sauvegarde des registres;	move.l	-8(pc),a5			; récupération de a5;	jmp		VBL_MainRoutine		; saut à la routine sous intéruptions;***   STOCKAGE DES VARIABLES DE PREFERENCE DE FONCTIONNEMENT ***   Stockée en tête de fichier  Preference							equ	*	; addresse de début des préferences.; --------------- la version du logicielversionLogiciel						ds.w	1; --------------  préférence pour le film en coursPreference_TitreOriginal						ds.b	256Preference_TitreFrancais						ds.b	256Preference_TitreEpisodeOriginal			ds.b	256Preference_TitreEpisodeTraduit			ds.b	256Preference_NomAdaptateur					ds.b	256Preference_CoordonneesAdaptateur		ds.b	256Preference_commentaire						ds.b	256CodeDeReference									ds.b	256PaysOrigine											ds.w	1 		CodeLangue											ds.w	1CodeCaractere										ds.w	1TcDebutFilm											ds.l	1DateDeCreation										ds.l	1	;; format date macintosh (second since 1907...)ModifieLe												ds.l	1Revision												ds.w	1Preference_NombreSauv						ds.w	1Preference_AutoCheck							ds.w	1Preference_UtilCheck							ds.w	1Preference_KernCheck							ds.w	1Preference_Interval								ds.w	1Preference_LisiValue							ds.w	1Preference_Renumerotation					ds.w	1Preference_Enchaine								ds.w	1affiche_CR_Flag									ds.w	1Preference_SaisieLock							ds.w	1; -------------- table de correspondance pour les touches de fonctionsTableFonctionKeys								ds.b	32; flag true/false pour le dessin gris (listing)General_Preference_DessinGris			ds.w	1	; divers General_NombreST								ds.l	1General_StartNumberForST					ds.l	1	;$1 (par defaut)General_IncrementPourST						ds.l	1	;$1 (par defaut)General_Preference_flag_1					ds.w	1   ; pour le dialog recherche STGeneral_Preference_flag_2					ds.w	1	;  ##### non utilisé	; ---- Police et taille choisies pour l'affichageGeneral_TextSize								ds.w	1		; courant size for saisieGeneral_FontNumber							ds.w	1		; courant number for saisieSaisieModePreferenciel						ds.w	1 		; mode de saisie  ; ---- Structure de données liée à l'impression du documentT_Print							    		ds.b		26spareprint									ds.b		94; ---- liste de font en mémoireDisplay_Font_List_Handle	ds.l	1		; 0 si pas de police disponible; ---- parramètres d'affichage; format 8 alpha, 8 red, 8 green, 8 blue => 32 bitsRGB_FaceColor						ds.l	1		RGB_BorderColor					ds.l	1RGB_OutlineBoxColor			ds.l	1RGB_ShadowColor					ds.l	1X_Offset								ds.w	1Y_Offset								ds.w	1Outline_Box							ds.w	1Overriding_All_Attribute		ds.w	1; --------- mémoire pour le block noteBlockNote_tc						ds.l	16		; espace pour 16 time code BlockNote_texte					ds.b	256		; 256 caractères; -------- dernier offset effectué sur le filmoffsetTC								ds.l	1EditeurListe							ds.b	34		;Editeur liste sous-titreNomDuMonteur						ds.b	34		; Nom du monteur de la liste de sous-titreCoordonneeMonteur				ds.b	34Justification							ds.w	1		; justification d'affichageOffset_JustifRL					ds.w	1		;offset// bord écran pour justif right et leftDisplay_interligne					ds.w		1Boxing_Size							ds.w		1Boxing_SizeV						ds.w		1; espace pour la protection du logiciel ; case pour le n°de série (comme cela on peut connaître la provenance d'un fichier)Appl_SerialNumber_InKey		ds.l	1 	; n° de serie de la clef pour le logiciel (GFR 0_1) offsetTCIn							ds.l	1offsetTCOut							ds.l	1; dernière police d'affichage utiliséeLastFontUsed						ds.b		32	;; préférence pour l'effet de transitionEffectMode							ds.w		1FadeFactor							ds.w		1FadeTime								ds.w		1; Hauteur des sous-titre dans la fenêtre listingHauteurST							ds.w		1; positionnement de départ N19N19_VPStart						ds.w		1OffsetLectureTCPlay				ds.l		1OffsetLectureTCStop				ds.l		1ModeSaisieTC						ds.w		1; Espace suplémentaire pour des versions futurs du logicielspareForFutur						ds.b	572		; espace pour d'autre parramètresPreference_Header_SizeOf		equ	*	; longueur des préferences stockable en fichier  		ENDR* -------------------------------------------------; status des magnétoscope protocole sony;suffixe=vtr_VtrStatusRecord		RECORD	0					org		0vtr_error		ds.w	1	; errorvtr_Ticks		ds.l	1	; temps ou info série reçuevtr_Type		ds.w	1	; vtr idvtr_status		ds.b	10	; grille de bit status data vtr_data		ds.l	1	; speedvtr_LTC			ds.l	1	; ltc courantvtr_VITC		ds.l	1	; vitc courantvtr_TTM1 		ds.l	1	; tape timer 1vtr_TTM2		ds.l	1	; tape timer 2vtr_LTC_UB		ds.l	1	; user bits du ltcvtr_VITC_UB		ds.l	1	; user bits du vitcvtr_recInhibit	ds.b	2	;vtr_DoSomethingTC		ds.l	1;vtr_DoSomethingorder	ds.l	1;vtr_DoSomethingParam	ds.l	1;vtr_DoNotSendRequest	ds.w	1; demande à la routine d'interruption de ne pas fair d'interrogationspare			ds.l	1	;vtr_sizeof  	equ	*				endR				************************************************************ structure pour un sous-titre dans la liste***********************************************************;suffixe=st_SOUSTITRERECORD		RECORD	0					org		0st_NextST			DS.L	1		; pointeur sur st suivantst_PreviousST		DS.L	1		; pointeur sur st précédant; le time code est codé sur un mots long; en BCD HH MM SS FF; Les bits b31 et B30 ont une signication spéciale; b31=vérouillage (Pour Changement de Plan); b30=field select  (0= field1 1=field2)st_TimeCodeIn 		DS.L	1	; tc in st_TimeCodeOut 		DS.L	1	; tc out ; les bits 0 à 23 définissent le numéro "principal"; les bits 24 à 31	définissent le numéro "secondaire"; le numéro secondaire sert pour indentifier un sous-titre, lorsque l'on ne; renumérote pas automatiquement la liste de montage.st_AbsNUMST			ds.l	1		; numéro absolu du stst_NumeroST			DS.L	1		;(dc.l) numéro du sous-titre dans la liste; case pour stocker l'ancien numéro si renumérotationst_OldNumeroST		DS.L	1		;(dc.l)st_StylePtr			ds.l	1st_CommentairePtr	ds.l	1	st_TexteLenth		ds.l	1st_StyleLenth		ds.l	1; normalement st_LenthST = texte+style lenth; mais il sert à donner la longueur data du ST; entre autre si texte et style = 0; quand on vient de créer un nouveau stst_LenthST			ds.l	1st_CommentaireLenth	ds.l	1; on garde la position relative du sous-titre dans l'écranst_XOffset			ds.w	1	; ± 32000 au maximumst_YOffset			ds.w	1	; ± 32000 au maximum; Case pour stocker le type d'erreur et certains attributs dans le sous-titrest_Error			ds.w	1	; 16 possibilitées (suffisants je l'espère)st_Flags			equ		st_Error; --------------------- signification des bits ----------------------;Decale_bit 			equ		14	; sous-titre ayant été décalé	|	;outline box_bit 		equ		13	; 1 si outline box				|;XOffsetModel_bit 		equ 	12	; 0 si unité en pixel			|									; 1 mode téletexte (1 à 23)		|;doubleHauteur_bit	 	equ		11	; 1 si double hauteur			|;doubleLargeur_bit 		equ		10	; 1 si double hauteur			|;TeletextColor_bit		equ		9	; 1 siteletext, 0 si RGBColor	|;Suprimme_bit			equ		4	;?								|;TC_error_bit  			equ		3									|;Lisibilite_error_bit	equ		2									|;Interval_error_bit		equ		1									|; -------------------------------------------------------------------; nombres de lignes dans le sous-titre	st_Nlines			ds.w	1; addresse de la table des positions ; permet potentiellement le positionnement indépendant ; de chaques caractèresst_PosOffsetTable	ds.l	1st_Justification	ds.b	1		; justification du texte 0 centrée, st_MasKType			ds.b	1		; type de mask box, line, rectangle; = rienst_spare			ds.b	6		; 6 octets en reservest_sizeOf			EQU		*; sizeof= début de la zone texte; on aligne la longueur du texte sur un mot				ENDR; il y a un bug dans asm il faut donner la longueur en .l sinon; les instructions deviennent .w	!; si changement de taille du record st, modifier la valeur suivante !st_sizeOfST		equ	 $00000040  ; quelques EQU	POUR STst_LongueurParDefaut EQU  32stFlag_Decale  	equ	 14************************************************************ structure pour un sous-titre dans un fichier***********************************************************;suffixe=file_SOUSTITREformat		RECORD	0					org		0file_LenthST			ds.l	1file_TimeCodeIn 		DS.L	1	; tc in file_TimeCodeOut 		DS.L	1	; tc out ; les bits 0 à 23 définissent le numéro "principal"; les bits 24 à 31	définissent le numéro "secondaire"; le numéro secondaire sert pour indentifier un sous-titre, lorsque l'on ne; renumérote pas automatiquement la liste de montage.file_NumeroST				DS.L	1		;(dc.l) numéro du sous-titre dans la listefile_TexteLenth			ds.l	1file_StyleLenth			ds.l	1file_CommentaireLenth		ds.l	1; on garde la position relative du sous-titre dans l'écranfile_XOffset			ds.w	1	; ± 32000 au maximumfile_YOffset			ds.w	1	; ± 32000 au maximum; Case pour stocker le type d'erreur dans le sous-titrefile_Error			ds.w	1	; 16 possibilitées (suffisants je l'espère); pour une meilleur compréhension on peut utiliser st_Flagsfile_Flags		equ		file_Error; bit Decale equ	14			;; nombres de lignes dans le sous-titre	file_Nlines			ds.w	1; addresse de la table des positions ; permet potentiellement le positionnement indépendant ; de chaques caractèresfile_PosOffsetTable	ds.l	1file_Justification	ds.b	1		; justification du sous-titresfile_MasKType		ds.b	1		; type de mask box, line, rectanglefile_spare			ds.b	6		; 6 octets en reservefile_sizeOf			EQU		*; sizeof= début de la zone texte; on aligne la longueur du texte sur un mot				ENDR* =====================================================* Structure pour les préférences d'affichage en resourcesPreferenceAffichage_Resource	record	0Pa_Baseline				ds.w	1Pa_Xpos					ds.w	1	Pa_Kerning				ds.w	1Pa_Espace				ds.w	1Pa_Interligne	 		ds.w	1Pa_MasqueBordure		ds.w	1					endR* =====================================================* Structure pour les préférences de travail stockées en resourcesPreferenceTravail_Resource	record	0Pt_BackDropFlag			ds.w	1Pt_PatNum				ds.w	1	; n° de la pattern «ppat» du fond de l'écranPt_Enchaine				ds.w	1Pt_SauvegardeAuto		ds.w	1Pt_SauvegardeDuree		ds.l	1Pt_RenumerotationAuto	ds.w	1					endR****** ------------------------------------------------- *************      Structure de données pour la norme n19		 ************* ------------------------------------------------- ********** structure pour le block GSIN19_GSI			Record	0CPN				ds.b	3	;numéro page de codeDFC				ds.b	8	;Code du format de disquetteDSC				ds.b	1	;norme d'affichageCCT				ds.b	2	;Tableau code de caractèresLC				ds.b	2	;Code de langueOPT				ds.b	32	;titre original de programmeOET				ds.b	32	;titre original de l'épisodeTPT				ds.b	32	;Nom du traducteurTET				ds.b	32	;Traduction du titre de l'épisodeTN				ds.b	32	;Nom du traducteurTCD				ds.b	32	;Détails des coordonnées du traducteurSLR				ds.b	16	;Code de référence de la liste des sous-titresCD				ds.b	6	;Date de créationRD				ds.b	6	;Date de révisionRN				ds.b	2	;Numéro de révisionTNB				ds.b	5	;Nombre total de Block TTITNS				ds.b	5	;Nombre total de sous-titreTNG				ds.b	3	;Nombre total de groupe de sous-titreMNC				ds.b	2	;Nombre maximal de caractères par ligneMNR				ds.b	2	;Nombre maximum de lignes TCS				ds.b	1	;Status du Time codeTCP				ds.b	8	;Tc début du filmTCF				ds.b	8	;Tc Premier sous-titreTND				ds.b	1	;Nombre total de disquetteDSN				ds.b	1	;Numéro de la disquetteCO				ds.b	3	;Pays d'originePUB				ds.b	32	;EditeurEN				ds.b	32	;Nom du monteurECD				ds.b	32	;Détails coordonnées du monteurSPARE_GSI		ds.b	75	; n.u.UDA				ds.b	576	;pour l'utilisateur				ENDRN19_TTI			Record	0SGN				ds.b	1	;Numéro de groupe de sous-titreSN				ds.b	2	;numéro du sous-titreEBN				ds.b	1	;Numéro du block d'extensionCS				ds.b	1	;Etat cumulatifTCI				ds.b	4	;time code inTCO				ds.b	4	;time code outVP				ds.b	1	;Emplacement verticalJC				ds.b	1	;Code de justificationCF				ds.b	1	;Drapeau de remarqueTF				ds.b	112	;Champ de texte				ENDR*********** quelques déclaration de variables pour le logiciel; display time codetc_STcourant		equ		1tc_STsuivant		equ		2tc_Bandeau			equ		4tc_BarGraph			equ		8tc_Decompte			equ		16tc_TimeCode			equ		32********************************************************************************************************************************************* -------------------- Définition des equ pour le logiciel nice fellow; definition des bits de Preference_world_1 GP_AutoRenumber_Bit 					EQU	1GP_mode_saisieTCInOut 					EQU	1GP_mode_saisieText	 					EQU	2GP_mode_rien_masque						EQU	3	PREF_AFF_REC		Record	0Pref_Baseline		DS.W	1		; baselinePref_XOffset		DS.W	1		; XoffsetPref_MaskSize		DS.W	1		;SizeOf maskPref_VeMode			ds.w	1		; upstream keyer /Downstream keyerPref_Reserved		ds.w	28				endR		