 kNuVistaPlusBoardID	equ 0346 kDrHwNuVistaPlusNTSC	equ $028B kDrHwNuVistaPlusPAL	equ $028C kDrHwNuVistaPlusPAL	equ $028C kNuVistaBoardID		equ $0169 kDrHwNuVista4Meg		equ $0118 kDrHwNuVista2Meg		equ $0135 kDrHwNuVista1Meg		equ $0136 kHdwReadRequest		equ 130 kHdwWriteRequest		equ 131 kBlendReadRequest		equ 132	 kBlendWriteRequest		equ 133	 kSoftReset				equ 136 kOverlay				equ 137		/* call to go to overlay mode - no paramaters */ kDisplay				equ 138		/* call to go to display mode - no paramaters */ kLive					equ 139		/* call to go to live mode - no paramaters */ kDisplayState			equ 0 kBlendState			equ 1 kLiveFadeState			equ 2 kBufferFadeState		equ 3 kSet					equ 0 kActive				equ 1 kDoNothing				equ 0 kSetAndWait			equ 1 kSetAndGo				equ 2 kGo					equ 3 kStop					equ 4/*** The blend interval code will always be in one of two states, Set, or Active.** Set means that you have previously provided a begin, end and frameCount and the driver is waiting for ** a Go command.  Active implies that the driver is in the process of doing a blend interval.  After the driver** finishes a blend interval it will reset itself and wait for another Go command. You can issue any command at** any time.**** You may issue any of the following commands:**   DoNothing: The driver will ignore all the blend interval variables and won't do anything to change the state.**   SetAndWait:The driver will read the begin, end and frameCount values and setup its internal**				structures so that it can begin the blend interval when a Go cmd is recieved.**   SetAndGo:	Same as SetAndWait except that the driver will proceed immediatly to the Active state without**				waiting for a Go command.**   Go:		If the driver is in the Set state this will cause it to proceed to the Active state and**				thus the blend interval will begin.  If it was in the active state, the blend interval will**				be reset then will become active.**   Stop:		This will cause the driver to immediatly stop the blend interval if there is one active.**				The blend interval will be reset and the driver will go to the Set state.*/BlendInterval		RECORD	0					org		0	start 		ds.b	1;			/* starting value */	end 		ds.b	1;				/* ending value */	frameCount	ds.w	1;		/* number of frames to do it */	state 		ds.b	1;			/* see above -> set, active */	cmd 		ds.b	1;				/* see above -> SetAndWait, SetAndGo, Go, or Stop */	endR	NuVistaBlend RECORD	0			org		0						blendColor			ds RGBColor;	fadeColor 			ds RGBColor;	colorMixLevel 		ds.b	1;	notColorMixLevel 	ds.b	1;	keyColor 			ds BlendInterval ;	notKeyColor 		ds BlendInterval;	mode 				ds.w	1;			/* display, blend or one of the fades */	endR/*** Video Timing registers */NuVistaVideoCtlRegs RECORD	0				org		0	hesync	ds.w	1;		heblnk	ds.w	1;		hsblnk	ds.w	1;		htotal	ds.w	1;		vesync	ds.w	1;		veblnk	ds.w	1;		vsblnk	ds.w	1;		vtotal	ds.w	1;			dpyctl	ds.w	1;		dpystrt	ds.w	1;			wmask	ds.w	1;		pio		ds.w	1;		tap		ds.w	1;		hrate	ds.w	1;		vrate	ds.w	1;		vswidth	ds.w	1;		clkrate	ds.w	1;		hswidth	ds.w	1;		genlock	ds.w	1;		status	ds.w	1;			hphase	ds.w	1;		bgstart	ds.w	1;		bgwidth	ds.w	1;		mode1	ds.w	1;		mode2	ds.w	1;			video	ds.w	1;		mode	ds.w	1;			imr		ds.l	1;		Endr/*** Mixer Control registers */NuVistaMixerCtlRegs RECORD	0				org		0									rgb			ds.b	1;						/* 1 bit(s) */	sVideo		ds.b	1;					/* 1 bit(s) */	vxp			ds.b	1;					/* 1 bit(s) */	monoSrc		ds.b	1;				/* 1 bit(s) */	live8		ds.b	1;					/* 1 bit(s) */	alpha8		ds.b	1;					/* 1 bit(s) */	lutBypass	ds.b	1;				/* 2 bit(s) */	fgndProc	ds.b	1;				/* 1 bit(s) */	captZoom	ds.b	1;				/* 2 bit(s) */	color0		ds.b	1;					/* 8 bit(s) */	color1		ds.b	1;					/* 8 bit(s) */	color2		ds.b	1;					/* 8 bit(s) */	color3		ds.b	1;				/* 8 bit(s) */	compare0	ds.b	1;				/* 8 bit(s) */	compare1	ds.b	1;				/* 8 bit(s) */	compare2	ds.b	1;				/* 8 bit(s) */	notOVLLevel	ds.b	1;			/* 8 bit(s) */	OVLLevel	ds.b	1;				/* 8 bit(s) */	overlayInv	ds.b	1;				/* 1 bit(s) */	overlaySrc	ds.b	1;				/* 3 bit(s) */	liveMixInv			ds.b	1;				/* 1 bit(s) */	liveMixGain			ds.b	1;			/* 2 bit(s) */	liveMixZeroLevel	ds.b	1;		/* 8 bit(s) */	liveMixSrc			ds.b	1;				/* 1 bit(s) */	liveMixColor		ds.b	1;			/* 1 bit(s) */	liveMixBypass		ds.b	1;			/* 1 bit(s) */	livePortInv			ds.b	1;			/* 1 bit(s) */	livePortSrc			ds.b	1;			/* 1 bit(s) */	livePortColor		ds.b	1;			/* 1 bit(s) */	livePortWord		ds.b	1;			/* 1 bit(s) */	bufferPortSrc		ds.b	1;			/* 2 bit(s) */	bufferPortColor		ds.b	1;		/* 1 bit(s) */	ENDR/*** Analog Control registers */NuVistaAnalogCtlRegs RECORD	0				org		0	/*	** Phased locked loop registers	*/	PLLN			ds.w	1; 			/* Phased Locked Loop N counter */	PLLR			ds.w	1;			/* Phased Locked Loop R counter */		/*	** Serial DAC registers.	** Registers are listed in order DAC $48 then DAC $4C	** and from DAC0 to DAC7	*/	contrast		ds.b	1;			/* contrast for RGB or composite video */	saturation		ds.b	1;			/* saturation for composite video */	hue				ds.b	1;				/* hue for composite video */	brightness		ds.b	1;			/* DC offset for controlling brightness in RGB and composite */	sCPhaseAdj		ds.b	1;			/* Sub Carrier phase adjustment: (range 0 to 63) */	vrtr			ds.b	1;				/* internal factory setting - do not change */	vrtb			ds.b	1;				/* internal factory setting - do not change */	vrbr			ds.b	1;				/* internal factory setting - do not change */	vrbb			ds.b	1;				/* internal factory setting - do not change */	rsrvdDac1		ds.b	1;			/* reserved for future use */	sCPhaseInv		ds.b	1;			/* Sub Carrier phase adjustment: 0 => 0 degrees, 63 => 180 degrees */	chromaKill		ds.b	1;			/* == 0 for no chroma, == 1 for chroma */	rsrvdDac4		ds.b	1;			/* reserved for future use */	rsrvdDac5		ds.b	1;			/* reserved for future use */	rsrvdDac6		ds.b	1;			/* reserved for future use */	rsrvdDac7		ds.b	1;			/* reserved for future use */	Endr		HdwReqCntrl RECORD	0				org		0	video			ds.l	1;		/* ptr to video regs structure */	mixer			ds.l	1;		/* ptr to mixer regs structure */	analog			ds.l	1;		/* ptr to analog regs structure */	nominalHPhase	ds.l	1;		/* ptr to a short that will be filled in with the nominal */									/* HPhase value during a read request.  Ignored during a write */	EndR