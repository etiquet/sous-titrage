#define kNuVistaPlusBoardID		0x0346#define kDrHwNuVistaPlusNTSC	0x028B#define kDrHwNuVistaPlusPAL		0x028C#define kDrHwNuVistaPlusPAL		0x028C#define kNuVistaBoardID			0x0169#define kDrHwNuVista4Meg		0x0118#define kDrHwNuVista2Meg		0x0135#define kDrHwNuVista1Meg		0x0136#define kScanRate			128#define kHdwReadRequest		130#define kHdwWriteRequest	131#define kBlendReadRequest	132	#define kBlendWriteRequest	133	#define kSoftReset			136#define kOverlay			137		/* call to go to overlay mode - no paramaters */#define kDisplay			138		/* call to go to display mode - no paramaters */#define kLive				139		/* call to go to live mode - no paramaters */#define kScanMain			0#define kScanNTSC			1#define kScanPAL			2#define kDisplayState		0#define kBlendState			1#define kLiveFadeState		2#define kBufferFadeState	3#define kSet				0#define kActive				1#define kDoNothing			0#define kSetAndWait			1#define kSetAndGo			2#define kGo					3#define kStop				4/*** The blend interval code will always be in one of two states, Set, or Active.** Set means that you have previously provided a begin, end and frameCount and the driver is waiting for ** a Go command.  Active implies that the driver is in the process of doing a blend interval.  After the driver** finishes a blend interval it will reset itself and wait for another Go command. You can issue any command at** any time.**** You may issue any of the following commands:**   DoNothing: The driver will ignore all the blend interval variables and won't do anything to change the state.**   SetAndWait:The driver will read the begin, end and frameCount values and setup its internal**				structures so that it can begin the blend interval when a Go cmd is recieved.**   SetAndGo:	Same as SetAndWait except that the driver will proceed immediatly to the Active state without**				waiting for a Go command.**   Go:		If the driver is in the Set state this will cause it to proceed to the Active state and**				thus the blend interval will begin.  If it was in the active state, the blend interval will**				be reset then will become active.**   Stop:		This will cause the driver to immediatly stop the blend interval if there is one active.**				The blend interval will be reset and the driver will go to the Set state.*/struct BlendInterval{	unsigned char start;			/* starting value */	unsigned char end;				/* ending value */	unsigned short frameCount;		/* number of frames to do it */	unsigned char state;			/* see above -> set, active */	unsigned char cmd;				/* see above -> SetAndWait, SetAndGo, Go, or Stop */};typedef struct BlendInterval BlendInterval;struct NuVistaBlend {	RGBColor			blendColor;	RGBColor			fadeColor;	unsigned char		colorMixLevel;	unsigned char		notColorMixLevel;	BlendInterval 		keyColor;	BlendInterval 		notKeyColor;	unsigned short		mode;			/* display, blend or one of the fades */};typedef struct NuVistaBlend NuVistaBlend;/*** Video Timing registers */struct NuVistaVideoCtlRegs{	unsigned short	hesync;		unsigned short	heblnk;	unsigned short	hsblnk;	unsigned short	htotal;	unsigned short	vesync;	unsigned short	veblnk;	unsigned short	vsblnk;	unsigned short	vtotal;		unsigned short	dpyctl;	unsigned short	dpystrt;		unsigned short	wmask;	unsigned short	pio;	unsigned short	tap;	unsigned short	hrate;	unsigned short	vrate;	unsigned short	vswidth;	unsigned short	clkrate;	unsigned short	hswidth;	unsigned short	genlock;	unsigned short	status;		unsigned short	hphase;	unsigned short	bgstart;	unsigned short	bgwidth;	unsigned short	mode1;	unsigned short	mode2;		unsigned short	video;	unsigned short	mode;		unsigned long	imr;};typedef struct NuVistaVideoCtlRegs NuVistaVideoCtlRegs;/*** Mixer Control registers */struct NuVistaMixerCtlRegs{	unsigned char	rgb;					/* 1 bit(s) */	unsigned char	sVideo;					/* 1 bit(s) */	unsigned char	vxp;					/* 1 bit(s) */	unsigned char	monoSrc;				/* 1 bit(s) */	unsigned char	live8;					/* 1 bit(s) */	unsigned char	alpha8;					/* 1 bit(s) */	unsigned char	lutBypass;				/* 2 bit(s) */	unsigned char	fgndProc;				/* 1 bit(s) */	unsigned char	captZoom;				/* 2 bit(s) */	unsigned char 	color0;					/* 8 bit(s) */	unsigned char 	color1;					/* 8 bit(s) */	unsigned char 	color2;					/* 8 bit(s) */	unsigned char 	color3;					/* 8 bit(s) */	unsigned char	compare0;				/* 8 bit(s) */	unsigned char	compare1;				/* 8 bit(s) */	unsigned char	compare2;				/* 8 bit(s) */	unsigned char	notOVLLevel;			/* 8 bit(s) */	unsigned char	OVLLevel;				/* 8 bit(s) */	unsigned char	overlayInv;				/* 1 bit(s) */	unsigned char	overlaySrc;				/* 3 bit(s) */	unsigned char	liveMixInv;				/* 1 bit(s) */	unsigned char	liveMixGain;			/* 2 bit(s) */	unsigned char	liveMixZeroLevel;		/* 8 bit(s) */	unsigned char	liveMixSrc;				/* 1 bit(s) */	unsigned char	liveMixColor;			/* 1 bit(s) */	unsigned char	liveMixBypass;			/* 1 bit(s) */	unsigned char	livePortInv;			/* 1 bit(s) */	unsigned char	livePortSrc;			/* 1 bit(s) */	unsigned char	livePortColor;			/* 1 bit(s) */	unsigned char	livePortWord;			/* 1 bit(s) */	unsigned char	bufferPortSrc;			/* 2 bit(s) */	unsigned char	bufferPortColor;		/* 1 bit(s) */};typedef struct NuVistaMixerCtlRegs NuVistaMixerCtlRegs;/*** Analog Control registers */struct NuVistaAnalogCtlRegs{	/*	** Phased locked loop registers	*/	unsigned short PLLN;			/* Phased Locked Loop N counter */	unsigned short PLLR;			/* Phased Locked Loop R counter */		/*	** Serial DAC registers.	** Registers are listed in order DAC 0x48 then DAC 0x4C	** and from DAC0 to DAC7	*/	unsigned char	contrast;			/* contrast for RGB or composite video */	unsigned char	saturation;			/* saturation for composite video */	unsigned char	hue;				/* hue for composite video */	unsigned char	brightness;			/* DC offset for controlling brightness in RGB and composite */	unsigned char	sCPhaseAdj;			/* Sub Carrier phase adjustment: (range 0 to 63) */	unsigned char	vrtr;				/* internal factory setting - do not change */	unsigned char	vrtb;				/* internal factory setting - do not change */	unsigned char	vrbr;				/* internal factory setting - do not change */	unsigned char	vrbb;				/* internal factory setting - do not change */	unsigned char	rsrvdDac1;			/* reserved for future use */	unsigned char	sCPhaseInv;			/* Sub Carrier phase adjustment: 0 => 0 degrees, 63 => 180 degrees */	unsigned char	chromaKill;			/* == 0 for no chroma, == 1 for chroma */	unsigned char	rsrvdDac4;			/* reserved for future use */	unsigned char	rsrvdDac5;			/* reserved for future use */	unsigned char	rsrvdDac6;			/* reserved for future use */	unsigned char	rsrvdDac7;			/* reserved for future use */};typedef struct NuVistaAnalogCtlRegs NuVistaAnalogCtlRegs;struct HdwReqCntrl{	NuVistaVideoCtlRegs	*video;			/* ptr to video regs structure */	NuVistaMixerCtlRegs	*mixer;			/* ptr to mixer regs structure */	NuVistaAnalogCtlRegs *analog;		/* ptr to analog regs structure */	unsigned short		*nominalHPhase;	/* ptr to a short that will be filled in with the nominal */										/* HPhase value during a read request.  Ignored during a write */};typedef struct HdwReqCntrl HdwReqCntrl;