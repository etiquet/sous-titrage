//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	EFUtilities.h//______________________________________________________________________________________________________________________//                                                Copyright (c) 1993//                                   INTELLIGENT RESOURCES INTEGRATED SYSTEMS INC.//                                                All Rights Reserved.////                           This is unpublished work and is the proprietary source code of//                                   INTELLIGENT RESOURCES INTEGRATED SYSTEMS INC.//                                       and should be treated as confidential//______________________________________________________________________________________________________________________//// Author		Date			Description// ------		----			-----------// FEA			11/22/93		Ported to new project management system// APJ			12/08/93		Changed type of alphaVal parameter in AddSimpleAlpha() from char to Byte//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#ifndef _EFUtilities_h_#define _EFUtilities_h_//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////___ Headers to include.//__________________________________________________________#ifndef	_VEDriver_h_#include "VEDriver.h"#endif#ifndef	_VESupport_h_#include "VESupport.h"#endif//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////___ Useful Types, etc.//__________________________________________________________union EFFixed {	struct {		unsigned short	whole;		unsigned short	frac;	} wf;						// "fixed" version	long	l;					// long for type compatability};typedef union EFFixed EFFixed;typedef struct EFPICTData {	short		rowBytes;	// the number of bytes in a row	Point		PICTSize;	// the size of the PICT loading	short		curLineNum;	// the line number in the PICT we are at	Handle	PICTData;	// handle to PICT data} EFPICTData;typedef	EFPICTData *EFPICTDataPtr;#define EFUnity		0x00010000#define	noProtect		0#define	protectAlpha	1#define	protectRGB		2//	Filter selectors#define		noFilter				0#define		textAlpha			1#define		textAntiAlias		2#define		returnPICTData		3#define		setAlphaVal			4// These are NOT in VEDriver.h#define alphaMask	0xFF000000#define redMask	0x00FF0000#define greenMask	0x0000FF00#define blueMask	0x000000FF#define	veRows		1024	// number of lines in memory (4MB card)#define	veRowBytes	4096	// 1024 * 4 (1 long = 4 bytes): the number of bytes in a line of VE memory#define setupPhase		0#define waitPhase			1#define runPhase			2#define restorePhase		3#define updatePhase		4			// for interactive effects#define saveStatePhase	5			// for restore card stuff#define deQvblPhase		6			// sets status to 1 and doesn't requeue//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////___ Function prototypes.//__________________________________________________________#ifdef __cplusplusextern "C" {#endifpascal void InitEFUtilities(void);	// 	Loads any otherwise unreferenced segments to fool linker..				pascal void	ClearBuffer(short				theVE,								unsigned long	color);	// 	Fills the VE memory with the specified color using Capture. pascal void	ClearBufferFill(short 				theVE,									 unsigned long		color);	// 	Fills the VE memory with the specified color using BlockMoves. pascal short	CountVE(void);	// 	Returns a count of installed Video Explorers.							pascal short	FindNextVE(short prevVE);	// 	Finds the next available Video Explorer. For 1st call prevVE = 0.			// 	Returns the slot# of a the next card, or 0 if there are no more VEs.	pascal void	FreeARect(short	theDriver,							 short	whichRect);	// 	Sets the priority of the indicated rectangle to 0 and the boundary			// 	rectangle to {0,0,0,0}. Ideal from Bill L.	Returns without doing			// 	anything if whichRect not in range rectangle1 - rectangle4				pascal void	FreeAllRects(short theDriver);	// 	Calls FreeARect for all rectangles.										pascal short	FindFirstFreeRect(short theDriver);	// 	Finds the next available hardware rectangle (1-4). This is based on the 	//	priority of the rectangle. If the priority is 0, it is considered free.	//	Returns (-1) if there are no free rects, otherwise returns the rectangleID.pascal short	FindLastFreeRect(short theDriver);	// 	Finds the last available hardware rectangle (1-4). This is based on the 	//	priority of the rectangle. If the priority is 0, it is considered free.	//	Returns (-1) if there are no free rects, otherwise returns the rectangleID.pascal void	GetHighestPriority(short	theDriver,										 short*	thePriority,										 short*	theControl,										 short*	theChannel);	// 	Set "*thePriority" to the highest priority found on the VE, Set				// 	"*theControl" to the control ID of the device that had that highest			// 	priority and set "*theChannel" to the channel that device is				// 	forwarding. Limitation:														// 																					// 	This routine should test certain devices to see if theControl is			// 	active line control and pixel control for example have to be enabled		// 	before their priority setting takes effect.  I do NOT currently test		// 	for these special cases.													// 																					// 	If 2 or more devices have the highest priority, I'm not certain that		// 	the device with the highest precedence is returned.							// 	(original courtesy Ron Schreiner)										pascal void LiveVideoAlpha(short	theDriver);	// 	Fills the entire alpha channel with 0xFF to permit live video to serve		// 	as one source in a blend or overlay even if only a smaller portion of		// 	the alpha channel is set by another effect.									// 	Can simplify working with "Load buffer" routines that clip.				pascal Boolean	LoadBufferPICTFile(short	theDriver,											 short	fileRefNum,											 Boolean	useOffscreen,											 short	protectComp,											 Rect		dest);	// 	Loads the VE buffer from the indicated pict file, which is assumed to		// 	be already open. If "useOffscreen" is true, the resource is first drawn		// 	to an offscreen bitmap & then moved to the VE buffer. This has a longer		//  	delay than drawing directly to the VE but is much smoother.					// 	-- version 1 (offscreen switch is ignored) (3/9/92)							// 																				// 	The "dest" parameter can be used in 2 ways:									// 		1) If it is a real rectangle (in the VE space, with 0,0 at the			// 			topLeft) it defines the clipping rectangle used when copying		// 			to the VE frame buffer. WE DON'T SCALE, JUST CLIP					// 		2) If right==left and top=bottom no clipping is used and the whole		// 			pict read is simply copied using those coordinates. 				// 	-- version 2																// 																				// 	"protectComp" determines which if any components in the VE memory are		// 	unalterable during the copybits from the offscreen bitmap. Legal values 	// 	are:	0 = no protection													// 			1 = protect alpha, change RGB										// 			2 = protect RGB, change alpha										// 	-- version 3																// 																				// 	This can now load pictures up to 1024 * 1024 pixels in size. Pictures		//  	larger than 1024 pixels in either dimension are clipped when drawn into		// 	the offscreen grafport.														// 	-- version 4															pascal Boolean	LoadBufferPICTFileSetAlpha(short		theDriver, 														short		fileRefNum, 														char		theAlphaValue, 														Rect		dest);////	Version 1:	(9/9/92)//		fileRefNum:		which file to load in//		theAlphaValue:	select what alpha value to enter. This is in the range //							0-$FF.//		dest:			same as in the LoadBufferPICTFilepascal Boolean	LoadBufferPICTFileKeyed(short		theDriver,													short		fileRefNum,													Boolean	useOffscreen,													short		protectComp,													Rect		dest,													long		keyColor);	// 	This is the same as the	LoadBufferPICTFile function except that the			// 	alpha channel of the offscreen CGrafPort is modified. For evey pixel		// 	in the RGB set to "keyColor" the alpha is set to 0xFF (100% live),			// 	for all others it is set to 0 (100% frame buffer). This makes it easier		// 	to overlay text without explicitly creating an alpha mask, if the			// 	keyColor used is white (0x00FFFFFF). A "hard key" results.				pascal Boolean	LoadBufferResource(short	theDriver,											 short	resID,											 Boolean	useOffscreen,											 short	protectComp,											 Rect		dest);	// 	Loads the VE buffer from the indicated pict resource in a file which		// 	is assumed to be already open. If "useOffscreen" is true, the resource		// 	is first drawn to an offscreen bitmap & then moved to the VE buffer.		//  	This has a longer delay than drawing directly to the VE but is much			// 	smoother.																	// 																				// 	The "dest" parameter can be used in 2 ways:									// 		1) If it is a real rectangle (in the VE space, with 0,0 at the			// 			topLeft) it defines the clipping rectangle used when copying		// 			to the VE frame buffer. WE DON'T SCALE, JUST CLIP					// 		2) If right==left and top=bottom no clipping is used and the whole		// 			pict read is simply copied using those coordinates. 				// 	-- version 1 (offscreen switch is ignored) (3/7/92)							// 																				// 	"protectComp" determines which if any components in the VE memory are		// 	unalterable during the copybits from the offscreen bitmap. Legal values 	// 	are:	0 = no protection													// 			1 = protect alpha, change RGB										// 			2 = protect RGB, change alpha										// 	-- version 3																// 																				// 	This can now load pictures up to 1024 * 1024 pixels in size. Pictures		//  	larger than 1024 pixels in either dimension are clipped when drawn into		// 	the offscreen grafport.														// 	-- version 4															pascal Boolean	LoadBufferResourceKeyed(short		theDriver,													short		resID,													Boolean	useOffscreen,													short		protectComp,													Rect		dest,													long		keyColor);	// 	This is the same as the	LoadBufferResource function except that the			// 	alpha channel of the offscreen CGrafPort is modified. For evey pixel		// 	in the RGB set to "keyColor" the alpha is set to 0xFF (100% live),			// 	for all others it is set to 0 (100% frame buffer). This makes it easier		// 	to overlay text without explicitly creating an alpha mask, if the			// 	keyColor used is white (0x00FFFFFF). A "hard key" results.				pascal void	LoadBufferCGrafPort(short		theDriver,										  CGrafPtr	cPtr,										  short		protectComp,										  Rect		dest);	// 	Loads the VE buffer from the indicated cGrafPort. The cGrafPort must		// 	fulfill the following conditions:											// 	(1) When created, the VE must be the current GDevice.						// 	(2) When this is called, the main device must be the current GDevice		// 	(3) Bounds for the portRect have top=left=0									// 																				// 	"protectComp" determines which if any components in the VE memory are		// 	unalterable during the copybits from the offscreen bitmap. Legal values 	// 	are:	0 = no protection													// 			1 = protect alpha, change RGB										// 			2 = protect RGB, change alpha										// 	-- version 2															pascal void	LoadBufferCGrafPortKeyed(short		theDriver,												 CGrafPtr	cPtr,												 short		protectComp,												 Rect			dest,												 long			keyColor);	// 	This is the same as the	LoadBufferCGrafPort function except that the		// 	alpha channel of the offscreen CGrafPort is modified. For evey pixel		// 	in the RGB set to "keyColor" the alpha is set to 0xFF (100% live),			// 	for all others it is set to 0 (100% frame buffer). This makes it easier		// 	to overlay text without explicitly creating an alpha mask, if the			// 	keyColor used is white (0x00FFFFFF). A "hard key" results.				pascal void ProtectAlpha(short		theDriver,								 Boolean		doIt);	// 	This enables/disables protection of the alpha component in the buffer.		// 	If doIt, the alpha component is protected from modification. If false,		// 	the alpha component is modifiable. In either case, the remaining (RBG)		// 	components are modifiable.												pascal void SetCLUT(short	theDriver,			//  which card 						  short	whichCLUT,			//  CLUT1 or CLUT2 						  Ptr		vals);				//  array of longs 	// 	This writes an entire CLUT onto the specified VE. The table of longs		// 	is assumed to be the right size for the specified CLUT (256 for CLUT1,		// 	128 for CLUT2). No checking on table entries is performed.							 #if 0pascal Boolean	OffsetLoadBufferPICTfile(short		theDriver,			//  which card 													 short		theRefNum,			//  open PICT file 													 Rect			dest,				//  where in VE to load 													 Boolean		useOffScreen,													 Point		preloadOffset);		//  offset physical memory by this 	// 	This uses the physical memory management to load a PICT file (which			// 	usually has a 0,0 origin) into the VE frame buffer such	that it can			// 	extend "below" the normal bounds and wrap around if	necessary.			pascal Boolean	OffsetLoadBufferResource(short		theDriver,			//  which card 													 short		resID,													 Rect			dest,				//  where in VE to load 													 Boolean		useOffScreen,													 Point		preloadOffset);		//  offset physical memory by this 	// 	This uses the physical memory management to load a PICT (which usually 		// 	has a 0,0 origin) from an open resource file into the VE frame buffer		// 	such that it can extend "below" the normal bounds and wrap around if		// 	necessary.																#endifpascal void AddAlpha(CGrafPtr		thePort,							long			keyColor);	// 	Checks each pixel's RGB components. If the pixel is the keycolor the		// 	alpha component is set to 0xFF (when doing a blend, this usually means		// 	"100% live video"), otherwise it is set to 0 ("100% graphic"). This 		// 	will probably work best with text, since it almost	always has a white		// 	background, and is a	royal pain to add alpha to in Photoshop. This		//  	could be extended later to check a neighborhood for anti-aliasing...		// 																				// 	Note: the keycolor must have alpha=0 (i.e. in the form 0x00XXXXXX)		pascal void AddSimpleAlpha(CGrafPtr		thePort,									Byte			alphaVal);	//	Given an alpha value & a CGrafPtr, this will set the alpha of the pic 	//	in the CGrafPtr to that value. 	pascal Boolean	XXLoadBufferPICTFile(short		theDriver,												short		fileRefNum,												Boolean	useOffscreen,												short		protectComp,												Rect		dest,												short		filterSelector,												long		filterParm);	// 	This is the core of the	LoadBufferPICTFile function family.	//	Filters available are:	//		noFilter			0	//		textAlpha			1		filterParm is a key color	//		textAntiAlias		2		(currently same as textAlpha)	//		returnPICTData		3		(return the PICT data described	//									 in the EFPICTData struct. filterParm	//									 is a EFPICTDataPtr typecast as a long)	//		setAlphaVal			4		 filterParm is the alpha value (0-$FF)	//	//		When using the returnPICTData "filter" the caller MUST dispose of the	//		memory whose handle is returned in the EFPICTData structure.	//	//		When using the returnPICTData "filter" the picture is NOT clipped to	//		1024*1024 pixels. The code assumes that the picture is being loaded will	//		be "fed" to an effect such as scroll or crawl.pascal Boolean	LoadEFPICTDataPICTFile(	short				theDriver,													short				fileRefNum,													EFPICTDataPtr	thePICTDataPtr);	//	This is a spur of the LoadBufferPICTFile. This will return the PICT data	//	described in the EFPICTData struct. The caller MUST dispose of the memory	//	whose handle is returned in the EFPICTData structure.// // 	Miscellaneous//Ptr GetVBLRec() = 0x2008;		// 	MOVE.L A0,D0 	//  Typecast the returned value to the actual record pointer pascal void FixPC()       = {0x41FA, 0x000A,  //    LEA        *+$000C,A0                               0x2008,          //    MOVE.L     A0,D0                                    0xA055,          //    _StripAddress                                       0x2040,          //    MOVEA.L    D0,A0                                    0x4ED0};         //    JMP        (A0) ;jmps to next instruction 	//  From TechNote 228: clean up PC in external code resource #ifdef __cplusplus}#endif////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#endif